(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('ant-design-vue'), require('vue-quill-editor'), require('vant'), require('resize-detector'), require('vue'), require('vue-i18n'), require('lodash'), require('hotkeys-js'), require('x-data-spreadsheet'), require('papaparse')) :
  typeof define === 'function' && define.amd ? define(['ant-design-vue', 'vue-quill-editor', 'vant', 'resize-detector', 'vue', 'vue-i18n', 'lodash', 'hotkeys-js', 'x-data-spreadsheet', 'papaparse'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global['luban-h5-editor'] = factory(global['ant-design-vue'], global.VueQuillEditor, global.vant, global.resizeDetector, global.Vue, global.VueI18n, global.lodash, global.hotkeys, global.x_spreadsheet, global.papaparse));
}(this, (function (antDesignVue, vueQuillEditor, vant, resizeDetector, Vue, VueI18n, lodash, hotkeys, Spreadsheet, Papa) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var Vue__default = /*#__PURE__*/_interopDefaultLegacy(Vue);
  var VueI18n__default = /*#__PURE__*/_interopDefaultLegacy(VueI18n);
  var hotkeys__default = /*#__PURE__*/_interopDefaultLegacy(hotkeys);
  var Spreadsheet__default = /*#__PURE__*/_interopDefaultLegacy(Spreadsheet);
  var Papa__default = /*#__PURE__*/_interopDefaultLegacy(Papa);

  var fails = function (exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  // Thank's IE8 for his funny defineProperty
  var descriptors = !fails(function () {
    return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
  });

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var check = function (it) {
    return it && it.Math == Math && it;
  };

  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global_1 =
    // eslint-disable-next-line no-undef
    check(typeof globalThis == 'object' && globalThis) ||
    check(typeof window == 'object' && window) ||
    check(typeof self == 'object' && self) ||
    check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
    // eslint-disable-next-line no-new-func
    Function('return this')();

  var isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var document$1 = global_1.document;
  // typeof document.createElement is 'object' in old IE
  var EXISTS = isObject(document$1) && isObject(document$1.createElement);

  var documentCreateElement = function (it) {
    return EXISTS ? document$1.createElement(it) : {};
  };

  // Thank's IE8 for his funny defineProperty
  var ie8DomDefine = !descriptors && !fails(function () {
    return Object.defineProperty(documentCreateElement('div'), 'a', {
      get: function () { return 7; }
    }).a != 7;
  });

  var anObject = function (it) {
    if (!isObject(it)) {
      throw TypeError(String(it) + ' is not an object');
    } return it;
  };

  // `ToPrimitive` abstract operation
  // https://tc39.github.io/ecma262/#sec-toprimitive
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  var toPrimitive = function (input, PREFERRED_STRING) {
    if (!isObject(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var nativeDefineProperty = Object.defineProperty;

  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  var f = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (ie8DomDefine) try {
      return nativeDefineProperty(O, P, Attributes);
    } catch (error) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var objectDefineProperty = {
  	f: f
  };

  var defineProperty = objectDefineProperty.f;

  var FunctionPrototype = Function.prototype;
  var FunctionPrototypeToString = FunctionPrototype.toString;
  var nameRE = /^\s*function ([^ (]*)/;
  var NAME = 'name';

  // Function instances `.name` property
  // https://tc39.github.io/ecma262/#sec-function-instances-name
  if (descriptors && !(NAME in FunctionPrototype)) {
    defineProperty(FunctionPrototype, NAME, {
      configurable: true,
      get: function () {
        try {
          return FunctionPrototypeToString.call(this).match(nameRE)[1];
        } catch (error) {
          return '';
        }
      }
    });
  }

  var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  // Nashorn ~ JDK8 bug
  var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

  // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
  var f$1 = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable;

  var objectPropertyIsEnumerable = {
  	f: f$1
  };

  var createPropertyDescriptor = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var toString = {}.toString;

  var classofRaw = function (it) {
    return toString.call(it).slice(8, -1);
  };

  var split = ''.split;

  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var indexedObject = fails(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins
    return !Object('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
  } : Object;

  // `RequireObjectCoercible` abstract operation
  // https://tc39.github.io/ecma262/#sec-requireobjectcoercible
  var requireObjectCoercible = function (it) {
    if (it == undefined) throw TypeError("Can't call method on " + it);
    return it;
  };

  // toObject with fallback for non-array-like ES3 strings



  var toIndexedObject = function (it) {
    return indexedObject(requireObjectCoercible(it));
  };

  var hasOwnProperty = {}.hasOwnProperty;

  var has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
  var f$2 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPrimitive(P, true);
    if (ie8DomDefine) try {
      return nativeGetOwnPropertyDescriptor(O, P);
    } catch (error) { /* empty */ }
    if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
  };

  var objectGetOwnPropertyDescriptor = {
  	f: f$2
  };

  var createNonEnumerableProperty = descriptors ? function (object, key, value) {
    return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var setGlobal = function (key, value) {
    try {
      createNonEnumerableProperty(global_1, key, value);
    } catch (error) {
      global_1[key] = value;
    } return value;
  };

  var SHARED = '__core-js_shared__';
  var store = global_1[SHARED] || setGlobal(SHARED, {});

  var sharedStore = store;

  var functionToString = Function.toString;

  // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
  if (typeof sharedStore.inspectSource != 'function') {
    sharedStore.inspectSource = function (it) {
      return functionToString.call(it);
    };
  }

  var inspectSource = sharedStore.inspectSource;

  var WeakMap = global_1.WeakMap;

  var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

  var shared = createCommonjsModule(function (module) {
  (module.exports = function (key, value) {
    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.6.5',
    mode:  'global',
    copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
  });
  });

  var id = 0;
  var postfix = Math.random();

  var uid = function (key) {
    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
  };

  var keys = shared('keys');

  var sharedKey = function (key) {
    return keys[key] || (keys[key] = uid(key));
  };

  var hiddenKeys = {};

  var WeakMap$1 = global_1.WeakMap;
  var set, get, has$1;

  var enforce = function (it) {
    return has$1(it) ? get(it) : set(it, {});
  };

  var getterFor = function (TYPE) {
    return function (it) {
      var state;
      if (!isObject(it) || (state = get(it)).type !== TYPE) {
        throw TypeError('Incompatible receiver, ' + TYPE + ' required');
      } return state;
    };
  };

  if (nativeWeakMap) {
    var store$1 = new WeakMap$1();
    var wmget = store$1.get;
    var wmhas = store$1.has;
    var wmset = store$1.set;
    set = function (it, metadata) {
      wmset.call(store$1, it, metadata);
      return metadata;
    };
    get = function (it) {
      return wmget.call(store$1, it) || {};
    };
    has$1 = function (it) {
      return wmhas.call(store$1, it);
    };
  } else {
    var STATE = sharedKey('state');
    hiddenKeys[STATE] = true;
    set = function (it, metadata) {
      createNonEnumerableProperty(it, STATE, metadata);
      return metadata;
    };
    get = function (it) {
      return has(it, STATE) ? it[STATE] : {};
    };
    has$1 = function (it) {
      return has(it, STATE);
    };
  }

  var internalState = {
    set: set,
    get: get,
    has: has$1,
    enforce: enforce,
    getterFor: getterFor
  };

  var redefine = createCommonjsModule(function (module) {
  var getInternalState = internalState.get;
  var enforceInternalState = internalState.enforce;
  var TEMPLATE = String(String).split('String');

  (module.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == 'function') {
      if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
      enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
    if (O === global_1) {
      if (simple) O[key] = value;
      else setGlobal(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty(O, key, value);
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
  });
  });

  var path = global_1;

  var aFunction = function (variable) {
    return typeof variable == 'function' ? variable : undefined;
  };

  var getBuiltIn = function (namespace, method) {
    return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])
      : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
  };

  var ceil = Math.ceil;
  var floor = Math.floor;

  // `ToInteger` abstract operation
  // https://tc39.github.io/ecma262/#sec-tointeger
  var toInteger = function (argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
  };

  var min = Math.min;

  // `ToLength` abstract operation
  // https://tc39.github.io/ecma262/#sec-tolength
  var toLength = function (argument) {
    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var max = Math.max;
  var min$1 = Math.min;

  // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
  var toAbsoluteIndex = function (index, length) {
    var integer = toInteger(index);
    return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
  };

  // `Array.prototype.{ indexOf, includes }` methods implementation
  var createMethod = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject($this);
      var length = toLength(O.length);
      var index = toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };

  var indexOf = arrayIncludes.indexOf;


  var objectKeysInternal = function (object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (has(O, key = names[i++])) {
      ~indexOf(result, key) || result.push(key);
    }
    return result;
  };

  // IE8- don't enum bug keys
  var enumBugKeys = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
  ];

  var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return objectKeysInternal(O, hiddenKeys$1);
  };

  var objectGetOwnPropertyNames = {
  	f: f$3
  };

  var f$4 = Object.getOwnPropertySymbols;

  var objectGetOwnPropertySymbols = {
  	f: f$4
  };

  // all object keys, includes non-enumerable and symbols
  var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = objectGetOwnPropertyNames.f(anObject(it));
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
  };

  var copyConstructorProperties = function (target, source) {
    var keys = ownKeys(source);
    var defineProperty = objectDefineProperty.f;
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  };

  var replacement = /#|\.prototype\./;

  var isForced = function (feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true
      : value == NATIVE ? false
      : typeof detection == 'function' ? fails(detection)
      : !!detection;
  };

  var normalize = isForced.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = 'N';
  var POLYFILL = isForced.POLYFILL = 'P';

  var isForced_1 = isForced;

  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
  */
  var _export = function (options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global_1;
    } else if (STATIC) {
      target = global_1[TARGET] || setGlobal(TARGET, {});
    } else {
      target = (global_1[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$1(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
      // contained in target
      if (!FORCED && targetProperty !== undefined) {
        if (typeof sourceProperty === typeof targetProperty) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      // add a flag to not completely full polyfills
      if (options.sham || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty(sourceProperty, 'sham', true);
      }
      // extend global
      redefine(target, key, sourceProperty, options);
    }
  };

  var aFunction$1 = function (it) {
    if (typeof it != 'function') {
      throw TypeError(String(it) + ' is not a function');
    } return it;
  };

  // optional / simple context binding
  var functionBindContext = function (fn, that, length) {
    aFunction$1(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 0: return function () {
        return fn.call(that);
      };
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  // `ToObject` abstract operation
  // https://tc39.github.io/ecma262/#sec-toobject
  var toObject = function (argument) {
    return Object(requireObjectCoercible(argument));
  };

  // `IsArray` abstract operation
  // https://tc39.github.io/ecma262/#sec-isarray
  var isArray = Array.isArray || function isArray(arg) {
    return classofRaw(arg) == 'Array';
  };

  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
    // Chrome 38 Symbol has incorrect toString conversion
    // eslint-disable-next-line no-undef
    return !String(Symbol());
  });

  var useSymbolAsUid = nativeSymbol
    // eslint-disable-next-line no-undef
    && !Symbol.sham
    // eslint-disable-next-line no-undef
    && typeof Symbol.iterator == 'symbol';

  var WellKnownSymbolsStore = shared('wks');
  var Symbol$1 = global_1.Symbol;
  var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

  var wellKnownSymbol = function (name) {
    if (!has(WellKnownSymbolsStore, name)) {
      if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
      else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    } return WellKnownSymbolsStore[name];
  };

  var SPECIES = wellKnownSymbol('species');

  // `ArraySpeciesCreate` abstract operation
  // https://tc39.github.io/ecma262/#sec-arrayspeciescreate
  var arraySpeciesCreate = function (originalArray, length) {
    var C;
    if (isArray(originalArray)) {
      C = originalArray.constructor;
      // cross-realm fallback
      if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
      else if (isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
  };

  var push = [].push;

  // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
  var createMethod$1 = function (TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that, specificCreate) {
      var O = toObject($this);
      var self = indexedObject(O);
      var boundFunction = functionBindContext(callbackfn, that, 3);
      var length = toLength(self.length);
      var index = 0;
      var create = specificCreate || arraySpeciesCreate;
      var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
      var value, result;
      for (;length > index; index++) if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);
        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
            case 3: return true;              // some
            case 5: return value;             // find
            case 6: return index;             // findIndex
            case 2: push.call(target, value); // filter
          } else if (IS_EVERY) return false;  // every
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };

  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
    forEach: createMethod$1(0),
    // `Array.prototype.map` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.map
    map: createMethod$1(1),
    // `Array.prototype.filter` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.filter
    filter: createMethod$1(2),
    // `Array.prototype.some` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.some
    some: createMethod$1(3),
    // `Array.prototype.every` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.every
    every: createMethod$1(4),
    // `Array.prototype.find` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.find
    find: createMethod$1(5),
    // `Array.prototype.findIndex` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod$1(6)
  };

  var arrayMethodIsStrict = function (METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails(function () {
      // eslint-disable-next-line no-useless-call,no-throw-literal
      method.call(null, argument || function () { throw 1; }, 1);
    });
  };

  var defineProperty$1 = Object.defineProperty;
  var cache = {};

  var thrower = function (it) { throw it; };

  var arrayMethodUsesToLength = function (METHOD_NAME, options) {
    if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
    if (!options) options = {};
    var method = [][METHOD_NAME];
    var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
    var argument0 = has(options, 0) ? options[0] : thrower;
    var argument1 = has(options, 1) ? options[1] : undefined;

    return cache[METHOD_NAME] = !!method && !fails(function () {
      if (ACCESSORS && !descriptors) return true;
      var O = { length: -1 };

      if (ACCESSORS) defineProperty$1(O, 1, { enumerable: true, get: thrower });
      else O[1] = 1;

      method.call(O, argument0, argument1);
    });
  };

  var $forEach = arrayIteration.forEach;



  var STRICT_METHOD = arrayMethodIsStrict('forEach');
  var USES_TO_LENGTH = arrayMethodUsesToLength('forEach');

  // `Array.prototype.forEach` method implementation
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  var arrayForEach = (!STRICT_METHOD || !USES_TO_LENGTH) ? function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  } : [].forEach;

  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  _export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
    forEach: arrayForEach
  });

  var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

  var process = global_1.process;
  var versions = process && process.versions;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.');
    version = match[0] + match[1];
  } else if (engineUserAgent) {
    match = engineUserAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = engineUserAgent.match(/Chrome\/(\d+)/);
      if (match) version = match[1];
    }
  }

  var engineV8Version = version && +version;

  var SPECIES$1 = wellKnownSymbol('species');

  var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
    // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/677
    return engineV8Version >= 51 || !fails(function () {
      var array = [];
      var constructor = array.constructor = {};
      constructor[SPECIES$1] = function () {
        return { foo: 1 };
      };
      return array[METHOD_NAME](Boolean).foo !== 1;
    });
  };

  var $map = arrayIteration.map;



  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
  // FF49- issue
  var USES_TO_LENGTH$1 = arrayMethodUsesToLength('map');

  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  // with adding support of @@species
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$1 }, {
    map: function map(callbackfn /* , thisArg */) {
      return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // `Object.keys` method
  // https://tc39.github.io/ecma262/#sec-object.keys
  var objectKeys = Object.keys || function keys(O) {
    return objectKeysInternal(O, enumBugKeys);
  };

  var nativeAssign = Object.assign;
  var defineProperty$2 = Object.defineProperty;

  // `Object.assign` method
  // https://tc39.github.io/ecma262/#sec-object.assign
  var objectAssign = !nativeAssign || fails(function () {
    // should have correct order of operations (Edge bug)
    if (descriptors && nativeAssign({ b: 1 }, nativeAssign(defineProperty$2({}, 'a', {
      enumerable: true,
      get: function () {
        defineProperty$2(this, 'b', {
          value: 3,
          enumerable: false
        });
      }
    }), { b: 2 })).b !== 1) return true;
    // should work with symbols and should have deterministic property order (V8 bug)
    var A = {};
    var B = {};
    // eslint-disable-next-line no-undef
    var symbol = Symbol();
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    alphabet.split('').forEach(function (chr) { B[chr] = chr; });
    return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
  }) ? function assign(target, source) { // eslint-disable-line no-unused-vars
    var T = toObject(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    var propertyIsEnumerable = objectPropertyIsEnumerable.f;
    while (argumentsLength > index) {
      var S = indexedObject(arguments[index++]);
      var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys[j++];
        if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
      }
    } return T;
  } : nativeAssign;

  // `Object.assign` method
  // https://tc39.github.io/ecma262/#sec-object.assign
  _export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
    assign: objectAssign
  });

  // iterable DOM collections
  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  for (var COLLECTION_NAME in domIterables) {
    var Collection = global_1[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
      createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
    } catch (error) {
      CollectionPrototype.forEach = arrayForEach;
    }
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  var arrayLikeToArray = _arrayLikeToArray;

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }

  var arrayWithoutHoles = _arrayWithoutHoles;

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  var iterableToArray = _iterableToArray;

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
  }

  var unsupportedIterableToArray = _unsupportedIterableToArray;

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var nonIterableSpread = _nonIterableSpread;

  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
  }

  var toConsumableArray = _toConsumableArray;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var defineProperty$3 = _defineProperty;

  var aPossiblePrototype = function (it) {
    if (!isObject(it) && it !== null) {
      throw TypeError("Can't set " + String(it) + ' as a prototype');
    } return it;
  };

  // `Object.setPrototypeOf` method
  // https://tc39.github.io/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  /* eslint-disable no-proto */
  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
      setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
      setter.call(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) { /* empty */ }
    return function setPrototypeOf(O, proto) {
      anObject(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter.call(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  // makes subclassing work correct for wrapped built-ins
  var inheritIfRequired = function ($this, dummy, Wrapper) {
    var NewTarget, NewTargetPrototype;
    if (
      // it can work only with native `setPrototypeOf`
      objectSetPrototypeOf &&
      // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
      typeof (NewTarget = dummy.constructor) == 'function' &&
      NewTarget !== Wrapper &&
      isObject(NewTargetPrototype = NewTarget.prototype) &&
      NewTargetPrototype !== Wrapper.prototype
    ) objectSetPrototypeOf($this, NewTargetPrototype);
    return $this;
  };

  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
    return O;
  };

  var html = getBuiltIn('document', 'documentElement');

  var GT = '>';
  var LT = '<';
  var PROTOTYPE = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO = sharedKey('IE_PROTO');

  var EmptyConstructor = function () { /* empty */ };

  var scriptTag = function (content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  };

  // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
  var NullProtoObjectViaActiveX = function (activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak
    return temp;
  };

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var NullProtoObjectViaIFrame = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  };

  // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug
  var activeXDocument;
  var NullProtoObject = function () {
    try {
      /* global ActiveXObject */
      activeXDocument = document.domain && new ActiveXObject('htmlfile');
    } catch (error) { /* ignore */ }
    NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
    var length = enumBugKeys.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
  };

  hiddenKeys[IE_PROTO] = true;

  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  var objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : objectDefineProperties(result, Properties);
  };

  // a string of all valid unicode whitespaces
  // eslint-disable-next-line max-len
  var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var whitespace = '[' + whitespaces + ']';
  var ltrim = RegExp('^' + whitespace + whitespace + '*');
  var rtrim = RegExp(whitespace + whitespace + '*$');

  // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
  var createMethod$2 = function (TYPE) {
    return function ($this) {
      var string = String(requireObjectCoercible($this));
      if (TYPE & 1) string = string.replace(ltrim, '');
      if (TYPE & 2) string = string.replace(rtrim, '');
      return string;
    };
  };

  var stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
    start: createMethod$2(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
    end: createMethod$2(2),
    // `String.prototype.trim` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.trim
    trim: createMethod$2(3)
  };

  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
  var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
  var defineProperty$4 = objectDefineProperty.f;
  var trim = stringTrim.trim;

  var NUMBER = 'Number';
  var NativeNumber = global_1[NUMBER];
  var NumberPrototype = NativeNumber.prototype;

  // Opera ~12 has broken Object#toString
  var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER;

  // `ToNumber` abstract operation
  // https://tc39.github.io/ecma262/#sec-tonumber
  var toNumber = function (argument) {
    var it = toPrimitive(argument, false);
    var first, third, radix, maxCode, digits, length, index, code;
    if (typeof it == 'string' && it.length > 2) {
      it = trim(it);
      first = it.charCodeAt(0);
      if (first === 43 || first === 45) {
        third = it.charCodeAt(2);
        if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
      } else if (first === 48) {
        switch (it.charCodeAt(1)) {
          case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
          case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
          default: return +it;
        }
        digits = it.slice(2);
        length = digits.length;
        for (index = 0; index < length; index++) {
          code = digits.charCodeAt(index);
          // parseInt parses a string to a first unavailable symbol
          // but ToNumber should return NaN if a string contains unavailable symbols
          if (code < 48 || code > maxCode) return NaN;
        } return parseInt(digits, radix);
      }
    } return +it;
  };

  // `Number` constructor
  // https://tc39.github.io/ecma262/#sec-number-constructor
  if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
    var NumberWrapper = function Number(value) {
      var it = arguments.length < 1 ? 0 : value;
      var dummy = this;
      return dummy instanceof NumberWrapper
        // check on 1..constructor(foo) case
        && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classofRaw(dummy) != NUMBER)
          ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
    };
    for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : (
      // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
      // ES2015 (in case, if modules with ES2015 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
      'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
    ).split(','), j = 0, key; keys$1.length > j; j++) {
      if (has(NativeNumber, key = keys$1[j]) && !has(NumberWrapper, key)) {
        defineProperty$4(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
      }
    }
    NumberWrapper.prototype = NumberPrototype;
    NumberPrototype.constructor = NumberWrapper;
    redefine(global_1, NUMBER, NumberWrapper);
  }

  var defaultNumberInputProp = {// step: 1,
    // min: 0,
    // max: 144
  };
  var dataSourceLayout = {
    labelCol: {
      span: 24
    },
    wrapperCol: {
      span: 24,
      offset: 0
    }
  };
  var PropTypes = {
    boolean: function boolean() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$label = _ref.label,
          label = _ref$label === void 0 ? 'å¼å³' : _ref$label,
          _ref$defaultValue = _ref.defaultValue,
          defaultValue = _ref$defaultValue === void 0 ? false : _ref$defaultValue,
          _ref$props = _ref.props,
          props = _ref$props === void 0 ? {} : _ref$props,
          _ref$visible = _ref.visible,
          visible = _ref$visible === void 0 ? true : _ref$visible;

      return {
        type: Boolean,
        default: defaultValue,
        visible: visible,
        editor: {
          type: 'a-switch',
          label: label,
          props: props
        }
      };
    },
    required: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },

    /**
     * é¢è² é»è®¤ç¼è¾å¨
     * Q: ä¸ºä»ä¹ transparent æ æï¼
     * A: æ³¨æï¼æ ¹æ® MDN ææ¡£ï¼é¢è²éæ©å¨ç value åªè½æ¯ï¼# + 6ä¸ª16è¿å¶å­ç¬¦ä¸²
     * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/color#Value
     * The value of an <input> element of type color is always a DOMString which contains a 7-character string specifying an RGB color in hexadecimal format.
     *
     */
    color: function color() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$label = _ref2.label,
          label = _ref2$label === void 0 ? 'æå­é¢è²' : _ref2$label,
          _ref2$defaultValue = _ref2.defaultValue,
          defaultValue = _ref2$defaultValue === void 0 ? '#000000' : _ref2$defaultValue,
          _ref2$visible = _ref2.visible,
          visible = _ref2$visible === void 0 ? true : _ref2$visible;

      return {
        type: String,
        default: defaultValue,
        visible: visible,
        editor: {
          type: 'colors-panel',
          label: label,
          props: {
            size: 'mini',
            showAlpha: true
          },
          require: true
        }
      };
    },
    colors: function colors() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$label = _ref3.label,
          label = _ref3$label === void 0 ? 'é¢è²é¢æ¿' : _ref3$label,
          _ref3$defaultValue = _ref3.defaultValue,
          defaultValue = _ref3$defaultValue === void 0 ? function () {
        return [];
      } : _ref3$defaultValue,
          _ref3$layout = _ref3.layout,
          layout = _ref3$layout === void 0 ? dataSourceLayout : _ref3$layout,
          _ref3$visible = _ref3.visible,
          visible = _ref3$visible === void 0 ? true : _ref3$visible;

      return {
        type: Array,
        default: defaultValue,
        visible: visible,
        editor: {
          type: 'colors-panel',
          label: label,
          // !#zh ä¸ºç¼è¾ç»ä»¶æå® props
          props: {
            size: 'mini',
            showAlpha: true
          },
          layout: layout,
          require: true
        }
      };
    },

    /**
     * æ°å¼ç±»å é»è®¤ç¼è¾å¨
     */
    number: function number() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$label = _ref4.label,
          label = _ref4$label === void 0 ? 'æ°å¼' : _ref4$label,
          _ref4$defaultValue = _ref4.defaultValue,
          defaultValue = _ref4$defaultValue === void 0 ? 10 : _ref4$defaultValue,
          _ref4$props = _ref4.props,
          props = _ref4$props === void 0 ? defaultNumberInputProp : _ref4$props,
          _ref4$visible = _ref4.visible,
          visible = _ref4$visible === void 0 ? true : _ref4$visible;

      return {
        type: Number,
        default: defaultValue,
        visible: visible,
        editor: {
          type: 'a-input-number',
          label: label,
          require: true,
          props: props
        }
      };
    },

    /**
     * ææ¬ç±»å é»è®¤ç¼è¾å¨
     *
     * component å¯ä»¥éç¨
     * 1. a-input
     * 2. a-textarea
     * 3. å¯ææ¬ç¼è¾å¨
     */
    string: function string() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$label = _ref5.label,
          label = _ref5$label === void 0 ? 'æé®æå­' : _ref5$label,
          _ref5$defaultValue = _ref5.defaultValue,
          defaultValue = _ref5$defaultValue === void 0 ? 'æé®' : _ref5$defaultValue,
          _ref5$component = _ref5.component,
          component = _ref5$component === void 0 ? 'a-input' : _ref5$component,
          _ref5$props = _ref5.props,
          props = _ref5$props === void 0 ? {} : _ref5$props,
          extra = _ref5.extra,
          _ref5$visible = _ref5.visible,
          visible = _ref5$visible === void 0 ? true : _ref5$visible;

      return {
        type: String,
        default: defaultValue,
        visible: visible,
        editor: {
          type: component,
          label: label,
          require: true,
          props: props,
          extra: extra
        }
      };
    },
    textAlign: function textAlign() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$label = _ref6.label,
          label = _ref6$label === void 0 ? 'æå­å¯¹é½' : _ref6$label,
          _ref6$defaultValue = _ref6.defaultValue,
          defaultValue = _ref6$defaultValue === void 0 ? 'center' : _ref6$defaultValue,
          _ref6$visible = _ref6.visible,
          visible = _ref6$visible === void 0 ? true : _ref6$visible;

      return {
        type: String,
        default: defaultValue,
        visible: visible,
        editor: {
          type: 'lbs-text-align',
          label: label,
          require: true
        }
      };
    },
    textOptions: function textOptions() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$label = _ref7.label,
          label = _ref7$label === void 0 ? 'éé¡¹åè¡¨' : _ref7$label,
          _ref7$defaultValue = _ref7.defaultValue,
          defaultValue = _ref7$defaultValue === void 0 ? function () {
        return [{
          label: 'label1',
          value: 'value1'
        }];
      } : _ref7$defaultValue,
          _ref7$visible = _ref7.visible,
          visible = _ref7$visible === void 0 ? true : _ref7$visible;

      return {
        type: Array,
        default: defaultValue,
        visible: visible,
        editor: {
          type: 'lbs-props-text-enum-editor',
          label: label,
          require: true
        }
      };
    },
    image: function image() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$label = _ref8.label,
          label = _ref8$label === void 0 ? 'å¾ç' : _ref8$label,
          _ref8$defaultValue = _ref8.defaultValue,
          defaultValue = _ref8$defaultValue === void 0 ? '' : _ref8$defaultValue,
          _ref8$visible = _ref8.visible,
          visible = _ref8$visible === void 0 ? true : _ref8$visible;

      return {
        type: String,
        default: defaultValue,
        visible: visible,
        editor: {
          type: 'lbs-image-gallery',
          label: label
        }
      };
    },

    /**
     * æ°æ®æºç»ä»¶
     */
    excel: function excel() {
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref9$label = _ref9.label,
          label = _ref9$label === void 0 ? 'æ°æ®æº' : _ref9$label,
          _ref9$defaultValue = _ref9.defaultValue,
          defaultValue = _ref9$defaultValue === void 0 ? [] : _ref9$defaultValue,
          _ref9$layout = _ref9.layout,
          layout = _ref9$layout === void 0 ? dataSourceLayout : _ref9$layout,
          _ref9$visible = _ref9.visible,
          visible = _ref9$visible === void 0 ? true : _ref9$visible;

      return {
        type: Array,
        default: defaultValue,
        visible: visible,
        editor: {
          type: 'lbs-excel-editor',
          label: label,
          layout: layout
        }
      };
    },
    select: function select() {
      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref10$valueType = _ref10.valueType,
          valueType = _ref10$valueType === void 0 ? String : _ref10$valueType,
          _ref10$label = _ref10.label,
          label = _ref10$label === void 0 ? 'éé¡¹' : _ref10$label,
          _ref10$defaultValue = _ref10.defaultValue,
          defaultValue = _ref10$defaultValue === void 0 ? [] : _ref10$defaultValue,
          _ref10$visible = _ref10.visible,
          visible = _ref10$visible === void 0 ? true : _ref10$visible,
          _ref10$options = _ref10.options,
          options = _ref10$options === void 0 ? [] : _ref10$options;

      return {
        type: valueType,
        default: defaultValue,
        visible: visible,
        editor: {
          type: 'a-select',
          label: label,
          props: {
            options: options
          }
        }
      };
    }
  };

  var LbpButton = {
    render: function render() {
      var h = arguments[0];
      var color = this.color,
          textAlign = this.textAlign,
          backgroundColor = this.backgroundColor,
          fontSize = this.fontSize,
          lineHeight = this.lineHeight,
          borderColor = this.borderColor,
          borderRadius = this.borderRadius,
          borderWidth = this.borderWidth,
          text = this.text;
      var style = {
        color: color,
        textAlign: textAlign,
        backgroundColor: backgroundColor,
        fontSize: fontSize,
        lineHeight: lineHeight + 'em',
        borderColor: borderColor,
        borderRadius: borderRadius + 'px',
        borderWidth: borderWidth + 'px',
        textDecoration: 'none',
        width: "".concat(this.width, "px"),
        height: "".concat(this.height, "px")
      };
      return h("button", {
        "style": style
      }, [text]);
    },
    name: 'lbp-button',
    props: {
      width: {
        type: Number,
        default: 120
      },
      height: {
        type: Number,
        default: 40
      },
      text: PropTypes.string(),
      vertical: PropTypes.boolean(),
      backgroundColor: PropTypes.color({
        label: 'èæ¯è²',
        defaultValue: '#ffffff'
      }),
      color: PropTypes.color(),
      fontSize: PropTypes.number({
        label: 'å­å·(px)',
        defaultValue: 14
      }),
      lineHeight: PropTypes.number({
        label: 'è¡é«(px)',
        defaultValue: 1
      }),
      borderWidth: PropTypes.number({
        label: 'è¾¹æ¡å®½åº¦(px)',
        defaultValue: 1
      }),
      borderRadius: PropTypes.number({
        label: 'åè§(px)',
        defaultValue: 4
      }),
      borderColor: PropTypes.color({
        label: 'è¾¹æ¡é¢è²',
        defaultValue: '#ced4da'
      }),
      textAlign: PropTypes.textAlign()
    }
  };

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-10-27 15:04:59
   * @LastEditTime : 2020-11-11 10:27:57
   * @Description :
   */
  var LbpPicture = {
    name: 'lbp-picture',
    render: function render() {
      var h = arguments[0];
      return h("img", {
        "attrs": {
          "src": this.imgSrc,
          "alt": "",
          "srcset": "",
          "width": "100%"
        },
        "style": {
          objectFit: this.fillType
        }
      });
    },
    props: {
      imgSrc: PropTypes.string({
        label: 'å¾çå°å'
      }),
      fillType: {
        type: String,
        default: 'contain',
        editor: {
          type: 'a-select',
          label: 'å¡«åæ¹å¼',
          props: {
            options: [{
              label: 'contain ç­è¾¹ç¼©æ¾',
              value: 'contain'
            }, {
              label: 'cover é¿è¾¹ç¼©æ¾',
              value: 'cover'
            }, {
              label: 'fill æä¼¸',
              value: 'fill'
            }, {
              label: 'none åå§',
              value: 'none'
            }, {
              label: 'scale-down å¼¹æ§ç¼©æ¾',
              value: 'scale-down'
            }]
          }
        }
      }
    }
  };

  var playIcon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4NCjxzdmcgd2lkdGg9IjMyMHB4IiBoZWlnaHQ9IjE4MHB4IiB2aWV3Qm94PSIwIDAgMzIwIDE4MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4NCiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUxLjMgKDU3NTQ0KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4NCiAgICA8dGl0bGU+UmVjdGFuZ2xlIDM8L3RpdGxlPg0KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPg0KICAgIDxkZWZzPjwvZGVmcz4NCiAgICA8ZyBpZD0icGxheSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+DQogICAgICAgIDxnIGlkPSJHcm91cC0yOSIgZmlsbC1ydWxlPSJub256ZXJvIj4NCiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMyIgZmlsbD0iI0Q4RDhEOCIgb3BhY2l0eT0iMCIgeD0iMCIgeT0iMCIgd2lkdGg9IjMyMCIgaGVpZ2h0PSIxODAiPjwvcmVjdD4NCiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0yIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjQuMDAwMDAwLCA1NC4wMDAwMDApIj4NCiAgICAgICAgICAgICAgICA8Y2lyY2xlIGlkPSJDb21iaW5lZC1TaGFwZSIgZmlsbD0iI0ZGRkZGRiIgb3BhY2l0eT0iMC40MDAwMDAwMDYiIGN4PSIzNiIgY3k9IjM2IiByPSIzNiI+PC9jaXJjbGU+DQogICAgICAgICAgICAgICAgPHBhdGggZD0iTTUyLjUwMTQ1NzEsMzguNDY4NzAzOSBMMjkuNTEyNTQ3NCw1My4wOTEwNDA2IEMyOC40MjUyMDE2LDUzLjc4MjY1ODMgMjYuOTgzMDY2Nyw1My40NjE4NTczIDI2LjI5MTQ0OSw1Mi4zNzQ1MTE0IEMyNi4wNTMzNzY0LDUyLjAwMDIxOSAyNS45MjY5Mjk1LDUxLjU2NTgxODMgMjUuOTI2OTI5NSw1MS4xMjIyMjY4IEwyNS45MjY5Mjk1LDIxLjg3NzU1MzQgQzI1LjkyNjkyOTUsMjAuNTg4ODg5IDI2Ljk3MTU5ODQsMTkuNTQ0MjIwMSAyOC4yNjAyNjI4LDE5LjU0NDIyMDEgQzI4LjcwMzg1NDMsMTkuNTQ0MjIwMSAyOS4xMzgyNTUsMTkuNjcwNjY3MSAyOS41MTI1NDc0LDE5LjkwODczOTcgTDUyLjUwMTQ1NzEsMzQuNTMxMDc2NCBDNTMuNTg4ODAyOSwzNS4yMjI2OTQxIDUzLjkwOTYwNCwzNi42NjQ4Mjg5IDUzLjIxNzk4NjMsMzcuNzUyMTc0NyBDNTMuMDM0NTE1OCwzOC4wNDA2MjI5IDUyLjc4OTkwNTIsMzguMjg1MjMzNSA1Mi41MDE0NTcxLDM4LjQ2ODcwMzkgWiIgaWQ9IlRyaWFuZ2xlLTIiIGZpbGw9IiMwMDAwMDAiIG9wYWNpdHk9IjAuNSI+PC9wYXRoPg0KICAgICAgICAgICAgPC9nPg0KICAgICAgICA8L2c+DQogICAgPC9nPg0KPC9zdmc+";

  /*
   * @Author: ly525
   * @Date: 2019-12-01 18:11:50
   * @LastEditors : Please set LastEditors
   * @LastEditTime : 2020-11-17 16:52:08
   * @FilePath: /luban-h5/front-end/h5/src/components/@/plugins/lbp-video.js
   * @Github: https://github.com/ly525/luban-h5
   * @Description: Do not edit
   * @Copyright 2018 - 2020 luban-h5. All Rights Reserved
   */

  var LbpVideo = {
    name: 'lbp-video',
    props: {
      src: PropTypes.string({
        label: 'è§é¢å°å'
      }),
      disabled: PropTypes.boolean({
        label: 'disabled'
      }),
      useIframe: PropTypes.boolean({
        label: 'ä½¿ç¨iframe'
      }),
      iframeSrc: PropTypes.string({
        default: '',
        label: 'iframe å°å',
        props: {
          type: 'textarea',
          placeholder: 'åªæä½¿ç¨iframeæå¼çæ¶åï¼è¿ä¸ªæææ'
        },
        extra: function extra(h) {
          return 'ãä½¿ç¨iframeãæå¼çæ¶åï¼è¿ä¸ªæææï¼ä¸ä¼ è§é¢è¯·å¿½ç¥è¯¥éç½®';
        }
      })
    },
    watch: {
      src: function src() {
        this.appendIframe();
      },
      disabled: function disabled() {
        this.appendIframe();
      },
      useIframe: function useIframe() {
        this.appendIframe();
      },
      iframeSrc: function iframeSrc() {
        this.appendIframe();
      }
    },
    mounted: function mounted() {
      this.appendIframe();
    },
    methods: {
      appendIframe: function appendIframe() {
        if (this.useIframe && this.iframeSrc) {
          // v-html
          this.$refs.iframeWrapper && (this.$refs.iframeWrapper.innerHTML = this.iframeSrc);
        } // else if (this.src) {
        //   this.$refs.videoTag && (this.$refs.videoTag.innerHTML = `<source type="video/mp4" src=${this.src} />`)
        // }

      }
    },
    render: function render(h) {
      var style = this.disabled ? {
        'pointer-events': 'none'
      } : {};
      return h("div", {
        "class": "lbc-video",
        "style": style
      }, [this.useIframe ? h("div", {
        "ref": "iframeWrapper"
      }, [h("img", {
        "attrs": {
          "src": playIcon,
          "width": "100%",
          "height": "100%"
        }
      })]) : h("video", {
        "attrs": {
          "playsinline": "true",
          "webkit-playsinline": "",
          "width": "100%",
          "height": "100%",
          "poster": playIcon,
          "controls": true
        },
        "ref": "videoTag"
      }, [h("source", {
        "attrs": {
          "type": "video/mp4",
          "src": this.src
        }
      })])]);
    },
    componentsForPropsEditor: {}
  };

  var createProperty = function (object, key, value) {
    var propertyKey = toPrimitive(key);
    if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
    else object[propertyKey] = value;
  };

  var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
  var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/679
  var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
  });

  var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

  var isConcatSpreadable = function (O) {
    if (!isObject(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== undefined ? !!spreadable : isArray(O);
  };

  var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

  // `Array.prototype.concat` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.concat
  // with adding support of @@isConcatSpreadable and @@species
  _export({ target: 'Array', proto: true, forced: FORCED }, {
    concat: function concat(arg) { // eslint-disable-line no-unused-vars
      var O = toObject(this);
      var A = arraySpeciesCreate(O, 0);
      var n = 0;
      var i, k, length, len, E;
      for (i = -1, length = arguments.length; i < length; i++) {
        E = i === -1 ? O : arguments[i];
        if (isConcatSpreadable(E)) {
          len = toLength(E.length);
          if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
        } else {
          if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          createProperty(A, n++, E);
        }
      }
      A.length = n;
      return A;
    }
  });

  var LbpText = {
    render: function render(h) {
      var _this = this;

      var canEdit = this.canEdit && this.editorMode === 'edit';
      var style = {
        position: 'relative',
        color: "".concat(this.color, " !important"),
        textDecoration: 'none',
        backgroundColor: this.backgroundColor || 'rgba(255, 255, 255, 0.2)',
        lineHeight: "".concat(this.lineHeight, "em"),
        border: "".concat(this.borderWidth, "px solid ").concat(this.borderColor),
        borderRadius: "".concat(this.borderRadius, "px")
      };
      /**
       * https://github.com/ly525/luban-h5/issues/155
       * éè¦ç»é¢è§æ¨¡å¼çæå­æ·»å  ql-snow æ ·å¼åå ï¼æå­æ ·å¼åæå­ç¼è¾å¨(ql-editor)ç theme æå³ç³»
       * æ¯å¦ç¼è¾æ¨¡å¼ h1 æ ·å¼ä¸ºï¼.ql-snow .ql-editor h1 {font-size: 2em;}
       * å æ­¤é¢è§æ¨¡å¼çæå­åå®¹ä¹éè¦å ä¸ div.ql-snow > div.ql-editor ä½ä¸ºwrapper
       */

      var previewText = h("div", {
        "class": "ql-snow"
      }, [h("div", {
        "domProps": {
          "innerHTML": this.text
        },
        "class": "ql-editor ql-container"
      })]);
      return h("div", {
        "on": {
          "dblclick": function dblclick(e) {
            _this.canEdit = true;
            e.stopPropagation();
          },
          "mousedown": function mousedown(e) {
            if (_this.canEdit) {
              e.stopPropagation();
            }
          },
          "keydown": function keydown(event) {
            var key = event.keyCode || event.charCode; // #!en: backspace/delete key should only delete letter in textarea, do not delete element in canvas
            // #!zh: é®çå é¤ï¼åºè¯¥åªå é¤æå­ç»ä»¶éé¢çæå­ï¼èä¸æ¯å é¤ç»å¸ä¸çåç´ 

            if (key === 8 || key === 46) {
              event.stopPropagation();
            }
          }
        },
        "style": style
      }, [canEdit ? h(vueQuillEditor.quillEditor, {
        "attrs": {
          "content": this.text,
          "options": {
            modules: {
              // toolbar: '#toolbar-wrapper'
              toolbar: [['bold', 'italic', 'underline', 'strike'], // åæ¢æé®
              [{
                list: 'ordered'
              }, {
                list: 'bullet'
              }], [{
                color: []
              }, {
                background: []
              }], // ä¸»é¢é»è®¤ä¸æï¼ä½¿ç¨ä¸»é¢æä¾çå¼
              [{
                align: []
              }], ['clean'], // æ¸é¤æ ¼å¼
              [{
                header: [1, 2, 3, 4, 5, 6, false]
              }] // https://github.com/quilljs/quill/issues/1208
              ]
            },
            theme: 'snow'
          }
        },
        "on": {
          "change": function change(_ref) {
            var quill = _ref.quill,
                html = _ref.html,
                text = _ref.text;

            _this.$emit('input', {
              value: html,
              pluginName: 'lbp-text'
            });
          }
        }
      }) : previewText]);
    },
    name: 'lbp-text',
    data: function data() {
      return {
        canEdit: false,
        innerText: this.text || 'åå»ä¿®æ¹æå­'
      };
    },
    props: {
      backgroundColor: PropTypes.color({
        label: 'èæ¯è²',
        defaultValue: 'rgba(0, 0, 0, 0)'
      }),
      borderWidth: PropTypes.number({
        label: 'è¾¹æ¡å®½åº¦(px)',
        defaultValue: 0
      }),
      borderRadius: PropTypes.number({
        label: 'åè§(px)'
      }),
      borderColor: PropTypes.color({
        label: 'è¾¹æ¡é¢è²'
      }),
      text: PropTypes.string({
        label: 'åå®¹',
        defaultValue: 'åå»ä¿®æ¹æå­',
        visible: false
      }),
      editorMode: PropTypes.string({
        defaultValue: 'preview',
        // å¯éå¼: preview/edit
        label: 'æ¨¡å¼',
        visible: false
      })
    },
    editorConfig: {}
  };

  var typeOptions = [{
    label: 'æå­',
    value: 'text'
  }, {
    label: 'å¯ç ',
    value: 'password'
  }, {
    label: 'æ¥æ',
    value: 'date'
  }, {
    label: 'é®ç®±',
    value: 'email'
  }, {
    label: 'ææºå·',
    value: 'tel'
  }];
  var LbpFormInput = {
    name: 'lbp-form-input',
    render: function render(h) {
      var style = {
        color: this.color,
        textAlign: this.textAlign,
        backgroundColor: this.backgroundColor,
        fontSize: this.fontSize + 'px',
        lineHeight: this.lineHeight + 'em',
        borderColor: this.borderColor,
        borderRadius: this.borderRadius + 'px',
        borderWidth: this.borderWidth + 'px',
        padding: '0 5px'
      };
      return h("input", {
        "attrs": {
          "disabled": this.disabled,
          "type": this.type,
          "name": this.name,
          "placeholder": this.placeholder,
          "autocomplete": "off",
          "data-type": "lbp-form-input"
        },
        "style": style
      });
    },
    props: {
      type: PropTypes.select({
        defaultValue: 'text',
        label: 'ç±»å',
        options: typeOptions
      }),
      name: PropTypes.string({
        defaultValue: 'name',
        label: 'name'
      }),
      disabled: PropTypes.boolean({
        label: 'disabled'
      }),
      fontSize: PropTypes.number({
        label: 'å­å·(px)'
      }),
      placeholder: PropTypes.string({
        defaultValue: 'æç¤ºä¿¡æ¯',
        label: 'æç¤ºä¿¡æ¯'
      }),
      color: PropTypes.color(),
      backgroundColor: PropTypes.color({
        label: 'èæ¯è²',
        defaultValue: 'rgba(255, 255, 255, 0.2)'
      }),
      borderWidth: PropTypes.number({
        label: 'è¾¹æ¡å®½åº¦(px)',
        defaultValue: 1
      }),
      borderRadius: PropTypes.number({
        label: 'åè§(px)',
        defaultValue: 0
      }),
      borderColor: PropTypes.color({
        label: 'è¾¹æ¡é¢è²',
        defaultValue: '#ced4da'
      }),
      textAlign: PropTypes.textAlign({
        defaultValue: 'left'
      }),
      vertical: PropTypes.boolean(),
      lineHeight: PropTypes.number({
        label: 'è¡é«(px)',
        defaultValue: 1
      })
    }
  }; // .lb-plugin__input {
  //   display: block;
  //   margin: 0;
  //   padding: 0 5px;
  //   box-sizing: border-box;
  //   overflow: visible;
  //   border: 1px solid #ced4da;
  //   &:focus {
  //     outline: none;
  //   }
  // }

  var LbpFormButton = {
    render: function render() {
      var h = arguments[0];
      var color = this.color,
          textAlign = this.textAlign,
          backgroundColor = this.backgroundColor,
          fontSize = this.fontSize,
          lineHeight = this.lineHeight,
          borderColor = this.borderColor,
          borderRadius = this.borderRadius,
          borderWidth = this.borderWidth,
          text = this.text,
          disabled = this.disabled;
      var style = {
        color: color,
        textAlign: textAlign,
        backgroundColor: backgroundColor,
        fontSize: fontSize,
        lineHeight: lineHeight + 'em',
        borderColor: borderColor,
        borderRadius: borderRadius + 'px',
        borderWidth: borderWidth + 'px',
        textDecoration: 'none',
        disabled: disabled
      };
      return h("button", {
        "style": style,
        "on": {
          "click": this.handleClick
        }
      }, [text]);
    },
    name: 'lbp-form-button',
    props: {
      text: PropTypes.string({
        defaultValue: 'æäº¤'
      }),
      vertical: PropTypes.boolean(),
      backgroundColor: PropTypes.color({
        label: 'èæ¯è²',
        defaultValue: 'rgba(255, 255, 255, 0.2)'
      }),
      color: PropTypes.color(),
      fontSize: PropTypes.number({
        label: 'å­å·(px)',
        defaultValue: 14
      }),
      lineHeight: PropTypes.number({
        label: 'è¡é«(px)',
        defaultValue: 1
      }),
      borderWidth: PropTypes.number({
        label: 'è¾¹æ¡å®½åº¦(px)',
        defaultValue: 1
      }),
      borderRadius: PropTypes.number({
        label: 'åè§(px)',
        defaultValue: 4
      }),
      borderColor: PropTypes.color({
        label: 'è¾¹æ¡é¢è²',
        defaultValue: '#ced4da'
      }),
      textAlign: PropTypes.textAlign(),
      disabled: PropTypes.boolean()
    },
    methods: {
      handleClick: function handleClick() {
        if (this.disabled) return; // #!zh: data-type=lbp-form-input å¨ lbp-form-input ç»ä»¶ä¸­å®ä¹

        var inputs = document.querySelectorAll("[data-type^='lbp-form-input']");
        if (!inputs.length) return;
        var self = this;
        var formData = new FormData();
        inputs.forEach(function (input) {
          return formData.append(input.dataset.uuid, input.value);
        });
        var req = new XMLHttpRequest();

        req.onreadystatechange = function () {
          if (req.readyState === 4) {
            var message = req.status === 200 ? 'æäº¤æå' : 'æäº¤å¤±è´¥';
            self.$message.info(message);
          }
        };

        var workId = window.__work.id; // TODO #!zh: å¯ä»¥å¨æéç½®è¡¨åæäº¤å°å

        req.open('post', "/works/form/submit/".concat(workId), true);
        req.send(formData);
      }
    }
  };

  var $indexOf = arrayIncludes.indexOf;



  var nativeIndexOf = [].indexOf;

  var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
  var STRICT_METHOD$1 = arrayMethodIsStrict('indexOf');
  var USES_TO_LENGTH$2 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  _export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$1 || !USES_TO_LENGTH$2 }, {
    indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
      return NEGATIVE_ZERO
        // convert -0 to +0
        ? nativeIndexOf.apply(this, arguments) || 0
        : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var nativeJoin = [].join;

  var ES3_STRINGS = indexedObject != Object;
  var STRICT_METHOD$2 = arrayMethodIsStrict('join', ',');

  // `Array.prototype.join` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.join
  _export({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD$2 }, {
    join: function join(separator) {
      return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
    }
  });

  var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('splice');
  var USES_TO_LENGTH$3 = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

  var max$1 = Math.max;
  var min$2 = Math.min;
  var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

  // `Array.prototype.splice` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.splice
  // with adding support of @@species
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$3 }, {
    splice: function splice(start, deleteCount /* , ...items */) {
      var O = toObject(this);
      var len = toLength(O.length);
      var actualStart = toAbsoluteIndex(start, len);
      var argumentsLength = arguments.length;
      var insertCount, actualDeleteCount, A, k, from, to;
      if (argumentsLength === 0) {
        insertCount = actualDeleteCount = 0;
      } else if (argumentsLength === 1) {
        insertCount = 0;
        actualDeleteCount = len - actualStart;
      } else {
        insertCount = argumentsLength - 2;
        actualDeleteCount = min$2(max$1(toInteger(deleteCount), 0), len - actualStart);
      }
      if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
        throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
      }
      A = arraySpeciesCreate(O, actualDeleteCount);
      for (k = 0; k < actualDeleteCount; k++) {
        from = actualStart + k;
        if (from in O) createProperty(A, k, O[from]);
      }
      A.length = actualDeleteCount;
      if (insertCount < actualDeleteCount) {
        for (k = actualStart; k < len - actualDeleteCount; k++) {
          from = k + actualDeleteCount;
          to = k + insertCount;
          if (from in O) O[to] = O[from];
          else delete O[to];
        }
        for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
      } else if (insertCount > actualDeleteCount) {
        for (k = len - actualDeleteCount; k > actualStart; k--) {
          from = k + actualDeleteCount - 1;
          to = k + insertCount - 1;
          if (from in O) O[to] = O[from];
          else delete O[to];
        }
      }
      for (k = 0; k < insertCount; k++) {
        O[k + actualStart] = arguments[k + 2];
      }
      O.length = len - actualDeleteCount + insertCount;
      return A;
    }
  });

  var LbpFormRadio = {
    name: 'lbp-form-radio',
    props: {
      value: {
        type: [String, Number],
        default: 'éé¡¹å¼'
      },
      aliasName: {
        type: String,
        default: 'æ é¢æ¼ç¤º'
      },
      type: {
        type: String,
        default: 'radio'
      },
      checked: {
        type: Boolean,
        default: false
      },
      onFocus: {
        type: Function,
        default: function _default() {}
      },
      onClick: {
        type: Function,
        default: function _default() {}
      },
      onBlur: {
        type: Function,
        default: function _default() {}
      },
      doChange: {
        type: Function,
        default: function _default() {}
      }
    },
    methods: {
      handleChange: function handleChange(e) {
        if (this.disabled) return;
        this.$emit('change', e.target.value);
      }
    },
    render: function render() {
      var h = arguments[0];
      var aliasName = this.aliasName,
          type = this.type,
          disabled = this.disabled,
          checked = this.checked,
          value = this.value;
      var uuid = +new Date();
      return h("div", {
        "class": ['lbp-' + this.type + '-wrapper', 'lbp-rc-wrapper']
      }, [h("span", {
        "class": "tag"
      }, [value]), h("input", {
        "class": ['lbp-' + this.type, 'lbp-rc-input'],
        "attrs": {
          "name": aliasName,
          "id": uuid,
          "type": type,
          "disabled": disabled
        },
        "ref": "input",
        "domProps": {
          "value": value,
          "checked": !!checked
        },
        "on": {
          "change": this.handleChange
        }
      }), h("label", {
        "attrs": {
          "for": uuid
        }
      })]);
    }
  };

  function getDefaultItems() {
    // defaultItems.slice(0)[0] === defaultItems.slice(0)[0] -> true
    // Object.assign(defaultItems)[0] === Object.assign(defaultItems)[0] -> true
    // clone = (val) => JSON.parse(JSON.stringify(val))
    // clone(defaultItems)[0] === clone(defaultItems)[0] -> false
    var defaultItems = [{
      value: 'éé¡¹A'
    }, {
      value: 'éé¡¹B'
    }, {
      value: 'éé¡¹C'
    }];
    return defaultItems;
  }

  var LbpFormRadioGroup = {
    name: 'lbp-form-radio-group',
    props: {
      width: {
        default: 120
      },
      height: {
        default: 120
      },
      aliasName: PropTypes.string({
        defaultValue: 'æ é¢æ¼ç¤º',
        label: 'å¡«åæ é¢'
      }),
      items: PropTypes.textOptions({
        label: 'éé¡¹åè¡¨',
        defaultValue: function defaultValue() {
          return getDefaultItems();
        }
      }),
      type: {
        type: String,
        default: 'radio',
        editor: {
          type: 'a-radio-group',
          label: 'éæ©æ¨¡å¼',
          require: true,
          props: {
            options: [{
              label: 'åé',
              value: 'radio'
            }, {
              label: 'å¤é',
              value: 'checkbox'
            }],
            name: 'mode'
          }
        }
      }
    },
    data: function data() {
      return {
        value: this.type === 'radio' ? '' : [],
        uuid: undefined
      };
    },
    computed: {
      value_: function value_() {
        if (this.type === 'radio') {
          return this.value;
        } else {
          var value = Array.isArray(this.value) && this.value || [];
          return value.join(',');
        }
      }
    },
    watch: {
      type: function type(_type) {
        this.value = _type === 'radio' ? '' : [];
      }
    },
    mounted: function mounted() {
      this.uuid = this.$el.dataset.uuid;
    },
    methods: {
      /**
       * @param {String, Number} val radioValue or checkboxValue
       */
      onChange: function onChange(val) {
        switch (this.type) {
          case 'radio':
            this.toggleRadio(val);
            break;

          case 'checkbox':
            this.toggleCheckbox(val);
            break;
        }
      },
      toggleCheckbox: function toggleCheckbox(val) {
        var index = this.value.indexOf(val);

        if (index === -1) {
          this.value.push(val);
        } else {
          this.value.splice(index, 1);
        }
      },
      toggleRadio: function toggleRadio(val) {
        this.value = val;
      }
    },
    render: function render() {
      var _this = this;

      var h = arguments[0];
      return h("div", [h("h3", [this.aliasName]), h("input", {
        "attrs": {
          "type": "text",
          "hidden": true,
          "data-type": "lbp-form-input",
          "data-uuid": this.uuid
        },
        "domProps": {
          "value": this.value_
        }
      }), this.items.map(function (item) {
        return h(LbpFormRadio, {
          "attrs": {
            "vertical": true,
            "value": item.value,
            "checked": _this.value === item.value,
            "aliasName": _this.uuid,
            "type": _this.type
          },
          "on": {
            "change": _this.onChange
          }
        }, [item.value]);
      })]);
    }
  };

  var UNSCOPABLES = wellKnownSymbol('unscopables');
  var ArrayPrototype = Array.prototype;

  // Array.prototype[@@unscopables]
  // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
  if (ArrayPrototype[UNSCOPABLES] == undefined) {
    objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: objectCreate(null)
    });
  }

  // add a key to Array.prototype[@@unscopables]
  var addToUnscopables = function (key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };

  var $includes = arrayIncludes.includes;



  var USES_TO_LENGTH$4 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  _export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH$4 }, {
    includes: function includes(el /* , fromIndex = 0 */) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('includes');

  var MATCH = wellKnownSymbol('match');

  // `IsRegExp` abstract operation
  // https://tc39.github.io/ecma262/#sec-isregexp
  var isRegexp = function (it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
  };

  var notARegexp = function (it) {
    if (isRegexp(it)) {
      throw TypeError("The method doesn't accept regular expressions");
    } return it;
  };

  var MATCH$1 = wellKnownSymbol('match');

  var correctIsRegexpLogic = function (METHOD_NAME) {
    var regexp = /./;
    try {
      '/./'[METHOD_NAME](regexp);
    } catch (e) {
      try {
        regexp[MATCH$1] = false;
        return '/./'[METHOD_NAME](regexp);
      } catch (f) { /* empty */ }
    } return false;
  };

  // `String.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.includes
  _export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
    includes: function includes(searchString /* , position = 0 */) {
      return !!~String(requireObjectCoercible(this))
        .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  function getDefaultItems$1() {
    // defaultItems.slice(0)[0] === defaultItems.slice(0)[0] -> true
    // Object.assign(defaultItems)[0] === Object.assign(defaultItems)[0] -> true
    // clone = (val) => JSON.parse(JSON.stringify(val))
    // clone(defaultItems)[0] === clone(defaultItems)[0] -> false
    var defaultItems = [{
      value: 'éé¡¹A'
    }, {
      value: 'éé¡¹B'
    }, {
      value: 'éé¡¹C'
    }];
    return defaultItems;
  }

  var LbpFormCheckboxGroup = {
    name: 'lbp-form-checkbox-group',
    components: {
      LbpFormRadio: LbpFormRadio
    },
    props: {
      width: {
        default: 120
      },
      height: {
        default: 120
      },
      aliasName: PropTypes.string({
        defaultValue: 'æ é¢æ¼ç¤º',
        label: 'å¡«åæ é¢'
      }),
      items: PropTypes.textOptions({
        label: 'éé¡¹åè¡¨',
        defaultValue: function defaultValue() {
          return getDefaultItems$1();
        }
      }),
      // TODO æ½ç¦» radio-group è³ common-props
      type: {
        type: String,
        default: 'checkbox',
        editor: {
          type: 'a-radio-group',
          label: 'éæ©æ¨¡å¼',
          require: true,
          props: {
            options: [{
              label: 'åé',
              value: 'radio'
            }, {
              label: 'å¤é',
              value: 'checkbox'
            }],
            name: 'mode'
          }
        }
      }
    },
    data: function data() {
      return {
        value: this.type === 'radio' ? '' : [],
        uuid: undefined
      };
    },
    computed: {
      value_: function value_() {
        if (this.type === 'radio') {
          return this.value;
        } else {
          var value = Array.isArray(this.value) && this.value || [];
          return value.join(',');
        }
      }
    },
    watch: {
      type: function type(_type) {
        this.value = _type === 'radio' ? '' : [];
      }
    },
    mounted: function mounted() {
      this.uuid = this.$el.dataset.uuid;
    },
    methods: {
      /**
       * @param {String, Number} val radioValue or checkboxValue
       */
      onChange: function onChange(val) {
        switch (this.type) {
          case 'radio':
            this.toggleRadio(val);
            break;

          case 'checkbox':
            this.toggleCheckbox(val);
            break;
        }
      },
      toggleCheckbox: function toggleCheckbox(val) {
        var index = this.value.indexOf(val);

        if (index === -1) {
          this.value.push(val);
        } else {
          this.value.splice(index, 1);
        }
      },
      toggleRadio: function toggleRadio(val) {
        this.value = val;
      }
    },
    render: function render() {
      var _this = this;

      var h = arguments[0];
      return h("div", [h("h3", [this.aliasName]), h("input", {
        "attrs": {
          "type": "text",
          "hidden": true,
          "data-type": "lbp-form-input",
          "data-uuid": this.uuid
        },
        "domProps": {
          "value": this.value_
        }
      }), this.items.map(function (item) {
        return h("lbp-form-radio", {
          "attrs": {
            "vertical": true,
            "value": item.value,
            "checked": _this.type === 'radio' ? _this.value === item.value : _this.value.includes(item.value),
            "aliasName": _this.uuid,
            "type": _this.type
          },
          "on": {
            "change": _this.onChange
          }
        }, [item.value]);
      })]);
    }
  };

  var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;

  var toString$1 = {}.toString;

  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
    ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function (it) {
    try {
      return nativeGetOwnPropertyNames(it);
    } catch (error) {
      return windowNames.slice();
    }
  };

  // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
  var f$5 = function getOwnPropertyNames(it) {
    return windowNames && toString$1.call(it) == '[object Window]'
      ? getWindowNames(it)
      : nativeGetOwnPropertyNames(toIndexedObject(it));
  };

  var objectGetOwnPropertyNamesExternal = {
  	f: f$5
  };

  var f$6 = wellKnownSymbol;

  var wellKnownSymbolWrapped = {
  	f: f$6
  };

  var defineProperty$5 = objectDefineProperty.f;

  var defineWellKnownSymbol = function (NAME) {
    var Symbol = path.Symbol || (path.Symbol = {});
    if (!has(Symbol, NAME)) defineProperty$5(Symbol, NAME, {
      value: wellKnownSymbolWrapped.f(NAME)
    });
  };

  var defineProperty$6 = objectDefineProperty.f;



  var TO_STRING_TAG = wellKnownSymbol('toStringTag');

  var setToStringTag = function (it, TAG, STATIC) {
    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
      defineProperty$6(it, TO_STRING_TAG, { configurable: true, value: TAG });
    }
  };

  var $forEach$1 = arrayIteration.forEach;

  var HIDDEN = sharedKey('hidden');
  var SYMBOL = 'Symbol';
  var PROTOTYPE$1 = 'prototype';
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
  var setInternalState = internalState.set;
  var getInternalState = internalState.getterFor(SYMBOL);
  var ObjectPrototype = Object[PROTOTYPE$1];
  var $Symbol = global_1.Symbol;
  var $stringify = getBuiltIn('JSON', 'stringify');
  var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
  var nativeDefineProperty$1 = objectDefineProperty.f;
  var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
  var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
  var AllSymbols = shared('symbols');
  var ObjectPrototypeSymbols = shared('op-symbols');
  var StringToSymbolRegistry = shared('string-to-symbol-registry');
  var SymbolToStringRegistry = shared('symbol-to-string-registry');
  var WellKnownSymbolsStore$1 = shared('wks');
  var QObject = global_1.QObject;
  // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
  var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

  // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
  var setSymbolDescriptor = descriptors && fails(function () {
    return objectCreate(nativeDefineProperty$1({}, 'a', {
      get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }
    })).a != 7;
  }) ? function (O, P, Attributes) {
    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
    if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
    nativeDefineProperty$1(O, P, Attributes);
    if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
      nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
    }
  } : nativeDefineProperty$1;

  var wrap = function (tag, description) {
    var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
    setInternalState(symbol, {
      type: SYMBOL,
      tag: tag,
      description: description
    });
    if (!descriptors) symbol.description = description;
    return symbol;
  };

  var isSymbol = useSymbolAsUid ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    return Object(it) instanceof $Symbol;
  };

  var $defineProperty = function defineProperty(O, P, Attributes) {
    if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
    anObject(O);
    var key = toPrimitive(P, true);
    anObject(Attributes);
    if (has(AllSymbols, key)) {
      if (!Attributes.enumerable) {
        if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
        O[HIDDEN][key] = true;
      } else {
        if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
        Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
      } return setSymbolDescriptor(O, key, Attributes);
    } return nativeDefineProperty$1(O, key, Attributes);
  };

  var $defineProperties = function defineProperties(O, Properties) {
    anObject(O);
    var properties = toIndexedObject(Properties);
    var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
    $forEach$1(keys, function (key) {
      if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
    });
    return O;
  };

  var $create = function create(O, Properties) {
    return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
  };

  var $propertyIsEnumerable = function propertyIsEnumerable(V) {
    var P = toPrimitive(V, true);
    var enumerable = nativePropertyIsEnumerable$1.call(this, P);
    if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
    return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
  };

  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
    var it = toIndexedObject(O);
    var key = toPrimitive(P, true);
    if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
    var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
    if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
      descriptor.enumerable = true;
    }
    return descriptor;
  };

  var $getOwnPropertyNames = function getOwnPropertyNames(O) {
    var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
    var result = [];
    $forEach$1(names, function (key) {
      if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
    });
    return result;
  };

  var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
    var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
    var result = [];
    $forEach$1(names, function (key) {
      if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
        result.push(AllSymbols[key]);
      }
    });
    return result;
  };

  // `Symbol` constructor
  // https://tc39.github.io/ecma262/#sec-symbol-constructor
  if (!nativeSymbol) {
    $Symbol = function Symbol() {
      if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
      var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
      var tag = uid(description);
      var setter = function (value) {
        if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
        if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
      };
      if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
      return wrap(tag, description);
    };

    redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
      return getInternalState(this).tag;
    });

    redefine($Symbol, 'withoutSetter', function (description) {
      return wrap(uid(description), description);
    });

    objectPropertyIsEnumerable.f = $propertyIsEnumerable;
    objectDefineProperty.f = $defineProperty;
    objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
    objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
    objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

    wellKnownSymbolWrapped.f = function (name) {
      return wrap(wellKnownSymbol(name), name);
    };

    if (descriptors) {
      // https://github.com/tc39/proposal-Symbol-description
      nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
        configurable: true,
        get: function description() {
          return getInternalState(this).description;
        }
      });
      {
        redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
      }
    }
  }

  _export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
    Symbol: $Symbol
  });

  $forEach$1(objectKeys(WellKnownSymbolsStore$1), function (name) {
    defineWellKnownSymbol(name);
  });

  _export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
    // `Symbol.for` method
    // https://tc39.github.io/ecma262/#sec-symbol.for
    'for': function (key) {
      var string = String(key);
      if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
      var symbol = $Symbol(string);
      StringToSymbolRegistry[string] = symbol;
      SymbolToStringRegistry[symbol] = string;
      return symbol;
    },
    // `Symbol.keyFor` method
    // https://tc39.github.io/ecma262/#sec-symbol.keyfor
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
      if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
    },
    useSetter: function () { USE_SETTER = true; },
    useSimple: function () { USE_SETTER = false; }
  });

  _export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
    // `Object.create` method
    // https://tc39.github.io/ecma262/#sec-object.create
    create: $create,
    // `Object.defineProperty` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperty
    defineProperty: $defineProperty,
    // `Object.defineProperties` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperties
    defineProperties: $defineProperties,
    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor
  });

  _export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
    // `Object.getOwnPropertyNames` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
    getOwnPropertyNames: $getOwnPropertyNames,
    // `Object.getOwnPropertySymbols` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
    getOwnPropertySymbols: $getOwnPropertySymbols
  });

  // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
  // https://bugs.chromium.org/p/v8/issues/detail?id=3443
  _export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
      return objectGetOwnPropertySymbols.f(toObject(it));
    }
  });

  // `JSON.stringify` method behavior with symbols
  // https://tc39.github.io/ecma262/#sec-json.stringify
  if ($stringify) {
    var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
      var symbol = $Symbol();
      // MS Edge converts symbol values to JSON as {}
      return $stringify([symbol]) != '[null]'
        // WebKit converts symbol values to JSON as null
        || $stringify({ a: symbol }) != '{}'
        // V8 throws on boxed symbols
        || $stringify(Object(symbol)) != '{}';
    });

    _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
      // eslint-disable-next-line no-unused-vars
      stringify: function stringify(it, replacer, space) {
        var args = [it];
        var index = 1;
        var $replacer;
        while (arguments.length > index) args.push(arguments[index++]);
        $replacer = replacer;
        if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
        if (!isArray(replacer)) replacer = function (key, value) {
          if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
          if (!isSymbol(value)) return value;
        };
        args[1] = replacer;
        return $stringify.apply(null, args);
      }
    });
  }

  // `Symbol.prototype[@@toPrimitive]` method
  // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
  if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
    createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
  }
  // `Symbol.prototype[@@toStringTag]` property
  // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
  setToStringTag($Symbol, SYMBOL);

  hiddenKeys[HIDDEN] = true;

  var $filter = arrayIteration.filter;



  var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('filter');
  // Edge 14- issue
  var USES_TO_LENGTH$5 = arrayMethodUsesToLength('filter');

  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  // with adding support of @@species
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$5 }, {
    filter: function filter(callbackfn /* , thisArg */) {
      return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;


  var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor$2(1); });
  var FORCED$1 = !descriptors || FAILS_ON_PRIMITIVES;

  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
  _export({ target: 'Object', stat: true, forced: FORCED$1, sham: !descriptors }, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
      return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
    }
  });

  // `Object.getOwnPropertyDescriptors` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  _export({ target: 'Object', stat: true, sham: !descriptors }, {
    getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
      var O = toIndexedObject(object);
      var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
      var keys = ownKeys(O);
      var result = {};
      var index = 0;
      var key, descriptor;
      while (keys.length > index) {
        descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
        if (descriptor !== undefined) createProperty(result, key, descriptor);
      }
      return result;
    }
  });

  var FAILS_ON_PRIMITIVES$1 = fails(function () { objectKeys(1); });

  // `Object.keys` method
  // https://tc39.github.io/ecma262/#sec-object.keys
  _export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$1 }, {
    keys: function keys(it) {
      return objectKeys(toObject(it));
    }
  });

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _renderWaterMark() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$container = _ref.container,
        container = _ref$container === void 0 ? document.body : _ref$container,
        _ref$width = _ref.width,
        width = _ref$width === void 0 ? '100px' : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === void 0 ? '100px' : _ref$height,
        _ref$textAlign = _ref.textAlign,
        textAlign = _ref$textAlign === void 0 ? 'center' : _ref$textAlign,
        _ref$textBaseline = _ref.textBaseline,
        textBaseline = _ref$textBaseline === void 0 ? 'middle' : _ref$textBaseline,
        _ref$fontSize = _ref.fontSize,
        fontSize = _ref$fontSize === void 0 ? 16 : _ref$fontSize,
        _ref$fillStyle = _ref.fillStyle,
        fillStyle = _ref$fillStyle === void 0 ? 'rgba(184, 184, 184, 0.2 )' : _ref$fillStyle,
        _ref$content = _ref.content,
        content = _ref$content === void 0 ? 'æ°´å°æå­' : _ref$content,
        _ref$rotate = _ref.rotate,
        rotate = _ref$rotate === void 0 ? 0 : _ref$rotate,
        _ref$zIndex = _ref.zIndex,
        zIndex = _ref$zIndex === void 0 ? 1000 : _ref$zIndex;

    var canvas = document.createElement('canvas');
    canvas.setAttribute('width', width);
    canvas.setAttribute('height', height);
    var ctx = canvas.getContext('2d');
    ctx.textAlign = textAlign;
    ctx.textBaseline = textBaseline;
    ctx.font = "".concat(fontSize, "px Arial");
    ctx.fillStyle = fillStyle; // ctx.rotate(Math.PI / 180 * rotate);

    ctx.fillText(content, 0, parseFloat(height) / 3);
    var base64Url = canvas.toDataURL();
    var wmEl = document.querySelector('.luban_h5__wm');
    var watermarkDiv = wmEl || document.createElement('div');
    var styleStr = "\n    transform: rotate(".concat(rotate, "deg);\n    position:absolute;\n    top:0;\n    left:0;\n    width:100%;\n    height:100%;\n    z-index:").concat(zIndex, ";\n    pointer-events:none;\n    background-repeat:repeat;\n    background-image:url('").concat(base64Url, "');\n    user-select: none");
    watermarkDiv.setAttribute('style', styleStr);

    if (!wmEl) {
      watermarkDiv.classList.add('luban_h5__wm');
      container.style.position = 'relative';
      container.insertBefore(watermarkDiv, container.firstChild);
    }
  }

  var LbpBackground = {
    name: 'lbp-background',
    props: {
      imgSrc: PropTypes.string({
        label: 'èæ¯å¾'
      }),
      backgroundColor: PropTypes.color({
        label: 'èæ¯è²',
        defaultValue: 'rgba(255, 255, 255, 0.2)'
      }),
      waterMarkText: PropTypes.string({
        label: 'æ°´å°æå­',
        defaultValue: 'æ°´å°æå­'
      }),
      waterMarkFontSize: PropTypes.number({
        label: 'æ°´å°æå­å¤§å°(px)',
        defaultValue: 16
      }),
      waterMarkRotate: PropTypes.number({
        label: 'æ°´å°æè½¬è§åº¦',
        defaultValue: 10
      }),
      waterMarkColor: PropTypes.color({
        label: 'æ°´å°æå­é¢è²',
        defaultValue: 'rgba(184, 184, 184, 0.2)'
      })
    },
    methods: {
      renderWaterMark: function renderWaterMark() {
        _renderWaterMark({
          container: this.$refs.root,
          content: this.waterMarkText,
          fontSize: this.waterMarkFontSize,
          rotate: this.waterMarkRotate,
          fillStyle: this.waterMarkColor
        });
      }
    },
    render: function render() {
      var h = arguments[0];
      var style = {
        width: '100%',
        height: '100%'
      };

      if (this.imgSrc) {
        style = _objectSpread(_objectSpread({}, style), {}, {
          'background-size': 'cover',
          'background-position': '50% 50%',
          'background-origin': 'content-box',
          'background-image': "url(".concat(this.imgSrc, ")")
        });
      } else {
        style = _objectSpread({
          backgroundColor: this.backgroundColor
        }, style);
      }

      return (// [ç¥è¯ç¹:CSS] : https://codesandbox.io/s/ziyuansuzindexzaigao-wufafugaifuyuansudexiongdiyuansu-n15rd?file=/index.html
        h("div", {
          "style": "width: 100%; height: 100%; overflow: hidden; position: absolute; z-index: 0; opacity: 1;",
          "ref": "root"
        }, [h("div", {
          "style": style
        })])
      );
    },
    mounted: function mounted() {
      var _this = this;

      this.renderWaterMark();
      ['waterMarkText', 'waterMarkFontSize', 'waterMarkRotate', 'waterMarkColor'].forEach(function (key) {
        _this.$watch(key, _this.renderWaterMark);
      });
    }
  };

  function getDefaultItems$2() {
    var defaultItems = [{
      image: 'https://img.yzcdn.cn/vant/apple-1.jpg'
    }, {
      image: 'https://img.yzcdn.cn/vant/apple-2.jpg'
    }];
    return defaultItems;
  }

  var LbpSlide = {
    name: 'lbp-slide',
    props: {
      interval: PropTypes.number({
        defaultValue: 4000,
        label: 'é´éæ¶é´'
      }),
      editorMode: PropTypes.string({
        defaultValue: 'preview',
        label: 'æ¨¡å¼'
      }),
      activeIndex: {
        type: Number,
        default: 0,
        editor: {
          custom: true
        }
      },
      items: {
        type: Array,
        default: function _default() {
          return getDefaultItems$2();
        },
        editor: {
          custom: true
        }
      }
    },
    componentsForPropsEditor: {},
    mounted: function mounted() {},
    methods: {},
    render: function render() {
      var h = arguments[0];
      var items = this.items,
          activeIndex = this.activeIndex;
      return this.editorMode === 'edit' ? items.length && h("img", {
        "attrs": {
          "src": items[activeIndex].image
        }
      }) : h(vant.Swipe, {
        "attrs": {
          "autoplay": +this.interval,
          "indicator-color": "red"
        }
      }, [items.map(function (item) {
        return h(vant.SwipeItem, [h("img", {
          "attrs": {
            "src": item.image,
            "width": "100%",
            "height": "100%"
          }
        })]);
      })]);
    }
  };

  /*
   * @Author: ly525
   * @Date: 2020-01-03 23:43:34
   * @LastEditors : Please set LastEditors
   * @LastEditTime : 2020-11-17 16:49:11
   * @FilePath: /luban-h5/front-end/h5/src/components/@/plugins/lbp-bg-music.js
   * @Github: https://github.com/ly525/luban-h5
   * @Description: Do not edit
   * @Copyright 2018 - 2020 luban-h5. All Rights Reserved
   */
  var LbpBgMusic = {
    name: 'lbp-bg-music',
    props: {
      disabled: PropTypes.boolean({
        defaultValue: true,
        label: 'disabled'
      }),
      autoplay: PropTypes.boolean({
        defaultValue: true,
        label: 'èªå¨æ­æ¾'
      }),
      src: PropTypes.string({
        label: 'é³ä¹URL',
        defaultValue: 'http://go.163.com/2018/0209/mengniu/audio/bgm.mp3',
        props: {
          type: 'textarea'
        }
      })
    },
    data: function data() {
      return {
        isPlaying: true
      };
    },
    methods: {
      toggle: function toggle() {
        var bgAudio = this.$refs.bgAudio;
        if (!bgAudio) return;
        this.isPlaying ? bgAudio.pause() : bgAudio.play();
        this.isPlaying = !this.isPlaying;
      }
    },
    render: function render() {
      var h = arguments[0];
      var btnStyle = {
        'animation-play-state': this.isPlaying ? 'running' : 'paused'
      };
      return h("div", {
        "class": "bg-music-wrapper",
        "style": "display: block;"
      }, [h("div", {
        "class": "bg-music-btn rotate",
        "style": btnStyle,
        "on": {
          "click": this.toggle
        },
        "attrs": {
          "disabled": this.disabled
        }
      }, [h("audio", {
        "attrs": {
          "src": this.src,
          "autoplay": this.autoplay,
          "preload": true,
          "loop": true
        },
        "ref": 'bgAudio'
      })])]);
    },
    created: function created() {
      // å¨åå§åçæ¶åï¼autoplay æ§å¶æ¯å¦æ­æ¾
      // åé¢æ¯å¦æ­æ¾ï¼ç±ç¨æ·çç¹å»è¡ä¸ºå³å®
      this.isPlaying = this.autoplay;
    }
  };

  /*
   * @Author: ly525
   * @Date: 2020-05-14 08:09:44
   * @LastEditors : Please set LastEditors
   * @LastEditTime : 2020-11-10 15:09:00
   * @FilePath: /luban-h5/front-end/h5/src/components/@/plugins/lbp-notice-bar.js
   * @Github: https://github.com/ly525/luban-h5
   * @Description: Do not edit
   * @Copyright 2018 - 2020 luban-h5. All Rights Reserved
   */
  var LbpNoticeBar = {
    name: 'lbp-notice-bar',
    props: {
      width: {
        default: 120
      },
      height: {
        default: 120
      },
      text: PropTypes.string({
        defaultValue: 'è¯·å¡«ååå®¹ï¼å¦æè¿é¿ï¼å°ä¼å¨ææºä¸æ»å¨æ¾ç¤º',
        label: 'å¬å',
        props: {
          type: 'textarea'
        }
      }),
      vertical: PropTypes.boolean(),
      backgroundColor: PropTypes.color({
        label: 'èæ¯è²',
        defaultValue: '#fffbe8'
      }),

      /** æ·¡é»è² */
      color: PropTypes.color({
        defaultValue: '#ed6a0c'
      }),

      /** æ·¡é»è² */
      mode: {
        type: String,
        default: '',
        editor: {
          type: 'a-select',
          label: 'æ¨¡å¼',
          props: {
            options: [{
              label: 'é»è®¤',
              value: ''
            }, {
              label: 'å³ä¾§æç®­å¤´',
              value: 'link'
            }, {
              label: 'å¯å³é­',
              value: 'closeable'
            }]
          }
        }
      }
    },
    componentsForPropsEditor: {},
    mounted: function mounted() {},
    methods: {},
    render: function render() {
      var h = arguments[0];
      return h(vant.NoticeBar, {
        "attrs": {
          "mode": this.mode,
          "color": this.color,
          "left-icon": "volume-o",
          "text": this.text,
          "background": this.backgroundColor
        }
      });
    }
  };

  /*
   * @Author: ly525
   * @Date: 2020-05-17 20:04:23
   * @LastEditors : Please set LastEditors
   * @LastEditTime : 2020-10-28 17:58:59
   * @FilePath: /luban-h5/front-end/h5/src/components/@/plugins/lbp-rate.js
   * @Github: https://github.com/ly525/luban-h5
   * @Description: Do not edit
   * @Copyright 2018 - 2020 luban-h5. All Rights Reserved
   */
  var LbpRate = {
    name: 'lbp-rate',
    props: {
      value: PropTypes.number({
        defaultValue: 5,
        label: 'å½ååå¼'
      }),
      count: PropTypes.number({
        defaultValue: 5,
        label: 'å¾æ æ»æ°'
      }),
      size: PropTypes.number({
        defaultValue: 16,
        label: 'å¾æ å¤§å°'
      }),
      gutter: PropTypes.number({
        defaultValue: 16,
        label: 'å¾æ é´è·'
      }),
      mode: {
        type: String,
        default: '',
        editor: {
          type: 'a-select',
          label: 'æ¨¡å¼',
          props: {
            options: [{
              label: 'star',
              value: 'star'
            }, {
              label: 'ç¹èµ',
              value: 'like'
            }, {
              label: 'Good',
              value: 'good-job'
            }]
          }
        }
      }
    },
    componentsForPropsEditor: {},
    mounted: function mounted() {},
    methods: {},
    render: function render() {
      var h = arguments[0];
      return h(vant.Rate, {
        "attrs": {
          "value": this.value,
          "count": this.count,
          "size": this.size,
          "color": this.color,
          "gutter": this.gutter,
          "void-icon": "star",
          "void-color": "#eee"
        }
      });
    }
  };

  var non = '\u200B\u0085\u180E';

  // check that a method works with the correct list
  // of whitespaces and has a correct name
  var stringTrimForced = function (METHOD_NAME) {
    return fails(function () {
      return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
    });
  };

  var $trim = stringTrim.trim;


  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  _export({ target: 'String', proto: true, forced: stringTrimForced('trim') }, {
    trim: function trim() {
      return $trim(this);
    }
  });

  var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
  var test = {};

  test[TO_STRING_TAG$1] = 'z';

  var toStringTagSupport = String(test) === '[object z]';

  var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
  // ES3 wrong here
  var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (error) { /* empty */ }
  };

  // getting tag from ES6+ `Object.prototype.toString`
  var classof = toStringTagSupport ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag
      // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O)
      // ES3 arguments fallback
      : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
  };

  // `Object.prototype.toString` method implementation
  // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
  var objectToString = toStringTagSupport ? {}.toString : function toString() {
    return '[object ' + classof(this) + ']';
  };

  // `Object.prototype.toString` method
  // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
  if (!toStringTagSupport) {
    redefine(Object.prototype, 'toString', objectToString, { unsafe: true });
  }

  var nativePromiseConstructor = global_1.Promise;

  var redefineAll = function (target, src, options) {
    for (var key in src) redefine(target, key, src[key], options);
    return target;
  };

  var SPECIES$2 = wellKnownSymbol('species');

  var setSpecies = function (CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = objectDefineProperty.f;

    if (descriptors && Constructor && !Constructor[SPECIES$2]) {
      defineProperty(Constructor, SPECIES$2, {
        configurable: true,
        get: function () { return this; }
      });
    }
  };

  var anInstance = function (it, Constructor, name) {
    if (!(it instanceof Constructor)) {
      throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
    } return it;
  };

  var iterators = {};

  var ITERATOR = wellKnownSymbol('iterator');
  var ArrayPrototype$1 = Array.prototype;

  // check on default Array iterator
  var isArrayIteratorMethod = function (it) {
    return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR] === it);
  };

  var ITERATOR$1 = wellKnownSymbol('iterator');

  var getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$1]
      || it['@@iterator']
      || iterators[classof(it)];
  };

  // call something on iterator step with safe closing on error
  var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
    try {
      return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
    } catch (error) {
      var returnMethod = iterator['return'];
      if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
      throw error;
    }
  };

  var iterate_1 = createCommonjsModule(function (module) {
  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, next, step;

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
      // optimisation for array iterators
      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = toLength(iterable.length); length > index; index++) {
          result = AS_ENTRIES
            ? boundFunction(anObject(step = iterable[index])[0], step[1])
            : boundFunction(iterable[index]);
          if (result && result instanceof Result) return result;
        } return new Result(false);
      }
      iterator = iterFn.call(iterable);
    }

    next = iterator.next;
    while (!(step = next.call(iterator)).done) {
      result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
      if (typeof result == 'object' && result && result instanceof Result) return result;
    } return new Result(false);
  };

  iterate.stop = function (result) {
    return new Result(true, result);
  };
  });

  var ITERATOR$2 = wellKnownSymbol('iterator');
  var SAFE_CLOSING = false;

  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function () {
        return { done: !!called++ };
      },
      'return': function () {
        SAFE_CLOSING = true;
      }
    };
    iteratorWithReturn[ITERATOR$2] = function () {
      return this;
    };
    // eslint-disable-next-line no-throw-literal
    Array.from(iteratorWithReturn, function () { throw 2; });
  } catch (error) { /* empty */ }

  var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR$2] = function () {
        return {
          next: function () {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec(object);
    } catch (error) { /* empty */ }
    return ITERATION_SUPPORT;
  };

  var SPECIES$3 = wellKnownSymbol('species');

  // `SpeciesConstructor` abstract operation
  // https://tc39.github.io/ecma262/#sec-speciesconstructor
  var speciesConstructor = function (O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || (S = anObject(C)[SPECIES$3]) == undefined ? defaultConstructor : aFunction$1(S);
  };

  var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

  var location = global_1.location;
  var set$1 = global_1.setImmediate;
  var clear = global_1.clearImmediate;
  var process$1 = global_1.process;
  var MessageChannel = global_1.MessageChannel;
  var Dispatch = global_1.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;

  var run = function (id) {
    // eslint-disable-next-line no-prototype-builtins
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };

  var runner = function (id) {
    return function () {
      run(id);
    };
  };

  var listener = function (event) {
    run(event.data);
  };

  var post = function (id) {
    // old engines have not location.origin
    global_1.postMessage(id + '', location.protocol + '//' + location.host);
  };

  // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
  if (!set$1 || !clear) {
    set$1 = function setImmediate(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue[++counter] = function () {
        // eslint-disable-next-line no-new-func
        (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
      };
      defer(counter);
      return counter;
    };
    clear = function clearImmediate(id) {
      delete queue[id];
    };
    // Node.js 0.8-
    if (classofRaw(process$1) == 'process') {
      defer = function (id) {
        process$1.nextTick(runner(id));
      };
    // Sphere (JS game engine) Dispatch API
    } else if (Dispatch && Dispatch.now) {
      defer = function (id) {
        Dispatch.now(runner(id));
      };
    // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624
    } else if (MessageChannel && !engineIsIos) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = functionBindContext(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (
      global_1.addEventListener &&
      typeof postMessage == 'function' &&
      !global_1.importScripts &&
      !fails(post) &&
      location.protocol !== 'file:'
    ) {
      defer = post;
      global_1.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
      defer = function (id) {
        html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
          html.removeChild(this);
          run(id);
        };
      };
    // Rest old browsers
    } else {
      defer = function (id) {
        setTimeout(runner(id), 0);
      };
    }
  }

  var task = {
    set: set$1,
    clear: clear
  };

  var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;

  var macrotask = task.set;


  var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
  var process$2 = global_1.process;
  var Promise$1 = global_1.Promise;
  var IS_NODE = classofRaw(process$2) == 'process';
  // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
  var queueMicrotaskDescriptor = getOwnPropertyDescriptor$3(global_1, 'queueMicrotask');
  var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

  var flush, head, last, notify, toggle, node, promise, then;

  // modern engines have queueMicrotask method
  if (!queueMicrotask) {
    flush = function () {
      var parent, fn;
      if (IS_NODE && (parent = process$2.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (error) {
          if (head) notify();
          else last = undefined;
          throw error;
        }
      } last = undefined;
      if (parent) parent.enter();
    };

    // Node.js
    if (IS_NODE) {
      notify = function () {
        process$2.nextTick(flush);
      };
    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
    } else if (MutationObserver && !engineIsIos) {
      toggle = true;
      node = document.createTextNode('');
      new MutationObserver(flush).observe(node, { characterData: true });
      notify = function () {
        node.data = toggle = !toggle;
      };
    // environments with maybe non-completely correct, but existent Promise
    } else if (Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      promise = Promise$1.resolve(undefined);
      then = promise.then;
      notify = function () {
        then.call(promise, flush);
      };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
    } else {
      notify = function () {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(global_1, flush);
      };
    }
  }

  var microtask = queueMicrotask || function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };

  var PromiseCapability = function (C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aFunction$1(resolve);
    this.reject = aFunction$1(reject);
  };

  // 25.4.1.5 NewPromiseCapability(C)
  var f$7 = function (C) {
    return new PromiseCapability(C);
  };

  var newPromiseCapability = {
  	f: f$7
  };

  var promiseResolve = function (C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var hostReportErrors = function (a, b) {
    var console = global_1.console;
    if (console && console.error) {
      arguments.length === 1 ? console.error(a) : console.error(a, b);
    }
  };

  var perform = function (exec) {
    try {
      return { error: false, value: exec() };
    } catch (error) {
      return { error: true, value: error };
    }
  };

  var task$1 = task.set;










  var SPECIES$4 = wellKnownSymbol('species');
  var PROMISE = 'Promise';
  var getInternalState$1 = internalState.get;
  var setInternalState$1 = internalState.set;
  var getInternalPromiseState = internalState.getterFor(PROMISE);
  var PromiseConstructor = nativePromiseConstructor;
  var TypeError$1 = global_1.TypeError;
  var document$2 = global_1.document;
  var process$3 = global_1.process;
  var $fetch = getBuiltIn('fetch');
  var newPromiseCapability$1 = newPromiseCapability.f;
  var newGenericPromiseCapability = newPromiseCapability$1;
  var IS_NODE$1 = classofRaw(process$3) == 'process';
  var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
  var UNHANDLED_REJECTION = 'unhandledrejection';
  var REJECTION_HANDLED = 'rejectionhandled';
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

  var FORCED$2 = isForced_1(PROMISE, function () {
    var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
    if (!GLOBAL_CORE_JS_PROMISE) {
      // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // We can't detect it synchronously, so just check versions
      if (engineV8Version === 66) return true;
      // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
      if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
    }
    // We can't use @@species feature detection in V8 since it causes
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679
    if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
    // Detect correctness of subclassing with @@species support
    var promise = PromiseConstructor.resolve(1);
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES$4] = FakePromise;
    return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
  });

  var INCORRECT_ITERATION = FORCED$2 || !checkCorrectnessOfIteration(function (iterable) {
    PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
  });

  // helpers
  var isThenable = function (it) {
    var then;
    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };

  var notify$1 = function (promise, state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask(function () {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var index = 0;
      // variable length - can't use forEach
      while (chain.length > index) {
        var reaction = chain[index++];
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
              state.rejection = HANDLED;
            }
            if (handler === true) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value); // can throw
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (error) {
          if (domain && !exited) domain.exit();
          reject(error);
        }
      }
      state.reactions = [];
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(promise, state);
    });
  };

  var dispatchEvent = function (name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
      event = document$2.createEvent('Event');
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      global_1.dispatchEvent(event);
    } else event = { promise: promise, reason: reason };
    if (handler = global_1['on' + name]) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
  };

  var onUnhandled = function (promise, state) {
    task$1.call(global_1, function () {
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform(function () {
          if (IS_NODE$1) {
            process$3.emit('unhandledRejection', value, promise);
          } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
        });
        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
        state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };

  var isUnhandled = function (state) {
    return state.rejection !== HANDLED && !state.parent;
  };

  var onHandleUnhandled = function (promise, state) {
    task$1.call(global_1, function () {
      if (IS_NODE$1) {
        process$3.emit('rejectionHandled', promise);
      } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
  };

  var bind = function (fn, promise, state, unwrap) {
    return function (value) {
      fn(promise, state, value, unwrap);
    };
  };

  var internalReject = function (promise, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify$1(promise, state, true);
  };

  var internalResolve = function (promise, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (promise === value) throw TypeError$1("Promise can't be resolved itself");
      var then = isThenable(value);
      if (then) {
        microtask(function () {
          var wrapper = { done: false };
          try {
            then.call(value,
              bind(internalResolve, promise, wrapper, state),
              bind(internalReject, promise, wrapper, state)
            );
          } catch (error) {
            internalReject(promise, wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify$1(promise, state, false);
      }
    } catch (error) {
      internalReject(promise, { done: false }, error, state);
    }
  };

  // constructor polyfill
  if (FORCED$2) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
      anInstance(this, PromiseConstructor, PROMISE);
      aFunction$1(executor);
      Internal.call(this);
      var state = getInternalState$1(this);
      try {
        executor(bind(internalResolve, this, state), bind(internalReject, this, state));
      } catch (error) {
        internalReject(this, state, error);
      }
    };
    // eslint-disable-next-line no-unused-vars
    Internal = function Promise(executor) {
      setInternalState$1(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: [],
        rejection: false,
        state: PENDING,
        value: undefined
      });
    };
    Internal.prototype = redefineAll(PromiseConstructor.prototype, {
      // `Promise.prototype.then` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.then
      then: function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = IS_NODE$1 ? process$3.domain : undefined;
        state.parent = true;
        state.reactions.push(reaction);
        if (state.state != PENDING) notify$1(this, state, false);
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });
    OwnPromiseCapability = function () {
      var promise = new Internal();
      var state = getInternalState$1(promise);
      this.promise = promise;
      this.resolve = bind(internalResolve, promise, state);
      this.reject = bind(internalReject, promise, state);
    };
    newPromiseCapability.f = newPromiseCapability$1 = function (C) {
      return C === PromiseConstructor || C === PromiseWrapper
        ? new OwnPromiseCapability(C)
        : newGenericPromiseCapability(C);
    };

    if ( typeof nativePromiseConstructor == 'function') {
      nativeThen = nativePromiseConstructor.prototype.then;

      // wrap native Promise#then for native async functions
      redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          nativeThen.call(that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });

      // wrap fetch result
      if (typeof $fetch == 'function') _export({ global: true, enumerable: true, forced: true }, {
        // eslint-disable-next-line no-unused-vars
        fetch: function fetch(input /* , init */) {
          return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
        }
      });
    }
  }

  _export({ global: true, wrap: true, forced: FORCED$2 }, {
    Promise: PromiseConstructor
  });

  setToStringTag(PromiseConstructor, PROMISE, false);
  setSpecies(PROMISE);

  PromiseWrapper = getBuiltIn(PROMISE);

  // statics
  _export({ target: PROMISE, stat: true, forced: FORCED$2 }, {
    // `Promise.reject` method
    // https://tc39.github.io/ecma262/#sec-promise.reject
    reject: function reject(r) {
      var capability = newPromiseCapability$1(this);
      capability.reject.call(undefined, r);
      return capability.promise;
    }
  });

  _export({ target: PROMISE, stat: true, forced:  FORCED$2 }, {
    // `Promise.resolve` method
    // https://tc39.github.io/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
      return promiseResolve( this, x);
    }
  });

  _export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
    // `Promise.all` method
    // https://tc39.github.io/ecma262/#sec-promise.all
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability$1(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction$1(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate_1(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          $promiseResolve.call(C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.github.io/ecma262/#sec-promise.race
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability$1(C);
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction$1(C.resolve);
        iterate_1(iterable, function (promise) {
          $promiseResolve.call(C, promise).then(capability.resolve, reject);
        });
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  function isScriptLoaded(src) {
    return !!document.querySelector('script[src="' + src + '"]');
  }

  var Map = {
    map: null,
    load: function load(key) {
      return new Promise(function (resolve, reject) {
        var src = '//map.qq.com/api/js?v=2.exp&libraries=place&callback=init&key=' + key;

        if (isScriptLoaded(src)) {
          resolve(window.qq);
          return;
        }

        window.init = function () {
          resolve(window.qq); // æ³¨æè¿é
        };

        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = src;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    },
    getPosition: function getPosition(_ref) {
      var lat = _ref.lat,
          lng = _ref.lng;
      return new window.qq.maps.LatLng(lat, lng); // å°å¾çä¸­å¿å°çåæ 
    }
  };

  function getPosition(_ref) {
    var lat = _ref.lat,
        lng = _ref.lng;
    return new window.qq.maps.LatLng(lat, lng); // å°å¾çä¸­å¿å°çåæ 
  }

  var MapMixin = {
    methods: {
      loadMap: function loadMap(key) {
        return Map.load(key);
      },
      setMarker: function setMarker(poi) {
        var map = this.map;
        var center = getPosition(poi.latLng); // å°å¾çä¸­å¿å°çåæ 

        if (this.marker) {
          this.marker.setMap(null);
          this.marker = new window.qq.maps.Marker({
            map: map,
            position: poi.latLng
          });
          map.panTo(center);
        } else {
          this.marker = new window.qq.maps.Marker({
            map: map,
            position: center
          });
        }
      }
    }
  };

  var script = {
    name: 'lbp-qq-map',
    mixins: [MapMixin],
    // loadMapãsetMarker
    props: {
      width: {
        default: 120
      },
      height: {
        default: 120
      },
      labelContent: PropTypes.string({
        label: 'å°ååç§°',
        defaultValue: ''
      }),
      // æ ç­¾åå®¹
      zoomLevel: PropTypes.number({
        label: 'ç¼©æ¾å±çº§',
        defaultValue: 12,
        visible: false
      }),
      // https://lbs.qq.com/dev/console/key/manage
      qqMapKey: PropTypes.string({
        label: 'è¾è®¯å°å¾Key',
        defaultValue: 'GENBZ-G5S3J-7OLFW-FLBX4-WVEMK-SOBL4',
        component: 'a-textarea',
        extra: function extra(h) {
          return h("div", [h("div", ["1. \u8BF7\u586B\u5165\u81EA\u5DF1\u7684\u817E\u8BAF\u5730\u56FE\u5F00\u53D1\u5BC6\u94A5\uFF0C", h("a", {
            "attrs": {
              "href": "https://lbs.qq.com/dev/console/key/manage",
              "target": "_blank"
            }
          }, ["\u524D\u5F80\u7533\u8BF7>>"])]), h("div", ["2. \u9C81\u73ED\u7684 Demo Key \u968F\u65F6\u53EF\u80FD\u5931\u6548\uFF1B\u5931\u6548\u63D0\u793A: \u9274\u6743\u5931\u8D25\uFF0C\u8BF7\u4F20\u5165\u6B63\u786E\u7684key"])]);
        }
      }),
      poi: {
        type: Object,
        default: function _default() {
          return {
            'latLng': {
              'lat': 39.90469,
              'lng': 116.40717
            },
            'name': 'åäº¬å¸',
            'type': 4
          };
        },
        editor: {
          custom: true
        }
      }
    },
    watch: {
      poi: {
        handler: function handler(poi) {
          if (!this.checkMapAvailable()) return;
          this.setMarker(poi);
        },
        deep: true
      },
      labelContent: function labelContent(_labelContent) {
        if (!this.checkMapAvailable()) return;
        this.setLabel(_labelContent);
      },
      zoomLevel: function zoomLevel(_zoomLevel) {
        if (!this.checkMapAvailable()) return;
        this.setZoomLevel(_zoomLevel);
      }
    },
    methods: {
      checkMapAvailable: function checkMapAvailable() {
        return window.qq && window.qq.maps;
      },
      onSearch: function onSearch(value) {
        console.log(value);
      },
      setLabel: function setLabel(labelContent) {
        var center = Map.getPosition(this.poi.latLng); // å°å¾çä¸­å¿å°çåæ 

        this.label = this.label || new window.qq.maps.Label({
          position: center,
          map: this.map,
          content: ''
        });

        if (labelContent.trim()) {
          // https://lbs.qq.com/webDemoCenter/javascriptV2/marker/label
          this.label.setVisible(true);
          this.label.setContent(labelContent || '');
          this.label.setPosition(center);
        } else {
          this.label.setVisible(false);
        }
      },
      setZoomLevel: function setZoomLevel(zoomLevel) {
        this.map.zoomTo(zoomLevel);
      },
      init: function init() {
        var _this = this;

        var poi = this.poi,
            qqMapKey = this.qqMapKey;
        this.loadMap(qqMapKey).then(function (qq) {
          _this.initMap(poi);

          _this.setLabel(_this.labelContent);

          _this.setMarker(poi);
        });
      },
      initMap: function initMap(poi) {
        var el = this.$refs.mapElement;
        var center = Map.getPosition(poi.latLng); // å°å¾çä¸­å¿å°çåæ 

        this.map = new window.qq.maps.Map(el, {
          center: center,
          zoom: this.zoomLevel,
          // è®¾ç½®å°å¾çç¼©æ¾çº§å«
          disableDefaultUI: true,
          // ç¦æ­¢æææ§ä»¶
          draggable: false,
          // è®¾ç½®æ¯å¦å¯ä»¥ææ½
          scrollwheel: false,
          // è®¾ç½®æ¯å¦å¯ä»¥æ»å¨
          disableDoubleClickZoom: true // è®¾ç½®æ¯å¦å¯ä»¥åå»æ¾å¤§
          // è®¾ç½®å°å¾æ ·å¼è¯¦æåè§MapType

        });
      }
    },
    mounted: function mounted() {
      this.init();
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
      if (typeof shadowMode !== 'boolean') {
          createInjectorSSR = createInjector;
          createInjector = shadowMode;
          shadowMode = false;
      }
      // Vue.extend constructor export interop.
      const options = typeof script === 'function' ? script.options : script;
      // render functions
      if (template && template.render) {
          options.render = template.render;
          options.staticRenderFns = template.staticRenderFns;
          options._compiled = true;
          // functional template
          if (isFunctionalTemplate) {
              options.functional = true;
          }
      }
      // scopedId
      if (scopeId) {
          options._scopeId = scopeId;
      }
      let hook;
      if (moduleIdentifier) {
          // server build
          hook = function (context) {
              // 2.3 injection
              context =
                  context || // cached call
                      (this.$vnode && this.$vnode.ssrContext) || // stateful
                      (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
              // 2.2 with runInNewContext: true
              if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                  context = __VUE_SSR_CONTEXT__;
              }
              // inject component styles
              if (style) {
                  style.call(this, createInjectorSSR(context));
              }
              // register component module identifier for async chunk inference
              if (context && context._registeredComponents) {
                  context._registeredComponents.add(moduleIdentifier);
              }
          };
          // used by ssr in case component is cached and beforeCreate
          // never gets called
          options._ssrRegister = hook;
      }
      else if (style) {
          hook = shadowMode
              ? function (context) {
                  style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
              }
              : function (context) {
                  style.call(this, createInjector(context));
              };
      }
      if (hook) {
          if (options.functional) {
              // register for functional component in vue file
              const originalRender = options.render;
              options.render = function renderWithStyleInjection(h, context) {
                  hook.call(context);
                  return originalRender(h, context);
              };
          }
          else {
              // inject component registration as beforeCreate hook
              const existing = options.beforeCreate;
              options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
      }
      return script;
  }

  /* script */
  const __vue_script__ = script;

  /* template */
  var __vue_render__ = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", [
      _c("div", {
        ref: "mapElement",
        staticStyle: { height: "100%", width: "100%" },
        attrs: { id: "qq-map-container" }
      })
    ])
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

    /* style */
    const __vue_inject_styles__ = undefined;
    /* scoped */
    const __vue_scope_id__ = undefined;
    /* module identifier */
    const __vue_module_identifier__ = undefined;
    /* functional template */
    const __vue_is_functional_template__ = false;
    /* style inject */
    
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__ = /*#__PURE__*/normalizeComponent(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      false,
      undefined,
      undefined,
      undefined
    );

  var ABBR = {
    th: 3,
    mi: 6,
    bi: 9,
    tr: 12
  };

  var DEFAULT_OPTIONS = {
    zeroFormat: null,
    nullFormat: null,
    defaultFormat: '0,0',
    scalePercentBy100: true,
    abbrLabel: {
      th: 'k',
      mi: 'm',
      bi: 'b',
      tr: 't'
    }
  };

  var TRILLION = 1e12;
  var BILLION = 1e9;
  var MILLION = 1e6;
  var THOUSAND = 1e3;

  function numIsNaN(value) {
    return typeof value === 'number' && isNaN(value);
  }

  function toFixed(value, maxDecimals, roundingFunction, optionals) {
    var splitValue = value.toString().split('.');
    var minDecimals = maxDecimals - (optionals || 0);
    var boundedPrecision = splitValue.length === 2 ? Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals) : minDecimals;
    var power = Math.pow(10, boundedPrecision);
    var output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);

    if (optionals > maxDecimals - boundedPrecision) {
      var optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
      output = output.replace(optionalsRegExp, '');
    }

    return output;
  }

  function numberToFormat(options, value, format, roundingFunction) {
    var abs = Math.abs(value);
    var negP = false;
    var optDec = false;
    var abbr = '';
    var decimal = '';
    var neg = false;
    var abbrForce = void 0;
    var signed = void 0;
    format = format || '';

    value = value || 0;

    if (~format.indexOf('(')) {
      negP = true;
      format = format.replace(/[(|)]/g, '');
    } else if (~format.indexOf('+') || ~format.indexOf('-')) {
      signed = ~format.indexOf('+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
      format = format.replace(/[+|-]/g, '');
    }
    if (~format.indexOf('a')) {
      abbrForce = format.match(/a(k|m|b|t)?/);

      abbrForce = abbrForce ? abbrForce[1] : false;

      if (~format.indexOf(' a')) abbr = ' ';
      format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');

      if (abs >= TRILLION && !abbrForce || abbrForce === 't') {
        abbr += options.abbrLabel.tr;
        value = value / TRILLION;
      } else if (abs < TRILLION && abs >= BILLION && !abbrForce || abbrForce === 'b') {
        abbr += options.abbrLabel.bi;
        value = value / BILLION;
      } else if (abs < BILLION && abs >= MILLION && !abbrForce || abbrForce === 'm') {
        abbr += options.abbrLabel.mi;
        value = value / MILLION;
      } else if (abs < MILLION && abs >= THOUSAND && !abbrForce || abbrForce === 'k') {
        abbr += options.abbrLabel.th;
        value = value / THOUSAND;
      }
    }
    if (~format.indexOf('[.]')) {
      optDec = true;
      format = format.replace('[.]', '.');
    }
    var int = value.toString().split('.')[0];
    var precision = format.split('.')[1];
    var thousands = format.indexOf(',');
    var leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;

    if (precision) {
      if (~precision.indexOf('[')) {
        precision = precision.replace(']', '');
        precision = precision.split('[');
        decimal = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
      } else {
        decimal = toFixed(value, precision.length, roundingFunction);
      }

      int = decimal.split('.')[0];
      decimal = ~decimal.indexOf('.') ? '.' + decimal.split('.')[1] : '';
      if (optDec && +decimal.slice(1) === 0) decimal = '';
    } else {
      int = toFixed(value, 0, roundingFunction);
    }
    if (abbr && !abbrForce && +int >= 1000 && abbr !== ABBR.trillion) {
      int = '' + +int / 1000;
      abbr = ABBR.million;
    }
    if (~int.indexOf('-')) {
      int = int.slice(1);
      neg = true;
    }
    if (int.length < leadingCount) {
      for (var i = leadingCount - int.length; i > 0; i--) {
        int = '0' + int;
      }
    }

    if (thousands > -1) {
      int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + ',');
    }

    if (!format.indexOf('.')) int = '';

    var output = int + decimal + (abbr || '');

    if (negP) {
      output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
    } else {
      if (signed >= 0) {
        output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
      } else if (neg) {
        output = '-' + output;
      }
    }

    return output;
  }

  function extend(target, sub) {
    Object.keys(sub).forEach(function (key) {
      target[key] = sub[key];
    });
  }

  var numerifyPercent = {
    regexp: /%/,
    format: function format(value, formatType, roundingFunction, numerify) {
      var space = ~formatType.indexOf(' %') ? ' ' : '';
      var output = void 0;

      if (numerify.options.scalePercentBy100) value = value * 100;

      formatType = formatType.replace(/\s?%/, '');

      output = numerify._numberToFormat(value, formatType, roundingFunction);

      if (~output.indexOf(')')) {
        output = output.split('');
        output.splice(-1, 0, space + '%');
        output = output.join('');
      } else {
        output = output + space + '%';
      }

      return output;
    }
  };

  var options = {};
  var formats = {};

  extend(options, DEFAULT_OPTIONS);

  function format(value, formatType, roundingFunction) {
    formatType = formatType || options.defaultFormat;
    roundingFunction = roundingFunction || Math.round;
    var output = void 0;
    var formatFunction = void 0;

    if (value === 0 && options.zeroFormat !== null) {
      output = options.zeroFormat;
    } else if (value === null && options.nullFormat !== null) {
      output = options.nullFormat;
    } else {
      for (var kind in formats) {
        if (formats[kind] && formatType.match(formats[kind].regexp)) {
          formatFunction = formats[kind].format;
          break;
        }
      }
      formatFunction = formatFunction || numberToFormat.bind(null, options);
      output = formatFunction(value, formatType, roundingFunction, numerify);
    }

    return output;
  }

  function numerify(input, formatType, roundingFunction) {
    var value = void 0;

    if (input === 0 || typeof input === 'undefined') {
      value = 0;
    } else if (input === null || numIsNaN(input)) {
      value = null;
    } else if (typeof input === 'string') {
      if (options.zeroFormat && input === options.zeroFormat) {
        value = 0;
      } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {
        value = null;
      } else {
        value = +input;
      }
    } else {
      value = +input || null;
    }

    return format(value, formatType, roundingFunction);
  }

  numerify.options = options;
  numerify._numberToFormat = numberToFormat.bind(null, options);
  numerify.register = function (name, format) {
    formats[name] = format;
  };
  numerify.unregister = function (name) {
    formats[name] = null;
  };
  numerify.setOptions = function (opts) {
    extend(options, opts);
  };
  numerify.reset = function () {
    extend(options, DEFAULT_OPTIONS);
  };

  numerify.register('percentage', numerifyPercent);

  var index_es = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': numerify
  });

  function debounce(fn, delay) {
    var timer = null;
    return function () {
      var self = this;
      var args = arguments;
      clearTimeout(timer);
      timer = setTimeout(function () {
        fn.apply(self, args);
      }, delay);
    };
  }

  function throttle(fn, wait, delay) {
    var timer = null;
    var previous = null;

    return function () {
      var self = this;
      var args = arguments;
      var now = Date.now();
      if (!previous) previous = now;
      if (now - previous > wait) {
        fn.apply(self, args);
        previous = now;
      } else if (delay) {
        clearTimeout(timer);
        timer = setTimeout(function () {
          fn.apply(self, args);
        }, delay);
      }
    };
  }

  function set$2(target, path, value) {
    if (!path) return;
    var targetTemp = target;
    var pathArr = path.split('.');
    pathArr.forEach(function (item, index) {
      if (index === pathArr.length - 1) {
        targetTemp[item] = value;
      } else {
        if (!targetTemp[item]) targetTemp[item] = {};
        targetTemp = targetTemp[item];
      }
    });
  }

  function get$1(target, path, defaultValue) {
    if (!path) return target;
    var pathArr = path.split('.');
    var targetTemp = target;
    pathArr.some(function (item, index) {
      if (targetTemp[item] === undefined) {
        targetTemp = defaultValue;
        return true;
      } else {
        targetTemp = targetTemp[item];
      }
    });
    return targetTemp;
  }

  function getStore(name) {
    try {
      return JSON.parse(window.localStorage.getItem(name));
    } catch (e) {}
  }

  function setStore(name, data) {
    try {
      window.localStorage.setItem(name, JSON.stringify(data));
    } catch (e) {}
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function getType(v) {
    return Object.prototype.toString.call(v);
  }

  function getTypeof(v) {
    return typeof v === 'undefined' ? 'undefined' : _typeof(v);
  }

  function isObject$1(v) {
    return getType(v) === '[object Object]';
  }

  function isArray$1(v) {
    return getType(v) === '[object Array]';
  }

  function isFunction(v) {
    return getType(v) === '[object Function]';
  }

  function isString(v) {
    return getType(v) === '[object String]';
  }

  function isBoolean(v) {
    return getType(v) === '[object Boolean]';
  }

  function isEmptyObj(v) {
    return isObject$1(v) && !Object.keys(v).length;
  }

  function isNumber(v) {
    return getType(v) === '[object Number]';
  }

  function clone(v) {
    if (isObject$1(v)) return Object.assign({}, v);
    if (isArray$1(v)) return v.slice();
  }

  function cloneDeep(v) {
    return JSON.parse(JSON.stringify(v));
  }

  function kebabToCamel(s) {
    return s.replace(/-(\w)/g, function (_, c) {
      return c.toUpperCase();
    });
  }

  function camelToKebab(s) {
    return s.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }

  function unique(arr) {
    var result = [];
    arr.forEach(function (item) {
      if (!~result.indexOf(item)) result.push(item);
    });
    return result;
  }

  function getLinearValue(x1, y1, x2, y2, x3) {
    var k = (y2 - y1) / (x2 - x1);
    var b = y1 - x1 * k;
    if (x3 == null) {
      return { k: k, b: b };
    } else {
      return x3 * k + b;
    }
  }

  function getFnAndObjValue(target, key) {
    return isFunction(target) ? target(key) : !isObject$1(target) ? key : target[key] != null ? target[key] : key;
  }

  function arrDelItem(arr, diffItem) {
    return arr.filter(function (item) {
      return diffItem !== item;
    });
  }

  var arrDelArrItem = function arrDelArrItem(arr, diffArr) {
    return arr.filter(function (item) {
      return !~diffArr.indexOf(item);
    });
  };

  function getArrMin(arr) {
    return Math.min.apply(null, arr);
  }

  function getArrMax(arr) {
    return Math.max.apply(null, arr);
  }

  function toArray(v) {
    return Array.prototype.slice.call(v);
  }

  function noop() {}

  function hasOwn(source, target) {
    return Object.prototype.hasOwnProperty.call(source, target);
  }

  var extend$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwn(source, key)) target[key] = source[key];
      }
    }
    return target;
  };

  function isEqual(alice, bob) {
    if (alice === bob) return true;
    if (alice === null || bob === null || getTypeof(alice) !== 'object' || getTypeof(bob) !== 'object') {
      return alice === bob;
    }

    for (var key in alice) {
      if (!hasOwn(alice, key)) continue;
      var aliceValue = alice[key];
      var bobValue = bob[key];
      var aliceType = getTypeof(aliceValue);

      if (getTypeof(bobValue) === 'undefined') {
        return false;
      } else if (aliceType === 'object') {
        if (!isEqual(aliceValue, bobValue)) return false;
      } else if (aliceValue !== bobValue) {
        return false;
      }
    }
    for (var _key in bob) {
      if (!hasOwn(bob, _key)) continue;
      if (getTypeof(alice)[_key] === 'undefined') return false;
    }

    return true;
  }

  var index_es$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    debounce: debounce,
    throttle: throttle,
    set: set$2,
    get: get$1,
    getStore: getStore,
    setStore: setStore,
    clone: clone,
    cloneDeep: cloneDeep,
    getType: getType,
    getTypeof: getTypeof,
    isObject: isObject$1,
    isArray: isArray$1,
    isFunction: isFunction,
    isString: isString,
    isBoolean: isBoolean,
    isEmptyObj: isEmptyObj,
    isNumber: isNumber,
    kebabToCamel: kebabToCamel,
    camelToKebab: camelToKebab,
    unique: unique,
    getLinearValue: getLinearValue,
    getFnAndObjValue: getFnAndObjValue,
    arrDelItem: arrDelItem,
    arrDelArrItem: arrDelArrItem,
    getArrMin: getArrMin,
    getArrMax: getArrMax,
    toArray: toArray,
    noop: noop,
    extend: extend$1,
    isEqual: isEqual,
    hasOwn: hasOwn
  });

  var require$$3 = /*@__PURE__*/getAugmentedNamespace(index_es);

  var utilsLite = /*@__PURE__*/getAugmentedNamespace(index_es$1);

  var utils = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, '__esModule', { value: true });

  function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

  var numerify = _interopDefault(require$$3);


  var getFormated = function getFormated(val, type, digit) {
    var defaultVal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '-';

    if (isNaN(val)) return defaultVal;
    if (!type) return val;
    if (utilsLite.isFunction(type)) return type(val, numerify);

    digit = isNaN(digit) ? 0 : ++digit;
    var digitStr = '.[' + new Array(digit).join(0) + ']';
    var formatter = type;
    switch (type) {
      case 'KMB':
        formatter = digit ? '0,0' + digitStr + 'a' : '0,0a';
        break;
      case 'normal':
        formatter = digit ? '0,0' + digitStr : '0,0';
        break;
      case 'percent':
        formatter = digit ? '0,0' + digitStr + '%' : '0,0.[00]%';
        break;
    }
    return numerify(val, formatter);
  };

  var getStackMap = function getStackMap(stack) {
    var stackMap = {};
    Object.keys(stack).forEach(function (item) {
      stack[item].forEach(function (name) {
        stackMap[name] = item;
      });
    });
    return stackMap;
  };

  var $get = function $get(url) {
    return new Promise(function (resolve, reject) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url);
      xhr.send(null);
      xhr.onload = function () {
        resolve(JSON.parse(xhr.responseText));
      };
      xhr.onerror = function () {
        reject(JSON.parse(xhr.responseText));
      };
    });
  };

  var mapPromise = {};

  var getMapJSON = function getMapJSON(_ref) {
    var position = _ref.position,
        positionJsonLink = _ref.positionJsonLink,
        beforeRegisterMapOnce = _ref.beforeRegisterMapOnce,
        mapURLProfix = _ref.mapURLProfix;

    var link = positionJsonLink || '' + mapURLProfix + position + '.json';
    if (!mapPromise[link]) {
      mapPromise[link] = $get(link).then(function (res) {
        if (beforeRegisterMapOnce) res = beforeRegisterMapOnce(res);
        return res;
      });
    }
    return mapPromise[link];
  };

  var bmapPromise = null;
  var amapPromise = null;

  var getBmap = function getBmap(key, v) {
    if (!bmapPromise) {
      bmapPromise = new Promise(function (resolve, reject) {
        var callbackName = 'bmap' + Date.now();
        window[callbackName] = resolve;
        var script = document.createElement('script');
        script.src = ['https://api.map.baidu.com/api?v=' + (v || '2.0'), 'ak=' + key, 'callback=' + callbackName].join('&');

        document.body.appendChild(script);
      });
    }
    return bmapPromise;
  };

  var getAmap = function getAmap(key, v) {
    if (!amapPromise) {
      amapPromise = new Promise(function (resolve, reject) {
        var callbackName = 'amap' + Date.now();
        window[callbackName] = resolve;
        var script = document.createElement('script');
        script.src = ['https://webapi.amap.com/maps?v=' + (v || '1.4.3'), 'key=' + key, 'callback=' + callbackName].join('&');

        document.body.appendChild(script);
      });
    }
    return amapPromise;
  };

  function setArrayValue(arr, index, value) {
    if (arr[index] !== undefined) {
      arr[index].push(value);
    } else {
      arr[index] = [value];
    }
  }

  exports.getFormated = getFormated;
  exports.getStackMap = getStackMap;
  exports.$get = $get;
  exports.getMapJSON = getMapJSON;
  exports.getBmap = getBmap;
  exports.getAmap = getAmap;
  exports.setArrayValue = setArrayValue;
  });

  /**
   * zrender: çæå¯ä¸id
   *
   * @author errorrik (errorrik@gmail.com)
   */
  var idStart = 0x0907;

  function _default() {
    return idStart++;
  }

  var guid = _default;

  /**
   * echartsè®¾å¤ç¯å¢è¯å«
   *
   * @desc echartsåºäºCanvasï¼çº¯Javascriptå¾è¡¨åºï¼æä¾ç´è§ï¼çå¨ï¼å¯äº¤äºï¼å¯ä¸ªæ§åå®å¶çæ°æ®ç»è®¡å¾è¡¨ã
   * @author firede[firede@firede.us]
   * @desc thanks zepto.
   */

  /* global wx */
  var env = {};

  if (typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function') {
    // In Weixin Application
    env = {
      browser: {},
      os: {},
      node: false,
      wxa: true,
      // Weixin Application
      canvasSupported: true,
      svgSupported: false,
      touchEventsSupported: true,
      domSupported: false
    };
  } else if (typeof document === 'undefined' && typeof self !== 'undefined') {
    // In worker
    env = {
      browser: {},
      os: {},
      node: false,
      worker: true,
      canvasSupported: true,
      domSupported: false
    };
  } else if (typeof navigator === 'undefined') {
    // In node
    env = {
      browser: {},
      os: {},
      node: true,
      worker: false,
      // Assume canvas is supported
      canvasSupported: true,
      svgSupported: true,
      domSupported: false
    };
  } else {
    env = detect(navigator.userAgent);
  }

  var _default$1 = env; // Zepto.js
  // (c) 2010-2013 Thomas Fuchs
  // Zepto.js may be freely distributed under the MIT license.

  function detect(ua) {
    var os = {};
    var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
    // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
    // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
    // var touchpad = webos && ua.match(/TouchPad/);
    // var kindle = ua.match(/Kindle\/([\d.]+)/);
    // var silk = ua.match(/Silk\/([\d._]+)/);
    // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
    // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
    // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
    // var playbook = ua.match(/PlayBook/);
    // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);

    var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
    // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;

    var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
    || ua.match(/Trident\/.+?rv:(([\d.]+))/);
    var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+

    var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
    // - discern (more) between multiple browsers on android
    // - decide if kindle fire in silk mode is android or not
    // - Firefox on Android doesn't specify the Android version
    // - possibly devide in os, device and browser hashes
    // if (browser.webkit = !!webkit) browser.version = webkit[1];
    // if (android) os.android = true, os.version = android[2];
    // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
    // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
    // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
    // if (webos) os.webos = true, os.version = webos[2];
    // if (touchpad) os.touchpad = true;
    // if (blackberry) os.blackberry = true, os.version = blackberry[2];
    // if (bb10) os.bb10 = true, os.version = bb10[2];
    // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
    // if (playbook) browser.playbook = true;
    // if (kindle) os.kindle = true, os.version = kindle[1];
    // if (silk) browser.silk = true, browser.version = silk[1];
    // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
    // if (chrome) browser.chrome = true, browser.version = chrome[1];

    if (firefox) {
      browser.firefox = true;
      browser.version = firefox[1];
    } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
    // if (webview) browser.webview = true;


    if (ie) {
      browser.ie = true;
      browser.version = ie[1];
    }

    if (edge) {
      browser.edge = true;
      browser.version = edge[1];
    } // It is difficult to detect WeChat in Win Phone precisely, because ua can
    // not be set on win phone. So we do not consider Win Phone.


    if (weChat) {
      browser.weChat = true;
    } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
    //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
    // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
    //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
    //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));


    return {
      browser: browser,
      os: os,
      node: false,
      // åçcanvasæ¯æï¼æ¹æç«¯ç¹äº
      // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
      canvasSupported: !!document.createElement('canvas').getContext,
      svgSupported: typeof SVGRect !== 'undefined',
      // works on most browsers
      // IE10/11 does not support touch event, and MS Edge supports them but not by
      // default, so we dont check navigator.maxTouchPoints for them here.
      touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
      // <http://caniuse.com/#search=pointer%20event>.
      pointerEventsSupported: // (1) Firefox supports pointer but not by default, only MS browsers are reliable on pointer
      // events currently. So we dont use that on other browsers unless tested sufficiently.
      // For example, in iOS 13 Mobile Chromium 78, if the touching behavior starts page
      // scroll, the `pointermove` event can not be fired any more. That will break some
      // features like "pan horizontally to move something and pan vertically to page scroll".
      // The horizontal pan probably be interrupted by the casually triggered page scroll.
      // (2) Although IE 10 supports pointer event, it use old style and is different from the
      // standard. So we exclude that. (IE 10 is hardly used on touch device)
      'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 11),
      // passiveSupported: detectPassiveSupport()
      domSupported: typeof document !== 'undefined'
    };
  } // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
  // function detectPassiveSupport() {
  //     // Test via a getter in the options object to see if the passive property is accessed
  //     var supportsPassive = false;
  //     try {
  //         var opts = Object.defineProperty({}, 'passive', {
  //             get: function() {
  //                 supportsPassive = true;
  //             }
  //         });
  //         window.addEventListener('testPassive', function() {}, opts);
  //     } catch (e) {
  //     }
  //     return supportsPassive;
  // }


  var env_1 = _default$1;

  /**
   * @module zrender/core/util
   */
  // ç¨äºå¤çmergeæ¶æ æ³éåDateç­å¯¹è±¡çé®é¢
  var BUILTIN_OBJECT = {
    '[object Function]': 1,
    '[object RegExp]': 1,
    '[object Date]': 1,
    '[object Error]': 1,
    '[object CanvasGradient]': 1,
    '[object CanvasPattern]': 1,
    // For node-canvas
    '[object Image]': 1,
    '[object Canvas]': 1
  };
  var TYPED_ARRAY = {
    '[object Int8Array]': 1,
    '[object Uint8Array]': 1,
    '[object Uint8ClampedArray]': 1,
    '[object Int16Array]': 1,
    '[object Uint16Array]': 1,
    '[object Int32Array]': 1,
    '[object Uint32Array]': 1,
    '[object Float32Array]': 1,
    '[object Float64Array]': 1
  };
  var objToString = Object.prototype.toString;
  var arrayProto = Array.prototype;
  var nativeForEach = arrayProto.forEach;
  var nativeFilter = arrayProto.filter;
  var nativeSlice = arrayProto.slice;
  var nativeMap = arrayProto.map;
  var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.

  var methods = {};

  function $override(name, fn) {
    // Clear ctx instance for different environment
    if (name === 'createCanvas') {
      _ctx = null;
    }

    methods[name] = fn;
  }
  /**
   * Those data types can be cloned:
   *     Plain object, Array, TypedArray, number, string, null, undefined.
   * Those data types will be assgined using the orginal data:
   *     BUILTIN_OBJECT
   * Instance of user defined class will be cloned to a plain object, without
   * properties in prototype.
   * Other data types is not supported (not sure what will happen).
   *
   * Caution: do not support clone Date, for performance consideration.
   * (There might be a large number of date in `series.data`).
   * So date should not be modified in and out of echarts.
   *
   * @param {*} source
   * @return {*} new
   */


  function clone$1(source) {
    if (source == null || typeof source !== 'object') {
      return source;
    }

    var result = source;
    var typeStr = objToString.call(source);

    if (typeStr === '[object Array]') {
      if (!isPrimitive(source)) {
        result = [];

        for (var i = 0, len = source.length; i < len; i++) {
          result[i] = clone$1(source[i]);
        }
      }
    } else if (TYPED_ARRAY[typeStr]) {
      if (!isPrimitive(source)) {
        var Ctor = source.constructor;

        if (source.constructor.from) {
          result = Ctor.from(source);
        } else {
          result = new Ctor(source.length);

          for (var i = 0, len = source.length; i < len; i++) {
            result[i] = clone$1(source[i]);
          }
        }
      }
    } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
      result = {};

      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          result[key] = clone$1(source[key]);
        }
      }
    }

    return result;
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {*} target
   * @param {*} source
   * @param {boolean} [overwrite=false]
   */


  function merge(target, source, overwrite) {
    // We should escapse that source is string
    // and enter for ... in ...
    if (!isObject$2(source) || !isObject$2(target)) {
      return overwrite ? clone$1(source) : target;
    }

    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        var targetProp = target[key];
        var sourceProp = source[key];

        if (isObject$2(sourceProp) && isObject$2(targetProp) && !isArray$2(sourceProp) && !isArray$2(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
          // å¦æéè¦éå½è¦çï¼å°±éå½è°ç¨merge
          merge(targetProp, sourceProp, overwrite);
        } else if (overwrite || !(key in target)) {
          // å¦ååªå¤çoverwriteä¸ºtrueï¼æèå¨ç®æ å¯¹è±¡ä¸­æ²¡ææ­¤å±æ§çæåµ
          // NOTEï¼å¨ target[key] ä¸å­å¨çæ¶åä¹æ¯ç´æ¥è¦ç
          target[key] = clone$1(source[key]);
        }
      }
    }

    return target;
  }
  /**
   * @param {Array} targetAndSources The first item is target, and the rests are source.
   * @param {boolean} [overwrite=false]
   * @return {*} target
   */


  function mergeAll(targetAndSources, overwrite) {
    var result = targetAndSources[0];

    for (var i = 1, len = targetAndSources.length; i < len; i++) {
      result = merge(result, targetAndSources[i], overwrite);
    }

    return result;
  }
  /**
   * @param {*} target
   * @param {*} source
   * @memberOf module:zrender/core/util
   */


  function extend$2(target, source) {
    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }

    return target;
  }
  /**
   * @param {*} target
   * @param {*} source
   * @param {boolean} [overlay=false]
   * @memberOf module:zrender/core/util
   */


  function defaults(target, source, overlay) {
    for (var key in source) {
      if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
        target[key] = source[key];
      }
    }

    return target;
  }

  var createCanvas = function () {
    return methods.createCanvas();
  };

  methods.createCanvas = function () {
    return document.createElement('canvas');
  }; // FIXME


  var _ctx;

  function getContext() {
    if (!_ctx) {
      // Use util.createCanvas instead of createCanvas
      // because createCanvas may be overwritten in different environment
      _ctx = createCanvas().getContext('2d');
    }

    return _ctx;
  }
  /**
   * æ¥è¯¢æ°ç»ä¸­åç´ çindex
   * @memberOf module:zrender/core/util
   */


  function indexOf$1(array, value) {
    if (array) {
      if (array.indexOf) {
        return array.indexOf(value);
      }

      for (var i = 0, len = array.length; i < len; i++) {
        if (array[i] === value) {
          return i;
        }
      }
    }

    return -1;
  }
  /**
   * æé ç±»ç»§æ¿å³ç³»
   *
   * @memberOf module:zrender/core/util
   * @param {Function} clazz æºç±»
   * @param {Function} baseClazz åºç±»
   */


  function inherits(clazz, baseClazz) {
    var clazzPrototype = clazz.prototype;

    function F() {}

    F.prototype = baseClazz.prototype;
    clazz.prototype = new F();

    for (var prop in clazzPrototype) {
      if (clazzPrototype.hasOwnProperty(prop)) {
        clazz.prototype[prop] = clazzPrototype[prop];
      }
    }

    clazz.prototype.constructor = clazz;
    clazz.superClass = baseClazz;
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {Object|Function} target
   * @param {Object|Function} sorce
   * @param {boolean} overlay
   */


  function mixin(target, source, overlay) {
    target = 'prototype' in target ? target.prototype : target;
    source = 'prototype' in source ? source.prototype : source;
    defaults(target, source, overlay);
  }
  /**
   * Consider typed array.
   * @param {Array|TypedArray} data
   */


  function isArrayLike(data) {
    if (!data) {
      return;
    }

    if (typeof data === 'string') {
      return false;
    }

    return typeof data.length === 'number';
  }
  /**
   * æ°ç»æå¯¹è±¡éå
   * @memberOf module:zrender/core/util
   * @param {Object|Array} obj
   * @param {Function} cb
   * @param {*} [context]
   */


  function each(obj, cb, context) {
    if (!(obj && cb)) {
      return;
    }

    if (obj.forEach && obj.forEach === nativeForEach) {
      obj.forEach(cb, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, len = obj.length; i < len; i++) {
        cb.call(context, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          cb.call(context, obj[key], key, obj);
        }
      }
    }
  }
  /**
   * æ°ç»æ å°
   * @memberOf module:zrender/core/util
   * @param {Array} obj
   * @param {Function} cb
   * @param {*} [context]
   * @return {Array}
   */


  function map(obj, cb, context) {
    if (!(obj && cb)) {
      return;
    }

    if (obj.map && obj.map === nativeMap) {
      return obj.map(cb, context);
    } else {
      var result = [];

      for (var i = 0, len = obj.length; i < len; i++) {
        result.push(cb.call(context, obj[i], i, obj));
      }

      return result;
    }
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {Array} obj
   * @param {Function} cb
   * @param {Object} [memo]
   * @param {*} [context]
   * @return {Array}
   */


  function reduce(obj, cb, memo, context) {
    if (!(obj && cb)) {
      return;
    }

    if (obj.reduce && obj.reduce === nativeReduce) {
      return obj.reduce(cb, memo, context);
    } else {
      for (var i = 0, len = obj.length; i < len; i++) {
        memo = cb.call(context, memo, obj[i], i, obj);
      }

      return memo;
    }
  }
  /**
   * æ°ç»è¿æ»¤
   * @memberOf module:zrender/core/util
   * @param {Array} obj
   * @param {Function} cb
   * @param {*} [context]
   * @return {Array}
   */


  function filter(obj, cb, context) {
    if (!(obj && cb)) {
      return;
    }

    if (obj.filter && obj.filter === nativeFilter) {
      return obj.filter(cb, context);
    } else {
      var result = [];

      for (var i = 0, len = obj.length; i < len; i++) {
        if (cb.call(context, obj[i], i, obj)) {
          result.push(obj[i]);
        }
      }

      return result;
    }
  }
  /**
   * æ°ç»é¡¹æ¥æ¾
   * @memberOf module:zrender/core/util
   * @param {Array} obj
   * @param {Function} cb
   * @param {*} [context]
   * @return {*}
   */


  function find(obj, cb, context) {
    if (!(obj && cb)) {
      return;
    }

    for (var i = 0, len = obj.length; i < len; i++) {
      if (cb.call(context, obj[i], i, obj)) {
        return obj[i];
      }
    }
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {Function} func
   * @param {*} context
   * @return {Function}
   */


  function bind$1(func, context) {
    var args = nativeSlice.call(arguments, 2);
    return function () {
      return func.apply(context, args.concat(nativeSlice.call(arguments)));
    };
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {Function} func
   * @return {Function}
   */


  function curry(func) {
    var args = nativeSlice.call(arguments, 1);
    return function () {
      return func.apply(this, args.concat(nativeSlice.call(arguments)));
    };
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {*} value
   * @return {boolean}
   */


  function isArray$2(value) {
    return objToString.call(value) === '[object Array]';
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {*} value
   * @return {boolean}
   */


  function isFunction$1(value) {
    return typeof value === 'function';
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {*} value
   * @return {boolean}
   */


  function isString$1(value) {
    return objToString.call(value) === '[object String]';
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {*} value
   * @return {boolean}
   */


  function isObject$2(value) {
    // Avoid a V8 JIT bug in Chrome 19-20.
    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value;
    return type === 'function' || !!value && type === 'object';
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {*} value
   * @return {boolean}
   */


  function isBuiltInObject(value) {
    return !!BUILTIN_OBJECT[objToString.call(value)];
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {*} value
   * @return {boolean}
   */


  function isTypedArray(value) {
    return !!TYPED_ARRAY[objToString.call(value)];
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {*} value
   * @return {boolean}
   */


  function isDom(value) {
    return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
  }
  /**
   * Whether is exactly NaN. Notice isNaN('a') returns true.
   * @param {*} value
   * @return {boolean}
   */


  function eqNaN(value) {
    /* eslint-disable-next-line no-self-compare */
    return value !== value;
  }
  /**
   * If value1 is not null, then return value1, otherwise judget rest of values.
   * Low performance.
   * @memberOf module:zrender/core/util
   * @return {*} Final value
   */


  function retrieve(values) {
    for (var i = 0, len = arguments.length; i < len; i++) {
      if (arguments[i] != null) {
        return arguments[i];
      }
    }
  }

  function retrieve2(value0, value1) {
    return value0 != null ? value0 : value1;
  }

  function retrieve3(value0, value1, value2) {
    return value0 != null ? value0 : value1 != null ? value1 : value2;
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {Array} arr
   * @param {number} startIndex
   * @param {number} endIndex
   * @return {Array}
   */


  function slice() {
    return Function.call.apply(nativeSlice, arguments);
  }
  /**
   * Normalize css liked array configuration
   * e.g.
   *  3 => [3, 3, 3, 3]
   *  [4, 2] => [4, 2, 4, 2]
   *  [4, 3, 2] => [4, 3, 2, 3]
   * @param {number|Array.<number>} val
   * @return {Array.<number>}
   */


  function normalizeCssArray(val) {
    if (typeof val === 'number') {
      return [val, val, val, val];
    }

    var len = val.length;

    if (len === 2) {
      // vertical | horizontal
      return [val[0], val[1], val[0], val[1]];
    } else if (len === 3) {
      // top | horizontal | bottom
      return [val[0], val[1], val[2], val[1]];
    }

    return val;
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {boolean} condition
   * @param {string} message
   */


  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  /**
   * @memberOf module:zrender/core/util
   * @param {string} str string to be trimed
   * @return {string} trimed string
   */


  function trim$1(str) {
    if (str == null) {
      return null;
    } else if (typeof str.trim === 'function') {
      return str.trim();
    } else {
      return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    }
  }

  var primitiveKey = '__ec_primitive__';
  /**
   * Set an object as primitive to be ignored traversing children in clone or merge
   */

  function setAsPrimitive(obj) {
    obj[primitiveKey] = true;
  }

  function isPrimitive(obj) {
    return obj[primitiveKey];
  }
  /**
   * @constructor
   * @param {Object} obj Only apply `ownProperty`.
   */


  function HashMap(obj) {
    var isArr = isArray$2(obj); // Key should not be set on this, otherwise
    // methods get/set/... may be overrided.

    this.data = {};
    var thisMap = this;
    obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);

    function visit(value, key) {
      isArr ? thisMap.set(value, key) : thisMap.set(key, value);
    }
  }

  HashMap.prototype = {
    constructor: HashMap,
    // Do not provide `has` method to avoid defining what is `has`.
    // (We usually treat `null` and `undefined` as the same, different
    // from ES6 Map).
    get: function (key) {
      return this.data.hasOwnProperty(key) ? this.data[key] : null;
    },
    set: function (key, value) {
      // Comparing with invocation chaining, `return value` is more commonly
      // used in this case: `var someVal = map.set('a', genVal());`
      return this.data[key] = value;
    },
    // Although util.each can be performed on this hashMap directly, user
    // should not use the exposed keys, who are prefixed.
    each: function (cb, context) {
      context !== void 0 && (cb = bind$1(cb, context));
      /* eslint-disable guard-for-in */

      for (var key in this.data) {
        this.data.hasOwnProperty(key) && cb(this.data[key], key);
      }
      /* eslint-enable guard-for-in */

    },
    // Do not use this method if performance sensitive.
    removeKey: function (key) {
      delete this.data[key];
    }
  };

  function createHashMap(obj) {
    return new HashMap(obj);
  }

  function concatArray(a, b) {
    var newArray = new a.constructor(a.length + b.length);

    for (var i = 0; i < a.length; i++) {
      newArray[i] = a[i];
    }

    var offset = a.length;

    for (i = 0; i < b.length; i++) {
      newArray[i + offset] = b[i];
    }

    return newArray;
  }

  function noop$1() {}

  var $override_1 = $override;
  var clone_1 = clone$1;
  var merge_1 = merge;
  var mergeAll_1 = mergeAll;
  var extend_1 = extend$2;
  var defaults_1 = defaults;
  var createCanvas_1 = createCanvas;
  var getContext_1 = getContext;
  var indexOf_1 = indexOf$1;
  var inherits_1 = inherits;
  var mixin_1 = mixin;
  var isArrayLike_1 = isArrayLike;
  var each_1 = each;
  var map_1 = map;
  var reduce_1 = reduce;
  var filter_1 = filter;
  var find_1 = find;
  var bind_1 = bind$1;
  var curry_1 = curry;
  var isArray_1 = isArray$2;
  var isFunction_1 = isFunction$1;
  var isString_1 = isString$1;
  var isObject_1 = isObject$2;
  var isBuiltInObject_1 = isBuiltInObject;
  var isTypedArray_1 = isTypedArray;
  var isDom_1 = isDom;
  var eqNaN_1 = eqNaN;
  var retrieve_1 = retrieve;
  var retrieve2_1 = retrieve2;
  var retrieve3_1 = retrieve3;
  var slice_1 = slice;
  var normalizeCssArray_1 = normalizeCssArray;
  var assert_1 = assert;
  var trim_1 = trim$1;
  var setAsPrimitive_1 = setAsPrimitive;
  var isPrimitive_1 = isPrimitive;
  var createHashMap_1 = createHashMap;
  var concatArray_1 = concatArray;
  var noop_1 = noop$1;

  var util = {
  	$override: $override_1,
  	clone: clone_1,
  	merge: merge_1,
  	mergeAll: mergeAll_1,
  	extend: extend_1,
  	defaults: defaults_1,
  	createCanvas: createCanvas_1,
  	getContext: getContext_1,
  	indexOf: indexOf_1,
  	inherits: inherits_1,
  	mixin: mixin_1,
  	isArrayLike: isArrayLike_1,
  	each: each_1,
  	map: map_1,
  	reduce: reduce_1,
  	filter: filter_1,
  	find: find_1,
  	bind: bind_1,
  	curry: curry_1,
  	isArray: isArray_1,
  	isFunction: isFunction_1,
  	isString: isString_1,
  	isObject: isObject_1,
  	isBuiltInObject: isBuiltInObject_1,
  	isTypedArray: isTypedArray_1,
  	isDom: isDom_1,
  	eqNaN: eqNaN_1,
  	retrieve: retrieve_1,
  	retrieve2: retrieve2_1,
  	retrieve3: retrieve3_1,
  	slice: slice_1,
  	normalizeCssArray: normalizeCssArray_1,
  	assert: assert_1,
  	trim: trim_1,
  	setAsPrimitive: setAsPrimitive_1,
  	isPrimitive: isPrimitive_1,
  	createHashMap: createHashMap_1,
  	concatArray: concatArray_1,
  	noop: noop_1
  };

  /* global Float32Array */
  var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
  /**
   * åå»ºä¸ä¸ªåé
   * @param {number} [x=0]
   * @param {number} [y=0]
   * @return {Vector2}
   */

  function create(x, y) {
    var out = new ArrayCtor(2);

    if (x == null) {
      x = 0;
    }

    if (y == null) {
      y = 0;
    }

    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * å¤å¶åéæ°æ®
   * @param {Vector2} out
   * @param {Vector2} v
   * @return {Vector2}
   */


  function copy(out, v) {
    out[0] = v[0];
    out[1] = v[1];
    return out;
  }
  /**
   * åéä¸ä¸ªåé
   * @param {Vector2} v
   * @return {Vector2}
   */


  function clone$2(v) {
    var out = new ArrayCtor(2);
    out[0] = v[0];
    out[1] = v[1];
    return out;
  }
  /**
   * è®¾ç½®åéçä¸¤ä¸ªé¡¹
   * @param {Vector2} out
   * @param {number} a
   * @param {number} b
   * @return {Vector2} ç»æ
   */


  function set$3(out, a, b) {
    out[0] = a;
    out[1] = b;
    return out;
  }
  /**
   * åéç¸å 
   * @param {Vector2} out
   * @param {Vector2} v1
   * @param {Vector2} v2
   */


  function add(out, v1, v2) {
    out[0] = v1[0] + v2[0];
    out[1] = v1[1] + v2[1];
    return out;
  }
  /**
   * åéç¼©æ¾åç¸å 
   * @param {Vector2} out
   * @param {Vector2} v1
   * @param {Vector2} v2
   * @param {number} a
   */


  function scaleAndAdd(out, v1, v2, a) {
    out[0] = v1[0] + v2[0] * a;
    out[1] = v1[1] + v2[1] * a;
    return out;
  }
  /**
   * åéç¸å
   * @param {Vector2} out
   * @param {Vector2} v1
   * @param {Vector2} v2
   */


  function sub(out, v1, v2) {
    out[0] = v1[0] - v2[0];
    out[1] = v1[1] - v2[1];
    return out;
  }
  /**
   * åéé¿åº¦
   * @param {Vector2} v
   * @return {number}
   */


  function len(v) {
    return Math.sqrt(lenSquare(v));
  }

  var length = len; // jshint ignore:line

  /**
   * åéé¿åº¦å¹³æ¹
   * @param {Vector2} v
   * @return {number}
   */

  function lenSquare(v) {
    return v[0] * v[0] + v[1] * v[1];
  }

  var lengthSquare = lenSquare;
  /**
   * åéä¹æ³
   * @param {Vector2} out
   * @param {Vector2} v1
   * @param {Vector2} v2
   */

  function mul(out, v1, v2) {
    out[0] = v1[0] * v2[0];
    out[1] = v1[1] * v2[1];
    return out;
  }
  /**
   * åéé¤æ³
   * @param {Vector2} out
   * @param {Vector2} v1
   * @param {Vector2} v2
   */


  function div(out, v1, v2) {
    out[0] = v1[0] / v2[0];
    out[1] = v1[1] / v2[1];
    return out;
  }
  /**
   * åéç¹ä¹
   * @param {Vector2} v1
   * @param {Vector2} v2
   * @return {number}
   */


  function dot(v1, v2) {
    return v1[0] * v2[0] + v1[1] * v2[1];
  }
  /**
   * åéç¼©æ¾
   * @param {Vector2} out
   * @param {Vector2} v
   * @param {number} s
   */


  function scale(out, v, s) {
    out[0] = v[0] * s;
    out[1] = v[1] * s;
    return out;
  }
  /**
   * åéå½ä¸å
   * @param {Vector2} out
   * @param {Vector2} v
   */


  function normalize$1(out, v) {
    var d = len(v);

    if (d === 0) {
      out[0] = 0;
      out[1] = 0;
    } else {
      out[0] = v[0] / d;
      out[1] = v[1] / d;
    }

    return out;
  }
  /**
   * è®¡ç®åéé´è·ç¦»
   * @param {Vector2} v1
   * @param {Vector2} v2
   * @return {number}
   */


  function distance(v1, v2) {
    return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
  }

  var dist = distance;
  /**
   * åéè·ç¦»å¹³æ¹
   * @param {Vector2} v1
   * @param {Vector2} v2
   * @return {number}
   */

  function distanceSquare(v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
  }

  var distSquare = distanceSquare;
  /**
   * æ±è´åé
   * @param {Vector2} out
   * @param {Vector2} v
   */

  function negate(out, v) {
    out[0] = -v[0];
    out[1] = -v[1];
    return out;
  }
  /**
   * æå¼ä¸¤ä¸ªç¹
   * @param {Vector2} out
   * @param {Vector2} v1
   * @param {Vector2} v2
   * @param {number} t
   */


  function lerp(out, v1, v2, t) {
    out[0] = v1[0] + t * (v2[0] - v1[0]);
    out[1] = v1[1] + t * (v2[1] - v1[1]);
    return out;
  }
  /**
   * ç©éµå·¦ä¹åé
   * @param {Vector2} out
   * @param {Vector2} v
   * @param {Vector2} m
   */


  function applyTransform(out, v, m) {
    var x = v[0];
    var y = v[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  /**
   * æ±ä¸¤ä¸ªåéæå°å¼
   * @param  {Vector2} out
   * @param  {Vector2} v1
   * @param  {Vector2} v2
   */


  function min$3(out, v1, v2) {
    out[0] = Math.min(v1[0], v2[0]);
    out[1] = Math.min(v1[1], v2[1]);
    return out;
  }
  /**
   * æ±ä¸¤ä¸ªåéæå¤§å¼
   * @param  {Vector2} out
   * @param  {Vector2} v1
   * @param  {Vector2} v2
   */


  function max$2(out, v1, v2) {
    out[0] = Math.max(v1[0], v2[0]);
    out[1] = Math.max(v1[1], v2[1]);
    return out;
  }

  var create_1 = create;
  var copy_1 = copy;
  var clone_1$1 = clone$2;
  var set_1 = set$3;
  var add_1 = add;
  var scaleAndAdd_1 = scaleAndAdd;
  var sub_1 = sub;
  var len_1 = len;
  var length_1 = length;
  var lenSquare_1 = lenSquare;
  var lengthSquare_1 = lengthSquare;
  var mul_1 = mul;
  var div_1 = div;
  var dot_1 = dot;
  var scale_1 = scale;
  var normalize_1 = normalize$1;
  var distance_1 = distance;
  var dist_1 = dist;
  var distanceSquare_1 = distanceSquare;
  var distSquare_1 = distSquare;
  var negate_1 = negate;
  var lerp_1 = lerp;
  var applyTransform_1 = applyTransform;
  var min_1 = min$3;
  var max_1 = max$2;

  var vector = {
  	create: create_1,
  	copy: copy_1,
  	clone: clone_1$1,
  	set: set_1,
  	add: add_1,
  	scaleAndAdd: scaleAndAdd_1,
  	sub: sub_1,
  	len: len_1,
  	length: length_1,
  	lenSquare: lenSquare_1,
  	lengthSquare: lengthSquare_1,
  	mul: mul_1,
  	div: div_1,
  	dot: dot_1,
  	scale: scale_1,
  	normalize: normalize_1,
  	distance: distance_1,
  	dist: dist_1,
  	distanceSquare: distanceSquare_1,
  	distSquare: distSquare_1,
  	negate: negate_1,
  	lerp: lerp_1,
  	applyTransform: applyTransform_1,
  	min: min_1,
  	max: max_1
  };

  // TODO Draggable for group
  // FIXME Draggable on element which has parent rotation or scale
  function Draggable() {
    this.on('mousedown', this._dragStart, this);
    this.on('mousemove', this._drag, this);
    this.on('mouseup', this._dragEnd, this); // `mosuemove` and `mouseup` can be continue to fire when dragging.
    // See [Drag outside] in `Handler.js`. So we do not need to trigger
    // `_dragEnd` when globalout. That would brings better user experience.
    // this.on('globalout', this._dragEnd, this);
    // this._dropTarget = null;
    // this._draggingTarget = null;
    // this._x = 0;
    // this._y = 0;
  }

  Draggable.prototype = {
    constructor: Draggable,
    _dragStart: function (e) {
      var draggingTarget = e.target; // Find if there is draggable in the ancestor

      while (draggingTarget && !draggingTarget.draggable) {
        draggingTarget = draggingTarget.parent;
      }

      if (draggingTarget) {
        this._draggingTarget = draggingTarget;
        draggingTarget.dragging = true;
        this._x = e.offsetX;
        this._y = e.offsetY;
        this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
      }
    },
    _drag: function (e) {
      var draggingTarget = this._draggingTarget;

      if (draggingTarget) {
        var x = e.offsetX;
        var y = e.offsetY;
        var dx = x - this._x;
        var dy = y - this._y;
        this._x = x;
        this._y = y;
        draggingTarget.drift(dx, dy, e);
        this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
        var dropTarget = this.findHover(x, y, draggingTarget).target;
        var lastDropTarget = this._dropTarget;
        this._dropTarget = dropTarget;

        if (draggingTarget !== dropTarget) {
          if (lastDropTarget && dropTarget !== lastDropTarget) {
            this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
          }

          if (dropTarget && dropTarget !== lastDropTarget) {
            this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
          }
        }
      }
    },
    _dragEnd: function (e) {
      var draggingTarget = this._draggingTarget;

      if (draggingTarget) {
        draggingTarget.dragging = false;
      }

      this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);

      if (this._dropTarget) {
        this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
      }

      this._draggingTarget = null;
      this._dropTarget = null;
    }
  };

  function param(target, e) {
    return {
      target: target,
      topTarget: e && e.topTarget
    };
  }

  var _default$2 = Draggable;
  var Draggable_1 = _default$2;

  /**
   * Event Mixin
   * @module zrender/mixin/Eventful
   * @author Kener (@Kener-æå³°, kener.linfeng@gmail.com)
   *         pissang (https://www.github.com/pissang)
   */
  var arrySlice = Array.prototype.slice;
  /**
   * Event dispatcher.
   *
   * @alias module:zrender/mixin/Eventful
   * @constructor
   * @param {Object} [eventProcessor] The object eventProcessor is the scope when
   *        `eventProcessor.xxx` called.
   * @param {Function} [eventProcessor.normalizeQuery]
   *        param: {string|Object} Raw query.
   *        return: {string|Object} Normalized query.
   * @param {Function} [eventProcessor.filter] Event will be dispatched only
   *        if it returns `true`.
   *        param: {string} eventType
   *        param: {string|Object} query
   *        return: {boolean}
   * @param {Function} [eventProcessor.afterTrigger] Called after all handlers called.
   *        param: {string} eventType
   */

  var Eventful = function (eventProcessor) {
    this._$handlers = {};
    this._$eventProcessor = eventProcessor;
  };

  Eventful.prototype = {
    constructor: Eventful,

    /**
     * The handler can only be triggered once, then removed.
     *
     * @param {string} event The event name.
     * @param {string|Object} [query] Condition used on event filter.
     * @param {Function} handler The event handler.
     * @param {Object} context
     */
    one: function (event, query, handler, context) {
      return on(this, event, query, handler, context, true);
    },

    /**
     * Bind a handler.
     *
     * @param {string} event The event name.
     * @param {string|Object} [query] Condition used on event filter.
     * @param {Function} handler The event handler.
     * @param {Object} [context]
     */
    on: function (event, query, handler, context) {
      return on(this, event, query, handler, context, false);
    },

    /**
     * Whether any handler has bound.
     *
     * @param  {string}  event
     * @return {boolean}
     */
    isSilent: function (event) {
      var _h = this._$handlers;
      return !_h[event] || !_h[event].length;
    },

    /**
     * Unbind a event.
     *
     * @param {string} [event] The event name.
     *        If no `event` input, "off" all listeners.
     * @param {Function} [handler] The event handler.
     *        If no `handler` input, "off" all listeners of the `event`.
     */
    off: function (event, handler) {
      var _h = this._$handlers;

      if (!event) {
        this._$handlers = {};
        return this;
      }

      if (handler) {
        if (_h[event]) {
          var newList = [];

          for (var i = 0, l = _h[event].length; i < l; i++) {
            if (_h[event][i].h !== handler) {
              newList.push(_h[event][i]);
            }
          }

          _h[event] = newList;
        }

        if (_h[event] && _h[event].length === 0) {
          delete _h[event];
        }
      } else {
        delete _h[event];
      }

      return this;
    },

    /**
     * Dispatch a event.
     *
     * @param {string} type The event name.
     */
    trigger: function (type) {
      var _h = this._$handlers[type];
      var eventProcessor = this._$eventProcessor;

      if (_h) {
        var args = arguments;
        var argLen = args.length;

        if (argLen > 3) {
          args = arrySlice.call(args, 1);
        }

        var len = _h.length;

        for (var i = 0; i < len;) {
          var hItem = _h[i];

          if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
            i++;
            continue;
          } // Optimize advise from backbone


          switch (argLen) {
            case 1:
              hItem.h.call(hItem.ctx);
              break;

            case 2:
              hItem.h.call(hItem.ctx, args[1]);
              break;

            case 3:
              hItem.h.call(hItem.ctx, args[1], args[2]);
              break;

            default:
              // have more than 2 given arguments
              hItem.h.apply(hItem.ctx, args);
              break;
          }

          if (hItem.one) {
            _h.splice(i, 1);

            len--;
          } else {
            i++;
          }
        }
      }

      eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
      return this;
    },

    /**
     * Dispatch a event with context, which is specified at the last parameter.
     *
     * @param {string} type The event name.
     */
    triggerWithContext: function (type) {
      var _h = this._$handlers[type];
      var eventProcessor = this._$eventProcessor;

      if (_h) {
        var args = arguments;
        var argLen = args.length;

        if (argLen > 4) {
          args = arrySlice.call(args, 1, args.length - 1);
        }

        var ctx = args[args.length - 1];
        var len = _h.length;

        for (var i = 0; i < len;) {
          var hItem = _h[i];

          if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
            i++;
            continue;
          } // Optimize advise from backbone


          switch (argLen) {
            case 1:
              hItem.h.call(ctx);
              break;

            case 2:
              hItem.h.call(ctx, args[1]);
              break;

            case 3:
              hItem.h.call(ctx, args[1], args[2]);
              break;

            default:
              // have more than 2 given arguments
              hItem.h.apply(ctx, args);
              break;
          }

          if (hItem.one) {
            _h.splice(i, 1);

            len--;
          } else {
            i++;
          }
        }
      }

      eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
      return this;
    }
  };

  function normalizeQuery(host, query) {
    var eventProcessor = host._$eventProcessor;

    if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
      query = eventProcessor.normalizeQuery(query);
    }

    return query;
  }

  function on(eventful, event, query, handler, context, isOnce) {
    var _h = eventful._$handlers;

    if (typeof query === 'function') {
      context = handler;
      handler = query;
      query = null;
    }

    if (!handler || !event) {
      return eventful;
    }

    query = normalizeQuery(eventful, query);

    if (!_h[event]) {
      _h[event] = [];
    }

    for (var i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return eventful;
      }
    }

    var wrap = {
      h: handler,
      one: isOnce,
      query: query,
      ctx: context || eventful,
      // FIXME
      // Do not publish this feature util it is proved that it makes sense.
      callAtLast: handler.zrEventfulCallAtLast
    };
    var lastIndex = _h[event].length - 1;
    var lastWrap = _h[event][lastIndex];
    lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
    return eventful;
  } // ----------------------
  // The events in zrender
  // ----------------------

  /**
   * @event module:zrender/mixin/Eventful#onclick
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#onmouseover
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#onmouseout
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#onmousemove
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#onmousewheel
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#onmousedown
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#onmouseup
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#ondrag
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#ondragstart
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#ondragend
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#ondragenter
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#ondragleave
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#ondragover
   * @type {Function}
   * @default null
   */

  /**
   * @event module:zrender/mixin/Eventful#ondrop
   * @type {Function}
   * @default null
   */


  var _default$3 = Eventful;
  var Eventful_1 = _default$3;

  /**
   * The algoritm is learnt from
   * https://franklinta.com/2014/09/08/computing-css-matrix3d-transforms/
   * And we made some optimization for matrix inversion.
   * Other similar approaches:
   * "cv::getPerspectiveTransform", "Direct Linear Transformation".
   */
  var LN2 = Math.log(2);

  function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
    var cacheKey = rowMask + '-' + colMask;
    var fullRank = rows.length;

    if (detCache.hasOwnProperty(cacheKey)) {
      return detCache[cacheKey];
    }

    if (rank === 1) {
      // In this case the colMask must be like: `11101111`. We can find the place of `0`.
      var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
      return rows[rowStart][colStart];
    }

    var subRowMask = rowMask | 1 << rowStart;
    var subRowStart = rowStart + 1;

    while (rowMask & 1 << subRowStart) {
      subRowStart++;
    }

    var sum = 0;

    for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
      var colTag = 1 << j;

      if (!(colTag & colMask)) {
        sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] // det(subMatrix(0, j))
        * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
        colLocalIdx++;
      }
    }

    detCache[cacheKey] = sum;
    return sum;
  }
  /**
   * Usage:
   * ```js
   * var transformer = buildTransformer(
   *     [10, 44, 100, 44, 100, 300, 10, 300],
   *     [50, 54, 130, 14, 140, 330, 14, 220]
   * );
   * var out = [];
   * transformer && transformer([11, 33], out);
   * ```
   *
   * Notice: `buildTransformer` may take more than 10ms in some Android device.
   *
   * @param {Array.<number>} src source four points, [x0, y0, x1, y1, x2, y2, x3, y3]
   * @param {Array.<number>} dest destination four points, [x0, y0, x1, y1, x2, y2, x3, y3]
   * @return {Function} transformer If fail, return null/undefined.
   */


  function buildTransformer(src, dest) {
    var mA = [[src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]], [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]], [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]], [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]], [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]], [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]], [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]], [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]];
    var detCache = {};
    var det = determinant(mA, 8, 0, 0, 0, detCache);

    if (det === 0) {
      // can not make transformer when and only when
      // any three of the markers are collinear.
      return;
    } // `invert(mA) * dest`, that is, `adj(mA) / det * dest`.


    var vh = [];

    for (var i = 0; i < 8; i++) {
      for (var j = 0; j < 8; j++) {
        vh[j] == null && (vh[j] = 0);
        vh[j] += ((i + j) % 2 ? -1 : 1) * // det(subMatrix(i, j))
        determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
      }
    }

    return function (out, srcPointX, srcPointY) {
      var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
      out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
      out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
    };
  }

  var buildTransformer_1 = buildTransformer;

  var fourPointsTransform = {
  	buildTransformer: buildTransformer_1
  };

  var buildTransformer$1 = fourPointsTransform.buildTransformer;
  var EVENT_SAVED_PROP = '___zrEVENTSAVED';
  var _calcOut = [];
  /**
   * Transform "local coord" from `elFrom` to `elTarget`.
   * "local coord": the coord based on the input `el`. The origin point is at
   *     the position of "left: 0; top: 0;" in the `el`.
   *
   * Support when CSS transform is used.
   *
   * Having the `out` (that is, `[outX, outY]`), we can create an DOM element
   * and set the CSS style as "left: outX; top: outY;" and append it to `elTarge`
   * to locate the element.
   *
   * For example, this code below positions a child of `document.body` on the event
   * point, no matter whether `body` has `margin`/`paddin`/`transfrom`/... :
   * ```js
   * transformLocalCoord(out, container, document.body, event.offsetX, event.offsetY);
   * if (!eqNaN(out[0])) {
   *     // Then locate the tip element on the event point.
   *     var tipEl = document.createElement('div');
   *     tipEl.style.cssText = 'position: absolute; left:' + out[0] + ';top:' + out[1] + ';';
   *     document.body.appendChild(tipEl);
   * }
   * ```
   *
   * Notice: In some env this method is not supported. If called, `out` will be `[NaN, NaN]`.
   *
   * @param {Array.<number>} out [inX: number, inY: number] The output..
   *        If can not transform, `out` will not be modified but return `false`.
   * @param {HTMLElement} elFrom The `[inX, inY]` is based on elFrom.
   * @param {HTMLElement} elTarget The `out` is based on elTarget.
   * @param {number} inX
   * @param {number} inY
   * @return {boolean} Whether transform successfully.
   */

  function transformLocalCoord(out, elFrom, elTarget, inX, inY) {
    return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1]);
  }
  /**
   * Transform between a "viewport coord" and a "local coord".
   * "viewport coord": the coord based on the left-top corner of the viewport
   *     of the browser.
   * "local coord": the coord based on the input `el`. The origin point is at
   *     the position of "left: 0; top: 0;" in the `el`.
   *
   * Support the case when CSS transform is used on el.
   *
   * @param {Array.<number>} out [inX: number, inY: number] The output. If `inverse: false`,
   *        it represents "local coord", otherwise "vireport coord".
   *        If can not transform, `out` will not be modified but return `false`.
   * @param {HTMLElement} el The "local coord" is based on the `el`, see comment above.
   * @param {number} inX If `inverse: false`,
   *        it represents "vireport coord", otherwise "local coord".
   * @param {number} inY If `inverse: false`,
   *        it represents "vireport coord", otherwise "local coord".
   * @param {boolean} [inverse=false]
   *        `true`: from "viewport coord" to "local coord".
   *        `false`: from "local coord" to "viewport coord".
   * @return {boolean} Whether transform successfully.
   */


  function transformCoordWithViewport(out, el, inX, inY, inverse) {
    if (el.getBoundingClientRect && env_1.domSupported && !isCanvasEl(el)) {
      var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
      var markers = prepareCoordMarkers(el, saved);
      var transformer = preparePointerTransformer(markers, saved, inverse);

      if (transformer) {
        transformer(out, inX, inY);
        return true;
      }
    }

    return false;
  }

  function prepareCoordMarkers(el, saved) {
    var markers = saved.markers;

    if (markers) {
      return markers;
    }

    markers = saved.markers = [];
    var propLR = ['left', 'right'];
    var propTB = ['top', 'bottom'];

    for (var i = 0; i < 4; i++) {
      var marker = document.createElement('div');
      var stl = marker.style;
      var idxLR = i % 2;
      var idxTB = (i >> 1) % 2;
      stl.cssText = ['position: absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'user-select: none', 'width:0', 'height:0', // 'width: 5px',
      // 'height: 5px',
      propLR[idxLR] + ':0', propTB[idxTB] + ':0', propLR[1 - idxLR] + ':auto', propTB[1 - idxTB] + ':auto', ''].join('!important;');
      el.appendChild(marker);
      markers.push(marker);
    }

    return markers;
  }

  function preparePointerTransformer(markers, saved, inverse) {
    var transformerName = inverse ? 'invTrans' : 'trans';
    var transformer = saved[transformerName];
    var oldSrcCoords = saved.srcCoords;
    var oldCoordTheSame = true;
    var srcCoords = [];
    var destCoords = [];

    for (var i = 0; i < 4; i++) {
      var rect = markers[i].getBoundingClientRect();
      var ii = 2 * i;
      var x = rect.left;
      var y = rect.top;
      srcCoords.push(x, y);
      oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
      destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
    } // Cache to avoid time consuming of `buildTransformer`.


    return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer$1(destCoords, srcCoords) : buildTransformer$1(srcCoords, destCoords));
  }

  function isCanvasEl(el) {
    return el.nodeName.toUpperCase() === 'CANVAS';
  }

  var transformLocalCoord_1 = transformLocalCoord;
  var transformCoordWithViewport_1 = transformCoordWithViewport;
  var isCanvasEl_1 = isCanvasEl;

  var dom = {
  	transformLocalCoord: transformLocalCoord_1,
  	transformCoordWithViewport: transformCoordWithViewport_1,
  	isCanvasEl: isCanvasEl_1
  };

  var Dispatcher = Eventful_1;





  var isCanvasEl$1 = dom.isCanvasEl;
  var transformCoordWithViewport$1 = dom.transformCoordWithViewport;

  /**
   * Utilities for mouse or touch events.
   */
  var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
  var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
  var _calcOut$1 = [];
  /**
   * Get the `zrX` and `zrY`, which are relative to the top-left of
   * the input `el`.
   * CSS transform (2D & 3D) is supported.
   *
   * The strategy to fetch the coords:
   * + If `calculate` is not set as `true`, users of this method should
   * ensure that `el` is the same or the same size & location as `e.target`.
   * Otherwise the result coords are probably not expected. Because we
   * firstly try to get coords from e.offsetX/e.offsetY.
   * + If `calculate` is set as `true`, the input `el` can be any element
   * and we force to calculate the coords based on `el`.
   * + The input `el` should be positionable (not position:static).
   *
   * The force `calculate` can be used in case like:
   * When mousemove event triggered on ec tooltip, `e.target` is not `el`(zr painter.dom).
   *
   * @param {HTMLElement} el DOM element.
   * @param {Event} e Mouse event or touch event.
   * @param {Object} out Get `out.zrX` and `out.zrY` as the result.
   * @param {boolean} [calculate=false] Whether to force calculate
   *        the coordinates but not use ones provided by browser.
   */

  function clientToLocal(el, e, out, calculate) {
    out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
    // to the padding edge of the target element. The only browser using this convention
    // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
    // not support the properties.
    // (see http://www.jacklmoore.com/notes/mouse-position/)
    // In zr painter.dom, padding edge equals to border edge.

    if (calculate || !env_1.canvasSupported) {
      calculateZrXY(el, e, out);
    } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
    // ancestor element, so we should make sure el is positioned (e.g., not position:static).
    // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
    // zoom-factor, overflow / opacity layers, transforms ...)
    // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
    // <https://bugs.jquery.com/ticket/8523#comment:14>
    // BTW3, In ff, offsetX/offsetY is always 0.
    else if (env_1.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
        out.zrX = e.layerX;
        out.zrY = e.layerY;
      } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
      else if (e.offsetX != null) {
          out.zrX = e.offsetX;
          out.zrY = e.offsetY;
        } // For some other device, e.g., IOS safari.
        else {
            calculateZrXY(el, e, out);
          }

    return out;
  }

  function calculateZrXY(el, e, out) {
    // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect.
    if (env_1.domSupported && el.getBoundingClientRect) {
      var ex = e.clientX;
      var ey = e.clientY;

      if (isCanvasEl$1(el)) {
        // Original approach, which do not support CSS transform.
        // marker can not be locationed in a canvas container
        // (getBoundingClientRect is always 0). We do not support
        // that input a pre-created canvas to zr while using css
        // transform in iOS.
        var box = el.getBoundingClientRect();
        out.zrX = ex - box.left;
        out.zrY = ey - box.top;
        return;
      } else {
        if (transformCoordWithViewport$1(_calcOut$1, el, ex, ey)) {
          out.zrX = _calcOut$1[0];
          out.zrY = _calcOut$1[1];
          return;
        }
      }
    }

    out.zrX = out.zrY = 0;
  }
  /**
   * Find native event compat for legency IE.
   * Should be called at the begining of a native event listener.
   *
   * @param {Event} [e] Mouse event or touch event or pointer event.
   *        For lagency IE, we use `window.event` is used.
   * @return {Event} The native event.
   */


  function getNativeEvent(e) {
    return e || window.event;
  }
  /**
   * Normalize the coordinates of the input event.
   *
   * Get the `e.zrX` and `e.zrY`, which are relative to the top-left of
   * the input `el`.
   * Get `e.zrDelta` if using mouse wheel.
   * Get `e.which`, see the comment inside this function.
   *
   * Do not calculate repeatly if `zrX` and `zrY` already exist.
   *
   * Notice: see comments in `clientToLocal`. check the relationship
   * between the result coords and the parameters `el` and `calculate`.
   *
   * @param {HTMLElement} el DOM element.
   * @param {Event} [e] See `getNativeEvent`.
   * @param {boolean} [calculate=false] Whether to force calculate
   *        the coordinates but not use ones provided by browser.
   * @return {UIEvent} The normalized native UIEvent.
   */


  function normalizeEvent(el, e, calculate) {
    e = getNativeEvent(e);

    if (e.zrX != null) {
      return e;
    }

    var eventType = e.type;
    var isTouch = eventType && eventType.indexOf('touch') >= 0;

    if (!isTouch) {
      clientToLocal(el, e, e, calculate);
      e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
    } else {
      var touch = eventType !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
      touch && clientToLocal(el, touch, e, calculate);
    } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
    // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
    // If e.which has been defined, it may be readonly,
    // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which


    var button = e.button;

    if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
      e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
    } // [Caution]: `e.which` from browser is not always reliable. For example,
    // when press left button and `mousemove (pointermove)` in Edge, the `e.which`
    // is 65536 and the `e.button` is -1. But the `mouseup (pointerup)` and
    // `mousedown (pointerdown)` is the same as Chrome does.


    return e;
  }
  /**
   * @param {HTMLElement} el
   * @param {string} name
   * @param {Function} handler
   * @param {Object|boolean} opt If boolean, means `opt.capture`
   * @param {boolean} [opt.capture=false]
   * @param {boolean} [opt.passive=false]
   */


  function addEventListener(el, name, handler, opt) {
    if (isDomLevel2) {
      // Reproduct the console warning:
      // [Violation] Added non-passive event listener to a scroll-blocking <some> event.
      // Consider marking event handler as 'passive' to make the page more responsive.
      // Just set console log level: verbose in chrome dev tool.
      // then the warning log will be printed when addEventListener called.
      // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
      // We have not yet found a neat way to using passive. Because in zrender the dom event
      // listener delegate all of the upper events of element. Some of those events need
      // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.
      // Before passive can be adopted, these issues should be considered:
      // (1) Whether and how a zrender user specifies an event listener passive. And by default,
      // passive or not.
      // (2) How to tread that some zrender event listener is passive, and some is not. If
      // we use other way but not preventDefault of mousewheel and touchmove, browser
      // compatibility should be handled.
      // var opts = (env.passiveSupported && name === 'mousewheel')
      //     ? {passive: true}
      //     // By default, the third param of el.addEventListener is `capture: false`.
      //     : void 0;
      // el.addEventListener(name, handler /* , opts */);
      el.addEventListener(name, handler, opt);
    } else {
      // For simplicity, do not implement `setCapture` for IE9-.
      el.attachEvent('on' + name, handler);
    }
  }
  /**
   * Parameter are the same as `addEventListener`.
   *
   * Notice that if a listener is registered twice, one with capture and one without,
   * remove each one separately. Removal of a capturing listener does not affect a
   * non-capturing version of the same listener, and vice versa.
   */


  function removeEventListener(el, name, handler, opt) {
    if (isDomLevel2) {
      el.removeEventListener(name, handler, opt);
    } else {
      el.detachEvent('on' + name, handler);
    }
  }
  /**
   * preventDefault and stopPropagation.
   * Notice: do not use this method in zrender. It can only be
   * used by upper applications if necessary.
   *
   * @param {Event} e A mouse or touch event.
   */


  var stop = isDomLevel2 ? function (e) {
    e.preventDefault();
    e.stopPropagation();
    e.cancelBubble = true;
  } : function (e) {
    e.returnValue = false;
    e.cancelBubble = true;
  };
  /**
   * This method only works for mouseup and mousedown. The functionality is restricted
   * for fault tolerance, See the `e.which` compatibility above.
   *
   * @param {MouseEvent} e
   * @return {boolean}
   */

  function isMiddleOrRightButtonOnMouseUpDown(e) {
    return e.which === 2 || e.which === 3;
  }
  /**
   * To be removed.
   * @deprecated
   */


  function notLeftMouse(e) {
    // If e.which is undefined, considered as left mouse event.
    return e.which > 1;
  } // For backward compatibility


  var clientToLocal_1 = clientToLocal;
  var getNativeEvent_1 = getNativeEvent;
  var normalizeEvent_1 = normalizeEvent;
  var addEventListener_1 = addEventListener;
  var removeEventListener_1 = removeEventListener;
  var stop_1 = stop;
  var isMiddleOrRightButtonOnMouseUpDown_1 = isMiddleOrRightButtonOnMouseUpDown;
  var notLeftMouse_1 = notLeftMouse;

  var event = {
  	Dispatcher: Dispatcher,
  	clientToLocal: clientToLocal_1,
  	getNativeEvent: getNativeEvent_1,
  	normalizeEvent: normalizeEvent_1,
  	addEventListener: addEventListener_1,
  	removeEventListener: removeEventListener_1,
  	stop: stop_1,
  	isMiddleOrRightButtonOnMouseUpDown: isMiddleOrRightButtonOnMouseUpDown_1,
  	notLeftMouse: notLeftMouse_1
  };

  /**
   * Only implements needed gestures for mobile.
   */
  var GestureMgr = function () {
    /**
     * @private
     * @type {Array.<Object>}
     */
    this._track = [];
  };

  GestureMgr.prototype = {
    constructor: GestureMgr,
    recognize: function (event, target, root) {
      this._doTrack(event, target, root);

      return this._recognize(event);
    },
    clear: function () {
      this._track.length = 0;
      return this;
    },
    _doTrack: function (event$1, target, root) {
      var touches = event$1.touches;

      if (!touches) {
        return;
      }

      var trackItem = {
        points: [],
        touches: [],
        target: target,
        event: event$1
      };

      for (var i = 0, len = touches.length; i < len; i++) {
        var touch = touches[i];
        var pos = event.clientToLocal(root, touch, {});
        trackItem.points.push([pos.zrX, pos.zrY]);
        trackItem.touches.push(touch);
      }

      this._track.push(trackItem);
    },
    _recognize: function (event) {
      for (var eventName in recognizers) {
        if (recognizers.hasOwnProperty(eventName)) {
          var gestureInfo = recognizers[eventName](this._track, event);

          if (gestureInfo) {
            return gestureInfo;
          }
        }
      }
    }
  };

  function dist$1(pointPair) {
    var dx = pointPair[1][0] - pointPair[0][0];
    var dy = pointPair[1][1] - pointPair[0][1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  function center(pointPair) {
    return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
  }

  var recognizers = {
    pinch: function (track, event) {
      var trackLen = track.length;

      if (!trackLen) {
        return;
      }

      var pinchEnd = (track[trackLen - 1] || {}).points;
      var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;

      if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
        var pinchScale = dist$1(pinchEnd) / dist$1(pinchPre);
        !isFinite(pinchScale) && (pinchScale = 1);
        event.pinchScale = pinchScale;
        var pinchCenter = center(pinchEnd);
        event.pinchX = pinchCenter[0];
        event.pinchY = pinchCenter[1];
        return {
          type: 'pinch',
          target: track[0].target,
          event: event
        };
      }
    } // Only pinch currently.

  };
  var _default$4 = GestureMgr;
  var GestureMgr_1 = _default$4;

  /**
   * [The interface between `Handler` and `HandlerProxy`]:
   *
   * The default `HandlerProxy` only support the common standard web environment
   * (e.g., standalone browser, headless browser, embed browser in mobild APP, ...).
   * But `HandlerProxy` can be replaced to support more non-standard environment
   * (e.g., mini app), or to support more feature that the default `HandlerProxy`
   * not provided (like echarts-gl did).
   * So the interface between `Handler` and `HandlerProxy` should be stable. Do not
   * make break changes util inevitable. The interface include the public methods
   * of `Handler` and the events listed in `handlerNames` below, by which `HandlerProxy`
   * drives `Handler`.
   */

  /**
   * [Drag outside]:
   *
   * That is, triggering `mousemove` and `mouseup` event when the pointer is out of the
   * zrender area when dragging. That is important for the improvement of the user experience
   * when dragging something near the boundary without being terminated unexpectedly.
   *
   * We originally consider to introduce new events like `pagemovemove` and `pagemouseup`
   * to resolve this issue. But some drawbacks of it is described in
   * https://github.com/ecomfe/zrender/pull/536#issuecomment-560286899
   *
   * Instead, we referenced the specifications:
   * https://www.w3.org/TR/touch-events/#the-touchmove-event
   * https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-mousemove
   * where the the mousemove/touchmove can be continue to fire if the user began a drag
   * operation and the pointer has left the boundary. (for the mouse event, browsers
   * only do it on `document` and when the pointer has left the boundary of the browser.)
   *
   * So the default `HandlerProxy` supports this feature similarly: if it is in the dragging
   * state (see `pointerCapture` in `HandlerProxy`), the `mousemove` and `mouseup` continue
   * to fire until release the pointer. That is implemented by listen to those event on
   * `document`.
   * If we implement some other `HandlerProxy` only for touch device, that would be easier.
   * The touch event support this feature by default.
   *
   * Note:
   * There might be some cases that the mouse event can not be
   * received on `document`. For example,
   * (A) `useCapture` is not supported and some user defined event listeners on the ancestor
   * of zr dom throw Error .
   * (B) `useCapture` is not supported Some user defined event listeners on the ancestor of
   * zr dom call `stopPropagation`.
   * In these cases, the `mousemove` event might be keep triggered event
   * if the mouse is released. We try to reduce the side-effect in those cases.
   * That is, do nothing (especially, `findHover`) in those cases. See `isOutsideBoundary`.
   *
   * Note:
   * If `HandlerProxy` listens to `document` with `useCapture`, `HandlerProxy` needs to
   * make sure `stopPropagation` and `preventDefault` doing nothing if and only if the event
   * target is not zrender dom. Becuase it is dangerous to enable users to call them in
   * `document` capture phase to prevent the propagation to any listener of the webpage.
   * But they are needed to work when the pointer inside the zrender dom.
   */
  var SILENT = 'silent';

  function makeEventPacket(eveType, targetInfo, event) {
    return {
      type: eveType,
      event: event,
      // target can only be an element that is not silent.
      target: targetInfo.target,
      // topTarget can be a silent element.
      topTarget: targetInfo.topTarget,
      cancelBubble: false,
      offsetX: event.zrX,
      offsetY: event.zrY,
      gestureEvent: event.gestureEvent,
      pinchX: event.pinchX,
      pinchY: event.pinchY,
      pinchScale: event.pinchScale,
      wheelDelta: event.zrDelta,
      zrByTouch: event.zrByTouch,
      which: event.which,
      stop: stopEvent
    };
  }

  function stopEvent() {
    event.stop(this.event);
  }

  function EmptyProxy() {}

  EmptyProxy.prototype.dispose = function () {};

  var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
  /**
   * @alias module:zrender/Handler
   * @constructor
   * @extends module:zrender/mixin/Eventful
   * @param {module:zrender/Storage} storage Storage instance.
   * @param {module:zrender/Painter} painter Painter instance.
   * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
   * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
   */

  var Handler = function (storage, painter, proxy, painterRoot) {
    Eventful_1.call(this);
    this.storage = storage;
    this.painter = painter;
    this.painterRoot = painterRoot;
    proxy = proxy || new EmptyProxy();
    /**
     * Proxy of event. can be Dom, WebGLSurface, etc.
     */

    this.proxy = null;
    /**
     * {target, topTarget, x, y}
     * @private
     * @type {Object}
     */

    this._hovered = {};
    /**
     * @private
     * @type {Date}
     */

    this._lastTouchMoment;
    /**
     * @private
     * @type {number}
     */

    this._lastX;
    /**
     * @private
     * @type {number}
     */

    this._lastY;
    /**
     * @private
     * @type {module:zrender/core/GestureMgr}
     */

    this._gestureMgr;
    Draggable_1.call(this);
    this.setHandlerProxy(proxy);
  };

  Handler.prototype = {
    constructor: Handler,
    setHandlerProxy: function (proxy) {
      if (this.proxy) {
        this.proxy.dispose();
      }

      if (proxy) {
        util.each(handlerNames, function (name) {
          proxy.on && proxy.on(name, this[name], this);
        }, this); // Attach handler

        proxy.handler = this;
      }

      this.proxy = proxy;
    },
    mousemove: function (event) {
      var x = event.zrX;
      var y = event.zrY;
      var isOutside = isOutsideBoundary(this, x, y);
      var lastHovered = this._hovered;
      var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
      // (like 'setOption' or 'dispatchAction') in event handlers, we should find
      // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
      // See #6198.

      if (lastHoveredTarget && !lastHoveredTarget.__zr) {
        lastHovered = this.findHover(lastHovered.x, lastHovered.y);
        lastHoveredTarget = lastHovered.target;
      }

      var hovered = this._hovered = isOutside ? {
        x: x,
        y: y
      } : this.findHover(x, y);
      var hoveredTarget = hovered.target;
      var proxy = this.proxy;
      proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element

      if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
        this.dispatchToElement(lastHovered, 'mouseout', event);
      } // Mouse moving on one element


      this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element

      if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
        this.dispatchToElement(hovered, 'mouseover', event);
      }
    },
    mouseout: function (event) {
      var eventControl = event.zrEventControl;
      var zrIsToLocalDOM = event.zrIsToLocalDOM;

      if (eventControl !== 'only_globalout') {
        this.dispatchToElement(this._hovered, 'mouseout', event);
      }

      if (eventControl !== 'no_globalout') {
        // FIXME: if the pointer moving from the extra doms to realy "outside",
        // the `globalout` should have been triggered. But currently not.
        !zrIsToLocalDOM && this.trigger('globalout', {
          type: 'globalout',
          event: event
        });
      }
    },

    /**
     * Resize
     */
    resize: function (event) {
      this._hovered = {};
    },

    /**
     * Dispatch event
     * @param {string} eventName
     * @param {event=} eventArgs
     */
    dispatch: function (eventName, eventArgs) {
      var handler = this[eventName];
      handler && handler.call(this, eventArgs);
    },

    /**
     * Dispose
     */
    dispose: function () {
      this.proxy.dispose();
      this.storage = this.proxy = this.painter = null;
    },

    /**
     * è®¾ç½®é»è®¤çcursor style
     * @param {string} [cursorStyle='default'] ä¾å¦ crosshair
     */
    setCursorStyle: function (cursorStyle) {
      var proxy = this.proxy;
      proxy.setCursor && proxy.setCursor(cursorStyle);
    },

    /**
     * äºä»¶ååä»£ç
     *
     * @private
     * @param {Object} targetInfo {target, topTarget} ç®æ å¾å½¢åç´ 
     * @param {string} eventName äºä»¶åç§°
     * @param {Object} event äºä»¶å¯¹è±¡
     */
    dispatchToElement: function (targetInfo, eventName, event) {
      targetInfo = targetInfo || {};
      var el = targetInfo.target;

      if (el && el.silent) {
        return;
      }

      var eventHandler = 'on' + eventName;
      var eventPacket = makeEventPacket(eventName, targetInfo, event);

      while (el) {
        el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
        el.trigger(eventName, eventPacket);
        el = el.parent;

        if (eventPacket.cancelBubble) {
          break;
        }
      }

      if (!eventPacket.cancelBubble) {
        // åæ³¡å°é¡¶çº§ zrender å¯¹è±¡
        this.trigger(eventName, eventPacket); // ååäºä»¶å°ç¨æ·èªå®ä¹å±
        // ç¨æ·æå¯è½å¨å¨å± click äºä»¶ä¸­ disposeï¼æä»¥éè¦å¤æ­ä¸ painter æ¯å¦å­å¨

        this.painter && this.painter.eachOtherLayer(function (layer) {
          if (typeof layer[eventHandler] === 'function') {
            layer[eventHandler].call(layer, eventPacket);
          }

          if (layer.trigger) {
            layer.trigger(eventName, eventPacket);
          }
        });
      }
    },

    /**
     * @private
     * @param {number} x
     * @param {number} y
     * @param {module:zrender/graphic/Displayable} exclude
     * @return {model:zrender/Element}
     * @method
     */
    findHover: function (x, y, exclude) {
      var list = this.storage.getDisplayList();
      var out = {
        x: x,
        y: y
      };

      for (var i = list.length - 1; i >= 0; i--) {
        var hoverCheckResult;

        if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
        && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
          !out.topTarget && (out.topTarget = list[i]);

          if (hoverCheckResult !== SILENT) {
            out.target = list[i];
            break;
          }
        }
      }

      return out;
    },
    processGesture: function (event, stage) {
      if (!this._gestureMgr) {
        this._gestureMgr = new GestureMgr_1();
      }

      var gestureMgr = this._gestureMgr;
      stage === 'start' && gestureMgr.clear();
      var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
      stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.

      if (gestureInfo) {
        var type = gestureInfo.type;
        event.gestureEvent = type;
        this.dispatchToElement({
          target: gestureInfo.target
        }, type, gestureInfo.event);
      }
    }
  }; // Common handlers

  util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
    Handler.prototype[name] = function (event) {
      var x = event.zrX;
      var y = event.zrY;
      var isOutside = isOutsideBoundary(this, x, y);
      var hovered;
      var hoveredTarget;

      if (name !== 'mouseup' || !isOutside) {
        // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
        hovered = this.findHover(x, y);
        hoveredTarget = hovered.target;
      }

      if (name === 'mousedown') {
        this._downEl = hoveredTarget;
        this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup

        this._upEl = hoveredTarget;
      } else if (name === 'mouseup') {
        this._upEl = hoveredTarget;
      } else if (name === 'click') {
        if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
        // including the case that `mousedown` - `mousemove` - `mouseup`,
        // which should be filtered, otherwise it will bring trouble to
        // pan and zoom.
        || !this._downPoint // Arbitrary value
        || vector.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
          return;
        }

        this._downPoint = null;
      }

      this.dispatchToElement(hovered, name, event);
    };
  });

  function isHover(displayable, x, y) {
    if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
      var el = displayable;
      var isSilent;

      while (el) {
        // If clipped by ancestor.
        // FIXME: If clipPath has neither stroke nor fill,
        // el.clipPath.contain(x, y) will always return false.
        if (el.clipPath && !el.clipPath.contain(x, y)) {
          return false;
        }

        if (el.silent) {
          isSilent = true;
        }

        el = el.parent;
      }

      return isSilent ? SILENT : true;
    }

    return false;
  }
  /**
   * See [Drag outside].
   */


  function isOutsideBoundary(handlerInstance, x, y) {
    var painter = handlerInstance.painter;
    return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
  }

  util.mixin(Handler, Eventful_1);
  util.mixin(Handler, Draggable_1);
  var _default$5 = Handler;
  var Handler_1 = _default$5;

  /**
   * 3x2ç©éµæä½ç±»
   * @exports zrender/tool/matrix
   */

  /* global Float32Array */
  var ArrayCtor$1 = typeof Float32Array === 'undefined' ? Array : Float32Array;
  /**
   * Create a identity matrix.
   * @return {Float32Array|Array.<number>}
   */

  function create$1() {
    var out = new ArrayCtor$1(6);
    identity(out);
    return out;
  }
  /**
   * è®¾ç½®ç©éµä¸ºåä½ç©éµ
   * @param {Float32Array|Array.<number>} out
   */


  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
  }
  /**
   * å¤å¶ç©éµ
   * @param {Float32Array|Array.<number>} out
   * @param {Float32Array|Array.<number>} m
   */


  function copy$1(out, m) {
    out[0] = m[0];
    out[1] = m[1];
    out[2] = m[2];
    out[3] = m[3];
    out[4] = m[4];
    out[5] = m[5];
    return out;
  }
  /**
   * ç©éµç¸ä¹
   * @param {Float32Array|Array.<number>} out
   * @param {Float32Array|Array.<number>} m1
   * @param {Float32Array|Array.<number>} m2
   */


  function mul$1(out, m1, m2) {
    // Consider matrix.mul(m, m2, m);
    // where out is the same as m2.
    // So use temp variable to escape error.
    var out0 = m1[0] * m2[0] + m1[2] * m2[1];
    var out1 = m1[1] * m2[0] + m1[3] * m2[1];
    var out2 = m1[0] * m2[2] + m1[2] * m2[3];
    var out3 = m1[1] * m2[2] + m1[3] * m2[3];
    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = out3;
    out[4] = out4;
    out[5] = out5;
    return out;
  }
  /**
   * å¹³ç§»åæ¢
   * @param {Float32Array|Array.<number>} out
   * @param {Float32Array|Array.<number>} a
   * @param {Float32Array|Array.<number>} v
   */


  function translate(out, a, v) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4] + v[0];
    out[5] = a[5] + v[1];
    return out;
  }
  /**
   * æè½¬åæ¢
   * @param {Float32Array|Array.<number>} out
   * @param {Float32Array|Array.<number>} a
   * @param {number} rad
   */


  function rotate(out, a, rad) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var st = Math.sin(rad);
    var ct = Math.cos(rad);
    out[0] = aa * ct + ab * st;
    out[1] = -aa * st + ab * ct;
    out[2] = ac * ct + ad * st;
    out[3] = -ac * st + ct * ad;
    out[4] = ct * atx + st * aty;
    out[5] = ct * aty - st * atx;
    return out;
  }
  /**
   * ç¼©æ¾åæ¢
   * @param {Float32Array|Array.<number>} out
   * @param {Float32Array|Array.<number>} a
   * @param {Float32Array|Array.<number>} v
   */


  function scale$1(out, a, v) {
    var vx = v[0];
    var vy = v[1];
    out[0] = a[0] * vx;
    out[1] = a[1] * vy;
    out[2] = a[2] * vx;
    out[3] = a[3] * vy;
    out[4] = a[4] * vx;
    out[5] = a[5] * vy;
    return out;
  }
  /**
   * æ±éç©éµ
   * @param {Float32Array|Array.<number>} out
   * @param {Float32Array|Array.<number>} a
   */


  function invert(out, a) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var det = aa * ad - ab * ac;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
  }
  /**
   * Clone a new matrix.
   * @param {Float32Array|Array.<number>} a
   */


  function clone$3(a) {
    var b = create$1();
    copy$1(b, a);
    return b;
  }

  var create_1$1 = create$1;
  var identity_1 = identity;
  var copy_1$1 = copy$1;
  var mul_1$1 = mul$1;
  var translate_1 = translate;
  var rotate_1 = rotate;
  var scale_1$1 = scale$1;
  var invert_1 = invert;
  var clone_1$2 = clone$3;

  var matrix = {
  	create: create_1$1,
  	identity: identity_1,
  	copy: copy_1$1,
  	mul: mul_1$1,
  	translate: translate_1,
  	rotate: rotate_1,
  	scale: scale_1$1,
  	invert: invert_1,
  	clone: clone_1$2
  };

  /**
   * æä¾åæ¢æ©å±
   * @module zrender/mixin/Transformable
   * @author pissang (https://www.github.com/pissang)
   */
  var mIdentity = matrix.identity;
  var EPSILON = 5e-5;

  function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
  }
  /**
   * @alias module:zrender/mixin/Transformable
   * @constructor
   */


  var Transformable = function (opts) {
    opts = opts || {}; // If there are no given position, rotation, scale

    if (!opts.position) {
      /**
       * å¹³ç§»
       * @type {Array.<number>}
       * @default [0, 0]
       */
      this.position = [0, 0];
    }

    if (opts.rotation == null) {
      /**
       * æè½¬
       * @type {Array.<number>}
       * @default 0
       */
      this.rotation = 0;
    }

    if (!opts.scale) {
      /**
       * ç¼©æ¾
       * @type {Array.<number>}
       * @default [1, 1]
       */
      this.scale = [1, 1];
    }
    /**
     * æè½¬åç¼©æ¾çåç¹
     * @type {Array.<number>}
     * @default null
     */


    this.origin = this.origin || null;
  };

  var transformableProto = Transformable.prototype;
  transformableProto.transform = null;
  /**
   * å¤æ­æ¯å¦éè¦æåæ åæ¢
   * å¦ææåæ åæ¢, åä»position, rotation, scaleä»¥åç¶èç¹çtransformè®¡ç®åºèªèº«çtransformç©éµ
   */

  transformableProto.needLocalTransform = function () {
    return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
  };

  var scaleTmp = [];

  transformableProto.updateTransform = function () {
    var parent = this.parent;
    var parentHasTransform = parent && parent.transform;
    var needLocalTransform = this.needLocalTransform();
    var m = this.transform;

    if (!(needLocalTransform || parentHasTransform)) {
      m && mIdentity(m);
      return;
    }

    m = m || matrix.create();

    if (needLocalTransform) {
      this.getLocalTransform(m);
    } else {
      mIdentity(m);
    } // åºç¨ç¶èç¹åæ¢


    if (parentHasTransform) {
      if (needLocalTransform) {
        matrix.mul(m, parent.transform, m);
      } else {
        matrix.copy(m, parent.transform);
      }
    } // ä¿å­è¿ä¸ªåæ¢ç©éµ


    this.transform = m;
    var globalScaleRatio = this.globalScaleRatio;

    if (globalScaleRatio != null && globalScaleRatio !== 1) {
      this.getGlobalScale(scaleTmp);
      var relX = scaleTmp[0] < 0 ? -1 : 1;
      var relY = scaleTmp[1] < 0 ? -1 : 1;
      var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
      var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
      m[0] *= sx;
      m[1] *= sx;
      m[2] *= sy;
      m[3] *= sy;
    }

    this.invTransform = this.invTransform || matrix.create();
    matrix.invert(this.invTransform, m);
  };

  transformableProto.getLocalTransform = function (m) {
    return Transformable.getLocalTransform(this, m);
  };
  /**
   * å°èªå·±çtransformåºç¨å°contextä¸
   * @param {CanvasRenderingContext2D} ctx
   */


  transformableProto.setTransform = function (ctx) {
    var m = this.transform;
    var dpr = ctx.dpr || 1;

    if (m) {
      ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
    } else {
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  };

  transformableProto.restoreTransform = function (ctx) {
    var dpr = ctx.dpr || 1;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  };

  var tmpTransform = [];
  var originTransform = matrix.create();

  transformableProto.setLocalTransform = function (m) {
    if (!m) {
      // TODO return or set identity?
      return;
    }

    var sx = m[0] * m[0] + m[1] * m[1];
    var sy = m[2] * m[2] + m[3] * m[3];
    var position = this.position;
    var scale = this.scale;

    if (isNotAroundZero(sx - 1)) {
      sx = Math.sqrt(sx);
    }

    if (isNotAroundZero(sy - 1)) {
      sy = Math.sqrt(sy);
    }

    if (m[0] < 0) {
      sx = -sx;
    }

    if (m[3] < 0) {
      sy = -sy;
    }

    position[0] = m[4];
    position[1] = m[5];
    scale[0] = sx;
    scale[1] = sy;
    this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
  };
  /**
   * åè§£`transform`ç©éµå°`position`, `rotation`, `scale`
   */


  transformableProto.decomposeTransform = function () {
    if (!this.transform) {
      return;
    }

    var parent = this.parent;
    var m = this.transform;

    if (parent && parent.transform) {
      // Get local transform and decompose them to position, scale, rotation
      matrix.mul(tmpTransform, parent.invTransform, m);
      m = tmpTransform;
    }

    var origin = this.origin;

    if (origin && (origin[0] || origin[1])) {
      originTransform[4] = origin[0];
      originTransform[5] = origin[1];
      matrix.mul(tmpTransform, m, originTransform);
      tmpTransform[4] -= origin[0];
      tmpTransform[5] -= origin[1];
      m = tmpTransform;
    }

    this.setLocalTransform(m);
  };
  /**
   * Get global scale
   * @return {Array.<number>}
   */


  transformableProto.getGlobalScale = function (out) {
    var m = this.transform;
    out = out || [];

    if (!m) {
      out[0] = 1;
      out[1] = 1;
      return out;
    }

    out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
    out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);

    if (m[0] < 0) {
      out[0] = -out[0];
    }

    if (m[3] < 0) {
      out[1] = -out[1];
    }

    return out;
  };
  /**
   * åæ¢åæ ä½ç½®å° shape çå±é¨åæ ç©ºé´
   * @method
   * @param {number} x
   * @param {number} y
   * @return {Array.<number>}
   */


  transformableProto.transformCoordToLocal = function (x, y) {
    var v2 = [x, y];
    var invTransform = this.invTransform;

    if (invTransform) {
      vector.applyTransform(v2, v2, invTransform);
    }

    return v2;
  };
  /**
   * åæ¢å±é¨åæ ä½ç½®å°å¨å±åæ ç©ºé´
   * @method
   * @param {number} x
   * @param {number} y
   * @return {Array.<number>}
   */


  transformableProto.transformCoordToGlobal = function (x, y) {
    var v2 = [x, y];
    var transform = this.transform;

    if (transform) {
      vector.applyTransform(v2, v2, transform);
    }

    return v2;
  };
  /**
   * @static
   * @param {Object} target
   * @param {Array.<number>} target.origin
   * @param {number} target.rotation
   * @param {Array.<number>} target.position
   * @param {Array.<number>} [m]
   */


  Transformable.getLocalTransform = function (target, m) {
    m = m || [];
    mIdentity(m);
    var origin = target.origin;
    var scale = target.scale || [1, 1];
    var rotation = target.rotation || 0;
    var position = target.position || [0, 0];

    if (origin) {
      // Translate to origin
      m[4] -= origin[0];
      m[5] -= origin[1];
    }

    matrix.scale(m, m, scale);

    if (rotation) {
      matrix.rotate(m, m, rotation);
    }

    if (origin) {
      // Translate back from origin
      m[4] += origin[0];
      m[5] += origin[1];
    }

    m[4] += position[0];
    m[5] += position[1];
    return m;
  };

  var _default$6 = Transformable;
  var Transformable_1 = _default$6;

  /**
   * ç¼å¨ä»£ç æ¥èª https://github.com/sole/tween.js/blob/master/src/Tween.js
   * @see http://sole.github.io/tween.js/examples/03_graphs.html
   * @exports zrender/animation/easing
   */
  var easing = {
    /**
    * @param {number} k
    * @return {number}
    */
    linear: function (k) {
      return k;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    quadraticIn: function (k) {
      return k * k;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    quadraticOut: function (k) {
      return k * (2 - k);
    },

    /**
    * @param {number} k
    * @return {number}
    */
    quadraticInOut: function (k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k;
      }

      return -0.5 * (--k * (k - 2) - 1);
    },
    // ä¸æ¬¡æ¹çç¼å¨ï¼t^3ï¼

    /**
    * @param {number} k
    * @return {number}
    */
    cubicIn: function (k) {
      return k * k * k;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    cubicOut: function (k) {
      return --k * k * k + 1;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    cubicInOut: function (k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k;
      }

      return 0.5 * ((k -= 2) * k * k + 2);
    },
    // åæ¬¡æ¹çç¼å¨ï¼t^4ï¼

    /**
    * @param {number} k
    * @return {number}
    */
    quarticIn: function (k) {
      return k * k * k * k;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    quarticOut: function (k) {
      return 1 - --k * k * k * k;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    quarticInOut: function (k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k;
      }

      return -0.5 * ((k -= 2) * k * k * k - 2);
    },
    // äºæ¬¡æ¹çç¼å¨ï¼t^5ï¼

    /**
    * @param {number} k
    * @return {number}
    */
    quinticIn: function (k) {
      return k * k * k * k * k;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    quinticOut: function (k) {
      return --k * k * k * k * k + 1;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    quinticInOut: function (k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k * k;
      }

      return 0.5 * ((k -= 2) * k * k * k * k + 2);
    },
    // æ­£å¼¦æ²çº¿çç¼å¨ï¼sin(t)ï¼

    /**
    * @param {number} k
    * @return {number}
    */
    sinusoidalIn: function (k) {
      return 1 - Math.cos(k * Math.PI / 2);
    },

    /**
    * @param {number} k
    * @return {number}
    */
    sinusoidalOut: function (k) {
      return Math.sin(k * Math.PI / 2);
    },

    /**
    * @param {number} k
    * @return {number}
    */
    sinusoidalInOut: function (k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    },
    // ææ°æ²çº¿çç¼å¨ï¼2^tï¼

    /**
    * @param {number} k
    * @return {number}
    */
    exponentialIn: function (k) {
      return k === 0 ? 0 : Math.pow(1024, k - 1);
    },

    /**
    * @param {number} k
    * @return {number}
    */
    exponentialOut: function (k) {
      return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },

    /**
    * @param {number} k
    * @return {number}
    */
    exponentialInOut: function (k) {
      if (k === 0) {
        return 0;
      }

      if (k === 1) {
        return 1;
      }

      if ((k *= 2) < 1) {
        return 0.5 * Math.pow(1024, k - 1);
      }

      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    },
    // åå½¢æ²çº¿çç¼å¨ï¼sqrt(1-t^2)ï¼

    /**
    * @param {number} k
    * @return {number}
    */
    circularIn: function (k) {
      return 1 - Math.sqrt(1 - k * k);
    },

    /**
    * @param {number} k
    * @return {number}
    */
    circularOut: function (k) {
      return Math.sqrt(1 - --k * k);
    },

    /**
    * @param {number} k
    * @return {number}
    */
    circularInOut: function (k) {
      if ((k *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - k * k) - 1);
      }

      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    },
    // åå»ºç±»ä¼¼äºå¼¹ç°§å¨åæ­¢åæ¥åæ¯è¡çå¨ç»

    /**
    * @param {number} k
    * @return {number}
    */
    elasticIn: function (k) {
      var s;
      var a = 0.1;
      var p = 0.4;

      if (k === 0) {
        return 0;
      }

      if (k === 1) {
        return 1;
      }

      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }

      return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    },

    /**
    * @param {number} k
    * @return {number}
    */
    elasticOut: function (k) {
      var s;
      var a = 0.1;
      var p = 0.4;

      if (k === 0) {
        return 0;
      }

      if (k === 1) {
        return 1;
      }

      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }

      return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    elasticInOut: function (k) {
      var s;
      var a = 0.1;
      var p = 0.4;

      if (k === 0) {
        return 0;
      }

      if (k === 1) {
        return 1;
      }

      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }

      if ((k *= 2) < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      }

      return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
    },
    // å¨æä¸å¨ç»å¼å§æ²¿æç¤ºçè·¯å¾è¿è¡å¨ç»å¤çåç¨ç¨æ¶åè¯¥å¨ç»çç§»å¨

    /**
    * @param {number} k
    * @return {number}
    */
    backIn: function (k) {
      var s = 1.70158;
      return k * k * ((s + 1) * k - s);
    },

    /**
    * @param {number} k
    * @return {number}
    */
    backOut: function (k) {
      var s = 1.70158;
      return --k * k * ((s + 1) * k + s) + 1;
    },

    /**
    * @param {number} k
    * @return {number}
    */
    backInOut: function (k) {
      var s = 1.70158 * 1.525;

      if ((k *= 2) < 1) {
        return 0.5 * (k * k * ((s + 1) * k - s));
      }

      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    },
    // åå»ºå¼¹è·³ææ

    /**
    * @param {number} k
    * @return {number}
    */
    bounceIn: function (k) {
      return 1 - easing.bounceOut(1 - k);
    },

    /**
    * @param {number} k
    * @return {number}
    */
    bounceOut: function (k) {
      if (k < 1 / 2.75) {
        return 7.5625 * k * k;
      } else if (k < 2 / 2.75) {
        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
      } else if (k < 2.5 / 2.75) {
        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
      } else {
        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
      }
    },

    /**
    * @param {number} k
    * @return {number}
    */
    bounceInOut: function (k) {
      if (k < 0.5) {
        return easing.bounceIn(k * 2) * 0.5;
      }

      return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
    }
  };
  var _default$7 = easing;
  var easing_1 = _default$7;

  /**
   * å¨ç»ä¸»æ§å¶å¨
   * @config target å¨ç»å¯¹è±¡ï¼å¯ä»¥æ¯æ°ç»ï¼å¦ææ¯æ°ç»çè¯ä¼æ¹éååonframeç­äºä»¶
   * @config life(1000) å¨ç»æ¶é¿
   * @config delay(0) å¨ç»å»¶è¿æ¶é´
   * @config loop(true)
   * @config gap(0) å¾ªç¯çé´éæ¶é´
   * @config onframe
   * @config easing(optional)
   * @config ondestroy(optional)
   * @config onrestart(optional)
   *
   * TODO pause
   */
  function Clip(options) {
    this._target = options.target; // çå½å¨æ

    this._life = options.life || 1000; // å»¶æ¶

    this._delay = options.delay || 0; // å¼å§æ¶é´
    // this._startTime = new Date().getTime() + this._delay;// åä½æ¯«ç§

    this._initialized = false; // æ¯å¦å¾ªç¯

    this.loop = options.loop == null ? false : options.loop;
    this.gap = options.gap || 0;
    this.easing = options.easing || 'Linear';
    this.onframe = options.onframe;
    this.ondestroy = options.ondestroy;
    this.onrestart = options.onrestart;
    this._pausedTime = 0;
    this._paused = false;
  }

  Clip.prototype = {
    constructor: Clip,
    step: function (globalTime, deltaTime) {
      // Set startTime on first step, or _startTime may has milleseconds different between clips
      // PENDING
      if (!this._initialized) {
        this._startTime = globalTime + this._delay;
        this._initialized = true;
      }

      if (this._paused) {
        this._pausedTime += deltaTime;
        return;
      }

      var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // è¿æ²¡å¼å§

      if (percent < 0) {
        return;
      }

      percent = Math.min(percent, 1);
      var easing = this.easing;
      var easingFunc = typeof easing === 'string' ? easing_1[easing] : easing;
      var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
      this.fire('frame', schedule); // ç»æ

      if (percent === 1) {
        if (this.loop) {
          this.restart(globalTime); // éæ°å¼å§å¨æ
          // æåºèä¸æ¯ç´æ¥è°ç¨äºä»¶ç´å° stage.update ååç»ä¸è°ç¨è¿äºäºä»¶

          return 'restart';
        } // å¨ç»å®æå°è¿ä¸ªæ§å¶å¨æ è¯ä¸ºå¾å é¤
        // å¨Animation.updateä¸­è¿è¡æ¹éå é¤


        this._needsRemove = true;
        return 'destroy';
      }

      return null;
    },
    restart: function (globalTime) {
      var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
      this._startTime = globalTime - remainder + this.gap;
      this._pausedTime = 0;
      this._needsRemove = false;
    },
    fire: function (eventType, arg) {
      eventType = 'on' + eventType;

      if (this[eventType]) {
        this[eventType](this._target, arg);
      }
    },
    pause: function () {
      this._paused = true;
    },
    resume: function () {
      this._paused = false;
    }
  };
  var _default$8 = Clip;
  var Clip_1 = _default$8;

  // Simple LRU cache use doubly linked list
  // @module zrender/core/LRU

  /**
   * Simple double linked list. Compared with array, it has O(1) remove operation.
   * @constructor
   */
  var LinkedList = function () {
    /**
     * @type {module:zrender/core/LRU~Entry}
     */
    this.head = null;
    /**
     * @type {module:zrender/core/LRU~Entry}
     */

    this.tail = null;
    this._len = 0;
  };

  var linkedListProto = LinkedList.prototype;
  /**
   * Insert a new value at the tail
   * @param  {} val
   * @return {module:zrender/core/LRU~Entry}
   */

  linkedListProto.insert = function (val) {
    var entry = new Entry(val);
    this.insertEntry(entry);
    return entry;
  };
  /**
   * Insert an entry at the tail
   * @param  {module:zrender/core/LRU~Entry} entry
   */


  linkedListProto.insertEntry = function (entry) {
    if (!this.head) {
      this.head = this.tail = entry;
    } else {
      this.tail.next = entry;
      entry.prev = this.tail;
      entry.next = null;
      this.tail = entry;
    }

    this._len++;
  };
  /**
   * Remove entry.
   * @param  {module:zrender/core/LRU~Entry} entry
   */


  linkedListProto.remove = function (entry) {
    var prev = entry.prev;
    var next = entry.next;

    if (prev) {
      prev.next = next;
    } else {
      // Is head
      this.head = next;
    }

    if (next) {
      next.prev = prev;
    } else {
      // Is tail
      this.tail = prev;
    }

    entry.next = entry.prev = null;
    this._len--;
  };
  /**
   * @return {number}
   */


  linkedListProto.len = function () {
    return this._len;
  };
  /**
   * Clear list
   */


  linkedListProto.clear = function () {
    this.head = this.tail = null;
    this._len = 0;
  };
  /**
   * @constructor
   * @param {} val
   */


  var Entry = function (val) {
    /**
     * @type {}
     */
    this.value = val;
    /**
     * @type {module:zrender/core/LRU~Entry}
     */

    this.next;
    /**
     * @type {module:zrender/core/LRU~Entry}
     */

    this.prev;
  };
  /**
   * LRU Cache
   * @constructor
   * @alias module:zrender/core/LRU
   */


  var LRU = function (maxSize) {
    this._list = new LinkedList();
    this._map = {};
    this._maxSize = maxSize || 10;
    this._lastRemovedEntry = null;
  };

  var LRUProto = LRU.prototype;
  /**
   * @param  {string} key
   * @param  {} value
   * @return {} Removed value
   */

  LRUProto.put = function (key, value) {
    var list = this._list;
    var map = this._map;
    var removed = null;

    if (map[key] == null) {
      var len = list.len(); // Reuse last removed entry

      var entry = this._lastRemovedEntry;

      if (len >= this._maxSize && len > 0) {
        // Remove the least recently used
        var leastUsedEntry = list.head;
        list.remove(leastUsedEntry);
        delete map[leastUsedEntry.key];
        removed = leastUsedEntry.value;
        this._lastRemovedEntry = leastUsedEntry;
      }

      if (entry) {
        entry.value = value;
      } else {
        entry = new Entry(value);
      }

      entry.key = key;
      list.insertEntry(entry);
      map[key] = entry;
    }

    return removed;
  };
  /**
   * @param  {string} key
   * @return {}
   */


  LRUProto.get = function (key) {
    var entry = this._map[key];
    var list = this._list;

    if (entry != null) {
      // Put the latest used entry in the tail
      if (entry !== list.tail) {
        list.remove(entry);
        list.insertEntry(entry);
      }

      return entry.value;
    }
  };
  /**
   * Clear the cache
   */


  LRUProto.clear = function () {
    this._list.clear();

    this._map = {};
  };

  var _default$9 = LRU;
  var LRU_1 = _default$9;

  var kCSSColorTable = {
    'transparent': [0, 0, 0, 0],
    'aliceblue': [240, 248, 255, 1],
    'antiquewhite': [250, 235, 215, 1],
    'aqua': [0, 255, 255, 1],
    'aquamarine': [127, 255, 212, 1],
    'azure': [240, 255, 255, 1],
    'beige': [245, 245, 220, 1],
    'bisque': [255, 228, 196, 1],
    'black': [0, 0, 0, 1],
    'blanchedalmond': [255, 235, 205, 1],
    'blue': [0, 0, 255, 1],
    'blueviolet': [138, 43, 226, 1],
    'brown': [165, 42, 42, 1],
    'burlywood': [222, 184, 135, 1],
    'cadetblue': [95, 158, 160, 1],
    'chartreuse': [127, 255, 0, 1],
    'chocolate': [210, 105, 30, 1],
    'coral': [255, 127, 80, 1],
    'cornflowerblue': [100, 149, 237, 1],
    'cornsilk': [255, 248, 220, 1],
    'crimson': [220, 20, 60, 1],
    'cyan': [0, 255, 255, 1],
    'darkblue': [0, 0, 139, 1],
    'darkcyan': [0, 139, 139, 1],
    'darkgoldenrod': [184, 134, 11, 1],
    'darkgray': [169, 169, 169, 1],
    'darkgreen': [0, 100, 0, 1],
    'darkgrey': [169, 169, 169, 1],
    'darkkhaki': [189, 183, 107, 1],
    'darkmagenta': [139, 0, 139, 1],
    'darkolivegreen': [85, 107, 47, 1],
    'darkorange': [255, 140, 0, 1],
    'darkorchid': [153, 50, 204, 1],
    'darkred': [139, 0, 0, 1],
    'darksalmon': [233, 150, 122, 1],
    'darkseagreen': [143, 188, 143, 1],
    'darkslateblue': [72, 61, 139, 1],
    'darkslategray': [47, 79, 79, 1],
    'darkslategrey': [47, 79, 79, 1],
    'darkturquoise': [0, 206, 209, 1],
    'darkviolet': [148, 0, 211, 1],
    'deeppink': [255, 20, 147, 1],
    'deepskyblue': [0, 191, 255, 1],
    'dimgray': [105, 105, 105, 1],
    'dimgrey': [105, 105, 105, 1],
    'dodgerblue': [30, 144, 255, 1],
    'firebrick': [178, 34, 34, 1],
    'floralwhite': [255, 250, 240, 1],
    'forestgreen': [34, 139, 34, 1],
    'fuchsia': [255, 0, 255, 1],
    'gainsboro': [220, 220, 220, 1],
    'ghostwhite': [248, 248, 255, 1],
    'gold': [255, 215, 0, 1],
    'goldenrod': [218, 165, 32, 1],
    'gray': [128, 128, 128, 1],
    'green': [0, 128, 0, 1],
    'greenyellow': [173, 255, 47, 1],
    'grey': [128, 128, 128, 1],
    'honeydew': [240, 255, 240, 1],
    'hotpink': [255, 105, 180, 1],
    'indianred': [205, 92, 92, 1],
    'indigo': [75, 0, 130, 1],
    'ivory': [255, 255, 240, 1],
    'khaki': [240, 230, 140, 1],
    'lavender': [230, 230, 250, 1],
    'lavenderblush': [255, 240, 245, 1],
    'lawngreen': [124, 252, 0, 1],
    'lemonchiffon': [255, 250, 205, 1],
    'lightblue': [173, 216, 230, 1],
    'lightcoral': [240, 128, 128, 1],
    'lightcyan': [224, 255, 255, 1],
    'lightgoldenrodyellow': [250, 250, 210, 1],
    'lightgray': [211, 211, 211, 1],
    'lightgreen': [144, 238, 144, 1],
    'lightgrey': [211, 211, 211, 1],
    'lightpink': [255, 182, 193, 1],
    'lightsalmon': [255, 160, 122, 1],
    'lightseagreen': [32, 178, 170, 1],
    'lightskyblue': [135, 206, 250, 1],
    'lightslategray': [119, 136, 153, 1],
    'lightslategrey': [119, 136, 153, 1],
    'lightsteelblue': [176, 196, 222, 1],
    'lightyellow': [255, 255, 224, 1],
    'lime': [0, 255, 0, 1],
    'limegreen': [50, 205, 50, 1],
    'linen': [250, 240, 230, 1],
    'magenta': [255, 0, 255, 1],
    'maroon': [128, 0, 0, 1],
    'mediumaquamarine': [102, 205, 170, 1],
    'mediumblue': [0, 0, 205, 1],
    'mediumorchid': [186, 85, 211, 1],
    'mediumpurple': [147, 112, 219, 1],
    'mediumseagreen': [60, 179, 113, 1],
    'mediumslateblue': [123, 104, 238, 1],
    'mediumspringgreen': [0, 250, 154, 1],
    'mediumturquoise': [72, 209, 204, 1],
    'mediumvioletred': [199, 21, 133, 1],
    'midnightblue': [25, 25, 112, 1],
    'mintcream': [245, 255, 250, 1],
    'mistyrose': [255, 228, 225, 1],
    'moccasin': [255, 228, 181, 1],
    'navajowhite': [255, 222, 173, 1],
    'navy': [0, 0, 128, 1],
    'oldlace': [253, 245, 230, 1],
    'olive': [128, 128, 0, 1],
    'olivedrab': [107, 142, 35, 1],
    'orange': [255, 165, 0, 1],
    'orangered': [255, 69, 0, 1],
    'orchid': [218, 112, 214, 1],
    'palegoldenrod': [238, 232, 170, 1],
    'palegreen': [152, 251, 152, 1],
    'paleturquoise': [175, 238, 238, 1],
    'palevioletred': [219, 112, 147, 1],
    'papayawhip': [255, 239, 213, 1],
    'peachpuff': [255, 218, 185, 1],
    'peru': [205, 133, 63, 1],
    'pink': [255, 192, 203, 1],
    'plum': [221, 160, 221, 1],
    'powderblue': [176, 224, 230, 1],
    'purple': [128, 0, 128, 1],
    'red': [255, 0, 0, 1],
    'rosybrown': [188, 143, 143, 1],
    'royalblue': [65, 105, 225, 1],
    'saddlebrown': [139, 69, 19, 1],
    'salmon': [250, 128, 114, 1],
    'sandybrown': [244, 164, 96, 1],
    'seagreen': [46, 139, 87, 1],
    'seashell': [255, 245, 238, 1],
    'sienna': [160, 82, 45, 1],
    'silver': [192, 192, 192, 1],
    'skyblue': [135, 206, 235, 1],
    'slateblue': [106, 90, 205, 1],
    'slategray': [112, 128, 144, 1],
    'slategrey': [112, 128, 144, 1],
    'snow': [255, 250, 250, 1],
    'springgreen': [0, 255, 127, 1],
    'steelblue': [70, 130, 180, 1],
    'tan': [210, 180, 140, 1],
    'teal': [0, 128, 128, 1],
    'thistle': [216, 191, 216, 1],
    'tomato': [255, 99, 71, 1],
    'turquoise': [64, 224, 208, 1],
    'violet': [238, 130, 238, 1],
    'wheat': [245, 222, 179, 1],
    'white': [255, 255, 255, 1],
    'whitesmoke': [245, 245, 245, 1],
    'yellow': [255, 255, 0, 1],
    'yellowgreen': [154, 205, 50, 1]
  };

  function clampCssByte(i) {
    // Clamp to integer 0 .. 255.
    i = Math.round(i); // Seems to be what Chrome does (vs truncation).

    return i < 0 ? 0 : i > 255 ? 255 : i;
  }

  function clampCssAngle(i) {
    // Clamp to integer 0 .. 360.
    i = Math.round(i); // Seems to be what Chrome does (vs truncation).

    return i < 0 ? 0 : i > 360 ? 360 : i;
  }

  function clampCssFloat(f) {
    // Clamp to float 0.0 .. 1.0.
    return f < 0 ? 0 : f > 1 ? 1 : f;
  }

  function parseCssInt(str) {
    // int or percentage.
    if (str.length && str.charAt(str.length - 1) === '%') {
      return clampCssByte(parseFloat(str) / 100 * 255);
    }

    return clampCssByte(parseInt(str, 10));
  }

  function parseCssFloat(str) {
    // float or percentage.
    if (str.length && str.charAt(str.length - 1) === '%') {
      return clampCssFloat(parseFloat(str) / 100);
    }

    return clampCssFloat(parseFloat(str));
  }

  function cssHueToRgb(m1, m2, h) {
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }

    if (h * 6 < 1) {
      return m1 + (m2 - m1) * h * 6;
    }

    if (h * 2 < 1) {
      return m2;
    }

    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }

    return m1;
  }

  function lerpNumber(a, b, p) {
    return a + (b - a) * p;
  }

  function setRgba(out, r, g, b, a) {
    out[0] = r;
    out[1] = g;
    out[2] = b;
    out[3] = a;
    return out;
  }

  function copyRgba(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }

  var colorCache = new LRU_1(20);
  var lastRemovedArr = null;

  function putToCache(colorStr, rgbaArr) {
    // Reuse removed array
    if (lastRemovedArr) {
      copyRgba(lastRemovedArr, rgbaArr);
    }

    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
  }
  /**
   * @param {string} colorStr
   * @param {Array.<number>} out
   * @return {Array.<number>}
   * @memberOf module:zrender/util/color
   */


  function parse(colorStr, rgbaArr) {
    if (!colorStr) {
      return;
    }

    rgbaArr = rgbaArr || [];
    var cached = colorCache.get(colorStr);

    if (cached) {
      return copyRgba(rgbaArr, cached);
    } // colorStr may be not string


    colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.

    var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

    if (str in kCSSColorTable) {
      copyRgba(rgbaArr, kCSSColorTable[str]);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } // #abc and #abc123 syntax.


    if (str.charAt(0) === '#') {
      if (str.length === 4) {
        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

        if (!(iv >= 0 && iv <= 0xfff)) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return; // Covers NaN.
        }

        setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      } else if (str.length === 7) {
        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

        if (!(iv >= 0 && iv <= 0xffffff)) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return; // Covers NaN.
        }

        setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      }

      return;
    }

    var op = str.indexOf('(');
    var ep = str.indexOf(')');

    if (op !== -1 && ep + 1 === str.length) {
      var fname = str.substr(0, op);
      var params = str.substr(op + 1, ep - (op + 1)).split(',');
      var alpha = 1; // To allow case fallthrough.

      switch (fname) {
        case 'rgba':
          if (params.length !== 4) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }

          alpha = parseCssFloat(params.pop());
        // jshint ignore:line
        // Fall through.

        case 'rgb':
          if (params.length !== 3) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }

          setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;

        case 'hsla':
          if (params.length !== 4) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }

          params[3] = parseCssFloat(params[3]);
          hsla2rgba(params, rgbaArr);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;

        case 'hsl':
          if (params.length !== 3) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }

          hsla2rgba(params, rgbaArr);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;

        default:
          return;
      }
    }

    setRgba(rgbaArr, 0, 0, 0, 1);
    return;
  }
  /**
   * @param {Array.<number>} hsla
   * @param {Array.<number>} rgba
   * @return {Array.<number>} rgba
   */


  function hsla2rgba(hsla, rgba) {
    var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
    // NOTE(deanm): According to the CSS spec s/l should only be
    // percentages, but we don't bother and let float or percentage.

    var s = parseCssFloat(hsla[1]);
    var l = parseCssFloat(hsla[2]);
    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    var m1 = l * 2 - m2;
    rgba = rgba || [];
    setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);

    if (hsla.length === 4) {
      rgba[3] = hsla[3];
    }

    return rgba;
  }
  /**
   * @param {Array.<number>} rgba
   * @return {Array.<number>} hsla
   */


  function rgba2hsla(rgba) {
    if (!rgba) {
      return;
    } // RGB from 0 to 255


    var R = rgba[0] / 255;
    var G = rgba[1] / 255;
    var B = rgba[2] / 255;
    var vMin = Math.min(R, G, B); // Min. value of RGB

    var vMax = Math.max(R, G, B); // Max. value of RGB

    var delta = vMax - vMin; // Delta RGB value

    var L = (vMax + vMin) / 2;
    var H;
    var S; // HSL results from 0 to 1

    if (delta === 0) {
      H = 0;
      S = 0;
    } else {
      if (L < 0.5) {
        S = delta / (vMax + vMin);
      } else {
        S = delta / (2 - vMax - vMin);
      }

      var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
      var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
      var deltaB = ((vMax - B) / 6 + delta / 2) / delta;

      if (R === vMax) {
        H = deltaB - deltaG;
      } else if (G === vMax) {
        H = 1 / 3 + deltaR - deltaB;
      } else if (B === vMax) {
        H = 2 / 3 + deltaG - deltaR;
      }

      if (H < 0) {
        H += 1;
      }

      if (H > 1) {
        H -= 1;
      }
    }

    var hsla = [H * 360, S, L];

    if (rgba[3] != null) {
      hsla.push(rgba[3]);
    }

    return hsla;
  }
  /**
   * @param {string} color
   * @param {number} level
   * @return {string}
   * @memberOf module:zrender/util/color
   */


  function lift(color, level) {
    var colorArr = parse(color);

    if (colorArr) {
      for (var i = 0; i < 3; i++) {
        if (level < 0) {
          colorArr[i] = colorArr[i] * (1 - level) | 0;
        } else {
          colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
        }

        if (colorArr[i] > 255) {
          colorArr[i] = 255;
        } else if (color[i] < 0) {
          colorArr[i] = 0;
        }
      }

      return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
    }
  }
  /**
   * @param {string} color
   * @return {string}
   * @memberOf module:zrender/util/color
   */


  function toHex(color) {
    var colorArr = parse(color);

    if (colorArr) {
      return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
    }
  }
  /**
   * Map value to color. Faster than lerp methods because color is represented by rgba array.
   * @param {number} normalizedValue A float between 0 and 1.
   * @param {Array.<Array.<number>>} colors List of rgba color array
   * @param {Array.<number>} [out] Mapped gba color array
   * @return {Array.<number>} will be null/undefined if input illegal.
   */


  function fastLerp(normalizedValue, colors, out) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return;
    }

    out = out || [];
    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = colors[leftIndex];
    var rightColor = colors[rightIndex];
    var dv = value - leftIndex;
    out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
    out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
    out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
    out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
    return out;
  }
  /**
   * @deprecated
   */


  var fastMapToColor = fastLerp;
  /**
   * @param {number} normalizedValue A float between 0 and 1.
   * @param {Array.<string>} colors Color list.
   * @param {boolean=} fullOutput Default false.
   * @return {(string|Object)} Result color. If fullOutput,
   *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
   * @memberOf module:zrender/util/color
   */

  function lerp$1(normalizedValue, colors, fullOutput) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return;
    }

    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = parse(colors[leftIndex]);
    var rightColor = parse(colors[rightIndex]);
    var dv = value - leftIndex;
    var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
    return fullOutput ? {
      color: color,
      leftIndex: leftIndex,
      rightIndex: rightIndex,
      value: value
    } : color;
  }
  /**
   * @deprecated
   */


  var mapToColor = lerp$1;
  /**
   * @param {string} color
   * @param {number=} h 0 ~ 360, ignore when null.
   * @param {number=} s 0 ~ 1, ignore when null.
   * @param {number=} l 0 ~ 1, ignore when null.
   * @return {string} Color string in rgba format.
   * @memberOf module:zrender/util/color
   */

  function modifyHSL(color, h, s, l) {
    color = parse(color);

    if (color) {
      color = rgba2hsla(color);
      h != null && (color[0] = clampCssAngle(h));
      s != null && (color[1] = parseCssFloat(s));
      l != null && (color[2] = parseCssFloat(l));
      return stringify(hsla2rgba(color), 'rgba');
    }
  }
  /**
   * @param {string} color
   * @param {number=} alpha 0 ~ 1
   * @return {string} Color string in rgba format.
   * @memberOf module:zrender/util/color
   */


  function modifyAlpha(color, alpha) {
    color = parse(color);

    if (color && alpha != null) {
      color[3] = clampCssFloat(alpha);
      return stringify(color, 'rgba');
    }
  }
  /**
   * @param {Array.<number>} arrColor like [12,33,44,0.4]
   * @param {string} type 'rgba', 'hsva', ...
   * @return {string} Result color. (If input illegal, return undefined).
   */


  function stringify(arrColor, type) {
    if (!arrColor || !arrColor.length) {
      return;
    }

    var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];

    if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
      colorStr += ',' + arrColor[3];
    }

    return type + '(' + colorStr + ')';
  }

  var parse_1 = parse;
  var lift_1 = lift;
  var toHex_1 = toHex;
  var fastLerp_1 = fastLerp;
  var fastMapToColor_1 = fastMapToColor;
  var lerp_1$1 = lerp$1;
  var mapToColor_1 = mapToColor;
  var modifyHSL_1 = modifyHSL;
  var modifyAlpha_1 = modifyAlpha;
  var stringify_1 = stringify;

  var color = {
  	parse: parse_1,
  	lift: lift_1,
  	toHex: toHex_1,
  	fastLerp: fastLerp_1,
  	fastMapToColor: fastMapToColor_1,
  	lerp: lerp_1$1,
  	mapToColor: mapToColor_1,
  	modifyHSL: modifyHSL_1,
  	modifyAlpha: modifyAlpha_1,
  	stringify: stringify_1
  };

  var isArrayLike$1 = util.isArrayLike;

  /**
   * @module echarts/animation/Animator
   */
  var arraySlice = Array.prototype.slice;

  function defaultGetter(target, key) {
    return target[key];
  }

  function defaultSetter(target, key, value) {
    target[key] = value;
  }
  /**
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} percent
   * @return {number}
   */


  function interpolateNumber(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
  }
  /**
   * @param  {string} p0
   * @param  {string} p1
   * @param  {number} percent
   * @return {string}
   */


  function interpolateString(p0, p1, percent) {
    return percent > 0.5 ? p1 : p0;
  }
  /**
   * @param  {Array} p0
   * @param  {Array} p1
   * @param  {number} percent
   * @param  {Array} out
   * @param  {number} arrDim
   */


  function interpolateArray(p0, p1, percent, out, arrDim) {
    var len = p0.length;

    if (arrDim === 1) {
      for (var i = 0; i < len; i++) {
        out[i] = interpolateNumber(p0[i], p1[i], percent);
      }
    } else {
      var len2 = len && p0[0].length;

      for (var i = 0; i < len; i++) {
        for (var j = 0; j < len2; j++) {
          out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
        }
      }
    }
  } // arr0 is source array, arr1 is target array.
  // Do some preprocess to avoid error happened when interpolating from arr0 to arr1


  function fillArr(arr0, arr1, arrDim) {
    var arr0Len = arr0.length;
    var arr1Len = arr1.length;

    if (arr0Len !== arr1Len) {
      // FIXME Not work for TypedArray
      var isPreviousLarger = arr0Len > arr1Len;

      if (isPreviousLarger) {
        // Cut the previous
        arr0.length = arr1Len;
      } else {
        // Fill the previous
        for (var i = arr0Len; i < arr1Len; i++) {
          arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
        }
      }
    } // Handling NaN value


    var len2 = arr0[0] && arr0[0].length;

    for (var i = 0; i < arr0.length; i++) {
      if (arrDim === 1) {
        if (isNaN(arr0[i])) {
          arr0[i] = arr1[i];
        }
      } else {
        for (var j = 0; j < len2; j++) {
          if (isNaN(arr0[i][j])) {
            arr0[i][j] = arr1[i][j];
          }
        }
      }
    }
  }
  /**
   * @param  {Array} arr0
   * @param  {Array} arr1
   * @param  {number} arrDim
   * @return {boolean}
   */


  function isArraySame(arr0, arr1, arrDim) {
    if (arr0 === arr1) {
      return true;
    }

    var len = arr0.length;

    if (len !== arr1.length) {
      return false;
    }

    if (arrDim === 1) {
      for (var i = 0; i < len; i++) {
        if (arr0[i] !== arr1[i]) {
          return false;
        }
      }
    } else {
      var len2 = arr0[0].length;

      for (var i = 0; i < len; i++) {
        for (var j = 0; j < len2; j++) {
          if (arr0[i][j] !== arr1[i][j]) {
            return false;
          }
        }
      }
    }

    return true;
  }
  /**
   * Catmull Rom interpolate array
   * @param  {Array} p0
   * @param  {Array} p1
   * @param  {Array} p2
   * @param  {Array} p3
   * @param  {number} t
   * @param  {number} t2
   * @param  {number} t3
   * @param  {Array} out
   * @param  {number} arrDim
   */


  function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
    var len = p0.length;

    if (arrDim === 1) {
      for (var i = 0; i < len; i++) {
        out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
      }
    } else {
      var len2 = p0[0].length;

      for (var i = 0; i < len; i++) {
        for (var j = 0; j < len2; j++) {
          out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
        }
      }
    }
  }
  /**
   * Catmull Rom interpolate number
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @param  {number} p3
   * @param  {number} t
   * @param  {number} t2
   * @param  {number} t3
   * @return {number}
   */


  function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
  }

  function cloneValue(value) {
    if (isArrayLike$1(value)) {
      var len = value.length;

      if (isArrayLike$1(value[0])) {
        var ret = [];

        for (var i = 0; i < len; i++) {
          ret.push(arraySlice.call(value[i]));
        }

        return ret;
      }

      return arraySlice.call(value);
    }

    return value;
  }

  function rgba2String(rgba) {
    rgba[0] = Math.floor(rgba[0]);
    rgba[1] = Math.floor(rgba[1]);
    rgba[2] = Math.floor(rgba[2]);
    return 'rgba(' + rgba.join(',') + ')';
  }

  function getArrayDim(keyframes) {
    var lastValue = keyframes[keyframes.length - 1].value;
    return isArrayLike$1(lastValue && lastValue[0]) ? 2 : 1;
  }

  function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
    var getter = animator._getter;
    var setter = animator._setter;
    var useSpline = easing === 'spline';
    var trackLen = keyframes.length;

    if (!trackLen) {
      return;
    } // Guess data type


    var firstVal = keyframes[0].value;
    var isValueArray = isArrayLike$1(firstVal);
    var isValueColor = false;
    var isValueString = false; // For vertices morphing

    var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
    var trackMaxTime; // Sort keyframe as ascending

    keyframes.sort(function (a, b) {
      return a.time - b.time;
    });
    trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe

    var kfPercents = []; // Value of each keyframe

    var kfValues = [];
    var prevValue = keyframes[0].value;
    var isAllValueEqual = true;

    for (var i = 0; i < trackLen; i++) {
      kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string

      var value = keyframes[i].value; // Check if value is equal, deep check if value is array

      if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
        isAllValueEqual = false;
      }

      prevValue = value; // Try converting a string to a color array

      if (typeof value === 'string') {
        var colorArray = color.parse(value);

        if (colorArray) {
          value = colorArray;
          isValueColor = true;
        } else {
          isValueString = true;
        }
      }

      kfValues.push(value);
    }

    if (!forceAnimate && isAllValueEqual) {
      return;
    }

    var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value

    for (var i = 0; i < trackLen - 1; i++) {
      if (isValueArray) {
        fillArr(kfValues[i], lastValue, arrDim);
      } else {
        if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
          kfValues[i] = lastValue;
        }
      }
    }

    isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
    // animation playback is sequency

    var lastFrame = 0;
    var lastFramePercent = 0;
    var start;
    var w;
    var p0;
    var p1;
    var p2;
    var p3;

    if (isValueColor) {
      var rgba = [0, 0, 0, 0];
    }

    var onframe = function (target, percent) {
      // Find the range keyframes
      // kf1-----kf2---------current--------kf3
      // find kf2 and kf3 and do interpolation
      var frame; // In the easing function like elasticOut, percent may less than 0

      if (percent < 0) {
        frame = 0;
      } else if (percent < lastFramePercent) {
        // Start from next key
        // PENDING start from lastFrame ?
        start = Math.min(lastFrame + 1, trackLen - 1);

        for (frame = start; frame >= 0; frame--) {
          if (kfPercents[frame] <= percent) {
            break;
          }
        } // PENDING really need to do this ?


        frame = Math.min(frame, trackLen - 2);
      } else {
        for (frame = lastFrame; frame < trackLen; frame++) {
          if (kfPercents[frame] > percent) {
            break;
          }
        }

        frame = Math.min(frame - 1, trackLen - 2);
      }

      lastFrame = frame;
      lastFramePercent = percent;
      var range = kfPercents[frame + 1] - kfPercents[frame];

      if (range === 0) {
        return;
      } else {
        w = (percent - kfPercents[frame]) / range;
      }

      if (useSpline) {
        p1 = kfValues[frame];
        p0 = kfValues[frame === 0 ? frame : frame - 1];
        p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
        p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];

        if (isValueArray) {
          catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
        } else {
          var value;

          if (isValueColor) {
            value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
            value = rgba2String(rgba);
          } else if (isValueString) {
            // String is step(0.5)
            return interpolateString(p1, p2, w);
          } else {
            value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
          }

          setter(target, propName, value);
        }
      } else {
        if (isValueArray) {
          interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
        } else {
          var value;

          if (isValueColor) {
            interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
            value = rgba2String(rgba);
          } else if (isValueString) {
            // String is step(0.5)
            return interpolateString(kfValues[frame], kfValues[frame + 1], w);
          } else {
            value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
          }

          setter(target, propName, value);
        }
      }
    };

    var clip = new Clip_1({
      target: animator._target,
      life: trackMaxTime,
      loop: animator._loop,
      delay: animator._delay,
      onframe: onframe,
      ondestroy: oneTrackDone
    });

    if (easing && easing !== 'spline') {
      clip.easing = easing;
    }

    return clip;
  }
  /**
   * @alias module:zrender/animation/Animator
   * @constructor
   * @param {Object} target
   * @param {boolean} loop
   * @param {Function} getter
   * @param {Function} setter
   */


  var Animator = function (target, loop, getter, setter) {
    this._tracks = {};
    this._target = target;
    this._loop = loop || false;
    this._getter = getter || defaultGetter;
    this._setter = setter || defaultSetter;
    this._clipCount = 0;
    this._delay = 0;
    this._doneList = [];
    this._onframeList = [];
    this._clipList = [];
  };

  Animator.prototype = {
    /**
     * Set Animation keyframe
     * @param  {number} time å³é®å¸§æ¶é´ï¼åä½æ¯ms
     * @param  {Object} props å³é®å¸§çå±æ§å¼ï¼key-valueè¡¨ç¤º
     * @return {module:zrender/animation/Animator}
     */
    when: function (time
    /* ms */
    , props) {
      var tracks = this._tracks;

      for (var propName in props) {
        if (!props.hasOwnProperty(propName)) {
          continue;
        }

        if (!tracks[propName]) {
          tracks[propName] = []; // Invalid value

          var value = this._getter(this._target, propName);

          if (value == null) {
            // zrLog('Invalid property ' + propName);
            continue;
          } // If time is 0
          //  Then props is given initialize value
          // Else
          //  Initialize value from current prop value


          if (time !== 0) {
            tracks[propName].push({
              time: 0,
              value: cloneValue(value)
            });
          }
        }

        tracks[propName].push({
          time: time,
          value: props[propName]
        });
      }

      return this;
    },

    /**
     * æ·»å å¨ç»æ¯ä¸å¸§çåè°å½æ°
     * @param  {Function} callback
     * @return {module:zrender/animation/Animator}
     */
    during: function (callback) {
      this._onframeList.push(callback);

      return this;
    },
    pause: function () {
      for (var i = 0; i < this._clipList.length; i++) {
        this._clipList[i].pause();
      }

      this._paused = true;
    },
    resume: function () {
      for (var i = 0; i < this._clipList.length; i++) {
        this._clipList[i].resume();
      }

      this._paused = false;
    },
    isPaused: function () {
      return !!this._paused;
    },
    _doneCallback: function () {
      // Clear all tracks
      this._tracks = {}; // Clear all clips

      this._clipList.length = 0;
      var doneList = this._doneList;
      var len = doneList.length;

      for (var i = 0; i < len; i++) {
        doneList[i].call(this);
      }
    },

    /**
     * Start the animation
     * @param  {string|Function} [easing]
     *         å¨ç»ç¼å¨å½æ°ï¼è¯¦è§{@link module:zrender/animation/easing}
     * @param  {boolean} forceAnimate
     * @return {module:zrender/animation/Animator}
     */
    start: function (easing, forceAnimate) {
      var self = this;
      var clipCount = 0;

      var oneTrackDone = function () {
        clipCount--;

        if (!clipCount) {
          self._doneCallback();
        }
      };

      var lastClip;

      for (var propName in this._tracks) {
        if (!this._tracks.hasOwnProperty(propName)) {
          continue;
        }

        var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);

        if (clip) {
          this._clipList.push(clip);

          clipCount++; // If start after added to animation

          if (this.animation) {
            this.animation.addClip(clip);
          }

          lastClip = clip;
        }
      } // Add during callback on the last clip


      if (lastClip) {
        var oldOnFrame = lastClip.onframe;

        lastClip.onframe = function (target, percent) {
          oldOnFrame(target, percent);

          for (var i = 0; i < self._onframeList.length; i++) {
            self._onframeList[i](target, percent);
          }
        };
      } // This optimization will help the case that in the upper application
      // the view may be refreshed frequently, where animation will be
      // called repeatly but nothing changed.


      if (!clipCount) {
        this._doneCallback();
      }

      return this;
    },

    /**
     * Stop animation
     * @param {boolean} forwardToLast If move to last frame before stop
     */
    stop: function (forwardToLast) {
      var clipList = this._clipList;
      var animation = this.animation;

      for (var i = 0; i < clipList.length; i++) {
        var clip = clipList[i];

        if (forwardToLast) {
          // Move to last frame before stop
          clip.onframe(this._target, 1);
        }

        animation && animation.removeClip(clip);
      }

      clipList.length = 0;
    },

    /**
     * Set when animation delay starts
     * @param  {number} time åä½ms
     * @return {module:zrender/animation/Animator}
     */
    delay: function (time) {
      this._delay = time;
      return this;
    },

    /**
     * Add callback for animation end
     * @param  {Function} cb
     * @return {module:zrender/animation/Animator}
     */
    done: function (cb) {
      if (cb) {
        this._doneList.push(cb);
      }

      return this;
    },

    /**
     * @return {Array.<module:zrender/animation/Clip>}
     */
    getClips: function () {
      return this._clipList;
    }
  };
  var _default$a = Animator;
  var Animator_1 = _default$a;

  var dpr = 1; // If in browser environment

  if (typeof window !== 'undefined') {
    dpr = Math.max(window.devicePixelRatio || 1, 1);
  }
  /**
   * configé»è®¤éç½®é¡¹
   * @exports zrender/config
   * @author Kener (@Kener-æå³°, kener.linfeng@gmail.com)
   */

  /**
   * Debug log mode:
   * 0: Do nothing, for release.
   * 1: console.error, for debug.
   */


  var debugMode = 0; // retina å±å¹ä¼å

  var devicePixelRatio = dpr;
  var debugMode_1 = debugMode;
  var devicePixelRatio_1 = devicePixelRatio;

  var config = {
  	debugMode: debugMode_1,
  	devicePixelRatio: devicePixelRatio_1
  };

  var logError = function () {};

  var _default$b = logError;
  var log = _default$b;

  var isString$2 = util.isString;
  var isFunction$2 = util.isFunction;
  var isObject$3 = util.isObject;
  var isArrayLike$2 = util.isArrayLike;
  var indexOf$2 = util.indexOf;

  /**
   * @alias module:zrender/mixin/Animatable
   * @constructor
   */
  var Animatable = function () {
    /**
     * @type {Array.<module:zrender/animation/Animator>}
     * @readOnly
     */
    this.animators = [];
  };

  Animatable.prototype = {
    constructor: Animatable,

    /**
     * å¨ç»
     *
     * @param {string} path The path to fetch value from object, like 'a.b.c'.
     * @param {boolean} [loop] Whether to loop animation.
     * @return {module:zrender/animation/Animator}
     * @example:
     *     el.animate('style', false)
     *         .when(1000, {x: 10} )
     *         .done(function(){ // Animation done })
     *         .start()
     */
    animate: function (path, loop) {
      var target;
      var animatingShape = false;
      var el = this;
      var zr = this.__zr;

      if (path) {
        var pathSplitted = path.split('.');
        var prop = el; // If animating shape

        animatingShape = pathSplitted[0] === 'shape';

        for (var i = 0, l = pathSplitted.length; i < l; i++) {
          if (!prop) {
            continue;
          }

          prop = prop[pathSplitted[i]];
        }

        if (prop) {
          target = prop;
        }
      } else {
        target = el;
      }

      if (!target) {
        log('Property "' + path + '" is not existed in element ' + el.id);
        return;
      }

      var animators = el.animators;
      var animator = new Animator_1(target, loop);
      animator.during(function (target) {
        el.dirty(animatingShape);
      }).done(function () {
        // FIXME Animator will not be removed if use `Animator#stop` to stop animation
        animators.splice(indexOf$2(animators, animator), 1);
      });
      animators.push(animator); // If animate after added to the zrender

      if (zr) {
        zr.animation.addAnimator(animator);
      }

      return animator;
    },

    /**
     * åæ­¢å¨ç»
     * @param {boolean} forwardToLast If move to last frame before stop
     */
    stopAnimation: function (forwardToLast) {
      var animators = this.animators;
      var len = animators.length;

      for (var i = 0; i < len; i++) {
        animators[i].stop(forwardToLast);
      }

      animators.length = 0;
      return this;
    },

    /**
     * Caution: this method will stop previous animation.
     * So do not use this method to one element twice before
     * animation starts, unless you know what you are doing.
     * @param {Object} target
     * @param {number} [time=500] Time in ms
     * @param {string} [easing='linear']
     * @param {number} [delay=0]
     * @param {Function} [callback]
     * @param {Function} [forceAnimate] Prevent stop animation and callback
     *        immediently when target values are the same as current values.
     *
     * @example
     *  // Animate position
     *  el.animateTo({
     *      position: [10, 10]
     *  }, function () { // done })
     *
     *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
     *  el.animateTo({
     *      shape: {
     *          width: 500
     *      },
     *      style: {
     *          fill: 'red'
     *      }
     *      position: [10, 10]
     *  }, 100, 100, 'cubicOut', function () { // done })
     */
    // TODO Return animation key
    animateTo: function (target, time, delay, easing, callback, forceAnimate) {
      animateTo(this, target, time, delay, easing, callback, forceAnimate);
    },

    /**
     * Animate from the target state to current state.
     * The params and the return value are the same as `this.animateTo`.
     */
    animateFrom: function (target, time, delay, easing, callback, forceAnimate) {
      animateTo(this, target, time, delay, easing, callback, forceAnimate, true);
    }
  };

  function animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {
    // animateTo(target, time, easing, callback);
    if (isString$2(delay)) {
      callback = easing;
      easing = delay;
      delay = 0;
    } // animateTo(target, time, delay, callback);
    else if (isFunction$2(easing)) {
        callback = easing;
        easing = 'linear';
        delay = 0;
      } // animateTo(target, time, callback);
      else if (isFunction$2(delay)) {
          callback = delay;
          delay = 0;
        } // animateTo(target, callback)
        else if (isFunction$2(time)) {
            callback = time;
            time = 500;
          } // animateTo(target)
          else if (!time) {
              time = 500;
            } // Stop all previous animations


    animatable.stopAnimation();
    animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start
    // if there is nothing to animate

    var animators = animatable.animators.slice();
    var count = animators.length;

    function done() {
      count--;

      if (!count) {
        callback && callback();
      }
    } // No animators. This should be checked before animators[i].start(),
    // because 'done' may be executed immediately if no need to animate.


    if (!count) {
      callback && callback();
    } // Start after all animators created
    // Incase any animator is done immediately when all animation properties are not changed


    for (var i = 0; i < animators.length; i++) {
      animators[i].done(done).start(easing, forceAnimate);
    }
  }
  /**
   * @param {string} path=''
   * @param {Object} source=animatable
   * @param {Object} target
   * @param {number} [time=500]
   * @param {number} [delay=0]
   * @param {boolean} [reverse] If `true`, animate
   *        from the `target` to current state.
   *
   * @example
   *  // Animate position
   *  el._animateToShallow({
   *      position: [10, 10]
   *  })
   *
   *  // Animate shape, style and position in 100ms, delayed 100ms
   *  el._animateToShallow({
   *      shape: {
   *          width: 500
   *      },
   *      style: {
   *          fill: 'red'
   *      }
   *      position: [10, 10]
   *  }, 100, 100)
   */


  function animateToShallow(animatable, path, source, target, time, delay, reverse) {
    var objShallow = {};
    var propertyCount = 0;

    for (var name in target) {
      if (!target.hasOwnProperty(name)) {
        continue;
      }

      if (source[name] != null) {
        if (isObject$3(target[name]) && !isArrayLike$2(target[name])) {
          animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);
        } else {
          if (reverse) {
            objShallow[name] = source[name];
            setAttrByPath(animatable, path, name, target[name]);
          } else {
            objShallow[name] = target[name];
          }

          propertyCount++;
        }
      } else if (target[name] != null && !reverse) {
        setAttrByPath(animatable, path, name, target[name]);
      }
    }

    if (propertyCount > 0) {
      animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
    }
  }

  function setAttrByPath(el, path, name, value) {
    // Attr directly if not has property
    // FIXME, if some property not needed for element ?
    if (!path) {
      el.attr(name, value);
    } else {
      // Only support set shape or style
      var props = {};
      props[path] = {};
      props[path][name] = value;
      el.attr(props);
    }
  }

  var _default$c = Animatable;
  var Animatable_1 = _default$c;

  /**
   * @alias module:zrender/Element
   * @constructor
   * @extends {module:zrender/mixin/Animatable}
   * @extends {module:zrender/mixin/Transformable}
   * @extends {module:zrender/mixin/Eventful}
   */
  var Element = function (opts) {
    // jshint ignore:line
    Transformable_1.call(this, opts);
    Eventful_1.call(this, opts);
    Animatable_1.call(this, opts);
    /**
     * ç»å¸åç´ ID
     * @type {string}
     */

    this.id = opts.id || guid();
  };

  Element.prototype = {
    /**
     * åç´ ç±»å
     * Element type
     * @type {string}
     */
    type: 'element',

    /**
     * åç´ åå­
     * Element name
     * @type {string}
     */
    name: '',

    /**
     * ZRender å®ä¾å¯¹è±¡ï¼ä¼å¨ element æ·»å å° zrender å®ä¾ä¸­åèªå¨èµå¼
     * ZRender instance will be assigned when element is associated with zrender
     * @name module:/zrender/Element#__zr
     * @type {module:zrender/ZRender}
     */
    __zr: null,

    /**
     * å¾å½¢æ¯å¦å¿½ç¥ï¼ä¸ºtrueæ¶å¿½ç¥å¾å½¢çç»å¶ä»¥åäºä»¶è§¦å
     * If ignore drawing and events of the element object
     * @name module:/zrender/Element#ignore
     * @type {boolean}
     * @default false
     */
    ignore: false,

    /**
     * ç¨äºè£åªçè·¯å¾(shape)ï¼ææ Group åçè·¯å¾å¨ç»å¶æ¶é½ä¼è¢«è¿ä¸ªè·¯å¾è£åª
     * è¯¥è·¯å¾ä¼ç»§æ¿è¢«è£åå¯¹è±¡çåæ¢
     * @type {module:zrender/graphic/Path}
     * @see http://www.w3.org/TR/2dcontext/#clipping-region
     * @readOnly
     */
    clipPath: null,

    /**
     * æ¯å¦æ¯ Group
     * @type {boolean}
     */
    isGroup: false,

    /**
     * Drift element
     * @param  {number} dx dx on the global space
     * @param  {number} dy dy on the global space
     */
    drift: function (dx, dy) {
      switch (this.draggable) {
        case 'horizontal':
          dy = 0;
          break;

        case 'vertical':
          dx = 0;
          break;
      }

      var m = this.transform;

      if (!m) {
        m = this.transform = [1, 0, 0, 1, 0, 0];
      }

      m[4] += dx;
      m[5] += dy;
      this.decomposeTransform();
      this.dirty(false);
    },

    /**
     * Hook before update
     */
    beforeUpdate: function () {},

    /**
     * Hook after update
     */
    afterUpdate: function () {},

    /**
     * Update each frame
     */
    update: function () {
      this.updateTransform();
    },

    /**
     * @param  {Function} cb
     * @param  {}   context
     */
    traverse: function (cb, context) {},

    /**
     * @protected
     */
    attrKV: function (key, value) {
      if (key === 'position' || key === 'scale' || key === 'origin') {
        // Copy the array
        if (value) {
          var target = this[key];

          if (!target) {
            target = this[key] = [];
          }

          target[0] = value[0];
          target[1] = value[1];
        }
      } else {
        this[key] = value;
      }
    },

    /**
     * Hide the element
     */
    hide: function () {
      this.ignore = true;
      this.__zr && this.__zr.refresh();
    },

    /**
     * Show the element
     */
    show: function () {
      this.ignore = false;
      this.__zr && this.__zr.refresh();
    },

    /**
     * @param {string|Object} key
     * @param {*} value
     */
    attr: function (key, value) {
      if (typeof key === 'string') {
        this.attrKV(key, value);
      } else if (util.isObject(key)) {
        for (var name in key) {
          if (key.hasOwnProperty(name)) {
            this.attrKV(name, key[name]);
          }
        }
      }

      this.dirty(false);
      return this;
    },

    /**
     * @param {module:zrender/graphic/Path} clipPath
     */
    setClipPath: function (clipPath) {
      var zr = this.__zr;

      if (zr) {
        clipPath.addSelfToZr(zr);
      } // Remove previous clip path


      if (this.clipPath && this.clipPath !== clipPath) {
        this.removeClipPath();
      }

      this.clipPath = clipPath;
      clipPath.__zr = zr;
      clipPath.__clipTarget = this;
      this.dirty(false);
    },

    /**
     */
    removeClipPath: function () {
      var clipPath = this.clipPath;

      if (clipPath) {
        if (clipPath.__zr) {
          clipPath.removeSelfFromZr(clipPath.__zr);
        }

        clipPath.__zr = null;
        clipPath.__clipTarget = null;
        this.clipPath = null;
        this.dirty(false);
      }
    },

    /**
     * Add self from zrender instance.
     * Not recursively because it will be invoked when element added to storage.
     * @param {module:zrender/ZRender} zr
     */
    addSelfToZr: function (zr) {
      this.__zr = zr; // æ·»å å¨ç»

      var animators = this.animators;

      if (animators) {
        for (var i = 0; i < animators.length; i++) {
          zr.animation.addAnimator(animators[i]);
        }
      }

      if (this.clipPath) {
        this.clipPath.addSelfToZr(zr);
      }
    },

    /**
     * Remove self from zrender instance.
     * Not recursively because it will be invoked when element added to storage.
     * @param {module:zrender/ZRender} zr
     */
    removeSelfFromZr: function (zr) {
      this.__zr = null; // ç§»é¤å¨ç»

      var animators = this.animators;

      if (animators) {
        for (var i = 0; i < animators.length; i++) {
          zr.animation.removeAnimator(animators[i]);
        }
      }

      if (this.clipPath) {
        this.clipPath.removeSelfFromZr(zr);
      }
    }
  };
  util.mixin(Element, Animatable_1);
  util.mixin(Element, Transformable_1);
  util.mixin(Element, Eventful_1);
  var _default$d = Element;
  var Element_1 = _default$d;

  /**
   * @module echarts/core/BoundingRect
   */
  var v2ApplyTransform = vector.applyTransform;
  var mathMin = Math.min;
  var mathMax = Math.max;
  /**
   * @alias module:echarts/core/BoundingRect
   */

  function BoundingRect(x, y, width, height) {
    if (width < 0) {
      x = x + width;
      width = -width;
    }

    if (height < 0) {
      y = y + height;
      height = -height;
    }
    /**
     * @type {number}
     */


    this.x = x;
    /**
     * @type {number}
     */

    this.y = y;
    /**
     * @type {number}
     */

    this.width = width;
    /**
     * @type {number}
     */

    this.height = height;
  }

  BoundingRect.prototype = {
    constructor: BoundingRect,

    /**
     * @param {module:echarts/core/BoundingRect} other
     */
    union: function (other) {
      var x = mathMin(other.x, this.x);
      var y = mathMin(other.y, this.y);
      this.width = mathMax(other.x + other.width, this.x + this.width) - x;
      this.height = mathMax(other.y + other.height, this.y + this.height) - y;
      this.x = x;
      this.y = y;
    },

    /**
     * @param {Array.<number>} m
     * @methods
     */
    applyTransform: function () {
      var lt = [];
      var rb = [];
      var lb = [];
      var rt = [];
      return function (m) {
        // In case usage like this
        // el.getBoundingRect().applyTransform(el.transform)
        // And element has no transform
        if (!m) {
          return;
        }

        lt[0] = lb[0] = this.x;
        lt[1] = rt[1] = this.y;
        rb[0] = rt[0] = this.x + this.width;
        rb[1] = lb[1] = this.y + this.height;
        v2ApplyTransform(lt, lt, m);
        v2ApplyTransform(rb, rb, m);
        v2ApplyTransform(lb, lb, m);
        v2ApplyTransform(rt, rt, m);
        this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
        this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
        var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
        var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
        this.width = maxX - this.x;
        this.height = maxY - this.y;
      };
    }(),

    /**
     * Calculate matrix of transforming from self to target rect
     * @param  {module:zrender/core/BoundingRect} b
     * @return {Array.<number>}
     */
    calculateTransform: function (b) {
      var a = this;
      var sx = b.width / a.width;
      var sy = b.height / a.height;
      var m = matrix.create(); // ç©éµå³ä¹

      matrix.translate(m, m, [-a.x, -a.y]);
      matrix.scale(m, m, [sx, sy]);
      matrix.translate(m, m, [b.x, b.y]);
      return m;
    },

    /**
     * @param {(module:echarts/core/BoundingRect|Object)} b
     * @return {boolean}
     */
    intersect: function (b) {
      if (!b) {
        return false;
      }

      if (!(b instanceof BoundingRect)) {
        // Normalize negative width/height.
        b = BoundingRect.create(b);
      }

      var a = this;
      var ax0 = a.x;
      var ax1 = a.x + a.width;
      var ay0 = a.y;
      var ay1 = a.y + a.height;
      var bx0 = b.x;
      var bx1 = b.x + b.width;
      var by0 = b.y;
      var by1 = b.y + b.height;
      return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    },
    contain: function (x, y) {
      var rect = this;
      return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
    },

    /**
     * @return {module:echarts/core/BoundingRect}
     */
    clone: function () {
      return new BoundingRect(this.x, this.y, this.width, this.height);
    },

    /**
     * Copy from another rect
     */
    copy: function (other) {
      this.x = other.x;
      this.y = other.y;
      this.width = other.width;
      this.height = other.height;
    },
    plain: function () {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    }
  };
  /**
   * @param {Object|module:zrender/core/BoundingRect} rect
   * @param {number} rect.x
   * @param {number} rect.y
   * @param {number} rect.width
   * @param {number} rect.height
   * @return {module:zrender/core/BoundingRect}
   */

  BoundingRect.create = function (rect) {
    return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
  };

  var _default$e = BoundingRect;
  var BoundingRect_1 = _default$e;

  /**
   * Groupæ¯ä¸ä¸ªå®¹å¨ï¼å¯ä»¥æå¥å­èç¹ï¼Groupçåæ¢ä¹ä¼è¢«åºç¨å°å­èç¹ä¸
   * @module zrender/graphic/Group
   * @example
   *     var Group = require('zrender/container/Group');
   *     var Circle = require('zrender/graphic/shape/Circle');
   *     var g = new Group();
   *     g.position[0] = 100;
   *     g.position[1] = 100;
   *     g.add(new Circle({
   *         style: {
   *             x: 100,
   *             y: 100,
   *             r: 20,
   *         }
   *     }));
   *     zr.add(g);
   */

  /**
   * @alias module:zrender/graphic/Group
   * @constructor
   * @extends module:zrender/mixin/Transformable
   * @extends module:zrender/mixin/Eventful
   */
  var Group = function (opts) {
    opts = opts || {};
    Element_1.call(this, opts);

    for (var key in opts) {
      if (opts.hasOwnProperty(key)) {
        this[key] = opts[key];
      }
    }

    this._children = [];
    this.__storage = null;
    this.__dirty = true;
  };

  Group.prototype = {
    constructor: Group,
    isGroup: true,

    /**
     * @type {string}
     */
    type: 'group',

    /**
     * ææå­å­åç´ æ¯å¦ååºé¼ æ äºä»¶
     * @name module:/zrender/container/Group#silent
     * @type {boolean}
     * @default false
     */
    silent: false,

    /**
     * @return {Array.<module:zrender/Element>}
     */
    children: function () {
      return this._children.slice();
    },

    /**
     * è·åæå® index çå¿å­èç¹
     * @param  {number} idx
     * @return {module:zrender/Element}
     */
    childAt: function (idx) {
      return this._children[idx];
    },

    /**
     * è·åæå®åå­çå¿å­èç¹
     * @param  {string} name
     * @return {module:zrender/Element}
     */
    childOfName: function (name) {
      var children = this._children;

      for (var i = 0; i < children.length; i++) {
        if (children[i].name === name) {
          return children[i];
        }
      }
    },

    /**
     * @return {number}
     */
    childCount: function () {
      return this._children.length;
    },

    /**
     * æ·»å å­èç¹å°æå
     * @param {module:zrender/Element} child
     */
    add: function (child) {
      if (child && child !== this && child.parent !== this) {
        this._children.push(child);

        this._doAdd(child);
      }

      return this;
    },

    /**
     * æ·»å å­èç¹å¨ nextSibling ä¹å
     * @param {module:zrender/Element} child
     * @param {module:zrender/Element} nextSibling
     */
    addBefore: function (child, nextSibling) {
      if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
        var children = this._children;
        var idx = children.indexOf(nextSibling);

        if (idx >= 0) {
          children.splice(idx, 0, child);

          this._doAdd(child);
        }
      }

      return this;
    },
    _doAdd: function (child) {
      if (child.parent) {
        child.parent.remove(child);
      }

      child.parent = this;
      var storage = this.__storage;
      var zr = this.__zr;

      if (storage && storage !== child.__storage) {
        storage.addToStorage(child);

        if (child instanceof Group) {
          child.addChildrenToStorage(storage);
        }
      }

      zr && zr.refresh();
    },

    /**
     * ç§»é¤å­èç¹
     * @param {module:zrender/Element} child
     */
    remove: function (child) {
      var zr = this.__zr;
      var storage = this.__storage;
      var children = this._children;
      var idx = util.indexOf(children, child);

      if (idx < 0) {
        return this;
      }

      children.splice(idx, 1);
      child.parent = null;

      if (storage) {
        storage.delFromStorage(child);

        if (child instanceof Group) {
          child.delChildrenFromStorage(storage);
        }
      }

      zr && zr.refresh();
      return this;
    },

    /**
     * ç§»é¤ææå­èç¹
     */
    removeAll: function () {
      var children = this._children;
      var storage = this.__storage;
      var child;
      var i;

      for (i = 0; i < children.length; i++) {
        child = children[i];

        if (storage) {
          storage.delFromStorage(child);

          if (child instanceof Group) {
            child.delChildrenFromStorage(storage);
          }
        }

        child.parent = null;
      }

      children.length = 0;
      return this;
    },

    /**
     * éåææå­èç¹
     * @param  {Function} cb
     * @param  {}   context
     */
    eachChild: function (cb, context) {
      var children = this._children;

      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        cb.call(context, child, i);
      }

      return this;
    },

    /**
     * æ·±åº¦ä¼åéåææå­å­èç¹
     * @param  {Function} cb
     * @param  {}   context
     */
    traverse: function (cb, context) {
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        cb.call(context, child);

        if (child.type === 'group') {
          child.traverse(cb, context);
        }
      }

      return this;
    },
    addChildrenToStorage: function (storage) {
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        storage.addToStorage(child);

        if (child instanceof Group) {
          child.addChildrenToStorage(storage);
        }
      }
    },
    delChildrenFromStorage: function (storage) {
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        storage.delFromStorage(child);

        if (child instanceof Group) {
          child.delChildrenFromStorage(storage);
        }
      }
    },
    dirty: function () {
      this.__dirty = true;
      this.__zr && this.__zr.refresh();
      return this;
    },

    /**
     * @return {module:zrender/core/BoundingRect}
     */
    getBoundingRect: function (includeChildren) {
      // TODO Caching
      var rect = null;
      var tmpRect = new BoundingRect_1(0, 0, 0, 0);
      var children = includeChildren || this._children;
      var tmpMat = [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i];

        if (child.ignore || child.invisible) {
          continue;
        }

        var childRect = child.getBoundingRect();
        var transform = child.getLocalTransform(tmpMat); // TODO
        // The boundingRect cacluated by transforming original
        // rect may be bigger than the actual bundingRect when rotation
        // is used. (Consider a circle rotated aginst its center, where
        // the actual boundingRect should be the same as that not be
        // rotated.) But we can not find better approach to calculate
        // actual boundingRect yet, considering performance.

        if (transform) {
          tmpRect.copy(childRect);
          tmpRect.applyTransform(transform);
          rect = rect || tmpRect.clone();
          rect.union(tmpRect);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }

      return rect || tmpRect;
    }
  };
  util.inherits(Group, Element_1);
  var _default$f = Group;
  var Group_1 = _default$f;

  // https://github.com/mziccard/node-timsort
  var DEFAULT_MIN_MERGE = 32;
  var DEFAULT_MIN_GALLOPING = 7;

  function minRunLength(n) {
    var r = 0;

    while (n >= DEFAULT_MIN_MERGE) {
      r |= n & 1;
      n >>= 1;
    }

    return n + r;
  }

  function makeAscendingRun(array, lo, hi, compare) {
    var runHi = lo + 1;

    if (runHi === hi) {
      return 1;
    }

    if (compare(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
        runHi++;
      }

      reverseRun(array, lo, runHi);
    } else {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
        runHi++;
      }
    }

    return runHi - lo;
  }

  function reverseRun(array, lo, hi) {
    hi--;

    while (lo < hi) {
      var t = array[lo];
      array[lo++] = array[hi];
      array[hi--] = t;
    }
  }

  function binaryInsertionSort(array, lo, hi, start, compare) {
    if (start === lo) {
      start++;
    }

    for (; start < hi; start++) {
      var pivot = array[start];
      var left = lo;
      var right = start;
      var mid;

      while (left < right) {
        mid = left + right >>> 1;

        if (compare(pivot, array[mid]) < 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }

      var n = start - left;

      switch (n) {
        case 3:
          array[left + 3] = array[left + 2];

        case 2:
          array[left + 2] = array[left + 1];

        case 1:
          array[left + 1] = array[left];
          break;

        default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }

      }

      array[left] = pivot;
    }
  }

  function gallopLeft(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) > 0) {
      maxOffset = length - hint;

      while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      lastOffset += hint;
      offset += hint;
    } else {
      maxOffset = hint + 1;

      while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    }

    lastOffset++;

    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);

      if (compare(value, array[start + m]) > 0) {
        lastOffset = m + 1;
      } else {
        offset = m;
      }
    }

    return offset;
  }

  function gallopRight(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) < 0) {
      maxOffset = hint + 1;

      while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    } else {
      maxOffset = length - hint;

      while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;

        if (offset <= 0) {
          offset = maxOffset;
        }
      }

      if (offset > maxOffset) {
        offset = maxOffset;
      }

      lastOffset += hint;
      offset += hint;
    }

    lastOffset++;

    while (lastOffset < offset) {
      var m = lastOffset + (offset - lastOffset >>> 1);

      if (compare(value, array[start + m]) < 0) {
        offset = m;
      } else {
        lastOffset = m + 1;
      }
    }

    return offset;
  }

  function TimSort(array, compare) {
    var minGallop = DEFAULT_MIN_GALLOPING;
    var length = 0;
    var runStart;
    var runLength;
    var stackSize = 0;
    length = array.length;

    var tmp = [];
    runStart = [];
    runLength = [];

    function pushRun(_runStart, _runLength) {
      runStart[stackSize] = _runStart;
      runLength[stackSize] = _runLength;
      stackSize += 1;
    }

    function mergeRuns() {
      while (stackSize > 1) {
        var n = stackSize - 2;

        if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
          if (runLength[n - 1] < runLength[n + 1]) {
            n--;
          }
        } else if (runLength[n] > runLength[n + 1]) {
          break;
        }

        mergeAt(n);
      }
    }

    function forceMergeRuns() {
      while (stackSize > 1) {
        var n = stackSize - 2;

        if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
          n--;
        }

        mergeAt(n);
      }
    }

    function mergeAt(i) {
      var start1 = runStart[i];
      var length1 = runLength[i];
      var start2 = runStart[i + 1];
      var length2 = runLength[i + 1];
      runLength[i] = length1 + length2;

      if (i === stackSize - 3) {
        runStart[i + 1] = runStart[i + 2];
        runLength[i + 1] = runLength[i + 2];
      }

      stackSize--;
      var k = gallopRight(array[start2], array, start1, length1, 0, compare);
      start1 += k;
      length1 -= k;

      if (length1 === 0) {
        return;
      }

      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

      if (length2 === 0) {
        return;
      }

      if (length1 <= length2) {
        mergeLow(start1, length1, start2, length2);
      } else {
        mergeHigh(start1, length1, start2, length2);
      }
    }

    function mergeLow(start1, length1, start2, length2) {
      var i = 0;

      for (i = 0; i < length1; i++) {
        tmp[i] = array[start1 + i];
      }

      var cursor1 = 0;
      var cursor2 = start2;
      var dest = start1;
      array[dest++] = array[cursor2++];

      if (--length2 === 0) {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }

        return;
      }

      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }

        array[dest + length2] = tmp[cursor1];
        return;
      }

      var _minGallop = minGallop;
      var count1;
      var count2;
      var exit;

      while (1) {
        count1 = 0;
        count2 = 0;
        exit = false;

        do {
          if (compare(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++];
            count2++;
            count1 = 0;

            if (--length2 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest++] = tmp[cursor1++];
            count1++;
            count2 = 0;

            if (--length1 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < _minGallop);

        if (exit) {
          break;
        }

        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

          if (count1 !== 0) {
            for (i = 0; i < count1; i++) {
              array[dest + i] = tmp[cursor1 + i];
            }

            dest += count1;
            cursor1 += count1;
            length1 -= count1;

            if (length1 <= 1) {
              exit = true;
              break;
            }
          }

          array[dest++] = array[cursor2++];

          if (--length2 === 0) {
            exit = true;
            break;
          }

          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

          if (count2 !== 0) {
            for (i = 0; i < count2; i++) {
              array[dest + i] = array[cursor2 + i];
            }

            dest += count2;
            cursor2 += count2;
            length2 -= count2;

            if (length2 === 0) {
              exit = true;
              break;
            }
          }

          array[dest++] = tmp[cursor1++];

          if (--length1 === 1) {
            exit = true;
            break;
          }

          _minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

        if (exit) {
          break;
        }

        if (_minGallop < 0) {
          _minGallop = 0;
        }

        _minGallop += 2;
      }

      minGallop = _minGallop;
      minGallop < 1 && (minGallop = 1);

      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
        }

        array[dest + length2] = tmp[cursor1];
      } else if (length1 === 0) {
        throw new Error(); // throw new Error('mergeLow preconditions were not respected');
      } else {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
      }
    }

    function mergeHigh(start1, length1, start2, length2) {
      var i = 0;

      for (i = 0; i < length2; i++) {
        tmp[i] = array[start2 + i];
      }

      var cursor1 = start1 + length1 - 1;
      var cursor2 = length2 - 1;
      var dest = start2 + length2 - 1;
      var customCursor = 0;
      var customDest = 0;
      array[dest--] = array[cursor1--];

      if (--length1 === 0) {
        customCursor = dest - (length2 - 1);

        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }

        return;
      }

      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        array[dest] = tmp[cursor2];
        return;
      }

      var _minGallop = minGallop;

      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;

        do {
          if (compare(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--];
            count1++;
            count2 = 0;

            if (--length1 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest--] = tmp[cursor2--];
            count2++;
            count1 = 0;

            if (--length2 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < _minGallop);

        if (exit) {
          break;
        }

        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

          if (count1 !== 0) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;

            for (i = count1 - 1; i >= 0; i--) {
              array[customDest + i] = array[customCursor + i];
            }

            if (length1 === 0) {
              exit = true;
              break;
            }
          }

          array[dest--] = tmp[cursor2--];

          if (--length2 === 1) {
            exit = true;
            break;
          }

          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

          if (count2 !== 0) {
            dest -= count2;
            cursor2 -= count2;
            length2 -= count2;
            customDest = dest + 1;
            customCursor = cursor2 + 1;

            for (i = 0; i < count2; i++) {
              array[customDest + i] = tmp[customCursor + i];
            }

            if (length2 <= 1) {
              exit = true;
              break;
            }
          }

          array[dest--] = array[cursor1--];

          if (--length1 === 0) {
            exit = true;
            break;
          }

          _minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

        if (exit) {
          break;
        }

        if (_minGallop < 0) {
          _minGallop = 0;
        }

        _minGallop += 2;
      }

      minGallop = _minGallop;

      if (minGallop < 1) {
        minGallop = 1;
      }

      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        array[dest] = tmp[cursor2];
      } else if (length2 === 0) {
        throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
      } else {
        customCursor = dest - (length2 - 1);

        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i];
        }
      }
    }

    this.mergeRuns = mergeRuns;
    this.forceMergeRuns = forceMergeRuns;
    this.pushRun = pushRun;
  }

  function sort(array, compare, lo, hi) {
    if (!lo) {
      lo = 0;
    }

    if (!hi) {
      hi = array.length;
    }

    var remaining = hi - lo;

    if (remaining < 2) {
      return;
    }

    var runLength = 0;

    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare);
      binaryInsertionSort(array, lo, hi, lo + runLength, compare);
      return;
    }

    var ts = new TimSort(array, compare);
    var minRun = minRunLength(remaining);

    do {
      runLength = makeAscendingRun(array, lo, hi, compare);

      if (runLength < minRun) {
        var force = remaining;

        if (force > minRun) {
          force = minRun;
        }

        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
        runLength = force;
      }

      ts.pushRun(lo, runLength);
      ts.mergeRuns();
      remaining -= runLength;
      lo += runLength;
    } while (remaining !== 0);

    ts.forceMergeRuns();
  }

  var timsort = sort;

  // Use timsort because in most case elements are partially sorted
  // https://jsfiddle.net/pissang/jr4x7mdm/8/
  function shapeCompareFunc(a, b) {
    if (a.zlevel === b.zlevel) {
      if (a.z === b.z) {
        // if (a.z2 === b.z2) {
        //     // FIXME Slow has renderidx compare
        //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
        //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
        //     return a.__renderidx - b.__renderidx;
        // }
        return a.z2 - b.z2;
      }

      return a.z - b.z;
    }

    return a.zlevel - b.zlevel;
  }
  /**
   * åå®¹ä»åº (M)
   * @alias module:zrender/Storage
   * @constructor
   */


  var Storage = function () {
    // jshint ignore:line
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
  };

  Storage.prototype = {
    constructor: Storage,

    /**
     * @param  {Function} cb
     *
     */
    traverse: function (cb, context) {
      for (var i = 0; i < this._roots.length; i++) {
        this._roots[i].traverse(cb, context);
      }
    },

    /**
     * è¿åææå¾å½¢çç»å¶éå
     * @param {boolean} [update=false] æ¯å¦å¨è¿ååæ´æ°è¯¥æ°ç»
     * @param {boolean} [includeIgnore=false] æ¯å¦åå« ignore çæ°ç», å¨ update ä¸º true çæ¶åææ
     *
     * è¯¦è§{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
     * @return {Array.<module:zrender/graphic/Displayable>}
     */
    getDisplayList: function (update, includeIgnore) {
      includeIgnore = includeIgnore || false;

      if (update) {
        this.updateDisplayList(includeIgnore);
      }

      return this._displayList;
    },

    /**
     * æ´æ°å¾å½¢çç»å¶éåã
     * æ¯æ¬¡ç»å¶åé½ä¼è°ç¨ï¼è¯¥æ¹æ³ä¼åæ·±åº¦ä¼åéåæ´ä¸ªæ ï¼æ´æ°ææGroupåShapeçåæ¢å¹¶ä¸æææå¯è§çShapeä¿å­å°æ°ç»ä¸­ï¼
     * æåæ ¹æ®ç»å¶çä¼åçº§ï¼zlevel > z > æå¥é¡ºåºï¼æåºå¾å°ç»å¶éå
     * @param {boolean} [includeIgnore=false] æ¯å¦åå« ignore çæ°ç»
     */
    updateDisplayList: function (includeIgnore) {
      this._displayListLen = 0;
      var roots = this._roots;
      var displayList = this._displayList;

      for (var i = 0, len = roots.length; i < len; i++) {
        this._updateAndAddDisplayable(roots[i], null, includeIgnore);
      }

      displayList.length = this._displayListLen;
      env_1.canvasSupported && timsort(displayList, shapeCompareFunc);
    },
    _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
      if (el.ignore && !includeIgnore) {
        return;
      }

      el.beforeUpdate();

      if (el.__dirty) {
        el.update();
      }

      el.afterUpdate();
      var userSetClipPath = el.clipPath;

      if (userSetClipPath) {
        // FIXME æçå½±å
        if (clipPaths) {
          clipPaths = clipPaths.slice();
        } else {
          clipPaths = [];
        }

        var currentClipPath = userSetClipPath;
        var parentClipPath = el; // Recursively add clip path

        while (currentClipPath) {
          // clipPath çåæ¢æ¯åºäºä½¿ç¨è¿ä¸ª clipPath çåç´ 
          currentClipPath.parent = parentClipPath;
          currentClipPath.updateTransform();
          clipPaths.push(currentClipPath);
          parentClipPath = currentClipPath;
          currentClipPath = currentClipPath.clipPath;
        }
      }

      if (el.isGroup) {
        var children = el._children;

        for (var i = 0; i < children.length; i++) {
          var child = children[i]; // Force to mark as dirty if group is dirty
          // FIXME __dirtyPath ?

          if (el.__dirty) {
            child.__dirty = true;
          }

          this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
        } // Mark group clean here


        el.__dirty = false;
      } else {
        el.__clipPaths = clipPaths;
        this._displayList[this._displayListLen++] = el;
      }
    },

    /**
     * æ·»å å¾å½¢(Shape)æèç»(Group)å°æ ¹èç¹
     * @param {module:zrender/Element} el
     */
    addRoot: function (el) {
      if (el.__storage === this) {
        return;
      }

      if (el instanceof Group_1) {
        el.addChildrenToStorage(this);
      }

      this.addToStorage(el);

      this._roots.push(el);
    },

    /**
     * å é¤æå®çå¾å½¢(Shape)æèç»(Group)
     * @param {string|Array.<string>} [el] å¦æä¸ºç©ºæ¸ç©ºæ´ä¸ªStorage
     */
    delRoot: function (el) {
      if (el == null) {
        // ä¸æå®elæ¸ç©º
        for (var i = 0; i < this._roots.length; i++) {
          var root = this._roots[i];

          if (root instanceof Group_1) {
            root.delChildrenFromStorage(this);
          }
        }

        this._roots = [];
        this._displayList = [];
        this._displayListLen = 0;
        return;
      }

      if (el instanceof Array) {
        for (var i = 0, l = el.length; i < l; i++) {
          this.delRoot(el[i]);
        }

        return;
      }

      var idx = util.indexOf(this._roots, el);

      if (idx >= 0) {
        this.delFromStorage(el);

        this._roots.splice(idx, 1);

        if (el instanceof Group_1) {
          el.delChildrenFromStorage(this);
        }
      }
    },
    addToStorage: function (el) {
      if (el) {
        el.__storage = this;
        el.dirty(false);
      }

      return this;
    },
    delFromStorage: function (el) {
      if (el) {
        el.__storage = null;
      }

      return this;
    },

    /**
     * æ¸ç©ºå¹¶ä¸éæ¾Storage
     */
    dispose: function () {
      this._renderList = this._roots = null;
    },
    displayableSortFunc: shapeCompareFunc
  };
  var _default$g = Storage;
  var Storage_1 = _default$g;

  var SHADOW_PROPS = {
    'shadowBlur': 1,
    'shadowOffsetX': 1,
    'shadowOffsetY': 1,
    'textShadowBlur': 1,
    'textShadowOffsetX': 1,
    'textShadowOffsetY': 1,
    'textBoxShadowBlur': 1,
    'textBoxShadowOffsetX': 1,
    'textBoxShadowOffsetY': 1
  };

  function _default$h(ctx, propName, value) {
    if (SHADOW_PROPS.hasOwnProperty(propName)) {
      return value *= ctx.dpr;
    }

    return value;
  }

  var fixShadow = _default$h;

  var ContextCachedBy = {
    NONE: 0,
    STYLE_BIND: 1,
    PLAIN_TEXT: 2
  }; // Avoid confused with 0/false.

  var WILL_BE_RESTORED = 9;
  var ContextCachedBy_1 = ContextCachedBy;
  var WILL_BE_RESTORED_1 = WILL_BE_RESTORED;

  var constant = {
  	ContextCachedBy: ContextCachedBy_1,
  	WILL_BE_RESTORED: WILL_BE_RESTORED_1
  };

  var ContextCachedBy$1 = constant.ContextCachedBy;
  var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
  // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);

  var Style = function (opts) {
    this.extendFrom(opts, false);
  };

  function createLinearGradient(ctx, obj, rect) {
    var x = obj.x == null ? 0 : obj.x;
    var x2 = obj.x2 == null ? 1 : obj.x2;
    var y = obj.y == null ? 0 : obj.y;
    var y2 = obj.y2 == null ? 0 : obj.y2;

    if (!obj.global) {
      x = x * rect.width + rect.x;
      x2 = x2 * rect.width + rect.x;
      y = y * rect.height + rect.y;
      y2 = y2 * rect.height + rect.y;
    } // Fix NaN when rect is Infinity


    x = isNaN(x) ? 0 : x;
    x2 = isNaN(x2) ? 1 : x2;
    y = isNaN(y) ? 0 : y;
    y2 = isNaN(y2) ? 0 : y2;
    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
    return canvasGradient;
  }

  function createRadialGradient(ctx, obj, rect) {
    var width = rect.width;
    var height = rect.height;
    var min = Math.min(width, height);
    var x = obj.x == null ? 0.5 : obj.x;
    var y = obj.y == null ? 0.5 : obj.y;
    var r = obj.r == null ? 0.5 : obj.r;

    if (!obj.global) {
      x = x * width + rect.x;
      y = y * height + rect.y;
      r = r * min;
    }

    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
    return canvasGradient;
  }

  Style.prototype = {
    constructor: Style,

    /**
     * @type {string}
     */
    fill: '#000',

    /**
     * @type {string}
     */
    stroke: null,

    /**
     * @type {number}
     */
    opacity: 1,

    /**
     * @type {number}
     */
    fillOpacity: null,

    /**
     * @type {number}
     */
    strokeOpacity: null,

    /**
     * `true` is not supported.
     * `false`/`null`/`undefined` are the same.
     * `false` is used to remove lineDash in some
     * case that `null`/`undefined` can not be set.
     * (e.g., emphasis.lineStyle in echarts)
     * @type {Array.<number>|boolean}
     */
    lineDash: null,

    /**
     * @type {number}
     */
    lineDashOffset: 0,

    /**
     * @type {number}
     */
    shadowBlur: 0,

    /**
     * @type {number}
     */
    shadowOffsetX: 0,

    /**
     * @type {number}
     */
    shadowOffsetY: 0,

    /**
     * @type {number}
     */
    lineWidth: 1,

    /**
     * If stroke ignore scale
     * @type {Boolean}
     */
    strokeNoScale: false,
    // Bounding rect text configuration
    // Not affected by element transform

    /**
     * @type {string}
     */
    text: null,

    /**
     * If `fontSize` or `fontFamily` exists, `font` will be reset by
     * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
     * So do not visit it directly in upper application (like echarts),
     * but use `contain/text#makeFont` instead.
     * @type {string}
     */
    font: null,

    /**
     * The same as font. Use font please.
     * @deprecated
     * @type {string}
     */
    textFont: null,

    /**
     * It helps merging respectively, rather than parsing an entire font string.
     * @type {string}
     */
    fontStyle: null,

    /**
     * It helps merging respectively, rather than parsing an entire font string.
     * @type {string}
     */
    fontWeight: null,

    /**
     * It helps merging respectively, rather than parsing an entire font string.
     * Should be 12 but not '12px'.
     * @type {number}
     */
    fontSize: null,

    /**
     * It helps merging respectively, rather than parsing an entire font string.
     * @type {string}
     */
    fontFamily: null,

    /**
     * Reserved for special functinality, like 'hr'.
     * @type {string}
     */
    textTag: null,

    /**
     * @type {string}
     */
    textFill: '#000',

    /**
     * @type {string}
     */
    textStroke: null,

    /**
     * @type {number}
     */
    textWidth: null,

    /**
     * Only for textBackground.
     * @type {number}
     */
    textHeight: null,

    /**
     * textStroke may be set as some color as a default
     * value in upper applicaion, where the default value
     * of textStrokeWidth should be 0 to make sure that
     * user can choose to do not use text stroke.
     * @type {number}
     */
    textStrokeWidth: 0,

    /**
     * @type {number}
     */
    textLineHeight: null,

    /**
     * 'inside', 'left', 'right', 'top', 'bottom'
     * [x, y]
     * Based on x, y of rect.
     * @type {string|Array.<number>}
     * @default 'inside'
     */
    textPosition: 'inside',

    /**
     * If not specified, use the boundingRect of a `displayable`.
     * @type {Object}
     */
    textRect: null,

    /**
     * [x, y]
     * @type {Array.<number>}
     */
    textOffset: null,

    /**
     * @type {string}
     */
    textAlign: null,

    /**
     * @type {string}
     */
    textVerticalAlign: null,

    /**
     * @type {number}
     */
    textDistance: 5,

    /**
     * @type {string}
     */
    textShadowColor: 'transparent',

    /**
     * @type {number}
     */
    textShadowBlur: 0,

    /**
     * @type {number}
     */
    textShadowOffsetX: 0,

    /**
     * @type {number}
     */
    textShadowOffsetY: 0,

    /**
     * @type {string}
     */
    textBoxShadowColor: 'transparent',

    /**
     * @type {number}
     */
    textBoxShadowBlur: 0,

    /**
     * @type {number}
     */
    textBoxShadowOffsetX: 0,

    /**
     * @type {number}
     */
    textBoxShadowOffsetY: 0,

    /**
     * Whether transform text.
     * Only available in Path and Image element,
     * where the text is called as `RectText`.
     * @type {boolean}
     */
    transformText: false,

    /**
     * Text rotate around position of Path or Image.
     * The origin of the rotation can be specified by `textOrigin`.
     * Only available in Path and Image element,
     * where the text is called as `RectText`.
     */
    textRotation: 0,

    /**
     * Text origin of text rotation.
     * Useful in the case like label rotation of circular symbol.
     * Only available in Path and Image element, where the text is called
     * as `RectText` and the element is called as "host element".
     * The value can be:
     * + If specified as a coordinate like `[10, 40]`, it is the `[x, y]`
     * base on the left-top corner of the rect of its host element.
     * + If specified as a string `center`, it is the center of the rect of
     * its host element.
     * + By default, this origin is the `textPosition`.
     * @type {string|Array.<number>}
     */
    textOrigin: null,

    /**
     * @type {string}
     */
    textBackgroundColor: null,

    /**
     * @type {string}
     */
    textBorderColor: null,

    /**
     * @type {number}
     */
    textBorderWidth: 0,

    /**
     * @type {number}
     */
    textBorderRadius: 0,

    /**
     * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
     * @type {number|Array.<number>}
     */
    textPadding: null,

    /**
     * Text styles for rich text.
     * @type {Object}
     */
    rich: null,

    /**
     * {outerWidth, outerHeight, ellipsis, placeholder}
     * @type {Object}
     */
    truncate: null,

    /**
     * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
     * @type {string}
     */
    blend: null,

    /**
     * @param {CanvasRenderingContext2D} ctx
     */
    bind: function (ctx, el, prevEl) {
      var style = this;
      var prevStyle = prevEl && prevEl.style; // If no prevStyle, it means first draw.
      // Only apply cache if the last time cachced by this function.

      var notCheckCache = !prevStyle || ctx.__attrCachedBy !== ContextCachedBy$1.STYLE_BIND;
      ctx.__attrCachedBy = ContextCachedBy$1.STYLE_BIND;

      for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
        var prop = STYLE_COMMON_PROPS[i];
        var styleName = prop[0];

        if (notCheckCache || style[styleName] !== prevStyle[styleName]) {
          // FIXME Invalid property value will cause style leak from previous element.
          ctx[styleName] = fixShadow(ctx, styleName, style[styleName] || prop[1]);
        }
      }

      if (notCheckCache || style.fill !== prevStyle.fill) {
        ctx.fillStyle = style.fill;
      }

      if (notCheckCache || style.stroke !== prevStyle.stroke) {
        ctx.strokeStyle = style.stroke;
      }

      if (notCheckCache || style.opacity !== prevStyle.opacity) {
        ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
      }

      if (notCheckCache || style.blend !== prevStyle.blend) {
        ctx.globalCompositeOperation = style.blend || 'source-over';
      }

      if (this.hasStroke()) {
        var lineWidth = style.lineWidth;
        ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
      }
    },
    hasFill: function () {
      var fill = this.fill;
      return fill != null && fill !== 'none';
    },
    hasStroke: function () {
      var stroke = this.stroke;
      return stroke != null && stroke !== 'none' && this.lineWidth > 0;
    },

    /**
     * Extend from other style
     * @param {zrender/graphic/Style} otherStyle
     * @param {boolean} overwrite true: overwrirte any way.
     *                            false: overwrite only when !target.hasOwnProperty
     *                            others: overwrite when property is not null/undefined.
     */
    extendFrom: function (otherStyle, overwrite) {
      if (otherStyle) {
        for (var name in otherStyle) {
          if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
            this[name] = otherStyle[name];
          }
        }
      }
    },

    /**
     * Batch setting style with a given object
     * @param {Object|string} obj
     * @param {*} [obj]
     */
    set: function (obj, value) {
      if (typeof obj === 'string') {
        this[obj] = value;
      } else {
        this.extendFrom(obj, true);
      }
    },

    /**
     * Clone
     * @return {zrender/graphic/Style} [description]
     */
    clone: function () {
      var newStyle = new this.constructor();
      newStyle.extendFrom(this, true);
      return newStyle;
    },
    getGradient: function (ctx, obj, rect) {
      var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
      var canvasGradient = method(ctx, obj, rect);
      var colorStops = obj.colorStops;

      for (var i = 0; i < colorStops.length; i++) {
        canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
      }

      return canvasGradient;
    }
  };
  var styleProto = Style.prototype;

  for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
    var prop = STYLE_COMMON_PROPS[i];

    if (!(prop[0] in styleProto)) {
      styleProto[prop[0]] = prop[1];
    }
  } // Provide for others


  Style.getGradient = styleProto.getGradient;
  var _default$i = Style;
  var Style_1 = _default$i;

  var Pattern = function (image, repeat) {
    // Should do nothing more in this constructor. Because gradient can be
    // declard by `color: {image: ...}`, where this constructor will not be called.
    this.image = image;
    this.repeat = repeat; // Can be cloned

    this.type = 'pattern';
  };

  Pattern.prototype.getCanvasPattern = function (ctx) {
    return ctx.createPattern(this.image, this.repeat || 'repeat');
  };

  var _default$j = Pattern;
  var Pattern_1 = _default$j;

  var devicePixelRatio$1 = config.devicePixelRatio;





  /**
   * @module zrender/Layer
   * @author pissang(https://www.github.com/pissang)
   */
  function returnFalse() {
    return false;
  }
  /**
   * åå»ºdom
   *
   * @inner
   * @param {string} id dom id å¾ç¨
   * @param {Painter} painter painter instance
   * @param {number} number
   */


  function createDom(id, painter, dpr) {
    var newDom = util.createCanvas();
    var width = painter.getWidth();
    var height = painter.getHeight();
    var newDomStyle = newDom.style;

    if (newDomStyle) {
      // In node or some other non-browser environment
      newDomStyle.position = 'absolute';
      newDomStyle.left = 0;
      newDomStyle.top = 0;
      newDomStyle.width = width + 'px';
      newDomStyle.height = height + 'px';
      newDom.setAttribute('data-zr-dom-id', id);
    }

    newDom.width = width * dpr;
    newDom.height = height * dpr;
    return newDom;
  }
  /**
   * @alias module:zrender/Layer
   * @constructor
   * @extends module:zrender/mixin/Transformable
   * @param {string} id
   * @param {module:zrender/Painter} painter
   * @param {number} [dpr]
   */


  var Layer = function (id, painter, dpr) {
    var dom;
    dpr = dpr || devicePixelRatio$1;

    if (typeof id === 'string') {
      dom = createDom(id, painter, dpr);
    } // Not using isDom because in node it will return false
    else if (util.isObject(id)) {
        dom = id;
        id = dom.id;
      }

    this.id = id;
    this.dom = dom;
    var domStyle = dom.style;

    if (domStyle) {
      // Not in node
      dom.onselectstart = returnFalse; // é¿åé¡µé¢éä¸­çå°´å°¬

      domStyle['-webkit-user-select'] = 'none';
      domStyle['user-select'] = 'none';
      domStyle['-webkit-touch-callout'] = 'none';
      domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
      domStyle['padding'] = 0; // eslint-disable-line dot-notation

      domStyle['margin'] = 0; // eslint-disable-line dot-notation

      domStyle['border-width'] = 0;
    }

    this.domBack = null;
    this.ctxBack = null;
    this.painter = painter;
    this.config = null; // Configs

    /**
     * æ¯æ¬¡æ¸ç©ºç»å¸çé¢è²
     * @type {string}
     * @default 0
     */

    this.clearColor = 0;
    /**
     * æ¯å¦å¼å¯å¨ææ¨¡ç³
     * @type {boolean}
     * @default false
     */

    this.motionBlur = false;
    /**
     * å¨å¼å¯å¨ææ¨¡ç³çæ¶åä½¿ç¨ï¼ä¸ä¸ä¸å¸§æ··åçalphaå¼ï¼å¼è¶å¤§å°¾è¿¹è¶ææ¾
     * @type {number}
     * @default 0.7
     */

    this.lastFrameAlpha = 0.7;
    /**
     * Layer dpr
     * @type {number}
     */

    this.dpr = dpr;
  };

  Layer.prototype = {
    constructor: Layer,
    __dirty: true,
    __used: false,
    __drawIndex: 0,
    __startIndex: 0,
    __endIndex: 0,
    incremental: false,
    getElementCount: function () {
      return this.__endIndex - this.__startIndex;
    },
    initContext: function () {
      this.ctx = this.dom.getContext('2d');
      this.ctx.dpr = this.dpr;
    },
    createBackBuffer: function () {
      var dpr = this.dpr;
      this.domBack = createDom('back-' + this.id, this.painter, dpr);
      this.ctxBack = this.domBack.getContext('2d');

      if (dpr !== 1) {
        this.ctxBack.scale(dpr, dpr);
      }
    },

    /**
     * @param  {number} width
     * @param  {number} height
     */
    resize: function (width, height) {
      var dpr = this.dpr;
      var dom = this.dom;
      var domStyle = dom.style;
      var domBack = this.domBack;

      if (domStyle) {
        domStyle.width = width + 'px';
        domStyle.height = height + 'px';
      }

      dom.width = width * dpr;
      dom.height = height * dpr;

      if (domBack) {
        domBack.width = width * dpr;
        domBack.height = height * dpr;

        if (dpr !== 1) {
          this.ctxBack.scale(dpr, dpr);
        }
      }
    },

    /**
     * æ¸ç©ºè¯¥å±ç»å¸
     * @param {boolean} [clearAll]=false Clear all with out motion blur
     * @param {Color} [clearColor]
     */
    clear: function (clearAll, clearColor) {
      var dom = this.dom;
      var ctx = this.ctx;
      var width = dom.width;
      var height = dom.height;
      var clearColor = clearColor || this.clearColor;
      var haveMotionBLur = this.motionBlur && !clearAll;
      var lastFrameAlpha = this.lastFrameAlpha;
      var dpr = this.dpr;

      if (haveMotionBLur) {
        if (!this.domBack) {
          this.createBackBuffer();
        }

        this.ctxBack.globalCompositeOperation = 'copy';
        this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
      }

      ctx.clearRect(0, 0, width, height);

      if (clearColor && clearColor !== 'transparent') {
        var clearColorGradientOrPattern; // Gradient

        if (clearColor.colorStops) {
          // Cache canvas gradient
          clearColorGradientOrPattern = clearColor.__canvasGradient || Style_1.getGradient(ctx, clearColor, {
            x: 0,
            y: 0,
            width: width,
            height: height
          });
          clearColor.__canvasGradient = clearColorGradientOrPattern;
        } // Pattern
        else if (clearColor.image) {
            clearColorGradientOrPattern = Pattern_1.prototype.getCanvasPattern.call(clearColor, ctx);
          }

        ctx.save();
        ctx.fillStyle = clearColorGradientOrPattern || clearColor;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      if (haveMotionBLur) {
        var domBack = this.domBack;
        ctx.save();
        ctx.globalAlpha = lastFrameAlpha;
        ctx.drawImage(domBack, 0, 0, width, height);
        ctx.restore();
      }
    }
  };
  var _default$k = Layer;
  var Layer_1 = _default$k;

  var _default$l = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
  window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
    setTimeout(func, 16);
  };

  var requestAnimationFrame = _default$l;

  var globalImageCache = new LRU_1(50);
  /**
   * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
   * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
   */

  function findExistImage(newImageOrSrc) {
    if (typeof newImageOrSrc === 'string') {
      var cachedImgObj = globalImageCache.get(newImageOrSrc);
      return cachedImgObj && cachedImgObj.image;
    } else {
      return newImageOrSrc;
    }
  }
  /**
   * Caution: User should cache loaded images, but not just count on LRU.
   * Consider if required images more than LRU size, will dead loop occur?
   *
   * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
   * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
   * @param {module:zrender/Element} [hostEl] For calling `dirty`.
   * @param {Function} [cb] params: (image, cbPayload)
   * @param {Object} [cbPayload] Payload on cb calling.
   * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
   */


  function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
    if (!newImageOrSrc) {
      return image;
    } else if (typeof newImageOrSrc === 'string') {
      // Image should not be loaded repeatly.
      if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
        return image;
      } // Only when there is no existent image or existent image src
      // is different, this method is responsible for load.


      var cachedImgObj = globalImageCache.get(newImageOrSrc);
      var pendingWrap = {
        hostEl: hostEl,
        cb: cb,
        cbPayload: cbPayload
      };

      if (cachedImgObj) {
        image = cachedImgObj.image;
        !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
      } else {
        image = new Image();
        image.onload = image.onerror = imageOnLoad;
        globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
          image: image,
          pending: [pendingWrap]
        });
        image.src = image.__zrImageSrc = newImageOrSrc;
      }

      return image;
    } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
    else {
        return newImageOrSrc;
      }
  }

  function imageOnLoad() {
    var cachedImgObj = this.__cachedImgObj;
    this.onload = this.onerror = this.__cachedImgObj = null;

    for (var i = 0; i < cachedImgObj.pending.length; i++) {
      var pendingWrap = cachedImgObj.pending[i];
      var cb = pendingWrap.cb;
      cb && cb(this, pendingWrap.cbPayload);
      pendingWrap.hostEl.dirty();
    }

    cachedImgObj.pending.length = 0;
  }

  function isImageReady(image) {
    return image && image.width && image.height;
  }

  var findExistImage_1 = findExistImage;
  var createOrUpdateImage_1 = createOrUpdateImage;
  var isImageReady_1 = isImageReady;

  var image = {
  	findExistImage: findExistImage_1,
  	createOrUpdateImage: createOrUpdateImage_1,
  	isImageReady: isImageReady_1
  };

  var getContext$1 = util.getContext;
  var extend$3 = util.extend;
  var retrieve2$1 = util.retrieve2;
  var retrieve3$1 = util.retrieve3;
  var trim$2 = util.trim;
  var textWidthCache = {};
  var textWidthCacheCounter = 0;
  var TEXT_CACHE_MAX = 5000;
  var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
  var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.

  var methods$1 = {};

  function $override$1(name, fn) {
    methods$1[name] = fn;
  }
  /**
   * @public
   * @param {string} text
   * @param {string} font
   * @return {number} width
   */


  function getWidth(text, font) {
    font = font || DEFAULT_FONT;
    var key = text + ':' + font;

    if (textWidthCache[key]) {
      return textWidthCache[key];
    }

    var textLines = (text + '').split('\n');
    var width = 0;

    for (var i = 0, l = textLines.length; i < l; i++) {
      // textContain.measureText may be overrided in SVG or VML
      width = Math.max(measureText(textLines[i], font).width, width);
    }

    if (textWidthCacheCounter > TEXT_CACHE_MAX) {
      textWidthCacheCounter = 0;
      textWidthCache = {};
    }

    textWidthCacheCounter++;
    textWidthCache[key] = width;
    return width;
  }
  /**
   * @public
   * @param {string} text
   * @param {string} font
   * @param {string} [textAlign='left']
   * @param {string} [textVerticalAlign='top']
   * @param {Array.<number>} [textPadding]
   * @param {Object} [rich]
   * @param {Object} [truncate]
   * @return {Object} {x, y, width, height, lineHeight}
   */


  function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
    return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);
  }

  function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {
    var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);
    var outerWidth = getWidth(text, font);

    if (textPadding) {
      outerWidth += textPadding[1] + textPadding[3];
    }

    var outerHeight = contentBlock.outerHeight;
    var x = adjustTextX(0, outerWidth, textAlign);
    var y = adjustTextY(0, outerHeight, textVerticalAlign);
    var rect = new BoundingRect_1(x, y, outerWidth, outerHeight);
    rect.lineHeight = contentBlock.lineHeight;
    return rect;
  }

  function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
    var contentBlock = parseRichText(text, {
      rich: rich,
      truncate: truncate,
      font: font,
      textAlign: textAlign,
      textPadding: textPadding,
      textLineHeight: textLineHeight
    });
    var outerWidth = contentBlock.outerWidth;
    var outerHeight = contentBlock.outerHeight;
    var x = adjustTextX(0, outerWidth, textAlign);
    var y = adjustTextY(0, outerHeight, textVerticalAlign);
    return new BoundingRect_1(x, y, outerWidth, outerHeight);
  }
  /**
   * @public
   * @param {number} x
   * @param {number} width
   * @param {string} [textAlign='left']
   * @return {number} Adjusted x.
   */


  function adjustTextX(x, width, textAlign) {
    // FIXME Right to left language
    if (textAlign === 'right') {
      x -= width;
    } else if (textAlign === 'center') {
      x -= width / 2;
    }

    return x;
  }
  /**
   * @public
   * @param {number} y
   * @param {number} height
   * @param {string} [textVerticalAlign='top']
   * @return {number} Adjusted y.
   */


  function adjustTextY(y, height, textVerticalAlign) {
    if (textVerticalAlign === 'middle') {
      y -= height / 2;
    } else if (textVerticalAlign === 'bottom') {
      y -= height;
    }

    return y;
  }
  /**
   * Follow same interface to `Displayable.prototype.calculateTextPosition`.
   * @public
   * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.
   * @param {module:zrender/graphic/Style} style where `textPosition` and `textDistance` are visited.
   * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.
   * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}
   */


  function calculateTextPosition(out, style, rect) {
    var textPosition = style.textPosition;
    var distance = style.textDistance;
    var x = rect.x;
    var y = rect.y;
    distance = distance || 0;
    var height = rect.height;
    var width = rect.width;
    var halfHeight = height / 2;
    var textAlign = 'left';
    var textVerticalAlign = 'top';

    switch (textPosition) {
      case 'left':
        x -= distance;
        y += halfHeight;
        textAlign = 'right';
        textVerticalAlign = 'middle';
        break;

      case 'right':
        x += distance + width;
        y += halfHeight;
        textVerticalAlign = 'middle';
        break;

      case 'top':
        x += width / 2;
        y -= distance;
        textAlign = 'center';
        textVerticalAlign = 'bottom';
        break;

      case 'bottom':
        x += width / 2;
        y += height + distance;
        textAlign = 'center';
        break;

      case 'inside':
        x += width / 2;
        y += halfHeight;
        textAlign = 'center';
        textVerticalAlign = 'middle';
        break;

      case 'insideLeft':
        x += distance;
        y += halfHeight;
        textVerticalAlign = 'middle';
        break;

      case 'insideRight':
        x += width - distance;
        y += halfHeight;
        textAlign = 'right';
        textVerticalAlign = 'middle';
        break;

      case 'insideTop':
        x += width / 2;
        y += distance;
        textAlign = 'center';
        break;

      case 'insideBottom':
        x += width / 2;
        y += height - distance;
        textAlign = 'center';
        textVerticalAlign = 'bottom';
        break;

      case 'insideTopLeft':
        x += distance;
        y += distance;
        break;

      case 'insideTopRight':
        x += width - distance;
        y += distance;
        textAlign = 'right';
        break;

      case 'insideBottomLeft':
        x += distance;
        y += height - distance;
        textVerticalAlign = 'bottom';
        break;

      case 'insideBottomRight':
        x += width - distance;
        y += height - distance;
        textAlign = 'right';
        textVerticalAlign = 'bottom';
        break;
    }

    out = out || {};
    out.x = x;
    out.y = y;
    out.textAlign = textAlign;
    out.textVerticalAlign = textVerticalAlign;
    return out;
  }
  /**
   * To be removed. But still do not remove in case that some one has imported it.
   * @deprecated
   * @public
   * @param {stirng} textPosition
   * @param {Object} rect {x, y, width, height}
   * @param {number} distance
   * @return {Object} {x, y, textAlign, textVerticalAlign}
   */


  function adjustTextPositionOnRect(textPosition, rect, distance) {
    var dummyStyle = {
      textPosition: textPosition,
      textDistance: distance
    };
    return calculateTextPosition({}, dummyStyle, rect);
  }
  /**
   * Show ellipsis if overflow.
   *
   * @public
   * @param  {string} text
   * @param  {string} containerWidth
   * @param  {string} font
   * @param  {number} [ellipsis='...']
   * @param  {Object} [options]
   * @param  {number} [options.maxIterations=3]
   * @param  {number} [options.minChar=0] If truncate result are less
   *                  then minChar, ellipsis will not show, which is
   *                  better for user hint in some cases.
   * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
   * @return {string}
   */


  function truncateText(text, containerWidth, font, ellipsis, options) {
    if (!containerWidth) {
      return '';
    }

    var textLines = (text + '').split('\n');
    options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
    // It is not appropriate that every line has '...' when truncate multiple lines.

    for (var i = 0, len = textLines.length; i < len; i++) {
      textLines[i] = truncateSingleLine(textLines[i], options);
    }

    return textLines.join('\n');
  }

  function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
    options = extend$3({}, options);
    options.font = font;
    var ellipsis = retrieve2$1(ellipsis, '...');
    options.maxIterations = retrieve2$1(options.maxIterations, 2);
    var minChar = options.minChar = retrieve2$1(options.minChar, 0); // FIXME
    // Other languages?

    options.cnCharWidth = getWidth('å½', font); // FIXME
    // Consider proportional font?

    var ascCharWidth = options.ascCharWidth = getWidth('a', font);
    options.placeholder = retrieve2$1(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
    // Example 2: minChar: 3, text: 'ç»´åº¦', truncate result: 'ç»´', but not: '...'.

    var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.

    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
      contentWidth -= ascCharWidth;
    }

    var ellipsisWidth = getWidth(ellipsis, font);

    if (ellipsisWidth > contentWidth) {
      ellipsis = '';
      ellipsisWidth = 0;
    }

    contentWidth = containerWidth - ellipsisWidth;
    options.ellipsis = ellipsis;
    options.ellipsisWidth = ellipsisWidth;
    options.contentWidth = contentWidth;
    options.containerWidth = containerWidth;
    return options;
  }

  function truncateSingleLine(textLine, options) {
    var containerWidth = options.containerWidth;
    var font = options.font;
    var contentWidth = options.contentWidth;

    if (!containerWidth) {
      return '';
    }

    var lineWidth = getWidth(textLine, font);

    if (lineWidth <= containerWidth) {
      return textLine;
    }

    for (var j = 0;; j++) {
      if (lineWidth <= contentWidth || j >= options.maxIterations) {
        textLine += options.ellipsis;
        break;
      }

      var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
      textLine = textLine.substr(0, subLength);
      lineWidth = getWidth(textLine, font);
    }

    if (textLine === '') {
      textLine = options.placeholder;
    }

    return textLine;
  }

  function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
    var width = 0;
    var i = 0;

    for (var len = text.length; i < len && width < contentWidth; i++) {
      var charCode = text.charCodeAt(i);
      width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
    }

    return i;
  }
  /**
   * @public
   * @param {string} font
   * @return {number} line height
   */


  function getLineHeight(font) {
    // FIXME A rough approach.
    return getWidth('å½', font);
  }
  /**
   * @public
   * @param {string} text
   * @param {string} font
   * @return {Object} width
   */


  function measureText(text, font) {
    return methods$1.measureText(text, font);
  } // Avoid assign to an exported variable, for transforming to cjs.


  methods$1.measureText = function (text, font) {
    var ctx = getContext$1();
    ctx.font = font || DEFAULT_FONT;
    return ctx.measureText(text);
  };
  /**
   * @public
   * @param {string} text
   * @param {string} font
   * @param {Object} [truncate]
   * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}
   *  Notice: for performance, do not calculate outerWidth util needed.
   *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.
   *  Thus we can simply comparing the `input` text to determin whether the result changed,
   *  without travel the result `lines`.
   */


  function parsePlainText(text, font, padding, textLineHeight, truncate) {
    text != null && (text += '');
    var lineHeight = retrieve2$1(textLineHeight, getLineHeight(font));
    var lines = text ? text.split('\n') : [];
    var height = lines.length * lineHeight;
    var outerHeight = height;
    var canCacheByTextString = true;

    if (padding) {
      outerHeight += padding[0] + padding[2];
    }

    if (text && truncate) {
      canCacheByTextString = false;
      var truncOuterHeight = truncate.outerHeight;
      var truncOuterWidth = truncate.outerWidth;

      if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
        text = '';
        lines = [];
      } else if (truncOuterWidth != null) {
        var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
          minChar: truncate.minChar,
          placeholder: truncate.placeholder
        }); // FIXME
        // It is not appropriate that every line has '...' when truncate multiple lines.

        for (var i = 0, len = lines.length; i < len; i++) {
          lines[i] = truncateSingleLine(lines[i], options);
        }
      }
    }

    return {
      lines: lines,
      height: height,
      outerHeight: outerHeight,
      lineHeight: lineHeight,
      canCacheByTextString: canCacheByTextString
    };
  }
  /**
   * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
   * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
   *
   * @public
   * @param {string} text
   * @param {Object} style
   * @return {Object} block
   * {
   *      width,
   *      height,
   *      lines: [{
   *          lineHeight,
   *          width,
   *          tokens: [[{
   *              styleName,
   *              text,
   *              width,      // include textPadding
   *              height,     // include textPadding
   *              textWidth, // pure text width
   *              textHeight, // pure text height
   *              lineHeihgt,
   *              font,
   *              textAlign,
   *              textVerticalAlign
   *          }], [...], ...]
   *      }, ...]
   * }
   * If styleName is undefined, it is plain text.
   */


  function parseRichText(text, style) {
    var contentBlock = {
      lines: [],
      width: 0,
      height: 0
    };
    text != null && (text += '');

    if (!text) {
      return contentBlock;
    }

    var lastIndex = STYLE_REG.lastIndex = 0;
    var result;

    while ((result = STYLE_REG.exec(text)) != null) {
      var matchedIndex = result.index;

      if (matchedIndex > lastIndex) {
        pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
      }

      pushTokens(contentBlock, result[2], result[1]);
      lastIndex = STYLE_REG.lastIndex;
    }

    if (lastIndex < text.length) {
      pushTokens(contentBlock, text.substring(lastIndex, text.length));
    }

    var lines = contentBlock.lines;
    var contentHeight = 0;
    var contentWidth = 0; // For `textWidth: 100%`

    var pendingList = [];
    var stlPadding = style.textPadding;
    var truncate = style.truncate;
    var truncateWidth = truncate && truncate.outerWidth;
    var truncateHeight = truncate && truncate.outerHeight;

    if (stlPadding) {
      truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
      truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
    } // Calculate layout info of tokens.


    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      var lineHeight = 0;
      var lineWidth = 0;

      for (var j = 0; j < line.tokens.length; j++) {
        var token = line.tokens[j];
        var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.

        var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.

        var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.

        var tokenHeight = token.textHeight = retrieve2$1( // textHeight should not be inherited, consider it can be specified
        // as box height of the block.
        tokenStyle.textHeight, getLineHeight(font));
        textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
        token.height = tokenHeight;
        token.lineHeight = retrieve3$1(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
        token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
        token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';

        if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
          return {
            lines: [],
            width: 0,
            height: 0
          };
        }

        token.textWidth = getWidth(token.text, font);
        var tokenWidth = tokenStyle.textWidth;
        var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
        // line when box width is needed to be auto.

        if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
          token.percentWidth = tokenWidth;
          pendingList.push(token);
          tokenWidth = 0; // Do not truncate in this case, because there is no user case
          // and it is too complicated.
        } else {
          if (tokenWidthNotSpecified) {
            tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
            // `getBoundingRect()` will not get correct result.

            var textBackgroundColor = tokenStyle.textBackgroundColor;
            var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
            // (1) If image is not loaded, it will be loaded at render phase and call
            // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
            // image, and then the right size will be calculated here at the next tick.
            // See `graphic/helper/text.js`.
            // (2) If image loaded, and `textBackgroundColor.image` is image src string,
            // use `imageHelper.findExistImage` to find cached image.
            // `imageHelper.findExistImage` will always be called here before
            // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
            // which ensures that image will not be rendered before correct size calcualted.

            if (bgImg) {
              bgImg = image.findExistImage(bgImg);

              if (image.isImageReady(bgImg)) {
                tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
              }
            }
          }

          var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
          tokenWidth += paddingW;
          var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;

          if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
            if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
              token.text = '';
              token.textWidth = tokenWidth = 0;
            } else {
              token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
                minChar: truncate.minChar
              });
              token.textWidth = getWidth(token.text, font);
              tokenWidth = token.textWidth + paddingW;
            }
          }
        }

        lineWidth += token.width = tokenWidth;
        tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
      }

      line.width = lineWidth;
      line.lineHeight = lineHeight;
      contentHeight += lineHeight;
      contentWidth = Math.max(contentWidth, lineWidth);
    }

    contentBlock.outerWidth = contentBlock.width = retrieve2$1(style.textWidth, contentWidth);
    contentBlock.outerHeight = contentBlock.height = retrieve2$1(style.textHeight, contentHeight);

    if (stlPadding) {
      contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
      contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
    }

    for (var i = 0; i < pendingList.length; i++) {
      var token = pendingList[i];
      var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.

      token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
    }

    return contentBlock;
  }

  function pushTokens(block, str, styleName) {
    var isEmptyStr = str === '';
    var strs = str.split('\n');
    var lines = block.lines;

    for (var i = 0; i < strs.length; i++) {
      var text = strs[i];
      var token = {
        styleName: styleName,
        text: text,
        isLineHolder: !text && !isEmptyStr
      }; // The first token should be appended to the last line.

      if (!i) {
        var tokens = (lines[lines.length - 1] || (lines[0] = {
          tokens: []
        })).tokens; // Consider cases:
        // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
        // (which is a placeholder) should be replaced by new token.
        // (2) A image backage, where token likes {a|}.
        // (3) A redundant '' will affect textAlign in line.
        // (4) tokens with the same tplName should not be merged, because
        // they should be displayed in different box (with border and padding).

        var tokensLen = tokens.length;
        tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
        // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
        (text || !tokensLen || isEmptyStr) && tokens.push(token);
      } // Other tokens always start a new line.
      else {
          // If there is '', insert it as a placeholder.
          lines.push({
            tokens: [token]
          });
        }
    }
  }

  function makeFont(style) {
    // FIXME in node-canvas fontWeight is before fontStyle
    // Use `fontSize` `fontFamily` to check whether font properties are defined.
    var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
    style.fontFamily || 'sans-serif'].join(' ');
    return font && trim$2(font) || style.textFont || style.font;
  }

  var DEFAULT_FONT_1 = DEFAULT_FONT;
  var $override_1$1 = $override$1;
  var getWidth_1 = getWidth;
  var getBoundingRect_1 = getBoundingRect;
  var adjustTextX_1 = adjustTextX;
  var adjustTextY_1 = adjustTextY;
  var calculateTextPosition_1 = calculateTextPosition;
  var adjustTextPositionOnRect_1 = adjustTextPositionOnRect;
  var truncateText_1 = truncateText;
  var getLineHeight_1 = getLineHeight;
  var measureText_1 = measureText;
  var parsePlainText_1 = parsePlainText;
  var parseRichText_1 = parseRichText;
  var makeFont_1 = makeFont;

  var text = {
  	DEFAULT_FONT: DEFAULT_FONT_1,
  	$override: $override_1$1,
  	getWidth: getWidth_1,
  	getBoundingRect: getBoundingRect_1,
  	adjustTextX: adjustTextX_1,
  	adjustTextY: adjustTextY_1,
  	calculateTextPosition: calculateTextPosition_1,
  	adjustTextPositionOnRect: adjustTextPositionOnRect_1,
  	truncateText: truncateText_1,
  	getLineHeight: getLineHeight_1,
  	measureText: measureText_1,
  	parsePlainText: parsePlainText_1,
  	parseRichText: parseRichText_1,
  	makeFont: makeFont_1
  };

  /**
   * @param {Object} ctx
   * @param {Object} shape
   * @param {number} shape.x
   * @param {number} shape.y
   * @param {number} shape.width
   * @param {number} shape.height
   * @param {number} shape.r
   */
  function buildPath(ctx, shape) {
    var x = shape.x;
    var y = shape.y;
    var width = shape.width;
    var height = shape.height;
    var r = shape.r;
    var r1;
    var r2;
    var r3;
    var r4; // Convert width and height to positive for better borderRadius

    if (width < 0) {
      x = x + width;
      width = -width;
    }

    if (height < 0) {
      y = y + height;
      height = -height;
    }

    if (typeof r === 'number') {
      r1 = r2 = r3 = r4 = r;
    } else if (r instanceof Array) {
      if (r.length === 1) {
        r1 = r2 = r3 = r4 = r[0];
      } else if (r.length === 2) {
        r1 = r3 = r[0];
        r2 = r4 = r[1];
      } else if (r.length === 3) {
        r1 = r[0];
        r2 = r4 = r[1];
        r3 = r[2];
      } else {
        r1 = r[0];
        r2 = r[1];
        r3 = r[2];
        r4 = r[3];
      }
    } else {
      r1 = r2 = r3 = r4 = 0;
    }

    var total;

    if (r1 + r2 > width) {
      total = r1 + r2;
      r1 *= width / total;
      r2 *= width / total;
    }

    if (r3 + r4 > width) {
      total = r3 + r4;
      r3 *= width / total;
      r4 *= width / total;
    }

    if (r2 + r3 > height) {
      total = r2 + r3;
      r2 *= height / total;
      r3 *= height / total;
    }

    if (r1 + r4 > height) {
      total = r1 + r4;
      r1 *= height / total;
      r4 *= height / total;
    }

    ctx.moveTo(x + r1, y);
    ctx.lineTo(x + width - r2, y);
    r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
    ctx.lineTo(x + width, y + height - r3);
    r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
    ctx.lineTo(x + r4, y + height);
    r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
    ctx.lineTo(x, y + r1);
    r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
  }

  var buildPath_1 = buildPath;

  var roundRect = {
  	buildPath: buildPath_1
  };

  var retrieve2$2 = util.retrieve2;
  var retrieve3$2 = util.retrieve3;
  var each$1 = util.each;
  var normalizeCssArray$1 = util.normalizeCssArray;
  var isString$3 = util.isString;
  var isObject$4 = util.isObject;











  var ContextCachedBy$2 = constant.ContextCachedBy;
  var WILL_BE_RESTORED$1 = constant.WILL_BE_RESTORED;
  var DEFAULT_FONT$1 = text.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.

  var VALID_TEXT_ALIGN = {
    left: 1,
    right: 1,
    center: 1
  };
  var VALID_TEXT_VERTICAL_ALIGN = {
    top: 1,
    bottom: 1,
    middle: 1
  }; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,
  // the default value of shadowColor is `'transparent'`.

  var SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];
  var _tmpTextPositionResult = {};
  var _tmpBoxPositionResult = {};
  /**
   * @param {module:zrender/graphic/Style} style
   * @return {module:zrender/graphic/Style} The input style.
   */

  function normalizeTextStyle(style) {
    normalizeStyle(style);
    each$1(style.rich, normalizeStyle);
    return style;
  }

  function normalizeStyle(style) {
    if (style) {
      style.font = text.makeFont(style);
      var textAlign = style.textAlign;
      textAlign === 'middle' && (textAlign = 'center');
      style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.

      var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
      textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
      style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
      var textPadding = style.textPadding;

      if (textPadding) {
        style.textPadding = normalizeCssArray$1(style.textPadding);
      }
    }
  }
  /**
   * @param {CanvasRenderingContext2D} ctx
   * @param {string} text
   * @param {module:zrender/graphic/Style} style
   * @param {Object|boolean} [rect] {x, y, width, height}
   *                  If set false, rect text is not used.
   * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.
   */


  function renderText(hostEl, ctx, text, style, rect, prevEl) {
    style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);
  } // Avoid setting to ctx according to prevEl if possible for
  // performance in scenarios of large amount text.


  function renderPlainText(hostEl, ctx, text$1, style, rect, prevEl) {

    var needDrawBg = needDrawBackground(style);
    var prevStyle;
    var checkCache = false;
    var cachedByMe = ctx.__attrCachedBy === ContextCachedBy$2.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.

    if (prevEl !== WILL_BE_RESTORED$1) {
      if (prevEl) {
        prevStyle = prevEl.style;
        checkCache = !needDrawBg && cachedByMe && prevStyle;
      } // Prevent from using cache in `Style::bind`, because of the case:
      // ctx property is modified by other properties than `Style::bind`
      // used, and Style::bind is called next.


      ctx.__attrCachedBy = needDrawBg ? ContextCachedBy$2.NONE : ContextCachedBy$2.PLAIN_TEXT;
    } // Since this will be restored, prevent from using these props to check cache in the next
    // entering of this method. But do not need to clear other cache like `Style::bind`.
    else if (cachedByMe) {
        ctx.__attrCachedBy = ContextCachedBy$2.NONE;
      }

    var styleFont = style.font || DEFAULT_FONT$1; // PENDING
    // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically
    // we can make font cache on ctx, which can cache for text el that are discontinuous.
    // But layer save/restore needed to be considered.
    // if (styleFont !== ctx.__fontCache) {
    //     ctx.font = styleFont;
    //     if (prevEl !== WILL_BE_RESTORED) {
    //         ctx.__fontCache = styleFont;
    //     }
    // }

    if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT$1)) {
      ctx.font = styleFont;
    } // Use the final font from context-2d, because the final
    // font might not be the style.font when it is illegal.
    // But get `ctx.font` might be time consuming.


    var computedFont = hostEl.__computedFont;

    if (hostEl.__styleFont !== styleFont) {
      hostEl.__styleFont = styleFont;
      computedFont = hostEl.__computedFont = ctx.font;
    }

    var textPadding = style.textPadding;
    var textLineHeight = style.textLineHeight;
    var contentBlock = hostEl.__textCotentBlock;

    if (!contentBlock || hostEl.__dirtyText) {
      contentBlock = hostEl.__textCotentBlock = text.parsePlainText(text$1, computedFont, textPadding, textLineHeight, style.truncate);
    }

    var outerHeight = contentBlock.outerHeight;
    var textLines = contentBlock.lines;
    var lineHeight = contentBlock.lineHeight;
    var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
    var baseX = boxPos.baseX;
    var baseY = boxPos.baseY;
    var textAlign = boxPos.textAlign || 'left';
    var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

    applyTextRotation(ctx, style, rect, baseX, baseY);
    var boxY = text.adjustTextY(baseY, outerHeight, textVerticalAlign);
    var textX = baseX;
    var textY = boxY;

    if (needDrawBg || textPadding) {
      // Consider performance, do not call getTextWidth util necessary.
      var textWidth = text.getWidth(text$1, computedFont);
      var outerWidth = textWidth;
      textPadding && (outerWidth += textPadding[1] + textPadding[3]);
      var boxX = text.adjustTextX(baseX, outerWidth, textAlign);
      needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

      if (textPadding) {
        textX = getTextXForPadding(baseX, textAlign, textPadding);
        textY += textPadding[0];
      }
    } // Always set textAlign and textBase line, because it is difficute to calculate
    // textAlign from prevEl, and we dont sure whether textAlign will be reset if
    // font set happened.


    ctx.textAlign = textAlign; // Force baseline to be "middle". Otherwise, if using "top", the
    // text will offset downward a little bit in font "Microsoft YaHei".

    ctx.textBaseline = 'middle'; // Set text opacity

    ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.

    for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {
      var propItem = SHADOW_STYLE_COMMON_PROPS[i];
      var styleProp = propItem[0];
      var ctxProp = propItem[1];
      var val = style[styleProp];

      if (!checkCache || val !== prevStyle[styleProp]) {
        ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);
      }
    } // `textBaseline` is set as 'middle'.


    textY += lineHeight / 2;
    var textStrokeWidth = style.textStrokeWidth;
    var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;
    var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;
    var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;
    var textStroke = getStroke(style.textStroke, textStrokeWidth);
    var textFill = getFill(style.textFill);

    if (textStroke) {
      if (strokeWidthChanged) {
        ctx.lineWidth = textStrokeWidth;
      }

      if (strokeChanged) {
        ctx.strokeStyle = textStroke;
      }
    }

    if (textFill) {
      if (!checkCache || style.textFill !== prevStyle.textFill) {
        ctx.fillStyle = textFill;
      }
    } // Optimize simply, in most cases only one line exists.


    if (textLines.length === 1) {
      // Fill after stroke so the outline will not cover the main part.
      textStroke && ctx.strokeText(textLines[0], textX, textY);
      textFill && ctx.fillText(textLines[0], textX, textY);
    } else {
      for (var i = 0; i < textLines.length; i++) {
        // Fill after stroke so the outline will not cover the main part.
        textStroke && ctx.strokeText(textLines[i], textX, textY);
        textFill && ctx.fillText(textLines[i], textX, textY);
        textY += lineHeight;
      }
    }
  }

  function renderRichText(hostEl, ctx, text$1, style, rect, prevEl) {
    // Do not do cache for rich text because of the complexity.
    // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.
    if (prevEl !== WILL_BE_RESTORED$1) {
      ctx.__attrCachedBy = ContextCachedBy$2.NONE;
    }

    var contentBlock = hostEl.__textCotentBlock;

    if (!contentBlock || hostEl.__dirtyText) {
      contentBlock = hostEl.__textCotentBlock = text.parseRichText(text$1, style);
    }

    drawRichText(hostEl, ctx, contentBlock, style, rect);
  }

  function drawRichText(hostEl, ctx, contentBlock, style, rect) {
    var contentWidth = contentBlock.width;
    var outerWidth = contentBlock.outerWidth;
    var outerHeight = contentBlock.outerHeight;
    var textPadding = style.textPadding;
    var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
    var baseX = boxPos.baseX;
    var baseY = boxPos.baseY;
    var textAlign = boxPos.textAlign;
    var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

    applyTextRotation(ctx, style, rect, baseX, baseY);
    var boxX = text.adjustTextX(baseX, outerWidth, textAlign);
    var boxY = text.adjustTextY(baseY, outerHeight, textVerticalAlign);
    var xLeft = boxX;
    var lineTop = boxY;

    if (textPadding) {
      xLeft += textPadding[3];
      lineTop += textPadding[0];
    }

    var xRight = xLeft + contentWidth;
    needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

    for (var i = 0; i < contentBlock.lines.length; i++) {
      var line = contentBlock.lines[i];
      var tokens = line.tokens;
      var tokenCount = tokens.length;
      var lineHeight = line.lineHeight;
      var usedWidth = line.width;
      var leftIndex = 0;
      var lineXLeft = xLeft;
      var lineXRight = xRight;
      var rightIndex = tokenCount - 1;
      var token;

      while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
        placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
        usedWidth -= token.width;
        lineXLeft += token.width;
        leftIndex++;
      }

      while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
        placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
        usedWidth -= token.width;
        lineXRight -= token.width;
        rightIndex--;
      } // The other tokens are placed as textAlign 'center' if there is enough space.


      lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;

      while (leftIndex <= rightIndex) {
        token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.

        placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
        lineXLeft += token.width;
        leftIndex++;
      }

      lineTop += lineHeight;
    }
  }

  function applyTextRotation(ctx, style, rect, x, y) {
    // textRotation only apply in RectText.
    if (rect && style.textRotation) {
      var origin = style.textOrigin;

      if (origin === 'center') {
        x = rect.width / 2 + rect.x;
        y = rect.height / 2 + rect.y;
      } else if (origin) {
        x = origin[0] + rect.x;
        y = origin[1] + rect.y;
      }

      ctx.translate(x, y); // Positive: anticlockwise

      ctx.rotate(-style.textRotation);
      ctx.translate(-x, -y);
    }
  }

  function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
    var tokenStyle = style.rich[token.styleName] || {};
    tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of
    // the bias of "Microsoft YaHei".

    var textVerticalAlign = token.textVerticalAlign;
    var y = lineTop + lineHeight / 2;

    if (textVerticalAlign === 'top') {
      y = lineTop + token.height / 2;
    } else if (textVerticalAlign === 'bottom') {
      y = lineTop + lineHeight - token.height / 2;
    }

    !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
    var textPadding = token.textPadding;

    if (textPadding) {
      x = getTextXForPadding(x, textAlign, textPadding);
      y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
    }

    setCtx(ctx, 'shadowBlur', retrieve3$2(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
    setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
    setCtx(ctx, 'shadowOffsetX', retrieve3$2(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
    setCtx(ctx, 'shadowOffsetY', retrieve3$2(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
    setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
    // text will offset downward a little bit in font "Microsoft YaHei".

    setCtx(ctx, 'textBaseline', 'middle');
    setCtx(ctx, 'font', token.font || DEFAULT_FONT$1);
    var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
    var textFill = getFill(tokenStyle.textFill || style.textFill);
    var textStrokeWidth = retrieve2$2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.

    if (textStroke) {
      setCtx(ctx, 'lineWidth', textStrokeWidth);
      setCtx(ctx, 'strokeStyle', textStroke);
      ctx.strokeText(token.text, x, y);
    }

    if (textFill) {
      setCtx(ctx, 'fillStyle', textFill);
      ctx.fillText(token.text, x, y);
    }
  }

  function needDrawBackground(style) {
    return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);
  } // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}
  // shape: {x, y, width, height}


  function drawBackground(hostEl, ctx, style, x, y, width, height) {
    var textBackgroundColor = style.textBackgroundColor;
    var textBorderWidth = style.textBorderWidth;
    var textBorderColor = style.textBorderColor;
    var isPlainBg = isString$3(textBackgroundColor);
    setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
    setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
    setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
    setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);

    if (isPlainBg || textBorderWidth && textBorderColor) {
      ctx.beginPath();
      var textBorderRadius = style.textBorderRadius;

      if (!textBorderRadius) {
        ctx.rect(x, y, width, height);
      } else {
        roundRect.buildPath(ctx, {
          x: x,
          y: y,
          width: width,
          height: height,
          r: textBorderRadius
        });
      }

      ctx.closePath();
    }

    if (isPlainBg) {
      setCtx(ctx, 'fillStyle', textBackgroundColor);

      if (style.fillOpacity != null) {
        var originalGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = style.fillOpacity * style.opacity;
        ctx.fill();
        ctx.globalAlpha = originalGlobalAlpha;
      } else {
        ctx.fill();
      }
    } else if (isObject$4(textBackgroundColor)) {
      var image$1 = textBackgroundColor.image;
      image$1 = image.createOrUpdateImage(image$1, null, hostEl, onBgImageLoaded, textBackgroundColor);

      if (image$1 && image.isImageReady(image$1)) {
        ctx.drawImage(image$1, x, y, width, height);
      }
    }

    if (textBorderWidth && textBorderColor) {
      setCtx(ctx, 'lineWidth', textBorderWidth);
      setCtx(ctx, 'strokeStyle', textBorderColor);

      if (style.strokeOpacity != null) {
        var originalGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = style.strokeOpacity * style.opacity;
        ctx.stroke();
        ctx.globalAlpha = originalGlobalAlpha;
      } else {
        ctx.stroke();
      }
    }
  }

  function onBgImageLoaded(image, textBackgroundColor) {
    // Replace image, so that `contain/text.js#parseRichText`
    // will get correct result in next tick.
    textBackgroundColor.image = image;
  }

  function getBoxPosition(out, hostEl, style, rect) {
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var textAlign = style.textAlign;
    var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord

    if (rect) {
      var textPosition = style.textPosition;

      if (textPosition instanceof Array) {
        // Percent
        baseX = rect.x + parsePercent(textPosition[0], rect.width);
        baseY = rect.y + parsePercent(textPosition[1], rect.height);
      } else {
        var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : text.calculateTextPosition(_tmpTextPositionResult, style, rect);
        baseX = res.x;
        baseY = res.y; // Default align and baseline when has textPosition

        textAlign = textAlign || res.textAlign;
        textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
      } // textOffset is only support in RectText, otherwise
      // we have to adjust boundingRect for textOffset.


      var textOffset = style.textOffset;

      if (textOffset) {
        baseX += textOffset[0];
        baseY += textOffset[1];
      }
    }

    out = out || {};
    out.baseX = baseX;
    out.baseY = baseY;
    out.textAlign = textAlign;
    out.textVerticalAlign = textVerticalAlign;
    return out;
  }

  function setCtx(ctx, prop, value) {
    ctx[prop] = fixShadow(ctx, prop, value);
    return ctx[prop];
  }
  /**
   * @param {string} [stroke] If specified, do not check style.textStroke.
   * @param {string} [lineWidth] If specified, do not check style.textStroke.
   * @param {number} style
   */


  function getStroke(stroke, lineWidth) {
    return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
    : stroke.image || stroke.colorStops ? '#000' : stroke;
  }

  function getFill(fill) {
    return fill == null || fill === 'none' ? null // TODO pattern and gradient?
    : fill.image || fill.colorStops ? '#000' : fill;
  }

  function parsePercent(value, maxValue) {
    if (typeof value === 'string') {
      if (value.lastIndexOf('%') >= 0) {
        return parseFloat(value) / 100 * maxValue;
      }

      return parseFloat(value);
    }

    return value;
  }

  function getTextXForPadding(x, textAlign, textPadding) {
    return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
  }
  /**
   * @param {string} text
   * @param {module:zrender/Style} style
   * @return {boolean}
   */


  function needDrawText(text, style) {
    return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
  }

  var normalizeTextStyle_1 = normalizeTextStyle;
  var renderText_1 = renderText;
  var getBoxPosition_1 = getBoxPosition;
  var getStroke_1 = getStroke;
  var getFill_1 = getFill;
  var parsePercent_1 = parsePercent;
  var needDrawText_1 = needDrawText;

  var text$1 = {
  	normalizeTextStyle: normalizeTextStyle_1,
  	renderText: renderText_1,
  	getBoxPosition: getBoxPosition_1,
  	getStroke: getStroke_1,
  	getFill: getFill_1,
  	parsePercent: parsePercent_1,
  	needDrawText: needDrawText_1
  };

  var WILL_BE_RESTORED$2 = constant.WILL_BE_RESTORED;

  /**
   * Mixin for drawing text in a element bounding rect
   * @module zrender/mixin/RectText
   */
  var tmpRect = new BoundingRect_1();

  var RectText = function () {};

  RectText.prototype = {
    constructor: RectText,

    /**
     * Draw text in a rect with specified position.
     * @param  {CanvasRenderingContext2D} ctx
     * @param  {Object} rect Displayable rect
     */
    drawRectText: function (ctx, rect) {
      var style = this.style;
      rect = style.textRect || rect; // Optimize, avoid normalize every time.

      this.__dirty && text$1.normalizeTextStyle(style, true);
      var text = style.text; // Convert to string

      text != null && (text += '');

      if (!text$1.needDrawText(text, style)) {
        return;
      } // FIXME
      // Do not provide prevEl to `textHelper.renderText` for ctx prop cache,
      // but use `ctx.save()` and `ctx.restore()`. Because the cache for rect
      // text propably break the cache for its host elements.


      ctx.save(); // Transform rect to view space

      var transform = this.transform;

      if (!style.transformText) {
        if (transform) {
          tmpRect.copy(rect);
          tmpRect.applyTransform(transform);
          rect = tmpRect;
        }
      } else {
        this.setTransform(ctx);
      } // transformText and textRotation can not be used at the same time.


      text$1.renderText(this, ctx, text, style, rect, WILL_BE_RESTORED$2);
      ctx.restore();
    }
  };
  var _default$m = RectText;
  var RectText_1 = _default$m;

  /**
   * Base class of all displayable graphic objects
   * @module zrender/graphic/Displayable
   */

  /**
   * @alias module:zrender/graphic/Displayable
   * @extends module:zrender/Element
   * @extends module:zrender/graphic/mixin/RectText
   */
  function Displayable(opts) {
    opts = opts || {};
    Element_1.call(this, opts); // Extend properties

    for (var name in opts) {
      if (opts.hasOwnProperty(name) && name !== 'style') {
        this[name] = opts[name];
      }
    }
    /**
     * @type {module:zrender/graphic/Style}
     */


    this.style = new Style_1(opts.style, this);
    this._rect = null; // Shapes for cascade clipping.
    // Can only be `null`/`undefined` or an non-empty array, MUST NOT be an empty array.
    // because it is easy to only using null to check whether clipPaths changed.

    this.__clipPaths = null; // FIXME Stateful must be mixined after style is setted
    // Stateful.call(this, opts);
  }

  Displayable.prototype = {
    constructor: Displayable,
    type: 'displayable',

    /**
     * Dirty flag. From which painter will determine if this displayable object needs brush.
     * @name module:zrender/graphic/Displayable#__dirty
     * @type {boolean}
     */
    __dirty: true,

    /**
     * Whether the displayable object is visible. when it is true, the displayable object
     * is not drawn, but the mouse event can still trigger the object.
     * @name module:/zrender/graphic/Displayable#invisible
     * @type {boolean}
     * @default false
     */
    invisible: false,

    /**
     * @name module:/zrender/graphic/Displayable#z
     * @type {number}
     * @default 0
     */
    z: 0,

    /**
     * @name module:/zrender/graphic/Displayable#z
     * @type {number}
     * @default 0
     */
    z2: 0,

    /**
     * The z level determines the displayable object can be drawn in which layer canvas.
     * @name module:/zrender/graphic/Displayable#zlevel
     * @type {number}
     * @default 0
     */
    zlevel: 0,

    /**
     * Whether it can be dragged.
     * @name module:/zrender/graphic/Displayable#draggable
     * @type {boolean}
     * @default false
     */
    draggable: false,

    /**
     * Whether is it dragging.
     * @name module:/zrender/graphic/Displayable#draggable
     * @type {boolean}
     * @default false
     */
    dragging: false,

    /**
     * Whether to respond to mouse events.
     * @name module:/zrender/graphic/Displayable#silent
     * @type {boolean}
     * @default false
     */
    silent: false,

    /**
     * If enable culling
     * @type {boolean}
     * @default false
     */
    culling: false,

    /**
     * Mouse cursor when hovered
     * @name module:/zrender/graphic/Displayable#cursor
     * @type {string}
     */
    cursor: 'pointer',

    /**
     * If hover area is bounding rect
     * @name module:/zrender/graphic/Displayable#rectHover
     * @type {string}
     */
    rectHover: false,

    /**
     * Render the element progressively when the value >= 0,
     * usefull for large data.
     * @type {boolean}
     */
    progressive: false,

    /**
     * @type {boolean}
     */
    incremental: false,

    /**
     * Scale ratio for global scale.
     * @type {boolean}
     */
    globalScaleRatio: 1,
    beforeBrush: function (ctx) {},
    afterBrush: function (ctx) {},

    /**
     * Graphic drawing method.
     * @param {CanvasRenderingContext2D} ctx
     */
    // Interface
    brush: function (ctx, prevEl) {},

    /**
     * Get the minimum bounding box.
     * @return {module:zrender/core/BoundingRect}
     */
    // Interface
    getBoundingRect: function () {},

    /**
     * If displayable element contain coord x, y
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     */
    contain: function (x, y) {
      return this.rectContain(x, y);
    },

    /**
     * @param  {Function} cb
     * @param  {}   context
     */
    traverse: function (cb, context) {
      cb.call(context, this);
    },

    /**
     * If bounding rect of element contain coord x, y
     * @param  {number} x
     * @param  {number} y
     * @return {boolean}
     */
    rectContain: function (x, y) {
      var coord = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      return rect.contain(coord[0], coord[1]);
    },

    /**
     * Mark displayable element dirty and refresh next frame
     */
    dirty: function () {
      this.__dirty = this.__dirtyText = true;
      this._rect = null;
      this.__zr && this.__zr.refresh();
    },

    /**
     * If displayable object binded any event
     * @return {boolean}
     */
    // TODO, events bound by bind
    // isSilent: function () {
    //     return !(
    //         this.hoverable || this.draggable
    //         || this.onmousemove || this.onmouseover || this.onmouseout
    //         || this.onmousedown || this.onmouseup || this.onclick
    //         || this.ondragenter || this.ondragover || this.ondragleave
    //         || this.ondrop
    //     );
    // },

    /**
     * Alias for animate('style')
     * @param {boolean} loop
     */
    animateStyle: function (loop) {
      return this.animate('style', loop);
    },
    attrKV: function (key, value) {
      if (key !== 'style') {
        Element_1.prototype.attrKV.call(this, key, value);
      } else {
        this.style.set(value);
      }
    },

    /**
     * @param {Object|string} key
     * @param {*} value
     */
    setStyle: function (key, value) {
      this.style.set(key, value);
      this.dirty(false);
      return this;
    },

    /**
     * Use given style object
     * @param  {Object} obj
     */
    useStyle: function (obj) {
      this.style = new Style_1(obj, this);
      this.dirty(false);
      return this;
    },

    /**
     * The string value of `textPosition` needs to be calculated to a real postion.
     * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`
     * by default. See `contain/text.js#calculateTextPosition` for more details.
     * But some coutom shapes like "pin", "flag" have center that is not exactly
     * `[width/2, height/2]`. So we provide this hook to customize the calculation
     * for those shapes. It will be called if the `style.textPosition` is a string.
     * @param {Obejct} [out] Prepared out object. If not provided, this method should
     *        be responsible for creating one.
     * @param {module:zrender/graphic/Style} style
     * @param {Object} rect {x, y, width, height}
     * @return {Obejct} out The same as the input out.
     *         {
     *             x: number. mandatory.
     *             y: number. mandatory.
     *             textAlign: string. optional. use style.textAlign by default.
     *             textVerticalAlign: string. optional. use style.textVerticalAlign by default.
     *         }
     */
    calculateTextPosition: null
  };
  util.inherits(Displayable, Element_1);
  util.mixin(Displayable, RectText_1); // zrUtil.mixin(Displayable, Stateful);

  var _default$n = Displayable;
  var Displayable_1 = _default$n;

  /**
   * @alias zrender/graphic/Image
   * @extends module:zrender/graphic/Displayable
   * @constructor
   * @param {Object} opts
   */
  function ZImage(opts) {
    Displayable_1.call(this, opts);
  }

  ZImage.prototype = {
    constructor: ZImage,
    type: 'image',
    brush: function (ctx, prevEl) {
      var style = this.style;
      var src = style.image; // Must bind each time

      style.bind(ctx, this, prevEl);
      var image$1 = this._image = image.createOrUpdateImage(src, this._image, this, this.onload);

      if (!image$1 || !image.isImageReady(image$1)) {
        return;
      } // å¾çå·²ç»å è½½å®æ
      // if (image.nodeName.toUpperCase() == 'IMG') {
      //     if (!image.complete) {
      //         return;
      //     }
      // }
      // Else is canvas


      var x = style.x || 0;
      var y = style.y || 0;
      var width = style.width;
      var height = style.height;
      var aspect = image$1.width / image$1.height;

      if (width == null && height != null) {
        // Keep image/height ratio
        width = height * aspect;
      } else if (height == null && width != null) {
        height = width / aspect;
      } else if (width == null && height == null) {
        width = image$1.width;
        height = image$1.height;
      } // è®¾ç½®transform


      this.setTransform(ctx);

      if (style.sWidth && style.sHeight) {
        var sx = style.sx || 0;
        var sy = style.sy || 0;
        ctx.drawImage(image$1, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
      } else if (style.sx && style.sy) {
        var sx = style.sx;
        var sy = style.sy;
        var sWidth = width - sx;
        var sHeight = height - sy;
        ctx.drawImage(image$1, sx, sy, sWidth, sHeight, x, y, width, height);
      } else {
        ctx.drawImage(image$1, x, y, width, height);
      } // Draw rect text


      if (style.text != null) {
        // Only restore transform when needs draw text.
        this.restoreTransform(ctx);
        this.drawRectText(ctx, this.getBoundingRect());
      }
    },
    getBoundingRect: function () {
      var style = this.style;

      if (!this._rect) {
        this._rect = new BoundingRect_1(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
      }

      return this._rect;
    }
  };
  util.inherits(ZImage, Displayable_1);
  var _default$o = ZImage;
  var Image$1 = _default$o;

  var devicePixelRatio$2 = config.devicePixelRatio;

















  var HOVER_LAYER_ZLEVEL = 1e5;
  var CANVAS_ZLEVEL = 314159;
  var EL_AFTER_INCREMENTAL_INC = 0.01;
  var INCREMENTAL_INC = 0.001;

  function parseInt10(val) {
    return parseInt(val, 10);
  }

  function isLayerValid(layer) {
    if (!layer) {
      return false;
    }

    if (layer.__builtin__) {
      return true;
    }

    if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
      return false;
    }

    return true;
  }

  var tmpRect$1 = new BoundingRect_1(0, 0, 0, 0);
  var viewRect = new BoundingRect_1(0, 0, 0, 0);

  function isDisplayableCulled(el, width, height) {
    tmpRect$1.copy(el.getBoundingRect());

    if (el.transform) {
      tmpRect$1.applyTransform(el.transform);
    }

    viewRect.width = width;
    viewRect.height = height;
    return !tmpRect$1.intersect(viewRect);
  }

  function isClipPathChanged(clipPaths, prevClipPaths) {
    // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.
    if (clipPaths === prevClipPaths) {
      return false;
    }

    if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
      return true;
    }

    for (var i = 0; i < clipPaths.length; i++) {
      if (clipPaths[i] !== prevClipPaths[i]) {
        return true;
      }
    }

    return false;
  }

  function doClip(clipPaths, ctx) {
    for (var i = 0; i < clipPaths.length; i++) {
      var clipPath = clipPaths[i];
      clipPath.setTransform(ctx);
      ctx.beginPath();
      clipPath.buildPath(ctx, clipPath.shape);
      ctx.clip(); // Transform back

      clipPath.restoreTransform(ctx);
    }
  }

  function createRoot(width, height) {
    var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // Avoid page selected

    domRoot.style.cssText = ['position:relative', // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent
    // dom does not act as expected) when some of the parent dom has
    // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and
    // the canvas is not at the top part of the page.
    // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove
    // this `overflow:hidden` to avoid the bug.
    // 'overflow:hidden',
    'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
    return domRoot;
  }
  /**
   * @alias module:zrender/Painter
   * @constructor
   * @param {HTMLElement} root ç»å¾å®¹å¨
   * @param {module:zrender/Storage} storage
   * @param {Object} opts
   */


  var Painter = function (root, storage, opts) {
    this.type = 'canvas'; // In node environment using node-canvas

    var singleCanvas = !root.nodeName // In node ?
    || root.nodeName.toUpperCase() === 'CANVAS';
    this._opts = opts = util.extend({}, opts || {});
    /**
     * @type {number}
     */

    this.dpr = opts.devicePixelRatio || devicePixelRatio$2;
    /**
     * @type {boolean}
     * @private
     */

    this._singleCanvas = singleCanvas;
    /**
     * ç»å¾å®¹å¨
     * @type {HTMLElement}
     */

    this.root = root;
    var rootStyle = root.style;

    if (rootStyle) {
      rootStyle['-webkit-tap-highlight-color'] = 'transparent';
      rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
      root.innerHTML = '';
    }
    /**
     * @type {module:zrender/Storage}
     */


    this.storage = storage;
    /**
     * @type {Array.<number>}
     * @private
     */

    var zlevelList = this._zlevelList = [];
    /**
     * @type {Object.<string, module:zrender/Layer>}
     * @private
     */

    var layers = this._layers = {};
    /**
     * @type {Object.<string, Object>}
     * @private
     */

    this._layerConfig = {};
    /**
     * zrender will do compositing when root is a canvas and have multiple zlevels.
     */

    this._needsManuallyCompositing = false;

    if (!singleCanvas) {
      this._width = this._getSize(0);
      this._height = this._getSize(1);
      var domRoot = this._domRoot = createRoot(this._width, this._height);
      root.appendChild(domRoot);
    } else {
      var width = root.width;
      var height = root.height;

      if (opts.width != null) {
        width = opts.width;
      }

      if (opts.height != null) {
        height = opts.height;
      }

      this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly

      root.width = width * this.dpr;
      root.height = height * this.dpr;
      this._width = width;
      this._height = height; // Create layer if only one given canvas
      // Device can be specified to create a high dpi image.

      var mainLayer = new Layer_1(root, this, this.dpr);
      mainLayer.__builtin__ = true;
      mainLayer.initContext(); // FIXME Use canvas width and height
      // mainLayer.resize(width, height);

      layers[CANVAS_ZLEVEL] = mainLayer;
      mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.

      zlevelList.push(CANVAS_ZLEVEL);
      this._domRoot = root;
    }
    /**
     * @type {module:zrender/Layer}
     * @private
     */


    this._hoverlayer = null;
    this._hoverElements = [];
  };

  Painter.prototype = {
    constructor: Painter,
    getType: function () {
      return 'canvas';
    },

    /**
     * If painter use a single canvas
     * @return {boolean}
     */
    isSingleCanvas: function () {
      return this._singleCanvas;
    },

    /**
     * @return {HTMLDivElement}
     */
    getViewportRoot: function () {
      return this._domRoot;
    },
    getViewportRootOffset: function () {
      var viewportRoot = this.getViewportRoot();

      if (viewportRoot) {
        return {
          offsetLeft: viewportRoot.offsetLeft || 0,
          offsetTop: viewportRoot.offsetTop || 0
        };
      }
    },

    /**
     * å·æ°
     * @param {boolean} [paintAll=false] å¼ºå¶ç»å¶æædisplayable
     */
    refresh: function (paintAll) {
      var list = this.storage.getDisplayList(true);
      var zlevelList = this._zlevelList;
      this._redrawId = Math.random();

      this._paintList(list, paintAll, this._redrawId); // Paint custum layers


      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        var layer = this._layers[z];

        if (!layer.__builtin__ && layer.refresh) {
          var clearColor = i === 0 ? this._backgroundColor : null;
          layer.refresh(clearColor);
        }
      }

      this.refreshHover();
      return this;
    },
    addHover: function (el, hoverStyle) {
      if (el.__hoverMir) {
        return;
      }

      var elMirror = new el.constructor({
        style: el.style,
        shape: el.shape,
        z: el.z,
        z2: el.z2,
        silent: el.silent
      });
      elMirror.__from = el;
      el.__hoverMir = elMirror;
      hoverStyle && elMirror.setStyle(hoverStyle);

      this._hoverElements.push(elMirror);

      return elMirror;
    },
    removeHover: function (el) {
      var elMirror = el.__hoverMir;
      var hoverElements = this._hoverElements;
      var idx = util.indexOf(hoverElements, elMirror);

      if (idx >= 0) {
        hoverElements.splice(idx, 1);
      }

      el.__hoverMir = null;
    },
    clearHover: function (el) {
      var hoverElements = this._hoverElements;

      for (var i = 0; i < hoverElements.length; i++) {
        var from = hoverElements[i].__from;

        if (from) {
          from.__hoverMir = null;
        }
      }

      hoverElements.length = 0;
    },
    refreshHover: function () {
      var hoverElements = this._hoverElements;
      var len = hoverElements.length;
      var hoverLayer = this._hoverlayer;
      hoverLayer && hoverLayer.clear();

      if (!len) {
        return;
      }

      timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
      // FIXME?

      if (!hoverLayer) {
        hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
      }

      var scope = {};
      hoverLayer.ctx.save();

      for (var i = 0; i < len;) {
        var el = hoverElements[i];
        var originalEl = el.__from; // Original el is removed
        // PENDING

        if (!(originalEl && originalEl.__zr)) {
          hoverElements.splice(i, 1);
          originalEl.__hoverMir = null;
          len--;
          continue;
        }

        i++; // Use transform
        // FIXME style and shape ?

        if (!originalEl.invisible) {
          el.transform = originalEl.transform;
          el.invTransform = originalEl.invTransform;
          el.__clipPaths = originalEl.__clipPaths; // el.

          this._doPaintEl(el, hoverLayer, true, scope);
        }
      }

      hoverLayer.ctx.restore();
    },
    getHoverLayer: function () {
      return this.getLayer(HOVER_LAYER_ZLEVEL);
    },
    _paintList: function (list, paintAll, redrawId) {
      if (this._redrawId !== redrawId) {
        return;
      }

      paintAll = paintAll || false;

      this._updateLayerStatus(list);

      var finished = this._doPaintList(list, paintAll);

      if (this._needsManuallyCompositing) {
        this._compositeManually();
      }

      if (!finished) {
        var self = this;
        requestAnimationFrame(function () {
          self._paintList(list, paintAll, redrawId);
        });
      }
    },
    _compositeManually: function () {
      var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
      var width = this._domRoot.width;
      var height = this._domRoot.height;
      ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?

      this.eachBuiltinLayer(function (layer) {
        if (layer.virtual) {
          ctx.drawImage(layer.dom, 0, 0, width, height);
        }
      });
    },
    _doPaintList: function (list, paintAll) {
      var layerList = [];

      for (var zi = 0; zi < this._zlevelList.length; zi++) {
        var zlevel = this._zlevelList[zi];
        var layer = this._layers[zlevel];

        if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
          layerList.push(layer);
        }
      }

      var finished = true;

      for (var k = 0; k < layerList.length; k++) {
        var layer = layerList[k];
        var ctx = layer.ctx;
        var scope = {};
        ctx.save();
        var start = paintAll ? layer.__startIndex : layer.__drawIndex;
        var useTimer = !paintAll && layer.incremental && Date.now;
        var startTime = useTimer && Date.now();
        var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.

        if (layer.__startIndex === layer.__endIndex) {
          layer.clear(false, clearColor);
        } else if (start === layer.__startIndex) {
          var firstEl = list[start];

          if (!firstEl.incremental || !firstEl.notClear || paintAll) {
            layer.clear(false, clearColor);
          }
        }

        if (start === -1) {
          console.error('For some unknown reason. drawIndex is -1');
          start = layer.__startIndex;
        }

        for (var i = start; i < layer.__endIndex; i++) {
          var el = list[i];

          this._doPaintEl(el, layer, paintAll, scope);

          el.__dirty = el.__dirtyText = false;

          if (useTimer) {
            // Date.now can be executed in 13,025,305 ops/second.
            var dTime = Date.now() - startTime; // Give 15 millisecond to draw.
            // The rest elements will be drawn in the next frame.

            if (dTime > 15) {
              break;
            }
          }
        }

        layer.__drawIndex = i;

        if (layer.__drawIndex < layer.__endIndex) {
          finished = false;
        }

        if (scope.prevElClipPaths) {
          // Needs restore the state. If last drawn element is in the clipping area.
          ctx.restore();
        }

        ctx.restore();
      }

      if (env_1.wxa) {
        // Flush for weixin application
        util.each(this._layers, function (layer) {
          if (layer && layer.ctx && layer.ctx.draw) {
            layer.ctx.draw();
          }
        });
      }

      return finished;
    },
    _doPaintEl: function (el, currentLayer, forcePaint, scope) {
      var ctx = currentLayer.ctx;
      var m = el.transform;

      if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
      !el.invisible // Ignore transparent element
      && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
      // Draw a scale 0 element can cause all following draw wrong
      // And setTransform with scale 0 will cause set back transform failed.
      && !(m && !m[0] && !m[3]) // Ignore culled element
      && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
        var clipPaths = el.__clipPaths;
        var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements

        if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
          // If has previous clipping state, restore from it
          if (prevElClipPaths) {
            ctx.restore();
            scope.prevElClipPaths = null; // Reset prevEl since context has been restored

            scope.prevEl = null;
          } // New clipping state


          if (clipPaths) {
            ctx.save();
            doClip(clipPaths, ctx);
            scope.prevElClipPaths = clipPaths;
          }
        }

        el.beforeBrush && el.beforeBrush(ctx);
        el.brush(ctx, scope.prevEl || null);
        scope.prevEl = el;
        el.afterBrush && el.afterBrush(ctx);
      }
    },

    /**
     * è·å zlevel æå¨å±ï¼å¦æä¸å­å¨åä¼åå»ºä¸ä¸ªæ°çå±
     * @param {number} zlevel
     * @param {boolean} virtual Virtual layer will not be inserted into dom.
     * @return {module:zrender/Layer}
     */
    getLayer: function (zlevel, virtual) {
      if (this._singleCanvas && !this._needsManuallyCompositing) {
        zlevel = CANVAS_ZLEVEL;
      }

      var layer = this._layers[zlevel];

      if (!layer) {
        // Create a new layer
        layer = new Layer_1('zr_' + zlevel, this, this.dpr);
        layer.zlevel = zlevel;
        layer.__builtin__ = true;

        if (this._layerConfig[zlevel]) {
          util.merge(layer, this._layerConfig[zlevel], true);
        } // TODO Remove EL_AFTER_INCREMENTAL_INC magic number
        else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
            util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
          }

        if (virtual) {
          layer.virtual = virtual;
        }

        this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
        // Or excanvas will get 0px clientWidth and clientHeight

        layer.initContext();
      }

      return layer;
    },
    insertLayer: function (zlevel, layer) {
      var layersMap = this._layers;
      var zlevelList = this._zlevelList;
      var len = zlevelList.length;
      var prevLayer = null;
      var i = -1;
      var domRoot = this._domRoot;

      if (layersMap[zlevel]) {
        return;
      } // Check if is a valid layer


      if (!isLayerValid(layer)) {
        return;
      }

      if (len > 0 && zlevel > zlevelList[0]) {
        for (i = 0; i < len - 1; i++) {
          if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
            break;
          }
        }

        prevLayer = layersMap[zlevelList[i]];
      }

      zlevelList.splice(i + 1, 0, zlevel);
      layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
      // (It can be a WebGL layer and assigned to a ZImage element)
      // But it still under management of zrender.

      if (!layer.virtual) {
        if (prevLayer) {
          var prevDom = prevLayer.dom;

          if (prevDom.nextSibling) {
            domRoot.insertBefore(layer.dom, prevDom.nextSibling);
          } else {
            domRoot.appendChild(layer.dom);
          }
        } else {
          if (domRoot.firstChild) {
            domRoot.insertBefore(layer.dom, domRoot.firstChild);
          } else {
            domRoot.appendChild(layer.dom);
          }
        }
      }
    },
    // Iterate each layer
    eachLayer: function (cb, context) {
      var zlevelList = this._zlevelList;
      var z;
      var i;

      for (i = 0; i < zlevelList.length; i++) {
        z = zlevelList[i];
        cb.call(context, this._layers[z], z);
      }
    },
    // Iterate each buildin layer
    eachBuiltinLayer: function (cb, context) {
      var zlevelList = this._zlevelList;
      var layer;
      var z;
      var i;

      for (i = 0; i < zlevelList.length; i++) {
        z = zlevelList[i];
        layer = this._layers[z];

        if (layer.__builtin__) {
          cb.call(context, layer, z);
        }
      }
    },
    // Iterate each other layer except buildin layer
    eachOtherLayer: function (cb, context) {
      var zlevelList = this._zlevelList;
      var layer;
      var z;
      var i;

      for (i = 0; i < zlevelList.length; i++) {
        z = zlevelList[i];
        layer = this._layers[z];

        if (!layer.__builtin__) {
          cb.call(context, layer, z);
        }
      }
    },

    /**
     * è·åææå·²åå»ºçå±
     * @param {Array.<module:zrender/Layer>} [prevLayer]
     */
    getLayers: function () {
      return this._layers;
    },
    _updateLayerStatus: function (list) {
      this.eachBuiltinLayer(function (layer, z) {
        layer.__dirty = layer.__used = false;
      });

      function updatePrevLayer(idx) {
        if (prevLayer) {
          if (prevLayer.__endIndex !== idx) {
            prevLayer.__dirty = true;
          }

          prevLayer.__endIndex = idx;
        }
      }

      if (this._singleCanvas) {
        for (var i = 1; i < list.length; i++) {
          var el = list[i];

          if (el.zlevel !== list[i - 1].zlevel || el.incremental) {
            this._needsManuallyCompositing = true;
            break;
          }
        }
      }

      var prevLayer = null;
      var incrementalLayerCount = 0;
      var prevZlevel;

      for (var i = 0; i < list.length; i++) {
        var el = list[i];
        var zlevel = el.zlevel;
        var layer;

        if (prevZlevel !== zlevel) {
          prevZlevel = zlevel;
          incrementalLayerCount = 0;
        } // TODO Not use magic number on zlevel.
        // Each layer with increment element can be separated to 3 layers.
        //          (Other Element drawn after incremental element)
        // -----------------zlevel + EL_AFTER_INCREMENTAL_INC--------------------
        //                      (Incremental element)
        // ----------------------zlevel + INCREMENTAL_INC------------------------
        //              (Element drawn before incremental element)
        // --------------------------------zlevel--------------------------------


        if (el.incremental) {
          layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
          layer.incremental = true;
          incrementalLayerCount = 1;
        } else {
          layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
        }

        if (!layer.__builtin__) {
          log('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);
        }

        if (layer !== prevLayer) {
          layer.__used = true;

          if (layer.__startIndex !== i) {
            layer.__dirty = true;
          }

          layer.__startIndex = i;

          if (!layer.incremental) {
            layer.__drawIndex = i;
          } else {
            // Mark layer draw index needs to update.
            layer.__drawIndex = -1;
          }

          updatePrevLayer(i);
          prevLayer = layer;
        }

        if (el.__dirty) {
          layer.__dirty = true;

          if (layer.incremental && layer.__drawIndex < 0) {
            // Start draw from the first dirty element.
            layer.__drawIndex = i;
          }
        }
      }

      updatePrevLayer(i);
      this.eachBuiltinLayer(function (layer, z) {
        // Used in last frame but not in this frame. Needs clear
        if (!layer.__used && layer.getElementCount() > 0) {
          layer.__dirty = true;
          layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;
        } // For incremental layer. In case start index changed and no elements are dirty.


        if (layer.__dirty && layer.__drawIndex < 0) {
          layer.__drawIndex = layer.__startIndex;
        }
      });
    },

    /**
     * æ¸é¤hoverå±å¤ææåå®¹
     */
    clear: function () {
      this.eachBuiltinLayer(this._clearLayer);
      return this;
    },
    _clearLayer: function (layer) {
      layer.clear();
    },
    setBackgroundColor: function (backgroundColor) {
      this._backgroundColor = backgroundColor;
    },

    /**
     * ä¿®æ¹æå®zlevelçç»å¶åæ°
     *
     * @param {string} zlevel
     * @param {Object} config éç½®å¯¹è±¡
     * @param {string} [config.clearColor=0] æ¯æ¬¡æ¸ç©ºç»å¸çé¢è²
     * @param {string} [config.motionBlur=false] æ¯å¦å¼å¯å¨ææ¨¡ç³
     * @param {number} [config.lastFrameAlpha=0.7]
     *                 å¨å¼å¯å¨ææ¨¡ç³çæ¶åä½¿ç¨ï¼ä¸ä¸ä¸å¸§æ··åçalphaå¼ï¼å¼è¶å¤§å°¾è¿¹è¶ææ¾
     */
    configLayer: function (zlevel, config) {
      if (config) {
        var layerConfig = this._layerConfig;

        if (!layerConfig[zlevel]) {
          layerConfig[zlevel] = config;
        } else {
          util.merge(layerConfig[zlevel], config, true);
        }

        for (var i = 0; i < this._zlevelList.length; i++) {
          var _zlevel = this._zlevelList[i]; // TODO Remove EL_AFTER_INCREMENTAL_INC magic number

          if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
            var layer = this._layers[_zlevel];
            util.merge(layer, layerConfig[zlevel], true);
          }
        }
      }
    },

    /**
     * å é¤æå®å±
     * @param {number} zlevel å±æå¨çzlevel
     */
    delLayer: function (zlevel) {
      var layers = this._layers;
      var zlevelList = this._zlevelList;
      var layer = layers[zlevel];

      if (!layer) {
        return;
      }

      layer.dom.parentNode.removeChild(layer.dom);
      delete layers[zlevel];
      zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
    },

    /**
     * åºåå¤§å°åååéç»
     */
    resize: function (width, height) {
      if (!this._domRoot.style) {
        // Maybe in node or worker
        if (width == null || height == null) {
          return;
        }

        this._width = width;
        this._height = height;
        this.getLayer(CANVAS_ZLEVEL).resize(width, height);
      } else {
        var domRoot = this._domRoot; // FIXME Why ?

        domRoot.style.display = 'none'; // Save input w/h

        var opts = this._opts;
        width != null && (opts.width = width);
        height != null && (opts.height = height);
        width = this._getSize(0);
        height = this._getSize(1);
        domRoot.style.display = ''; // ä¼åæ²¡æå®éæ¹åçresize

        if (this._width !== width || height !== this._height) {
          domRoot.style.width = width + 'px';
          domRoot.style.height = height + 'px';

          for (var id in this._layers) {
            if (this._layers.hasOwnProperty(id)) {
              this._layers[id].resize(width, height);
            }
          }

          util.each(this._progressiveLayers, function (layer) {
            layer.resize(width, height);
          });
          this.refresh(true);
        }

        this._width = width;
        this._height = height;
      }

      return this;
    },

    /**
     * æ¸é¤åç¬çä¸ä¸ªå±
     * @param {number} zlevel
     */
    clearLayer: function (zlevel) {
      var layer = this._layers[zlevel];

      if (layer) {
        layer.clear();
      }
    },

    /**
     * éæ¾
     */
    dispose: function () {
      this.root.innerHTML = '';
      this.root = this.storage = this._domRoot = this._layers = null;
    },

    /**
     * Get canvas which has all thing rendered
     * @param {Object} opts
     * @param {string} [opts.backgroundColor]
     * @param {number} [opts.pixelRatio]
     */
    getRenderedCanvas: function (opts) {
      opts = opts || {};

      if (this._singleCanvas && !this._compositeManually) {
        return this._layers[CANVAS_ZLEVEL].dom;
      }

      var imageLayer = new Layer_1('image', this, opts.pixelRatio || this.dpr);
      imageLayer.initContext();
      imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);

      if (opts.pixelRatio <= this.dpr) {
        this.refresh();
        var width = imageLayer.dom.width;
        var height = imageLayer.dom.height;
        var ctx = imageLayer.ctx;
        this.eachLayer(function (layer) {
          if (layer.__builtin__) {
            ctx.drawImage(layer.dom, 0, 0, width, height);
          } else if (layer.renderToCanvas) {
            imageLayer.ctx.save();
            layer.renderToCanvas(imageLayer.ctx);
            imageLayer.ctx.restore();
          }
        });
      } else {
        // PENDING, echarts-gl and incremental rendering.
        var scope = {};
        var displayList = this.storage.getDisplayList(true);

        for (var i = 0; i < displayList.length; i++) {
          var el = displayList[i];

          this._doPaintEl(el, imageLayer, true, scope);
        }
      }

      return imageLayer.dom;
    },

    /**
     * è·åç»å¾åºåå®½åº¦
     */
    getWidth: function () {
      return this._width;
    },

    /**
     * è·åç»å¾åºåé«åº¦
     */
    getHeight: function () {
      return this._height;
    },
    _getSize: function (whIdx) {
      var opts = this._opts;
      var wh = ['width', 'height'][whIdx];
      var cwh = ['clientWidth', 'clientHeight'][whIdx];
      var plt = ['paddingLeft', 'paddingTop'][whIdx];
      var prb = ['paddingRight', 'paddingBottom'][whIdx];

      if (opts[wh] != null && opts[wh] !== 'auto') {
        return parseFloat(opts[wh]);
      }

      var root = this.root; // IE8 does not support getComputedStyle, but it use VML.

      var stl = document.defaultView.getComputedStyle(root);
      return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
    },
    pathToImage: function (path, dpr) {
      dpr = dpr || this.dpr;
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      var rect = path.getBoundingRect();
      var style = path.style;
      var shadowBlurSize = style.shadowBlur * dpr;
      var shadowOffsetX = style.shadowOffsetX * dpr;
      var shadowOffsetY = style.shadowOffsetY * dpr;
      var lineWidth = style.hasStroke() ? style.lineWidth : 0;
      var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
      var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
      var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
      var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
      var width = rect.width + leftMargin + rightMargin;
      var height = rect.height + topMargin + bottomMargin;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
      ctx.clearRect(0, 0, width, height);
      ctx.dpr = dpr;
      var pathTransform = {
        position: path.position,
        rotation: path.rotation,
        scale: path.scale
      };
      path.position = [leftMargin - rect.x, topMargin - rect.y];
      path.rotation = 0;
      path.scale = [1, 1];
      path.updateTransform();

      if (path) {
        path.brush(ctx);
      }

      var ImageShape = Image$1;
      var imgShape = new ImageShape({
        style: {
          x: 0,
          y: 0,
          image: canvas
        }
      });

      if (pathTransform.position != null) {
        imgShape.position = path.position = pathTransform.position;
      }

      if (pathTransform.rotation != null) {
        imgShape.rotation = path.rotation = pathTransform.rotation;
      }

      if (pathTransform.scale != null) {
        imgShape.scale = path.scale = pathTransform.scale;
      }

      return imgShape;
    }
  };
  var _default$p = Painter;
  var Painter_1 = _default$p;

  var Dispatcher$1 = event.Dispatcher;





  /**
   * Animation main class, dispatch and manage all animation controllers
   *
   * @module zrender/animation/Animation
   * @author pissang(https://github.com/pissang)
   */
  // TODO Additive animation
  // http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
  // https://developer.apple.com/videos/wwdc2014/#236

  /**
   * @typedef {Object} IZRenderStage
   * @property {Function} update
   */

  /**
   * @alias module:zrender/animation/Animation
   * @constructor
   * @param {Object} [options]
   * @param {Function} [options.onframe]
   * @param {IZRenderStage} [options.stage]
   * @example
   *     var animation = new Animation();
   *     var obj = {
   *         x: 100,
   *         y: 100
   *     };
   *     animation.animate(node.position)
   *         .when(1000, {
   *             x: 500,
   *             y: 500
   *         })
   *         .when(2000, {
   *             x: 100,
   *             y: 100
   *         })
   *         .start('spline');
   */
  var Animation = function (options) {
    options = options || {};
    this.stage = options.stage || {};

    this.onframe = options.onframe || function () {}; // private properties


    this._clips = [];
    this._running = false;
    this._time;
    this._pausedTime;
    this._pauseStart;
    this._paused = false;
    Dispatcher$1.call(this);
  };

  Animation.prototype = {
    constructor: Animation,

    /**
     * Add clip
     * @param {module:zrender/animation/Clip} clip
     */
    addClip: function (clip) {
      this._clips.push(clip);
    },

    /**
     * Add animator
     * @param {module:zrender/animation/Animator} animator
     */
    addAnimator: function (animator) {
      animator.animation = this;
      var clips = animator.getClips();

      for (var i = 0; i < clips.length; i++) {
        this.addClip(clips[i]);
      }
    },

    /**
     * Delete animation clip
     * @param {module:zrender/animation/Clip} clip
     */
    removeClip: function (clip) {
      var idx = util.indexOf(this._clips, clip);

      if (idx >= 0) {
        this._clips.splice(idx, 1);
      }
    },

    /**
     * Delete animation clip
     * @param {module:zrender/animation/Animator} animator
     */
    removeAnimator: function (animator) {
      var clips = animator.getClips();

      for (var i = 0; i < clips.length; i++) {
        this.removeClip(clips[i]);
      }

      animator.animation = null;
    },
    _update: function () {
      var time = new Date().getTime() - this._pausedTime;

      var delta = time - this._time;
      var clips = this._clips;
      var len = clips.length;
      var deferredEvents = [];
      var deferredClips = [];

      for (var i = 0; i < len; i++) {
        var clip = clips[i];
        var e = clip.step(time, delta); // Throw out the events need to be called after
        // stage.update, like destroy

        if (e) {
          deferredEvents.push(e);
          deferredClips.push(clip);
        }
      } // Remove the finished clip


      for (var i = 0; i < len;) {
        if (clips[i]._needsRemove) {
          clips[i] = clips[len - 1];
          clips.pop();
          len--;
        } else {
          i++;
        }
      }

      len = deferredEvents.length;

      for (var i = 0; i < len; i++) {
        deferredClips[i].fire(deferredEvents[i]);
      }

      this._time = time;
      this.onframe(delta); // 'frame' should be triggered before stage, because upper application
      // depends on the sequence (e.g., echarts-stream and finish
      // event judge)

      this.trigger('frame', delta);

      if (this.stage.update) {
        this.stage.update();
      }
    },
    _startLoop: function () {
      var self = this;
      this._running = true;

      function step() {
        if (self._running) {
          requestAnimationFrame(step);
          !self._paused && self._update();
        }
      }

      requestAnimationFrame(step);
    },

    /**
     * Start animation.
     */
    start: function () {
      this._time = new Date().getTime();
      this._pausedTime = 0;

      this._startLoop();
    },

    /**
     * Stop animation.
     */
    stop: function () {
      this._running = false;
    },

    /**
     * Pause animation.
     */
    pause: function () {
      if (!this._paused) {
        this._pauseStart = new Date().getTime();
        this._paused = true;
      }
    },

    /**
     * Resume animation.
     */
    resume: function () {
      if (this._paused) {
        this._pausedTime += new Date().getTime() - this._pauseStart;
        this._paused = false;
      }
    },

    /**
     * Clear animation.
     */
    clear: function () {
      this._clips = [];
    },

    /**
     * Whether animation finished.
     */
    isFinished: function () {
      return !this._clips.length;
    },

    /**
     * Creat animator for a target, whose props can be animated.
     *
     * @param  {Object} target
     * @param  {Object} options
     * @param  {boolean} [options.loop=false] Whether loop animation.
     * @param  {Function} [options.getter=null] Get value from target.
     * @param  {Function} [options.setter=null] Set value to target.
     * @return {module:zrender/animation/Animation~Animator}
     */
    // TODO Gap
    animate: function (target, options) {
      options = options || {};
      var animator = new Animator_1(target, options.loop, options.getter, options.setter);
      this.addAnimator(animator);
      return animator;
    }
  };
  util.mixin(Animation, Dispatcher$1);
  var _default$q = Animation;
  var Animation_1 = _default$q;

  var addEventListener$1 = event.addEventListener;
  var removeEventListener$1 = event.removeEventListener;
  var normalizeEvent$1 = event.normalizeEvent;
  var getNativeEvent$1 = event.getNativeEvent;







  /* global document */
  var TOUCH_CLICK_DELAY = 300;
  var globalEventSupported = env_1.domSupported;

  var localNativeListenerNames = function () {
    var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
    var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
    var pointerEventNameMap = {
      pointerdown: 1,
      pointerup: 1,
      pointermove: 1,
      pointerout: 1
    };
    var pointerHandlerNames = util.map(mouseHandlerNames, function (name) {
      var nm = name.replace('mouse', 'pointer');
      return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
    });
    return {
      mouse: mouseHandlerNames,
      touch: touchHandlerNames,
      pointer: pointerHandlerNames
    };
  }();

  var globalNativeListenerNames = {
    mouse: ['mousemove', 'mouseup'],
    pointer: ['pointermove', 'pointerup']
  };

  function eventNameFix(name) {
    return name === 'mousewheel' && env_1.browser.firefox ? 'DOMMouseScroll' : name;
  }

  function isPointerFromTouch(event) {
    var pointerType = event.pointerType;
    return pointerType === 'pen' || pointerType === 'touch';
  } // function useMSGuesture(handlerProxy, event) {
  //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
  // }
  // function onMSGestureChange(proxy, event) {
  //     if (event.translationX || event.translationY) {
  //         // mousemove is carried by MSGesture to reduce the sensitivity.
  //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
  //     }
  //     if (event.scale !== 1) {
  //         event.pinchX = event.offsetX;
  //         event.pinchY = event.offsetY;
  //         event.pinchScale = event.scale;
  //         proxy.handler.dispatchToElement(event.target, 'pinch', event);
  //     }
  // }

  /**
   * Prevent mouse event from being dispatched after Touch Events action
   * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
   * 1. Mobile browsers dispatch mouse events 300ms after touchend.
   * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
   * Result: Blocking Mouse Events for 700ms.
   *
   * @param {DOMHandlerScope} scope
   */


  function setTouchTimer(scope) {
    scope.touching = true;

    if (scope.touchTimer != null) {
      clearTimeout(scope.touchTimer);
      scope.touchTimer = null;
    }

    scope.touchTimer = setTimeout(function () {
      scope.touching = false;
      scope.touchTimer = null;
    }, 700);
  } // Mark touch, which is useful in distinguish touch and
  // mouse event in upper applicatoin.


  function markTouch(event) {
    event && (event.zrByTouch = true);
  } // function markTriggeredFromLocal(event) {
  //     event && (event.__zrIsFromLocal = true);
  // }
  // function isTriggeredFromLocal(instance, event) {
  //     return !!(event && event.__zrIsFromLocal);
  // }


  function normalizeGlobalEvent(instance, event) {
    // offsetX, offsetY still need to be calculated. They are necessary in the event
    // handlers of the upper applications. Set `true` to force calculate them.
    return normalizeEvent$1(instance.dom, new FakeGlobalEvent(instance, event), true);
  }
  /**
   * Detect whether the given el is in `painterRoot`.
   */


  function isLocalEl(instance, el) {
    var elTmp = el;
    var isLocal = false;

    while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
      elTmp = elTmp.parentNode;
    }

    return isLocal;
  }
  /**
   * Make a fake event but not change the original event,
   * becuase the global event probably be used by other
   * listeners not belonging to zrender.
   * @class
   */


  function FakeGlobalEvent(instance, event) {
    this.type = event.type;
    this.target = this.currentTarget = instance.dom;
    this.pointerType = event.pointerType; // Necessray for the force calculation of zrX, zrY

    this.clientX = event.clientX;
    this.clientY = event.clientY; // Because we do not mount global listeners to touch events,
    // we do not copy `targetTouches` and `changedTouches` here.
  }

  var fakeGlobalEventProto = FakeGlobalEvent.prototype; // we make the default methods on the event do nothing,
  // otherwise it is dangerous. See more details in
  // [Drag outside] in `Handler.js`.

  fakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = util.noop;
  /**
   * Local DOM Handlers
   * @this {HandlerProxy}
   */

  var localDOMHandlers = {
    mousedown: function (event) {
      event = normalizeEvent$1(this.dom, event);
      this._mayPointerCapture = [event.zrX, event.zrY];
      this.trigger('mousedown', event);
    },
    mousemove: function (event) {
      event = normalizeEvent$1(this.dom, event);
      var downPoint = this._mayPointerCapture;

      if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
        togglePointerCapture(this, true);
      }

      this.trigger('mousemove', event);
    },
    mouseup: function (event) {
      event = normalizeEvent$1(this.dom, event);
      togglePointerCapture(this, false);
      this.trigger('mouseup', event);
    },
    mouseout: function (event) {
      event = normalizeEvent$1(this.dom, event); // Similarly to the browser did on `document` and touch event,
      // `globalout` will be delayed to final pointer cature release.

      if (this._pointerCapturing) {
        event.zrEventControl = 'no_globalout';
      } // There might be some doms created by upper layer application
      // at the same level of painter.getViewportRoot() (e.g., tooltip
      // dom created by echarts), where 'globalout' event should not
      // be triggered when mouse enters these doms. (But 'mouseout'
      // should be triggered at the original hovered element as usual).


      var element = event.toElement || event.relatedTarget;
      event.zrIsToLocalDOM = isLocalEl(this, element);
      this.trigger('mouseout', event);
    },
    touchstart: function (event) {
      // Default mouse behaviour should not be disabled here.
      // For example, page may needs to be slided.
      event = normalizeEvent$1(this.dom, event);
      markTouch(event);
      this._lastTouchMoment = new Date();
      this.handler.processGesture(event, 'start'); // For consistent event listener for both touch device and mouse device,
      // we simulate "mouseover-->mousedown" in touch device. So we trigger
      // `mousemove` here (to trigger `mouseover` inside), and then trigger
      // `mousedown`.

      localDOMHandlers.mousemove.call(this, event);
      localDOMHandlers.mousedown.call(this, event);
    },
    touchmove: function (event) {
      event = normalizeEvent$1(this.dom, event);
      markTouch(event);
      this.handler.processGesture(event, 'change'); // Mouse move should always be triggered no matter whether
      // there is gestrue event, because mouse move and pinch may
      // be used at the same time.

      localDOMHandlers.mousemove.call(this, event);
    },
    touchend: function (event) {
      event = normalizeEvent$1(this.dom, event);
      markTouch(event);
      this.handler.processGesture(event, 'end');
      localDOMHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
      // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
      // we can conveniently implement "hover style" in both PC and touch device just
      // by listening to `mouseover` to add "hover style" and listening to `mouseout`
      // to remove "hover style" on an element, without any additional code for
      // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
      // style" will remain for user view)
      // click event should always be triggered no matter whether
      // there is gestrue event. System click can not be prevented.

      if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
        localDOMHandlers.click.call(this, event);
      }
    },
    pointerdown: function (event) {
      localDOMHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
      //     this._msGesture.addPointer(event.pointerId);
      // }
    },
    pointermove: function (event) {
      // FIXME
      // pointermove is so sensitive that it always triggered when
      // tap(click) on touch screen, which affect some judgement in
      // upper application. So, we dont support mousemove on MS touch
      // device yet.
      if (!isPointerFromTouch(event)) {
        localDOMHandlers.mousemove.call(this, event);
      }
    },
    pointerup: function (event) {
      localDOMHandlers.mouseup.call(this, event);
    },
    pointerout: function (event) {
      // pointerout will be triggered when tap on touch screen
      // (IE11+/Edge on MS Surface) after click event triggered,
      // which is inconsistent with the mousout behavior we defined
      // in touchend. So we unify them.
      // (check localDOMHandlers.touchend for detailed explanation)
      if (!isPointerFromTouch(event)) {
        localDOMHandlers.mouseout.call(this, event);
      }
    }
  };
  /**
   * Othere DOM UI Event handlers for zr dom.
   * @this {HandlerProxy}
   */

  util.each(['click', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
    localDOMHandlers[name] = function (event) {
      event = normalizeEvent$1(this.dom, event);
      this.trigger(name, event);
    };
  });
  /**
   * DOM UI Event handlers for global page.
   *
   * [Caution]:
   * those handlers should both support in capture phase and bubble phase!
   *
   * @this {HandlerProxy}
   */

  var globalDOMHandlers = {
    pointermove: function (event) {
      // FIXME
      // pointermove is so sensitive that it always triggered when
      // tap(click) on touch screen, which affect some judgement in
      // upper application. So, we dont support mousemove on MS touch
      // device yet.
      if (!isPointerFromTouch(event)) {
        globalDOMHandlers.mousemove.call(this, event);
      }
    },
    pointerup: function (event) {
      globalDOMHandlers.mouseup.call(this, event);
    },
    mousemove: function (event) {
      this.trigger('mousemove', event);
    },
    mouseup: function (event) {
      var pointerCaptureReleasing = this._pointerCapturing;
      togglePointerCapture(this, false);
      this.trigger('mouseup', event);

      if (pointerCaptureReleasing) {
        event.zrEventControl = 'only_globalout';
        this.trigger('mouseout', event);
      }
    }
  };
  /**
   * @param {HandlerProxy} instance
   * @param {DOMHandlerScope} scope
   */

  function mountLocalDOMEventListeners(instance, scope) {
    var domHandlers = scope.domHandlers;

    if (env_1.pointerEventsSupported) {
      // Only IE11+/Edge
      // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
      // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
      // at the same time.
      // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
      // screen, which do not occurs in pointer event.
      // So we use pointer event to both detect touch gesture and mouse behavior.
      util.each(localNativeListenerNames.pointer, function (nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function (event) {
          // markTriggeredFromLocal(event);
          domHandlers[nativeEventName].call(instance, event);
        });
      }); // FIXME
      // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
      // which does not prevent defuault behavior occasionally (which may cause view port
      // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
      // So we have to not to use MSGesture and not to support touchmove and pinch on MS
      // touch screen. And we only support click behavior on MS touch screen now.
      // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
      // We dont support touch on IE on win7.
      // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
      // if (typeof MSGesture === 'function') {
      //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
      //     dom.addEventListener('MSGestureChange', onMSGestureChange);
      // }
    } else {
      if (env_1.touchEventsSupported) {
        util.each(localNativeListenerNames.touch, function (nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function (event) {
            // markTriggeredFromLocal(event);
            domHandlers[nativeEventName].call(instance, event);
            setTouchTimer(scope);
          });
        }); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
        // addEventListener(root, 'mouseout', this._mouseoutHandler);
      } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
      // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
      // mouse event can not be handle in those devices.
      // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
      // mouseevent after touch event triggered, see `setTouchTimer`.


      util.each(localNativeListenerNames.mouse, function (nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function (event) {
          event = getNativeEvent$1(event);

          if (!scope.touching) {
            // markTriggeredFromLocal(event);
            domHandlers[nativeEventName].call(instance, event);
          }
        });
      });
    }
  }
  /**
   * @param {HandlerProxy} instance
   * @param {DOMHandlerScope} scope
   */


  function mountGlobalDOMEventListeners(instance, scope) {
    // Only IE11+/Edge. See the comment in `mountLocalDOMEventListeners`.
    if (env_1.pointerEventsSupported) {
      util.each(globalNativeListenerNames.pointer, mount);
    } // Touch event has implemented "drag outside" so we do not mount global listener for touch event.
    // (see https://www.w3.org/TR/touch-events/#the-touchmove-event)
    // We do not consider "both-support-touch-and-mouse device" for this feature (see the comment of
    // `mountLocalDOMEventListeners`) to avoid bugs util some requirements come.
    else if (!env_1.touchEventsSupported) {
        util.each(globalNativeListenerNames.mouse, mount);
      }

    function mount(nativeEventName) {
      function nativeEventListener(event) {
        event = getNativeEvent$1(event); // See the reason in [Drag outside] in `Handler.js`
        // This checking supports both `useCapture` or not.
        // PENDING: if there is performance issue in some devices,
        // we probably can not use `useCapture` and change a easier
        // to judes whether local (mark).

        if (!isLocalEl(instance, event.target)) {
          event = normalizeGlobalEvent(instance, event);
          scope.domHandlers[nativeEventName].call(instance, event);
        }
      }

      mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, {
        capture: true
      } // See [Drag Outside] in `Handler.js`
      );
    }
  }

  function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
    scope.mounted[nativeEventName] = listener;
    scope.listenerOpts[nativeEventName] = opt;
    addEventListener$1(scope.domTarget, eventNameFix(nativeEventName), listener, opt);
  }

  function unmountDOMEventListeners(scope) {
    var mounted = scope.mounted;

    for (var nativeEventName in mounted) {
      if (mounted.hasOwnProperty(nativeEventName)) {
        removeEventListener$1(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
      }
    }

    scope.mounted = {};
  }
  /**
   * See [Drag Outside] in `Handler.js`.
   * @implement
   * @param {boolean} isPointerCapturing Should never be `null`/`undefined`.
   *        `true`: start to capture pointer if it is not capturing.
   *        `false`: end the capture if it is capturing.
   */


  function togglePointerCapture(instance, isPointerCapturing) {
    instance._mayPointerCapture = null;

    if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {
      instance._pointerCapturing = isPointerCapturing;
      var globalHandlerScope = instance._globalHandlerScope;
      isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
    }
  }
  /**
   * @inner
   * @class
   */


  function DOMHandlerScope(domTarget, domHandlers) {
    this.domTarget = domTarget;
    this.domHandlers = domHandlers; // Key: eventName, value: mounted handler funcitons.
    // Used for unmount.

    this.mounted = {};
    this.listenerOpts = {};
    this.touchTimer = null;
    this.touching = false;
  }
  /**
   * @public
   * @class
   */


  function HandlerDomProxy(dom, painterRoot) {
    Eventful_1.call(this);
    this.dom = dom;
    this.painterRoot = painterRoot;
    this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);

    if (globalEventSupported) {
      this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
    }
    /**
     * @type {boolean}
     */


    this._pointerCapturing = false;
    /**
     * @type {Array.<number>} [x, y] or null.
     */

    this._mayPointerCapture = null;
    mountLocalDOMEventListeners(this, this._localHandlerScope);
  }

  var handlerDomProxyProto = HandlerDomProxy.prototype;

  handlerDomProxyProto.dispose = function () {
    unmountDOMEventListeners(this._localHandlerScope);

    if (globalEventSupported) {
      unmountDOMEventListeners(this._globalHandlerScope);
    }
  };

  handlerDomProxyProto.setCursor = function (cursorStyle) {
    this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');
  };

  util.mixin(HandlerDomProxy, Eventful_1);
  var _default$r = HandlerDomProxy;
  var HandlerProxy = _default$r;

  /*!
  * ZRender, a high performance 2d drawing library.
  *
  * Copyright (c) 2013, Baidu Inc.
  * All rights reserved.
  *
  * LICENSE
  * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
  */
  var useVML = !env_1.canvasSupported;
  var painterCtors = {
    canvas: Painter_1
  };
  var instances = {}; // ZRenderå®ä¾mapç´¢å¼

  /**
   * @type {string}
   */

  var version$1 = '4.3.2';
  /**
   * Initializing a zrender instance
   * @param {HTMLElement} dom
   * @param {Object} [opts]
   * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
   * @param {number} [opts.devicePixelRatio]
   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
   * @return {module:zrender/ZRender}
   */

  function init(dom, opts) {
    var zr = new ZRender(guid(), dom, opts);
    instances[zr.id] = zr;
    return zr;
  }
  /**
   * Dispose zrender instance
   * @param {module:zrender/ZRender} zr
   */


  function dispose(zr) {
    if (zr) {
      zr.dispose();
    } else {
      for (var key in instances) {
        if (instances.hasOwnProperty(key)) {
          instances[key].dispose();
        }
      }

      instances = {};
    }

    return this;
  }
  /**
   * Get zrender instance by id
   * @param {string} id zrender instance id
   * @return {module:zrender/ZRender}
   */


  function getInstance(id) {
    return instances[id];
  }

  function registerPainter(name, Ctor) {
    painterCtors[name] = Ctor;
  }

  function delInstance(id) {
    delete instances[id];
  }
  /**
   * @module zrender/ZRender
   */

  /**
   * @constructor
   * @alias module:zrender/ZRender
   * @param {string} id
   * @param {HTMLElement} dom
   * @param {Object} opts
   * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
   * @param {number} [opts.devicePixelRatio]
   * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
   * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
   */


  var ZRender = function (id, dom, opts) {
    opts = opts || {};
    /**
     * @type {HTMLDomElement}
     */

    this.dom = dom;
    /**
     * @type {string}
     */

    this.id = id;
    var self = this;
    var storage = new Storage_1();
    var rendererType = opts.renderer; // TODO WebGL

    if (useVML) {
      if (!painterCtors.vml) {
        throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
      }

      rendererType = 'vml';
    } else if (!rendererType || !painterCtors[rendererType]) {
      rendererType = 'canvas';
    }

    var painter = new painterCtors[rendererType](dom, storage, opts, id);
    this.storage = storage;
    this.painter = painter;
    var handerProxy = !env_1.node && !env_1.worker ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;
    this.handler = new Handler_1(storage, painter, handerProxy, painter.root);
    /**
     * @type {module:zrender/animation/Animation}
     */

    this.animation = new Animation_1({
      stage: {
        update: util.bind(this.flush, this)
      }
    });
    this.animation.start();
    /**
     * @type {boolean}
     * @private
     */

    this._needsRefresh; // ä¿®æ¹ storage.delFromStorage, æ¯æ¬¡å é¤åç´ ä¹åå é¤å¨ç»
    // FIXME æç¹ugly

    var oldDelFromStorage = storage.delFromStorage;
    var oldAddToStorage = storage.addToStorage;

    storage.delFromStorage = function (el) {
      oldDelFromStorage.call(storage, el);
      el && el.removeSelfFromZr(self);
    };

    storage.addToStorage = function (el) {
      oldAddToStorage.call(storage, el);
      el.addSelfToZr(self);
    };
  };

  ZRender.prototype = {
    constructor: ZRender,

    /**
     * è·åå®ä¾å¯ä¸æ è¯
     * @return {string}
     */
    getId: function () {
      return this.id;
    },

    /**
     * æ·»å åç´ 
     * @param  {module:zrender/Element} el
     */
    add: function (el) {
      this.storage.addRoot(el);
      this._needsRefresh = true;
    },

    /**
     * å é¤åç´ 
     * @param  {module:zrender/Element} el
     */
    remove: function (el) {
      this.storage.delRoot(el);
      this._needsRefresh = true;
    },

    /**
     * Change configuration of layer
     * @param {string} zLevel
     * @param {Object} config
     * @param {string} [config.clearColor=0] Clear color
     * @param {string} [config.motionBlur=false] If enable motion blur
     * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
    */
    configLayer: function (zLevel, config) {
      if (this.painter.configLayer) {
        this.painter.configLayer(zLevel, config);
      }

      this._needsRefresh = true;
    },

    /**
     * Set background color
     * @param {string} backgroundColor
     */
    setBackgroundColor: function (backgroundColor) {
      if (this.painter.setBackgroundColor) {
        this.painter.setBackgroundColor(backgroundColor);
      }

      this._needsRefresh = true;
    },

    /**
     * Repaint the canvas immediately
     */
    refreshImmediately: function () {
      // var start = new Date();
      // Clear needsRefresh ahead to avoid something wrong happens in refresh
      // Or it will cause zrender refreshes again and again.
      this._needsRefresh = this._needsRefreshHover = false;
      this.painter.refresh(); // Avoid trigger zr.refresh in Element#beforeUpdate hook

      this._needsRefresh = this._needsRefreshHover = false; // var end = new Date();
      // var log = document.getElementById('log');
      // if (log) {
      //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
      // }
    },

    /**
     * Mark and repaint the canvas in the next frame of browser
     */
    refresh: function () {
      this._needsRefresh = true;
    },

    /**
     * Perform all refresh
     */
    flush: function () {
      var triggerRendered;

      if (this._needsRefresh) {
        triggerRendered = true;
        this.refreshImmediately();
      }

      if (this._needsRefreshHover) {
        triggerRendered = true;
        this.refreshHoverImmediately();
      }

      triggerRendered && this.trigger('rendered');
    },

    /**
     * Add element to hover layer
     * @param  {module:zrender/Element} el
     * @param {Object} style
     */
    addHover: function (el, style) {
      if (this.painter.addHover) {
        var elMirror = this.painter.addHover(el, style);
        this.refreshHover();
        return elMirror;
      }
    },

    /**
     * Add element from hover layer
     * @param  {module:zrender/Element} el
     */
    removeHover: function (el) {
      if (this.painter.removeHover) {
        this.painter.removeHover(el);
        this.refreshHover();
      }
    },

    /**
     * Clear all hover elements in hover layer
     * @param  {module:zrender/Element} el
     */
    clearHover: function () {
      if (this.painter.clearHover) {
        this.painter.clearHover();
        this.refreshHover();
      }
    },

    /**
     * Refresh hover in next frame
     */
    refreshHover: function () {
      this._needsRefreshHover = true;
    },

    /**
     * Refresh hover immediately
     */
    refreshHoverImmediately: function () {
      this._needsRefreshHover = false;
      this.painter.refreshHover && this.painter.refreshHover();
    },

    /**
     * Resize the canvas.
     * Should be invoked when container size is changed
     * @param {Object} [opts]
     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
     */
    resize: function (opts) {
      opts = opts || {};
      this.painter.resize(opts.width, opts.height);
      this.handler.resize();
    },

    /**
     * Stop and clear all animation immediately
     */
    clearAnimation: function () {
      this.animation.clear();
    },

    /**
     * Get container width
     */
    getWidth: function () {
      return this.painter.getWidth();
    },

    /**
     * Get container height
     */
    getHeight: function () {
      return this.painter.getHeight();
    },

    /**
     * Export the canvas as Base64 URL
     * @param {string} type
     * @param {string} [backgroundColor='#fff']
     * @return {string} Base64 URL
     */
    // toDataURL: function(type, backgroundColor) {
    //     return this.painter.getRenderedCanvas({
    //         backgroundColor: backgroundColor
    //     }).toDataURL(type);
    // },

    /**
     * Converting a path to image.
     * It has much better performance of drawing image rather than drawing a vector path.
     * @param {module:zrender/graphic/Path} e
     * @param {number} width
     * @param {number} height
     */
    pathToImage: function (e, dpr) {
      return this.painter.pathToImage(e, dpr);
    },

    /**
     * Set default cursor
     * @param {string} [cursorStyle='default'] ä¾å¦ crosshair
     */
    setCursorStyle: function (cursorStyle) {
      this.handler.setCursorStyle(cursorStyle);
    },

    /**
     * Find hovered element
     * @param {number} x
     * @param {number} y
     * @return {Object} {target, topTarget}
     */
    findHover: function (x, y) {
      return this.handler.findHover(x, y);
    },

    /**
     * Bind event
     *
     * @param {string} eventName Event name
     * @param {Function} eventHandler Handler function
     * @param {Object} [context] Context object
     */
    on: function (eventName, eventHandler, context) {
      this.handler.on(eventName, eventHandler, context);
    },

    /**
     * Unbind event
     * @param {string} eventName Event name
     * @param {Function} [eventHandler] Handler function
     */
    off: function (eventName, eventHandler) {
      this.handler.off(eventName, eventHandler);
    },

    /**
     * Trigger event manually
     *
     * @param {string} eventName Event name
     * @param {event=} event Event object
     */
    trigger: function (eventName, event) {
      this.handler.trigger(eventName, event);
    },

    /**
     * Clear all objects and the canvas.
     */
    clear: function () {
      this.storage.delRoot();
      this.painter.clear();
    },

    /**
     * Dispose self.
     */
    dispose: function () {
      this.animation.stop();
      this.clear();
      this.storage.dispose();
      this.painter.dispose();
      this.handler.dispose();
      this.animation = this.storage = this.painter = this.handler = null;
      delInstance(this.id);
    }
  };
  var version_1 = version$1;
  var init_1 = init;
  var dispose_1 = dispose;
  var getInstance_1 = getInstance;
  var registerPainter_1 = registerPainter;

  var zrender = {
  	version: version_1,
  	init: init_1,
  	dispose: dispose_1,
  	getInstance: getInstance_1,
  	registerPainter: registerPainter_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var each$2 = util.each;
  var isObject$5 = util.isObject;
  var isArray$3 = util.isArray;
  /**
   * Make the name displayable. But we should
   * make sure it is not duplicated with user
   * specified name, so use '\0';
   */

  var DUMMY_COMPONENT_NAME_PREFIX = 'series\0';
  /**
   * If value is not array, then translate it to array.
   * @param  {*} value
   * @return {Array} [value] or value
   */

  function normalizeToArray(value) {
    return value instanceof Array ? value : value == null ? [] : [value];
  }
  /**
   * Sync default option between normal and emphasis like `position` and `show`
   * In case some one will write code like
   *     label: {
   *          show: false,
   *          position: 'outside',
   *          fontSize: 18
   *     },
   *     emphasis: {
   *          label: { show: true }
   *     }
   * @param {Object} opt
   * @param {string} key
   * @param {Array.<string>} subOpts
   */


  function defaultEmphasis(opt, key, subOpts) {
    // Caution: performance sensitive.
    if (opt) {
      opt[key] = opt[key] || {};
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal

      for (var i = 0, len = subOpts.length; i < len; i++) {
        var subOptName = subOpts[i];

        if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
          opt.emphasis[key][subOptName] = opt[key][subOptName];
        }
      }
    }
  }

  var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([
  //     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',
  //     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',
  //     // FIXME: deprecated, check and remove it.
  //     'textStyle'
  // ]);

  /**
   * The method do not ensure performance.
   * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
   * This helper method retieves value from data.
   * @param {string|number|Date|Array|Object} dataItem
   * @return {number|string|Date|Array.<number|string|Date>}
   */

  function getDataItemValue(dataItem) {
    return isObject$5(dataItem) && !isArray$3(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
  }
  /**
   * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
   * This helper method determine if dataItem has extra option besides value
   * @param {string|number|Date|Array|Object} dataItem
   */


  function isDataItemOption(dataItem) {
    return isObject$5(dataItem) && !(dataItem instanceof Array); // // markLine data can be array
    // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
  }
  /**
   * Mapping to exists for merge.
   *
   * @public
   * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists
   * @param {Object|Array.<Object>} newCptOptions
   * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
   *                          index of which is the same as exists.
   */


  function mappingToExists(exists, newCptOptions) {
    // Mapping by the order by original option (but not order of
    // new option) in merge mode. Because we should ensure
    // some specified index (like xAxisIndex) is consistent with
    // original option, which is easy to understand, espatially in
    // media query. And in most case, merge option is used to
    // update partial option but not be expected to change order.
    newCptOptions = (newCptOptions || []).slice();
    var result = util.map(exists || [], function (obj, index) {
      return {
        exist: obj
      };
    }); // Mapping by id or name if specified.

    each$2(newCptOptions, function (cptOption, index) {
      if (!isObject$5(cptOption)) {
        return;
      } // id has highest priority.


      for (var i = 0; i < result.length; i++) {
        if (!result[i].option // Consider name: two map to one.
        && cptOption.id != null && result[i].exist.id === cptOption.id + '') {
          result[i].option = cptOption;
          newCptOptions[index] = null;
          return;
        }
      }

      for (var i = 0; i < result.length; i++) {
        var exist = result[i].exist;

        if (!result[i].option // Consider name: two map to one.
        // Can not match when both ids exist but different.
        && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {
          result[i].option = cptOption;
          newCptOptions[index] = null;
          return;
        }
      }
    }); // Otherwise mapping by index.

    each$2(newCptOptions, function (cptOption, index) {
      if (!isObject$5(cptOption)) {
        return;
      }

      var i = 0;

      for (; i < result.length; i++) {
        var exist = result[i].exist;

        if (!result[i].option // Existing model that already has id should be able to
        // mapped to (because after mapping performed model may
        // be assigned with a id, whish should not affect next
        // mapping), except those has inner id.
        && !isIdInner(exist) // Caution:
        // Do not overwrite id. But name can be overwritten,
        // because axis use name as 'show label text'.
        // 'exist' always has id and name and we dont
        // need to check it.
        && cptOption.id == null) {
          result[i].option = cptOption;
          break;
        }
      }

      if (i >= result.length) {
        result.push({
          option: cptOption
        });
      }
    });
    return result;
  }
  /**
   * Make id and name for mapping result (result of mappingToExists)
   * into `keyInfo` field.
   *
   * @public
   * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
   *                          which order is the same as exists.
   * @return {Array.<Object>} The input.
   */


  function makeIdAndName(mapResult) {
    // We use this id to hash component models and view instances
    // in echarts. id can be specified by user, or auto generated.
    // The id generation rule ensures new view instance are able
    // to mapped to old instance when setOption are called in
    // no-merge mode. So we generate model id by name and plus
    // type in view id.
    // name can be duplicated among components, which is convenient
    // to specify multi components (like series) by one name.
    // Ensure that each id is distinct.
    var idMap = util.createHashMap();
    each$2(mapResult, function (item, index) {
      var existCpt = item.exist;
      existCpt && idMap.set(existCpt.id, item);
    });
    each$2(mapResult, function (item, index) {
      var opt = item.option;
      util.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));
      opt && opt.id != null && idMap.set(opt.id, item);
      !item.keyInfo && (item.keyInfo = {});
    }); // Make name and id.

    each$2(mapResult, function (item, index) {
      var existCpt = item.exist;
      var opt = item.option;
      var keyInfo = item.keyInfo;

      if (!isObject$5(opt)) {
        return;
      } // name can be overwitten. Consider case: axis.name = '20km'.
      // But id generated by name will not be changed, which affect
      // only in that case: setOption with 'not merge mode' and view
      // instance will be recreated, which can be accepted.


      keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name // Avoid diffferent series has the same name,
      // because name may be used like in color pallet.
      : DUMMY_COMPONENT_NAME_PREFIX + index;

      if (existCpt) {
        keyInfo.id = existCpt.id;
      } else if (opt.id != null) {
        keyInfo.id = opt.id + '';
      } else {
        // Consider this situatoin:
        //  optionA: [{name: 'a'}, {name: 'a'}, {..}]
        //  optionB [{..}, {name: 'a'}, {name: 'a'}]
        // Series with the same name between optionA and optionB
        // should be mapped.
        var idNum = 0;

        do {
          keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
        } while (idMap.get(keyInfo.id));
      }

      idMap.set(keyInfo.id, item);
    });
  }

  function isNameSpecified(componentModel) {
    var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.

    return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
  }
  /**
   * @public
   * @param {Object} cptOption
   * @return {boolean}
   */


  function isIdInner(cptOption) {
    return isObject$5(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\0_ec_\0') === 0;
  }
  /**
   * A helper for removing duplicate items between batchA and batchB,
   * and in themselves, and categorize by series.
   *
   * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
   * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
   * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]
   */


  function compressBatches(batchA, batchB) {
    var mapA = {};
    var mapB = {};
    makeMap(batchA || [], mapA);
    makeMap(batchB || [], mapB, mapA);
    return [mapToArray(mapA), mapToArray(mapB)];

    function makeMap(sourceBatch, map, otherMap) {
      for (var i = 0, len = sourceBatch.length; i < len; i++) {
        var seriesId = sourceBatch[i].seriesId;
        var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
        var otherDataIndices = otherMap && otherMap[seriesId];

        for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
          var dataIndex = dataIndices[j];

          if (otherDataIndices && otherDataIndices[dataIndex]) {
            otherDataIndices[dataIndex] = null;
          } else {
            (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
          }
        }
      }
    }

    function mapToArray(map, isData) {
      var result = [];

      for (var i in map) {
        if (map.hasOwnProperty(i) && map[i] != null) {
          if (isData) {
            result.push(+i);
          } else {
            var dataIndices = mapToArray(map[i], true);
            dataIndices.length && result.push({
              seriesId: i,
              dataIndex: dataIndices
            });
          }
        }
      }

      return result;
    }
  }
  /**
   * @param {module:echarts/data/List} data
   * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name
   *                         each of which can be Array or primary type.
   * @return {number|Array.<number>} dataIndex If not found, return undefined/null.
   */


  function queryDataIndex(data, payload) {
    if (payload.dataIndexInside != null) {
      return payload.dataIndexInside;
    } else if (payload.dataIndex != null) {
      return util.isArray(payload.dataIndex) ? util.map(payload.dataIndex, function (value) {
        return data.indexOfRawIndex(value);
      }) : data.indexOfRawIndex(payload.dataIndex);
    } else if (payload.name != null) {
      return util.isArray(payload.name) ? util.map(payload.name, function (value) {
        return data.indexOfName(value);
      }) : data.indexOfName(payload.name);
    }
  }
  /**
   * Enable property storage to any host object.
   * Notice: Serialization is not supported.
   *
   * For example:
   * var inner = zrUitl.makeInner();
   *
   * function some1(hostObj) {
   *      inner(hostObj).someProperty = 1212;
   *      ...
   * }
   * function some2() {
   *      var fields = inner(this);
   *      fields.someProperty1 = 1212;
   *      fields.someProperty2 = 'xx';
   *      ...
   * }
   *
   * @return {Function}
   */


  function makeInner() {
    // Consider different scope by es module import.
    var key = '__\0ec_inner_' + innerUniqueIndex++ + '_' + Math.random().toFixed(5);
    return function (hostObj) {
      return hostObj[key] || (hostObj[key] = {});
    };
  }

  var innerUniqueIndex = 0;
  /**
   * @param {module:echarts/model/Global} ecModel
   * @param {string|Object} finder
   *        If string, e.g., 'geo', means {geoIndex: 0}.
   *        If Object, could contain some of these properties below:
   *        {
   *            seriesIndex, seriesId, seriesName,
   *            geoIndex, geoId, geoName,
   *            bmapIndex, bmapId, bmapName,
   *            xAxisIndex, xAxisId, xAxisName,
   *            yAxisIndex, yAxisId, yAxisName,
   *            gridIndex, gridId, gridName,
   *            ... (can be extended)
   *        }
   *        Each properties can be number|string|Array.<number>|Array.<string>
   *        For example, a finder could be
   *        {
   *            seriesIndex: 3,
   *            geoId: ['aa', 'cc'],
   *            gridName: ['xx', 'rr']
   *        }
   *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)
   *        If nothing or null/undefined specified, return nothing.
   * @param {Object} [opt]
   * @param {string} [opt.defaultMainType]
   * @param {Array.<string>} [opt.includeMainTypes]
   * @return {Object} result like:
   *        {
   *            seriesModels: [seriesModel1, seriesModel2],
   *            seriesModel: seriesModel1, // The first model
   *            geoModels: [geoModel1, geoModel2],
   *            geoModel: geoModel1, // The first model
   *            ...
   *        }
   */

  function parseFinder(ecModel, finder, opt) {
    if (util.isString(finder)) {
      var obj = {};
      obj[finder + 'Index'] = 0;
      finder = obj;
    }

    var defaultMainType = opt && opt.defaultMainType;

    if (defaultMainType && !has$2(finder, defaultMainType + 'Index') && !has$2(finder, defaultMainType + 'Id') && !has$2(finder, defaultMainType + 'Name')) {
      finder[defaultMainType + 'Index'] = 0;
    }

    var result = {};
    each$2(finder, function (value, key) {
      var value = finder[key]; // Exclude 'dataIndex' and other illgal keys.

      if (key === 'dataIndex' || key === 'dataIndexInside') {
        result[key] = value;
        return;
      }

      var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
      var mainType = parsedKey[1];
      var queryType = (parsedKey[2] || '').toLowerCase();

      if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && util.indexOf(opt.includeMainTypes, mainType) < 0) {
        return;
      }

      var queryParam = {
        mainType: mainType
      };

      if (queryType !== 'index' || value !== 'all') {
        queryParam[queryType] = value;
      }

      var models = ecModel.queryComponents(queryParam);
      result[mainType + 'Models'] = models;
      result[mainType + 'Model'] = models[0];
    });
    return result;
  }

  function has$2(obj, prop) {
    return obj && obj.hasOwnProperty(prop);
  }

  function setAttribute(dom, key, value) {
    dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
  }

  function getAttribute(dom, key) {
    return dom.getAttribute ? dom.getAttribute(key) : dom[key];
  }

  function getTooltipRenderMode(renderModeOption) {
    if (renderModeOption === 'auto') {
      // Using html when `document` exists, use richText otherwise
      return env_1.domSupported ? 'html' : 'richText';
    } else {
      return renderModeOption || 'html';
    }
  }
  /**
   * Group a list by key.
   *
   * @param {Array} array
   * @param {Function} getKey
   *        param {*} Array item
   *        return {string} key
   * @return {Object} Result
   *        {Array}: keys,
   *        {module:zrender/core/util/HashMap} buckets: {key -> Array}
   */


  function groupData(array, getKey) {
    var buckets = util.createHashMap();
    var keys = [];
    util.each(array, function (item) {
      var key = getKey(item);
      (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);
    });
    return {
      keys: keys,
      buckets: buckets
    };
  }

  var normalizeToArray_1 = normalizeToArray;
  var defaultEmphasis_1 = defaultEmphasis;
  var TEXT_STYLE_OPTIONS_1 = TEXT_STYLE_OPTIONS;
  var getDataItemValue_1 = getDataItemValue;
  var isDataItemOption_1 = isDataItemOption;
  var mappingToExists_1 = mappingToExists;
  var makeIdAndName_1 = makeIdAndName;
  var isNameSpecified_1 = isNameSpecified;
  var isIdInner_1 = isIdInner;
  var compressBatches_1 = compressBatches;
  var queryDataIndex_1 = queryDataIndex;
  var makeInner_1 = makeInner;
  var parseFinder_1 = parseFinder;
  var setAttribute_1 = setAttribute;
  var getAttribute_1 = getAttribute;
  var getTooltipRenderMode_1 = getTooltipRenderMode;
  var groupData_1 = groupData;

  var model = {
  	normalizeToArray: normalizeToArray_1,
  	defaultEmphasis: defaultEmphasis_1,
  	TEXT_STYLE_OPTIONS: TEXT_STYLE_OPTIONS_1,
  	getDataItemValue: getDataItemValue_1,
  	isDataItemOption: isDataItemOption_1,
  	mappingToExists: mappingToExists_1,
  	makeIdAndName: makeIdAndName_1,
  	isNameSpecified: isNameSpecified_1,
  	isIdInner: isIdInner_1,
  	compressBatches: compressBatches_1,
  	queryDataIndex: queryDataIndex_1,
  	makeInner: makeInner_1,
  	parseFinder: parseFinder_1,
  	setAttribute: setAttribute_1,
  	getAttribute: getAttribute_1,
  	getTooltipRenderMode: getTooltipRenderMode_1,
  	groupData: groupData_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var TYPE_DELIMITER = '.';
  var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
  /**
   * Notice, parseClassType('') should returns {main: '', sub: ''}
   * @public
   */

  function parseClassType(componentType) {
    var ret = {
      main: '',
      sub: ''
    };

    if (componentType) {
      componentType = componentType.split(TYPE_DELIMITER);
      ret.main = componentType[0] || '';
      ret.sub = componentType[1] || '';
    }

    return ret;
  }
  /**
   * @public
   */


  function checkClassType(componentType) {
    util.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
  }
  /**
   * @public
   */


  function enableClassExtend(RootClass, mandatoryMethods) {
    RootClass.$constructor = RootClass;

    RootClass.extend = function (proto) {
      var superClass = this;

      var ExtendedClass = function () {
        if (!proto.$constructor) {
          superClass.apply(this, arguments);
        } else {
          proto.$constructor.apply(this, arguments);
        }
      };

      util.extend(ExtendedClass.prototype, proto);
      ExtendedClass.extend = this.extend;
      ExtendedClass.superCall = superCall;
      ExtendedClass.superApply = superApply;
      util.inherits(ExtendedClass, this);
      ExtendedClass.superClass = superClass;
      return ExtendedClass;
    };
  }

  var classBase = 0;
  /**
   * Can not use instanceof, consider different scope by
   * cross domain or es module import in ec extensions.
   * Mount a method "isInstance()" to Clz.
   */

  function enableClassCheck(Clz) {
    var classAttr = ['__\0is_clz', classBase++, Math.random().toFixed(3)].join('_');
    Clz.prototype[classAttr] = true;

    Clz.isInstance = function (obj) {
      return !!(obj && obj[classAttr]);
    };
  } // superCall should have class info, which can not be fetch from 'this'.
  // Consider this case:
  // class A has method f,
  // class B inherits class A, overrides method f, f call superApply('f'),
  // class C inherits class B, do not overrides method f,
  // then when method of class C is called, dead loop occured.


  function superCall(context, methodName) {
    var args = util.slice(arguments, 2);
    return this.superClass.prototype[methodName].apply(context, args);
  }

  function superApply(context, methodName, args) {
    return this.superClass.prototype[methodName].apply(context, args);
  }
  /**
   * @param {Object} entity
   * @param {Object} options
   * @param {boolean} [options.registerWhenExtend]
   * @public
   */


  function enableClassManagement(entity, options) {
    options = options || {};
    /**
     * Component model classes
     * key: componentType,
     * value:
     *     componentClass, when componentType is 'xxx'
     *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
     * @type {Object}
     */

    var storage = {};

    entity.registerClass = function (Clazz, componentType) {
      if (componentType) {
        checkClassType(componentType);
        componentType = parseClassType(componentType);

        if (!componentType.sub) {
          storage[componentType.main] = Clazz;
        } else if (componentType.sub !== IS_CONTAINER) {
          var container = makeContainer(componentType);
          container[componentType.sub] = Clazz;
        }
      }

      return Clazz;
    };

    entity.getClass = function (componentMainType, subType, throwWhenNotFound) {
      var Clazz = storage[componentMainType];

      if (Clazz && Clazz[IS_CONTAINER]) {
        Clazz = subType ? Clazz[subType] : null;
      }

      if (throwWhenNotFound && !Clazz) {
        throw new Error(!subType ? componentMainType + '.' + 'type should be specified.' : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.');
      }

      return Clazz;
    };

    entity.getClassesByMainType = function (componentType) {
      componentType = parseClassType(componentType);
      var result = [];
      var obj = storage[componentType.main];

      if (obj && obj[IS_CONTAINER]) {
        util.each(obj, function (o, type) {
          type !== IS_CONTAINER && result.push(o);
        });
      } else {
        result.push(obj);
      }

      return result;
    };

    entity.hasClass = function (componentType) {
      // Just consider componentType.main.
      componentType = parseClassType(componentType);
      return !!storage[componentType.main];
    };
    /**
     * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
     */


    entity.getAllClassMainTypes = function () {
      var types = [];
      util.each(storage, function (obj, type) {
        types.push(type);
      });
      return types;
    };
    /**
     * If a main type is container and has sub types
     * @param  {string}  mainType
     * @return {boolean}
     */


    entity.hasSubTypes = function (componentType) {
      componentType = parseClassType(componentType);
      var obj = storage[componentType.main];
      return obj && obj[IS_CONTAINER];
    };

    entity.parseClassType = parseClassType;

    function makeContainer(componentType) {
      var container = storage[componentType.main];

      if (!container || !container[IS_CONTAINER]) {
        container = storage[componentType.main] = {};
        container[IS_CONTAINER] = true;
      }

      return container;
    }

    if (options.registerWhenExtend) {
      var originalExtend = entity.extend;

      if (originalExtend) {
        entity.extend = function (proto) {
          var ExtendedClass = originalExtend.call(this, proto);
          return entity.registerClass(ExtendedClass, proto.type);
        };
      }
    }

    return entity;
  }
  /**
   * @param {string|Array.<string>} properties
   */


  function setReadOnly(obj, properties) {// FIXME It seems broken in IE8 simulation of IE11
    // if (!zrUtil.isArray(properties)) {
    //     properties = properties != null ? [properties] : [];
    // }
    // zrUtil.each(properties, function (prop) {
    //     var value = obj[prop];
    //     Object.defineProperty
    //         && Object.defineProperty(obj, prop, {
    //             value: value, writable: false
    //         });
    //     zrUtil.isArray(obj[prop])
    //         && Object.freeze
    //         && Object.freeze(obj[prop]);
    // });
  }

  var parseClassType_1 = parseClassType;
  var enableClassExtend_1 = enableClassExtend;
  var enableClassCheck_1 = enableClassCheck;
  var enableClassManagement_1 = enableClassManagement;
  var setReadOnly_1 = setReadOnly;

  var clazz = {
  	parseClassType: parseClassType_1,
  	enableClassExtend: enableClassExtend_1,
  	enableClassCheck: enableClassCheck_1,
  	enableClassManagement: enableClassManagement_1,
  	setReadOnly: setReadOnly_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // TODO Parse shadow style
  // TODO Only shallow path support
  function _default$s(properties) {
    // Normalize
    for (var i = 0; i < properties.length; i++) {
      if (!properties[i][1]) {
        properties[i][1] = properties[i][0];
      }
    }

    return function (model, excludes, includes) {
      var style = {};

      for (var i = 0; i < properties.length; i++) {
        var propName = properties[i][1];

        if (excludes && util.indexOf(excludes, propName) >= 0 || includes && util.indexOf(includes, propName) < 0) {
          continue;
        }

        var val = model.getShallow(propName);

        if (val != null) {
          style[properties[i][0]] = val;
        }
      }

      return style;
    };
  }

  var makeStyleMapper = _default$s;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var getLineStyle = makeStyleMapper([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
  var _default$t = {
    getLineStyle: function (excludes) {
      var style = getLineStyle(this, excludes); // Always set lineDash whether dashed, otherwise we can not
      // erase the previous style when assigning to el.style.

      style.lineDash = this.getLineDash(style.lineWidth);
      return style;
    },
    getLineDash: function (lineWidth) {
      if (lineWidth == null) {
        lineWidth = 1;
      }

      var lineType = this.get('type');
      var dotSize = Math.max(lineWidth, 2);
      var dashSize = lineWidth * 4;
      return lineType === 'solid' || lineType == null ? // Use `false` but not `null` for the solid line here, because `null` might be
      // ignored when assigning to `el.style`. e.g., when setting `lineStyle.type` as
      // `'dashed'` and `emphasis.lineStyle.type` as `'solid'` in graph series, the
      // `lineDash` gotten form the latter one is not able to erase that from the former
      // one if using `null` here according to the emhpsis strategy in `util/graphic.js`.
      false : lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize];
    }
  };
  var lineStyle = _default$t;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var getAreaStyle = makeStyleMapper([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]);
  var _default$u = {
    getAreaStyle: function (excludes, includes) {
      return getAreaStyle(this, excludes, includes);
    }
  };
  var areaStyle = _default$u;

  var v2Create = vector.create;
  var v2DistSquare = vector.distSquare;

  /**
   * æ²çº¿è¾å©æ¨¡å
   * @module zrender/core/curve
   * @author pissang(https://www.github.com/pissang)
   */
  var mathPow = Math.pow;
  var mathSqrt = Math.sqrt;
  var EPSILON$1 = 1e-8;
  var EPSILON_NUMERIC = 1e-4;
  var THREE_SQRT = mathSqrt(3);
  var ONE_THIRD = 1 / 3; // ä¸´æ¶åé

  var _v0 = v2Create();

  var _v1 = v2Create();

  var _v2 = v2Create();

  function isAroundZero(val) {
    return val > -EPSILON$1 && val < EPSILON$1;
  }

  function isNotAroundZero$1(val) {
    return val > EPSILON$1 || val < -EPSILON$1;
  }
  /**
   * è®¡ç®ä¸æ¬¡è´å¡å°å¼
   * @memberOf module:zrender/core/curve
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @param  {number} p3
   * @param  {number} t
   * @return {number}
   */


  function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
  }
  /**
   * è®¡ç®ä¸æ¬¡è´å¡å°å¯¼æ°å¼
   * @memberOf module:zrender/core/curve
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @param  {number} p3
   * @param  {number} t
   * @return {number}
   */


  function cubicDerivativeAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
  }
  /**
   * è®¡ç®ä¸æ¬¡è´å¡å°æ¹ç¨æ ¹ï¼ä½¿ç¨çéå¬å¼
   * @memberOf module:zrender/core/curve
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @param  {number} p3
   * @param  {number} val
   * @param  {Array.<number>} roots
   * @return {number} æææ ¹æ°ç®
   */


  function cubicRootAt(p0, p1, p2, p3, val, roots) {
    // Evaluate roots of cubic functions
    var a = p3 + 3 * (p1 - p2) - p0;
    var b = 3 * (p2 - p1 * 2 + p0);
    var c = 3 * (p1 - p0);
    var d = p0 - val;
    var A = b * b - 3 * a * c;
    var B = b * c - 9 * a * d;
    var C = c * c - 3 * b * d;
    var n = 0;

    if (isAroundZero(A) && isAroundZero(B)) {
      if (isAroundZero(b)) {
        roots[0] = 0;
      } else {
        var t1 = -c / b; //t1, t2, t3, b is not zero

        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
      }
    } else {
      var disc = B * B - 4 * A * C;

      if (isAroundZero(disc)) {
        var K = B / A;
        var t1 = -b / a + K; // t1, a is not zero

        var t2 = -K / 2; // t2, t3

        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }

        if (t2 >= 0 && t2 <= 1) {
          roots[n++] = t2;
        }
      } else if (disc > 0) {
        var discSqrt = mathSqrt(disc);
        var Y1 = A * b + 1.5 * a * (-B + discSqrt);
        var Y2 = A * b + 1.5 * a * (-B - discSqrt);

        if (Y1 < 0) {
          Y1 = -mathPow(-Y1, ONE_THIRD);
        } else {
          Y1 = mathPow(Y1, ONE_THIRD);
        }

        if (Y2 < 0) {
          Y2 = -mathPow(-Y2, ONE_THIRD);
        } else {
          Y2 = mathPow(Y2, ONE_THIRD);
        }

        var t1 = (-b - (Y1 + Y2)) / (3 * a);

        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
      } else {
        var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
        var theta = Math.acos(T) / 3;
        var ASqrt = mathSqrt(A);
        var tmp = Math.cos(theta);
        var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
        var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
        var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);

        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }

        if (t2 >= 0 && t2 <= 1) {
          roots[n++] = t2;
        }

        if (t3 >= 0 && t3 <= 1) {
          roots[n++] = t3;
        }
      }
    }

    return n;
  }
  /**
   * è®¡ç®ä¸æ¬¡è´å¡å°æ¹ç¨æéå¼çä½ç½®
   * @memberOf module:zrender/core/curve
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @param  {number} p3
   * @param  {Array.<number>} extrema
   * @return {number} æææ°ç®
   */


  function cubicExtrema(p0, p1, p2, p3, extrema) {
    var b = 6 * p2 - 12 * p1 + 6 * p0;
    var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
    var c = 3 * p1 - 3 * p0;
    var n = 0;

    if (isAroundZero(a)) {
      if (isNotAroundZero$1(b)) {
        var t1 = -c / b;

        if (t1 >= 0 && t1 <= 1) {
          extrema[n++] = t1;
        }
      }
    } else {
      var disc = b * b - 4 * a * c;

      if (isAroundZero(disc)) {
        extrema[0] = -b / (2 * a);
      } else if (disc > 0) {
        var discSqrt = mathSqrt(disc);
        var t1 = (-b + discSqrt) / (2 * a);
        var t2 = (-b - discSqrt) / (2 * a);

        if (t1 >= 0 && t1 <= 1) {
          extrema[n++] = t1;
        }

        if (t2 >= 0 && t2 <= 1) {
          extrema[n++] = t2;
        }
      }
    }

    return n;
  }
  /**
   * ç»åä¸æ¬¡è´å¡å°æ²çº¿
   * @memberOf module:zrender/core/curve
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @param  {number} p3
   * @param  {number} t
   * @param  {Array.<number>} out
   */


  function cubicSubdivide(p0, p1, p2, p3, t, out) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p23 = (p3 - p2) * t + p2;
    var p012 = (p12 - p01) * t + p01;
    var p123 = (p23 - p12) * t + p12;
    var p0123 = (p123 - p012) * t + p012; // Seg0

    out[0] = p0;
    out[1] = p01;
    out[2] = p012;
    out[3] = p0123; // Seg1

    out[4] = p0123;
    out[5] = p123;
    out[6] = p23;
    out[7] = p3;
  }
  /**
   * æå°ç¹å°ä¸æ¬¡è´å¡å°æ²çº¿ä¸ï¼è¿åæå°è·ç¦»ã
   * æå°ç¹æå¯è½ä¼æä¸ä¸ªæèå¤ä¸ªï¼è¿éåªè¿åå¶ä¸­è·ç¦»æç­çä¸ä¸ªã
   * @param {number} x0
   * @param {number} y0
   * @param {number} x1
   * @param {number} y1
   * @param {number} x2
   * @param {number} y2
   * @param {number} x3
   * @param {number} y3
   * @param {number} x
   * @param {number} y
   * @param {Array.<number>} [out] æå°ç¹
   * @return {number}
   */


  function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
    // http://pomax.github.io/bezierinfo/#projections
    var t;
    var interval = 0.005;
    var d = Infinity;
    var prev;
    var next;
    var d1;
    var d2;
    _v0[0] = x;
    _v0[1] = y; // åç²ç¥ä¼°è®¡ä¸ä¸å¯è½çæå°è·ç¦»ç t å¼
    // PENDING

    for (var _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = cubicAt(x0, x1, x2, x3, _t);
      _v1[1] = cubicAt(y0, y1, y2, y3, _t);
      d1 = v2DistSquare(_v0, _v1);

      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }

    d = Infinity; // At most 32 iteration

    for (var i = 0; i < 32; i++) {
      if (interval < EPSILON_NUMERIC) {
        break;
      }

      prev = t - interval;
      next = t + interval; // t - interval

      _v1[0] = cubicAt(x0, x1, x2, x3, prev);
      _v1[1] = cubicAt(y0, y1, y2, y3, prev);
      d1 = v2DistSquare(_v1, _v0);

      if (prev >= 0 && d1 < d) {
        t = prev;
        d = d1;
      } else {
        // t + interval
        _v2[0] = cubicAt(x0, x1, x2, x3, next);
        _v2[1] = cubicAt(y0, y1, y2, y3, next);
        d2 = v2DistSquare(_v2, _v0);

        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval *= 0.5;
        }
      }
    } // t


    if (out) {
      out[0] = cubicAt(x0, x1, x2, x3, t);
      out[1] = cubicAt(y0, y1, y2, y3, t);
    } // console.log(interval, i);


    return mathSqrt(d);
  }
  /**
   * è®¡ç®äºæ¬¡æ¹è´å¡å°å¼
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @param  {number} t
   * @return {number}
   */


  function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
  }
  /**
   * è®¡ç®äºæ¬¡æ¹è´å¡å°å¯¼æ°å¼
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @param  {number} t
   * @return {number}
   */


  function quadraticDerivativeAt(p0, p1, p2, t) {
    return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
  }
  /**
   * è®¡ç®äºæ¬¡æ¹è´å¡å°æ¹ç¨æ ¹
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @param  {number} t
   * @param  {Array.<number>} roots
   * @return {number} æææ ¹æ°ç®
   */


  function quadraticRootAt(p0, p1, p2, val, roots) {
    var a = p0 - 2 * p1 + p2;
    var b = 2 * (p1 - p0);
    var c = p0 - val;
    var n = 0;

    if (isAroundZero(a)) {
      if (isNotAroundZero$1(b)) {
        var t1 = -c / b;

        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
      }
    } else {
      var disc = b * b - 4 * a * c;

      if (isAroundZero(disc)) {
        var t1 = -b / (2 * a);

        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }
      } else if (disc > 0) {
        var discSqrt = mathSqrt(disc);
        var t1 = (-b + discSqrt) / (2 * a);
        var t2 = (-b - discSqrt) / (2 * a);

        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1;
        }

        if (t2 >= 0 && t2 <= 1) {
          roots[n++] = t2;
        }
      }
    }

    return n;
  }
  /**
   * è®¡ç®äºæ¬¡è´å¡å°æ¹ç¨æéå¼
   * @memberOf module:zrender/core/curve
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @return {number}
   */


  function quadraticExtremum(p0, p1, p2) {
    var divider = p0 + p2 - 2 * p1;

    if (divider === 0) {
      // p1 is center of p0 and p2
      return 0.5;
    } else {
      return (p0 - p1) / divider;
    }
  }
  /**
   * ç»åäºæ¬¡è´å¡å°æ²çº¿
   * @memberOf module:zrender/core/curve
   * @param  {number} p0
   * @param  {number} p1
   * @param  {number} p2
   * @param  {number} t
   * @param  {Array.<number>} out
   */


  function quadraticSubdivide(p0, p1, p2, t, out) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p012 = (p12 - p01) * t + p01; // Seg0

    out[0] = p0;
    out[1] = p01;
    out[2] = p012; // Seg1

    out[3] = p012;
    out[4] = p12;
    out[5] = p2;
  }
  /**
   * æå°ç¹å°äºæ¬¡è´å¡å°æ²çº¿ä¸ï¼è¿åæå°è·ç¦»ã
   * æå°ç¹æå¯è½ä¼æä¸ä¸ªæèå¤ä¸ªï¼è¿éåªè¿åå¶ä¸­è·ç¦»æç­çä¸ä¸ªã
   * @param {number} x0
   * @param {number} y0
   * @param {number} x1
   * @param {number} y1
   * @param {number} x2
   * @param {number} y2
   * @param {number} x
   * @param {number} y
   * @param {Array.<number>} out æå°ç¹
   * @return {number}
   */


  function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
    // http://pomax.github.io/bezierinfo/#projections
    var t;
    var interval = 0.005;
    var d = Infinity;
    _v0[0] = x;
    _v0[1] = y; // åç²ç¥ä¼°è®¡ä¸ä¸å¯è½çæå°è·ç¦»ç t å¼
    // PENDING

    for (var _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = quadraticAt(x0, x1, x2, _t);
      _v1[1] = quadraticAt(y0, y1, y2, _t);
      var d1 = v2DistSquare(_v0, _v1);

      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }

    d = Infinity; // At most 32 iteration

    for (var i = 0; i < 32; i++) {
      if (interval < EPSILON_NUMERIC) {
        break;
      }

      var prev = t - interval;
      var next = t + interval; // t - interval

      _v1[0] = quadraticAt(x0, x1, x2, prev);
      _v1[1] = quadraticAt(y0, y1, y2, prev);
      var d1 = v2DistSquare(_v1, _v0);

      if (prev >= 0 && d1 < d) {
        t = prev;
        d = d1;
      } else {
        // t + interval
        _v2[0] = quadraticAt(x0, x1, x2, next);
        _v2[1] = quadraticAt(y0, y1, y2, next);
        var d2 = v2DistSquare(_v2, _v0);

        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval *= 0.5;
        }
      }
    } // t


    if (out) {
      out[0] = quadraticAt(x0, x1, x2, t);
      out[1] = quadraticAt(y0, y1, y2, t);
    } // console.log(interval, i);


    return mathSqrt(d);
  }

  var cubicAt_1 = cubicAt;
  var cubicDerivativeAt_1 = cubicDerivativeAt;
  var cubicRootAt_1 = cubicRootAt;
  var cubicExtrema_1 = cubicExtrema;
  var cubicSubdivide_1 = cubicSubdivide;
  var cubicProjectPoint_1 = cubicProjectPoint;
  var quadraticAt_1 = quadraticAt;
  var quadraticDerivativeAt_1 = quadraticDerivativeAt;
  var quadraticRootAt_1 = quadraticRootAt;
  var quadraticExtremum_1 = quadraticExtremum;
  var quadraticSubdivide_1 = quadraticSubdivide;
  var quadraticProjectPoint_1 = quadraticProjectPoint;

  var curve = {
  	cubicAt: cubicAt_1,
  	cubicDerivativeAt: cubicDerivativeAt_1,
  	cubicRootAt: cubicRootAt_1,
  	cubicExtrema: cubicExtrema_1,
  	cubicSubdivide: cubicSubdivide_1,
  	cubicProjectPoint: cubicProjectPoint_1,
  	quadraticAt: quadraticAt_1,
  	quadraticDerivativeAt: quadraticDerivativeAt_1,
  	quadraticRootAt: quadraticRootAt_1,
  	quadraticExtremum: quadraticExtremum_1,
  	quadraticSubdivide: quadraticSubdivide_1,
  	quadraticProjectPoint: quadraticProjectPoint_1
  };

  /**
   * @author Yi Shen(https://github.com/pissang)
   */
  var mathMin$1 = Math.min;
  var mathMax$1 = Math.max;
  var mathSin = Math.sin;
  var mathCos = Math.cos;
  var PI2 = Math.PI * 2;
  var start = vector.create();
  var end = vector.create();
  var extremity = vector.create();
  /**
   * ä»é¡¶ç¹æ°ç»ä¸­è®¡ç®åºæå°åå´çï¼åå¥`min`å`max`ä¸­
   * @module zrender/core/bbox
   * @param {Array<Object>} points é¡¶ç¹æ°ç»
   * @param {number} min
   * @param {number} max
   */

  function fromPoints(points, min, max) {
    if (points.length === 0) {
      return;
    }

    var p = points[0];
    var left = p[0];
    var right = p[0];
    var top = p[1];
    var bottom = p[1];
    var i;

    for (i = 1; i < points.length; i++) {
      p = points[i];
      left = mathMin$1(left, p[0]);
      right = mathMax$1(right, p[0]);
      top = mathMin$1(top, p[1]);
      bottom = mathMax$1(bottom, p[1]);
    }

    min[0] = left;
    min[1] = top;
    max[0] = right;
    max[1] = bottom;
  }
  /**
   * @memberOf module:zrender/core/bbox
   * @param {number} x0
   * @param {number} y0
   * @param {number} x1
   * @param {number} y1
   * @param {Array.<number>} min
   * @param {Array.<number>} max
   */


  function fromLine(x0, y0, x1, y1, min, max) {
    min[0] = mathMin$1(x0, x1);
    min[1] = mathMin$1(y0, y1);
    max[0] = mathMax$1(x0, x1);
    max[1] = mathMax$1(y0, y1);
  }

  var xDim = [];
  var yDim = [];
  /**
   * ä»ä¸é¶è´å¡å°æ²çº¿(p0, p1, p2, p3)ä¸­è®¡ç®åºæå°åå´çï¼åå¥`min`å`max`ä¸­
   * @memberOf module:zrender/core/bbox
   * @param {number} x0
   * @param {number} y0
   * @param {number} x1
   * @param {number} y1
   * @param {number} x2
   * @param {number} y2
   * @param {number} x3
   * @param {number} y3
   * @param {Array.<number>} min
   * @param {Array.<number>} max
   */

  function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
    var cubicExtrema = curve.cubicExtrema;
    var cubicAt = curve.cubicAt;
    var i;
    var n = cubicExtrema(x0, x1, x2, x3, xDim);
    min[0] = Infinity;
    min[1] = Infinity;
    max[0] = -Infinity;
    max[1] = -Infinity;

    for (i = 0; i < n; i++) {
      var x = cubicAt(x0, x1, x2, x3, xDim[i]);
      min[0] = mathMin$1(x, min[0]);
      max[0] = mathMax$1(x, max[0]);
    }

    n = cubicExtrema(y0, y1, y2, y3, yDim);

    for (i = 0; i < n; i++) {
      var y = cubicAt(y0, y1, y2, y3, yDim[i]);
      min[1] = mathMin$1(y, min[1]);
      max[1] = mathMax$1(y, max[1]);
    }

    min[0] = mathMin$1(x0, min[0]);
    max[0] = mathMax$1(x0, max[0]);
    min[0] = mathMin$1(x3, min[0]);
    max[0] = mathMax$1(x3, max[0]);
    min[1] = mathMin$1(y0, min[1]);
    max[1] = mathMax$1(y0, max[1]);
    min[1] = mathMin$1(y3, min[1]);
    max[1] = mathMax$1(y3, max[1]);
  }
  /**
   * ä»äºé¶è´å¡å°æ²çº¿(p0, p1, p2)ä¸­è®¡ç®åºæå°åå´çï¼åå¥`min`å`max`ä¸­
   * @memberOf module:zrender/core/bbox
   * @param {number} x0
   * @param {number} y0
   * @param {number} x1
   * @param {number} y1
   * @param {number} x2
   * @param {number} y2
   * @param {Array.<number>} min
   * @param {Array.<number>} max
   */


  function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
    var quadraticExtremum = curve.quadraticExtremum;
    var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero

    var tx = mathMax$1(mathMin$1(quadraticExtremum(x0, x1, x2), 1), 0);
    var ty = mathMax$1(mathMin$1(quadraticExtremum(y0, y1, y2), 1), 0);
    var x = quadraticAt(x0, x1, x2, tx);
    var y = quadraticAt(y0, y1, y2, ty);
    min[0] = mathMin$1(x0, x2, x);
    min[1] = mathMin$1(y0, y2, y);
    max[0] = mathMax$1(x0, x2, x);
    max[1] = mathMax$1(y0, y2, y);
  }
  /**
   * ä»åå¼§ä¸­è®¡ç®åºæå°åå´çï¼åå¥`min`å`max`ä¸­
   * @method
   * @memberOf module:zrender/core/bbox
   * @param {number} x
   * @param {number} y
   * @param {number} rx
   * @param {number} ry
   * @param {number} startAngle
   * @param {number} endAngle
   * @param {number} anticlockwise
   * @param {Array.<number>} min
   * @param {Array.<number>} max
   */


  function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
    var vec2Min = vector.min;
    var vec2Max = vector.max;
    var diff = Math.abs(startAngle - endAngle);

    if (diff % PI2 < 1e-4 && diff > 1e-4) {
      // Is a circle
      min[0] = x - rx;
      min[1] = y - ry;
      max[0] = x + rx;
      max[1] = y + ry;
      return;
    }

    start[0] = mathCos(startAngle) * rx + x;
    start[1] = mathSin(startAngle) * ry + y;
    end[0] = mathCos(endAngle) * rx + x;
    end[1] = mathSin(endAngle) * ry + y;
    vec2Min(min, start, end);
    vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]

    startAngle = startAngle % PI2;

    if (startAngle < 0) {
      startAngle = startAngle + PI2;
    }

    endAngle = endAngle % PI2;

    if (endAngle < 0) {
      endAngle = endAngle + PI2;
    }

    if (startAngle > endAngle && !anticlockwise) {
      endAngle += PI2;
    } else if (startAngle < endAngle && anticlockwise) {
      startAngle += PI2;
    }

    if (anticlockwise) {
      var tmp = endAngle;
      endAngle = startAngle;
      startAngle = tmp;
    } // var number = 0;
    // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;


    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
      if (angle > startAngle) {
        extremity[0] = mathCos(angle) * rx + x;
        extremity[1] = mathSin(angle) * ry + y;
        vec2Min(min, extremity, min);
        vec2Max(max, extremity, max);
      }
    }
  }

  var fromPoints_1 = fromPoints;
  var fromLine_1 = fromLine;
  var fromCubic_1 = fromCubic;
  var fromQuadratic_1 = fromQuadratic;
  var fromArc_1 = fromArc;

  var bbox = {
  	fromPoints: fromPoints_1,
  	fromLine: fromLine_1,
  	fromCubic: fromCubic_1,
  	fromQuadratic: fromQuadratic_1,
  	fromArc: fromArc_1
  };

  var dpr$1 = config.devicePixelRatio;

  /**
   * Path ä»£çï¼å¯ä»¥å¨`buildPath`ä¸­ç¨äºæ¿ä»£`ctx`, ä¼ä¿å­æ¯ä¸ªpathæä½çå½ä»¤å°pathCommandså±æ§ä¸­
   * å¯ä»¥ç¨äº isInsidePath å¤æ­ä»¥åè·åboundingRect
   *
   * @module zrender/core/PathProxy
   * @author Yi Shen (http://www.github.com/pissang)
   */
  // TODO getTotalLength, getPointAtLength

  /* global Float32Array */
  var CMD = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    // Rect
    R: 7
  }; // var CMD_MEM_SIZE = {
  //     M: 3,
  //     L: 3,
  //     C: 7,
  //     Q: 5,
  //     A: 9,
  //     R: 5,
  //     Z: 1
  // };

  var min$4 = [];
  var max$3 = [];
  var min2 = [];
  var max2 = [];
  var mathMin$2 = Math.min;
  var mathMax$2 = Math.max;
  var mathCos$1 = Math.cos;
  var mathSin$1 = Math.sin;
  var mathSqrt$1 = Math.sqrt;
  var mathAbs = Math.abs;
  var hasTypedArray = typeof Float32Array !== 'undefined';
  /**
   * @alias module:zrender/core/PathProxy
   * @constructor
   */

  var PathProxy = function (notSaveData) {
    this._saveData = !(notSaveData || false);

    if (this._saveData) {
      /**
       * Path data. Stored as flat array
       * @type {Array.<Object>}
       */
      this.data = [];
    }

    this._ctx = null;
  };
  /**
   * å¿«éè®¡ç®Pathåå´çï¼å¹¶ä¸æ¯æå°åå´çï¼
   * @return {Object}
   */


  PathProxy.prototype = {
    constructor: PathProxy,
    _xi: 0,
    _yi: 0,
    _x0: 0,
    _y0: 0,
    // Unit x, Unit y. Provide for avoiding drawing that too short line segment
    _ux: 0,
    _uy: 0,
    _len: 0,
    _lineDash: null,
    _dashOffset: 0,
    _dashIdx: 0,
    _dashSum: 0,

    /**
     * @readOnly
     */
    setScale: function (sx, sy, segmentIgnoreThreshold) {
      // Compat. Previously there is no segmentIgnoreThreshold.
      segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
      this._ux = mathAbs(segmentIgnoreThreshold / dpr$1 / sx) || 0;
      this._uy = mathAbs(segmentIgnoreThreshold / dpr$1 / sy) || 0;
    },
    getContext: function () {
      return this._ctx;
    },

    /**
     * @param  {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */
    beginPath: function (ctx) {
      this._ctx = ctx;
      ctx && ctx.beginPath();
      ctx && (this.dpr = ctx.dpr); // Reset

      if (this._saveData) {
        this._len = 0;
      }

      if (this._lineDash) {
        this._lineDash = null;
        this._dashOffset = 0;
      }

      return this;
    },

    /**
     * @param  {number} x
     * @param  {number} y
     * @return {module:zrender/core/PathProxy}
     */
    moveTo: function (x, y) {
      this.addData(CMD.M, x, y);
      this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi æ¯è®°å½å¨ _dashedXXXXTo æ¹æ³ä¸­ä½¿ç¨
      // xi, yi è®°å½å½åç¹, x0, y0 å¨ closePath çæ¶ååå°èµ·å§ç¹ã
      // æå¯è½å¨ beginPath ä¹åç´æ¥è°ç¨ lineToï¼è¿æ¶å x0, y0 éè¦
      // å¨ lineTo æ¹æ³ä¸­è®°å½ï¼è¿éåä¸èèè¿ç§æåµï¼dashed line ä¹åªå¨ IE10- ä¸­ä¸æ¯æ

      this._x0 = x;
      this._y0 = y;
      this._xi = x;
      this._yi = y;
      return this;
    },

    /**
     * @param  {number} x
     * @param  {number} y
     * @return {module:zrender/core/PathProxy}
     */
    lineTo: function (x, y) {
      var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
      || this._len < 5;
      this.addData(CMD.L, x, y);

      if (this._ctx && exceedUnit) {
        this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
      }

      if (exceedUnit) {
        this._xi = x;
        this._yi = y;
      }

      return this;
    },

    /**
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @param  {number} x3
     * @param  {number} y3
     * @return {module:zrender/core/PathProxy}
     */
    bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
      this.addData(CMD.C, x1, y1, x2, y2, x3, y3);

      if (this._ctx) {
        this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
      }

      this._xi = x3;
      this._yi = y3;
      return this;
    },

    /**
     * @param  {number} x1
     * @param  {number} y1
     * @param  {number} x2
     * @param  {number} y2
     * @return {module:zrender/core/PathProxy}
     */
    quadraticCurveTo: function (x1, y1, x2, y2) {
      this.addData(CMD.Q, x1, y1, x2, y2);

      if (this._ctx) {
        this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
      }

      this._xi = x2;
      this._yi = y2;
      return this;
    },

    /**
     * @param  {number} cx
     * @param  {number} cy
     * @param  {number} r
     * @param  {number} startAngle
     * @param  {number} endAngle
     * @param  {boolean} anticlockwise
     * @return {module:zrender/core/PathProxy}
     */
    arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
      this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
      this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
      this._xi = mathCos$1(endAngle) * r + cx;
      this._yi = mathSin$1(endAngle) * r + cy;
      return this;
    },
    // TODO
    arcTo: function (x1, y1, x2, y2, radius) {
      if (this._ctx) {
        this._ctx.arcTo(x1, y1, x2, y2, radius);
      }

      return this;
    },
    // TODO
    rect: function (x, y, w, h) {
      this._ctx && this._ctx.rect(x, y, w, h);
      this.addData(CMD.R, x, y, w, h);
      return this;
    },

    /**
     * @return {module:zrender/core/PathProxy}
     */
    closePath: function () {
      this.addData(CMD.Z);
      var ctx = this._ctx;
      var x0 = this._x0;
      var y0 = this._y0;

      if (ctx) {
        this._needsDash() && this._dashedLineTo(x0, y0);
        ctx.closePath();
      }

      this._xi = x0;
      this._yi = y0;
      return this;
    },

    /**
     * Context ä»å¤é¨ä¼ å¥ï¼å ä¸ºæå¯è½æ¯ rebuildPath å®ä¹åå fillã
     * stroke åæ ·
     * @param {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */
    fill: function (ctx) {
      ctx && ctx.fill();
      this.toStatic();
    },

    /**
     * @param {CanvasRenderingContext2D} ctx
     * @return {module:zrender/core/PathProxy}
     */
    stroke: function (ctx) {
      ctx && ctx.stroke();
      this.toStatic();
    },

    /**
     * å¿é¡»å¨å¶å®ç»å¶å½ä»¤åè°ç¨
     * Must be invoked before all other path drawing methods
     * @return {module:zrender/core/PathProxy}
     */
    setLineDash: function (lineDash) {
      if (lineDash instanceof Array) {
        this._lineDash = lineDash;
        this._dashIdx = 0;
        var lineDashSum = 0;

        for (var i = 0; i < lineDash.length; i++) {
          lineDashSum += lineDash[i];
        }

        this._dashSum = lineDashSum;
      }

      return this;
    },

    /**
     * å¿é¡»å¨å¶å®ç»å¶å½ä»¤åè°ç¨
     * Must be invoked before all other path drawing methods
     * @return {module:zrender/core/PathProxy}
     */
    setLineDashOffset: function (offset) {
      this._dashOffset = offset;
      return this;
    },

    /**
     *
     * @return {boolean}
     */
    len: function () {
      return this._len;
    },

    /**
     * ç´æ¥è®¾ç½® Path æ°æ®
     */
    setData: function (data) {
      var len = data.length;

      if (!(this.data && this.data.length === len) && hasTypedArray) {
        this.data = new Float32Array(len);
      }

      for (var i = 0; i < len; i++) {
        this.data[i] = data[i];
      }

      this._len = len;
    },

    /**
     * æ·»å å­è·¯å¾
     * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
     */
    appendPath: function (path) {
      if (!(path instanceof Array)) {
        path = [path];
      }

      var len = path.length;
      var appendSize = 0;
      var offset = this._len;

      for (var i = 0; i < len; i++) {
        appendSize += path[i].len();
      }

      if (hasTypedArray && this.data instanceof Float32Array) {
        this.data = new Float32Array(offset + appendSize);
      }

      for (var i = 0; i < len; i++) {
        var appendPathData = path[i].data;

        for (var k = 0; k < appendPathData.length; k++) {
          this.data[offset++] = appendPathData[k];
        }
      }

      this._len = offset;
    },

    /**
     * å¡«å Path æ°æ®ã
     * å°½éå¤ç¨èä¸ç³ææ°çæ°ç»ãå¤§é¨åå¾å½¢éç»çæä»¤æ°æ®é¿åº¦é½æ¯ä¸åçã
     */
    addData: function (cmd) {
      if (!this._saveData) {
        return;
      }

      var data = this.data;

      if (this._len + arguments.length > data.length) {
        // å ä¸ºä¹åçæ°ç»å·²ç»è½¬æ¢æéæç Float32Array
        // æä»¥ä¸å¤ç¨æ¶éè¦æ©å±ä¸ä¸ªæ°çå¨ææ°ç»
        this._expandData();

        data = this.data;
      }

      for (var i = 0; i < arguments.length; i++) {
        data[this._len++] = arguments[i];
      }

      this._prevCmd = cmd;
    },
    _expandData: function () {
      // Only if data is Float32Array
      if (!(this.data instanceof Array)) {
        var newData = [];

        for (var i = 0; i < this._len; i++) {
          newData[i] = this.data[i];
        }

        this.data = newData;
      }
    },

    /**
     * If needs js implemented dashed line
     * @return {boolean}
     * @private
     */
    _needsDash: function () {
      return this._lineDash;
    },
    _dashedLineTo: function (x1, y1) {
      var dashSum = this._dashSum;
      var offset = this._dashOffset;
      var lineDash = this._lineDash;
      var ctx = this._ctx;
      var x0 = this._xi;
      var y0 = this._yi;
      var dx = x1 - x0;
      var dy = y1 - y0;
      var dist = mathSqrt$1(dx * dx + dy * dy);
      var x = x0;
      var y = y0;
      var dash;
      var nDash = lineDash.length;
      var idx;
      dx /= dist;
      dy /= dist;

      if (offset < 0) {
        // Convert to positive offset
        offset = dashSum + offset;
      }

      offset %= dashSum;
      x -= offset * dx;
      y -= offset * dy;

      while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
        idx = this._dashIdx;
        dash = lineDash[idx];
        x += dx * dash;
        y += dy * dash;
        this._dashIdx = (idx + 1) % nDash; // Skip positive offset

        if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
          continue;
        }

        ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin$2(x, x1) : mathMax$2(x, x1), dy >= 0 ? mathMin$2(y, y1) : mathMax$2(y, y1));
      } // Offset for next lineTo


      dx = x - x1;
      dy = y - y1;
      this._dashOffset = -mathSqrt$1(dx * dx + dy * dy);
    },
    // Not accurate dashed line to
    _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
      var dashSum = this._dashSum;
      var offset = this._dashOffset;
      var lineDash = this._lineDash;
      var ctx = this._ctx;
      var x0 = this._xi;
      var y0 = this._yi;
      var t;
      var dx;
      var dy;
      var cubicAt = curve.cubicAt;
      var bezierLen = 0;
      var idx = this._dashIdx;
      var nDash = lineDash.length;
      var x;
      var y;
      var tmpLen = 0;

      if (offset < 0) {
        // Convert to positive offset
        offset = dashSum + offset;
      }

      offset %= dashSum; // Bezier approx length

      for (t = 0; t < 1; t += 0.1) {
        dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
        dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
        bezierLen += mathSqrt$1(dx * dx + dy * dy);
      } // Find idx after add offset


      for (; idx < nDash; idx++) {
        tmpLen += lineDash[idx];

        if (tmpLen > offset) {
          break;
        }
      }

      t = (tmpLen - offset) / bezierLen;

      while (t <= 1) {
        x = cubicAt(x0, x1, x2, x3, t);
        y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
        // Bad result if dash is long

        idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        t += lineDash[idx] / bezierLen;
        idx = (idx + 1) % nDash;
      } // Finish the last segment and calculate the new offset


      idx % 2 !== 0 && ctx.lineTo(x3, y3);
      dx = x3 - x;
      dy = y3 - y;
      this._dashOffset = -mathSqrt$1(dx * dx + dy * dy);
    },
    _dashedQuadraticTo: function (x1, y1, x2, y2) {
      // Convert quadratic to cubic using degree elevation
      var x3 = x2;
      var y3 = y2;
      x2 = (x2 + 2 * x1) / 3;
      y2 = (y2 + 2 * y1) / 3;
      x1 = (this._xi + 2 * x1) / 3;
      y1 = (this._yi + 2 * y1) / 3;

      this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
    },

    /**
     * è½¬æéæç Float32Array åå°å åå­å ç¨
     * Convert dynamic array to static Float32Array
     */
    toStatic: function () {
      var data = this.data;

      if (data instanceof Array) {
        data.length = this._len;

        if (hasTypedArray) {
          this.data = new Float32Array(data);
        }
      }
    },

    /**
     * @return {module:zrender/core/BoundingRect}
     */
    getBoundingRect: function () {
      min$4[0] = min$4[1] = min2[0] = min2[1] = Number.MAX_VALUE;
      max$3[0] = max$3[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
      var data = this.data;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;

      for (var i = 0; i < data.length;) {
        var cmd = data[i++];

        if (i === 1) {
          // å¦æç¬¬ä¸ä¸ªå½ä»¤æ¯ L, C, Q
          // å previous point åç»å¶å½ä»¤çç¬¬ä¸ä¸ª point
          //
          // ç¬¬ä¸ä¸ªå½ä»¤ä¸º Arc çæåµä¸ä¼å¨åé¢ç¹æ®å¤ç
          xi = data[i];
          yi = data[i + 1];
          x0 = xi;
          y0 = yi;
        }

        switch (cmd) {
          case CMD.M:
            // moveTo å½ä»¤éæ°åå»ºä¸ä¸ªæ°ç subpath, å¹¶ä¸æ´æ°æ°çèµ·ç¹
            // å¨ closePath çæ¶åä½¿ç¨
            x0 = data[i++];
            y0 = data[i++];
            xi = x0;
            yi = y0;
            min2[0] = x0;
            min2[1] = y0;
            max2[0] = x0;
            max2[1] = y0;
            break;

          case CMD.L:
            bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
            xi = data[i++];
            yi = data[i++];
            break;

          case CMD.C:
            bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
            xi = data[i++];
            yi = data[i++];
            break;

          case CMD.Q:
            bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
            xi = data[i++];
            yi = data[i++];
            break;

          case CMD.A:
            // TODO Arc å¤æ­çå¼éæ¯è¾å¤§
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var startAngle = data[i++];
            var endAngle = data[i++] + startAngle; // TODO Arc æè½¬

            i += 1;
            var anticlockwise = 1 - data[i++];

            if (i === 1) {
              // ç´æ¥ä½¿ç¨ arc å½ä»¤
              // ç¬¬ä¸ä¸ªå½ä»¤èµ·ç¹è¿æªå®ä¹
              x0 = mathCos$1(startAngle) * rx + cx;
              y0 = mathSin$1(startAngle) * ry + cy;
            }

            bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
            xi = mathCos$1(endAngle) * rx + cx;
            yi = mathSin$1(endAngle) * ry + cy;
            break;

          case CMD.R:
            x0 = xi = data[i++];
            y0 = yi = data[i++];
            var width = data[i++];
            var height = data[i++]; // Use fromLine

            bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
            break;

          case CMD.Z:
            xi = x0;
            yi = y0;
            break;
        } // Union


        vector.min(min$4, min$4, min2);
        vector.max(max$3, max$3, max2);
      } // No data


      if (i === 0) {
        min$4[0] = min$4[1] = max$3[0] = max$3[1] = 0;
      }

      return new BoundingRect_1(min$4[0], min$4[1], max$3[0] - min$4[0], max$3[1] - min$4[1]);
    },

    /**
     * Rebuild path from current data
     * Rebuild path will not consider javascript implemented line dash.
     * @param {CanvasRenderingContext2D} ctx
     */
    rebuildPath: function (ctx) {
      var d = this.data;
      var x0;
      var y0;
      var xi;
      var yi;
      var x;
      var y;
      var ux = this._ux;
      var uy = this._uy;
      var len = this._len;

      for (var i = 0; i < len;) {
        var cmd = d[i++];

        if (i === 1) {
          // å¦æç¬¬ä¸ä¸ªå½ä»¤æ¯ L, C, Q
          // å previous point åç»å¶å½ä»¤çç¬¬ä¸ä¸ª point
          //
          // ç¬¬ä¸ä¸ªå½ä»¤ä¸º Arc çæåµä¸ä¼å¨åé¢ç¹æ®å¤ç
          xi = d[i];
          yi = d[i + 1];
          x0 = xi;
          y0 = yi;
        }

        switch (cmd) {
          case CMD.M:
            x0 = xi = d[i++];
            y0 = yi = d[i++];
            ctx.moveTo(xi, yi);
            break;

          case CMD.L:
            x = d[i++];
            y = d[i++]; // Not draw too small seg between

            if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
              ctx.lineTo(x, y);
              xi = x;
              yi = y;
            }

            break;

          case CMD.C:
            ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
            xi = d[i - 2];
            yi = d[i - 1];
            break;

          case CMD.Q:
            ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
            xi = d[i - 2];
            yi = d[i - 1];
            break;

          case CMD.A:
            var cx = d[i++];
            var cy = d[i++];
            var rx = d[i++];
            var ry = d[i++];
            var theta = d[i++];
            var dTheta = d[i++];
            var psi = d[i++];
            var fs = d[i++];
            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            var isEllipse = Math.abs(rx - ry) > 1e-3;
            var endAngle = theta + dTheta;

            if (isEllipse) {
              ctx.translate(cx, cy);
              ctx.rotate(psi);
              ctx.scale(scaleX, scaleY);
              ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
              ctx.scale(1 / scaleX, 1 / scaleY);
              ctx.rotate(-psi);
              ctx.translate(-cx, -cy);
            } else {
              ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
            }

            if (i === 1) {
              // ç´æ¥ä½¿ç¨ arc å½ä»¤
              // ç¬¬ä¸ä¸ªå½ä»¤èµ·ç¹è¿æªå®ä¹
              x0 = mathCos$1(theta) * rx + cx;
              y0 = mathSin$1(theta) * ry + cy;
            }

            xi = mathCos$1(endAngle) * rx + cx;
            yi = mathSin$1(endAngle) * ry + cy;
            break;

          case CMD.R:
            x0 = xi = d[i];
            y0 = yi = d[i + 1];
            ctx.rect(d[i++], d[i++], d[i++], d[i++]);
            break;

          case CMD.Z:
            ctx.closePath();
            xi = x0;
            yi = y0;
        }
      }
    }
  };
  PathProxy.CMD = CMD;
  var _default$v = PathProxy;
  var PathProxy_1 = _default$v;

  /**
   * çº¿æ®µåå«å¤æ­
   * @param  {number}  x0
   * @param  {number}  y0
   * @param  {number}  x1
   * @param  {number}  y1
   * @param  {number}  lineWidth
   * @param  {number}  x
   * @param  {number}  y
   * @return {boolean}
   */
  function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }

    var _l = lineWidth;
    var _a = 0;
    var _b = x0; // Quick reject

    if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
      return false;
    }

    if (x0 !== x1) {
      _a = (y0 - y1) / (x0 - x1);
      _b = (x0 * y1 - x1 * y0) / (x0 - x1);
    } else {
      return Math.abs(x - x0) <= _l / 2;
    }

    var tmp = _a * x - y + _b;

    var _s = tmp * tmp / (_a * _a + 1);

    return _s <= _l / 2 * _l / 2;
  }

  var containStroke_1 = containStroke;

  var line = {
  	containStroke: containStroke_1
  };

  /**
   * ä¸æ¬¡è´å¡å°æ²çº¿æè¾¹åå«å¤æ­
   * @param  {number}  x0
   * @param  {number}  y0
   * @param  {number}  x1
   * @param  {number}  y1
   * @param  {number}  x2
   * @param  {number}  y2
   * @param  {number}  x3
   * @param  {number}  y3
   * @param  {number}  lineWidth
   * @param  {number}  x
   * @param  {number}  y
   * @return {boolean}
   */
  function containStroke$1(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }

    var _l = lineWidth; // Quick reject

    if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
      return false;
    }

    var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
    return d <= _l / 2;
  }

  var containStroke_1$1 = containStroke$1;

  var cubic = {
  	containStroke: containStroke_1$1
  };

  var quadraticProjectPoint$1 = curve.quadraticProjectPoint;

  /**
   * äºæ¬¡è´å¡å°æ²çº¿æè¾¹åå«å¤æ­
   * @param  {number}  x0
   * @param  {number}  y0
   * @param  {number}  x1
   * @param  {number}  y1
   * @param  {number}  x2
   * @param  {number}  y2
   * @param  {number}  lineWidth
   * @param  {number}  x
   * @param  {number}  y
   * @return {boolean}
   */
  function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }

    var _l = lineWidth; // Quick reject

    if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
      return false;
    }

    var d = quadraticProjectPoint$1(x0, y0, x1, y1, x2, y2, x, y, null);
    return d <= _l / 2;
  }

  var containStroke_1$2 = containStroke$2;

  var quadratic = {
  	containStroke: containStroke_1$2
  };

  var PI2$1 = Math.PI * 2;

  function normalizeRadian(angle) {
    angle %= PI2$1;

    if (angle < 0) {
      angle += PI2$1;
    }

    return angle;
  }

  var normalizeRadian_1 = normalizeRadian;

  var util$1 = {
  	normalizeRadian: normalizeRadian_1
  };

  var normalizeRadian$1 = util$1.normalizeRadian;
  var PI2$2 = Math.PI * 2;
  /**
   * åå¼§æè¾¹åå«å¤æ­
   * @param  {number}  cx
   * @param  {number}  cy
   * @param  {number}  r
   * @param  {number}  startAngle
   * @param  {number}  endAngle
   * @param  {boolean}  anticlockwise
   * @param  {number} lineWidth
   * @param  {number}  x
   * @param  {number}  y
   * @return {Boolean}
   */

  function containStroke$3(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }

    var _l = lineWidth;
    x -= cx;
    y -= cy;
    var d = Math.sqrt(x * x + y * y);

    if (d - _l > r || d + _l < r) {
      return false;
    }

    if (Math.abs(startAngle - endAngle) % PI2$2 < 1e-4) {
      // Is a circle
      return true;
    }

    if (anticlockwise) {
      var tmp = startAngle;
      startAngle = normalizeRadian$1(endAngle);
      endAngle = normalizeRadian$1(tmp);
    } else {
      startAngle = normalizeRadian$1(startAngle);
      endAngle = normalizeRadian$1(endAngle);
    }

    if (startAngle > endAngle) {
      endAngle += PI2$2;
    }

    var angle = Math.atan2(y, x);

    if (angle < 0) {
      angle += PI2$2;
    }

    return angle >= startAngle && angle <= endAngle || angle + PI2$2 >= startAngle && angle + PI2$2 <= endAngle;
  }

  var containStroke_1$3 = containStroke$3;

  var arc = {
  	containStroke: containStroke_1$3
  };

  function windingLine(x0, y0, x1, y1, x, y) {
    if (y > y0 && y > y1 || y < y0 && y < y1) {
      return 0;
    } // Ignore horizontal line


    if (y1 === y0) {
      return 0;
    }

    var dir = y1 < y0 ? 1 : -1;
    var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon

    if (t === 1 || t === 0) {
      dir = y1 < y0 ? 0.5 : -0.5;
    }

    var x_ = t * (x1 - x0) + x0; // If (x, y) on the line, considered as "contain".

    return x_ === x ? Infinity : x_ > x ? dir : 0;
  }

  var windingLine_1 = windingLine;

  var normalizeRadian$2 = util$1.normalizeRadian;





  var CMD$1 = PathProxy_1.CMD;
  var PI2$3 = Math.PI * 2;
  var EPSILON$2 = 1e-4;

  function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON$2;
  } // ä¸´æ¶æ°ç»


  var roots = [-1, -1, -1];
  var extrema = [-1, -1];

  function swapExtrema() {
    var tmp = extrema[0];
    extrema[0] = extrema[1];
    extrema[1] = tmp;
  }

  function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    // Quick reject
    if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
      return 0;
    }

    var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);

    if (nRoots === 0) {
      return 0;
    } else {
      var w = 0;
      var nExtrema = -1;
      var y0_;
      var y1_;

      for (var i = 0; i < nRoots; i++) {
        var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon

        var unit = t === 0 || t === 1 ? 0.5 : 1;
        var x_ = curve.cubicAt(x0, x1, x2, x3, t);

        if (x_ < x) {
          // Quick reject
          continue;
        }

        if (nExtrema < 0) {
          nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);

          if (extrema[1] < extrema[0] && nExtrema > 1) {
            swapExtrema();
          }

          y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);

          if (nExtrema > 1) {
            y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
          }
        }

        if (nExtrema === 2) {
          // åæä¸æ®µåè°å½æ°
          if (t < extrema[0]) {
            w += y0_ < y0 ? unit : -unit;
          } else if (t < extrema[1]) {
            w += y1_ < y0_ ? unit : -unit;
          } else {
            w += y3 < y1_ ? unit : -unit;
          }
        } else {
          // åæä¸¤æ®µåè°å½æ°
          if (t < extrema[0]) {
            w += y0_ < y0 ? unit : -unit;
          } else {
            w += y3 < y0_ ? unit : -unit;
          }
        }
      }

      return w;
    }
  }

  function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
    // Quick reject
    if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
      return 0;
    }

    var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);

    if (nRoots === 0) {
      return 0;
    } else {
      var t = curve.quadraticExtremum(y0, y1, y2);

      if (t >= 0 && t <= 1) {
        var w = 0;
        var y_ = curve.quadraticAt(y0, y1, y2, t);

        for (var i = 0; i < nRoots; i++) {
          // Remove one endpoint.
          var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
          var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);

          if (x_ < x) {
            // Quick reject
            continue;
          }

          if (roots[i] < t) {
            w += y_ < y0 ? unit : -unit;
          } else {
            w += y2 < y_ ? unit : -unit;
          }
        }

        return w;
      } else {
        // Remove one endpoint.
        var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
        var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);

        if (x_ < x) {
          // Quick reject
          return 0;
        }

        return y2 < y0 ? unit : -unit;
      }
    }
  } // TODO
  // Arc æè½¬


  function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
    y -= cy;

    if (y > r || y < -r) {
      return 0;
    }

    var tmp = Math.sqrt(r * r - y * y);
    roots[0] = -tmp;
    roots[1] = tmp;
    var diff = Math.abs(startAngle - endAngle);

    if (diff < 1e-4) {
      return 0;
    }

    if (diff % PI2$3 < 1e-4) {
      // Is a circle
      startAngle = 0;
      endAngle = PI2$3;
      var dir = anticlockwise ? 1 : -1;

      if (x >= roots[0] + cx && x <= roots[1] + cx) {
        return dir;
      } else {
        return 0;
      }
    }

    if (anticlockwise) {
      var tmp = startAngle;
      startAngle = normalizeRadian$2(endAngle);
      endAngle = normalizeRadian$2(tmp);
    } else {
      startAngle = normalizeRadian$2(startAngle);
      endAngle = normalizeRadian$2(endAngle);
    }

    if (startAngle > endAngle) {
      endAngle += PI2$3;
    }

    var w = 0;

    for (var i = 0; i < 2; i++) {
      var x_ = roots[i];

      if (x_ + cx > x) {
        var angle = Math.atan2(y, x_);
        var dir = anticlockwise ? 1 : -1;

        if (angle < 0) {
          angle = PI2$3 + angle;
        }

        if (angle >= startAngle && angle <= endAngle || angle + PI2$3 >= startAngle && angle + PI2$3 <= endAngle) {
          if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
            dir = -dir;
          }

          w += dir;
        }
      }
    }

    return w;
  }

  function containPath(data, lineWidth, isStroke, x, y) {
    var w = 0;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;

    for (var i = 0; i < data.length;) {
      var cmd = data[i++]; // Begin a new subpath

      if (cmd === CMD$1.M && i > 1) {
        // Close previous subpath
        if (!isStroke) {
          w += windingLine_1(xi, yi, x0, y0, x, y);
        } // å¦æè¢«ä»»ä½ä¸ä¸ª subpath åå«
        // if (w !== 0) {
        //     return true;
        // }

      }

      if (i === 1) {
        // å¦æç¬¬ä¸ä¸ªå½ä»¤æ¯ L, C, Q
        // å previous point åç»å¶å½ä»¤çç¬¬ä¸ä¸ª point
        //
        // ç¬¬ä¸ä¸ªå½ä»¤ä¸º Arc çæåµä¸ä¼å¨åé¢ç¹æ®å¤ç
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }

      switch (cmd) {
        case CMD$1.M:
          // moveTo å½ä»¤éæ°åå»ºä¸ä¸ªæ°ç subpath, å¹¶ä¸æ´æ°æ°çèµ·ç¹
          // å¨ closePath çæ¶åä½¿ç¨
          x0 = data[i++];
          y0 = data[i++];
          xi = x0;
          yi = y0;
          break;

        case CMD$1.L:
          if (isStroke) {
            if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            // NOTE å¨ç¬¬ä¸ä¸ªå½ä»¤ä¸º L, C, Q çæ¶åä¼è®¡ç®åº NaN
            w += windingLine_1(xi, yi, data[i], data[i + 1], x, y) || 0;
          }

          xi = data[i++];
          yi = data[i++];
          break;

        case CMD$1.C:
          if (isStroke) {
            if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
          }

          xi = data[i++];
          yi = data[i++];
          break;

        case CMD$1.Q:
          if (isStroke) {
            if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
          }

          xi = data[i++];
          yi = data[i++];
          break;

        case CMD$1.A:
          // TODO Arc å¤æ­çå¼éæ¯è¾å¤§
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var theta = data[i++];
          var dTheta = data[i++]; // TODO Arc æè½¬

          i += 1;
          var anticlockwise = 1 - data[i++];
          var x1 = Math.cos(theta) * rx + cx;
          var y1 = Math.sin(theta) * ry + cy; // ä¸æ¯ç´æ¥ä½¿ç¨ arc å½ä»¤

          if (i > 1) {
            w += windingLine_1(xi, yi, x1, y1, x, y);
          } else {
            // ç¬¬ä¸ä¸ªå½ä»¤èµ·ç¹è¿æªå®ä¹
            x0 = x1;
            y0 = y1;
          } // zr ä½¿ç¨scaleæ¥æ¨¡ææ¤­å, è¿éä¹å¯¹xåä¸å®çç¼©æ¾


          var _x = (x - cx) * ry / rx + cx;

          if (isStroke) {
            if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
              return true;
            }
          } else {
            w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
          }

          xi = Math.cos(theta + dTheta) * rx + cx;
          yi = Math.sin(theta + dTheta) * ry + cy;
          break;

        case CMD$1.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          var x1 = x0 + width;
          var y1 = y0 + height;

          if (isStroke) {
            if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
              return true;
            }
          } else {
            // FIXME Clockwise ?
            w += windingLine_1(x1, y0, x1, y1, x, y);
            w += windingLine_1(x0, y1, x0, y0, x, y);
          }

          break;

        case CMD$1.Z:
          if (isStroke) {
            if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
              return true;
            }
          } else {
            // Close a subpath
            w += windingLine_1(xi, yi, x0, y0, x, y); // å¦æè¢«ä»»ä½ä¸ä¸ª subpath åå«
            // FIXME subpaths may overlap
            // if (w !== 0) {
            //     return true;
            // }
          }

          xi = x0;
          yi = y0;
          break;
      }
    }

    if (!isStroke && !isAroundEqual(yi, y0)) {
      w += windingLine_1(xi, yi, x0, y0, x, y) || 0;
    }

    return w !== 0;
  }

  function contain(pathData, x, y) {
    return containPath(pathData, 0, false, x, y);
  }

  function containStroke$4(pathData, lineWidth, x, y) {
    return containPath(pathData, lineWidth, true, x, y);
  }

  var contain_1 = contain;
  var containStroke_1$4 = containStroke$4;

  var path$1 = {
  	contain: contain_1,
  	containStroke: containStroke_1$4
  };

  var getCanvasPattern = Pattern_1.prototype.getCanvasPattern;
  var abs = Math.abs;
  var pathProxyForDraw = new PathProxy_1(true);
  /**
   * @alias module:zrender/graphic/Path
   * @extends module:zrender/graphic/Displayable
   * @constructor
   * @param {Object} opts
   */

  function Path(opts) {
    Displayable_1.call(this, opts);
    /**
     * @type {module:zrender/core/PathProxy}
     * @readOnly
     */

    this.path = null;
  }

  Path.prototype = {
    constructor: Path,
    type: 'path',
    __dirtyPath: true,
    strokeContainThreshold: 5,
    // This item default to be false. But in map series in echarts,
    // in order to improve performance, it should be set to true,
    // so the shorty segment won't draw.
    segmentIgnoreThreshold: 0,

    /**
     * See `module:zrender/src/graphic/helper/subPixelOptimize`.
     * @type {boolean}
     */
    subPixelOptimize: false,
    brush: function (ctx, prevEl) {
      var style = this.style;
      var path = this.path || pathProxyForDraw;
      var hasStroke = style.hasStroke();
      var hasFill = style.hasFill();
      var fill = style.fill;
      var stroke = style.stroke;
      var hasFillGradient = hasFill && !!fill.colorStops;
      var hasStrokeGradient = hasStroke && !!stroke.colorStops;
      var hasFillPattern = hasFill && !!fill.image;
      var hasStrokePattern = hasStroke && !!stroke.image;
      style.bind(ctx, this, prevEl);
      this.setTransform(ctx);

      if (this.__dirty) {
        var rect; // Update gradient because bounding rect may changed

        if (hasFillGradient) {
          rect = rect || this.getBoundingRect();
          this._fillGradient = style.getGradient(ctx, fill, rect);
        }

        if (hasStrokeGradient) {
          rect = rect || this.getBoundingRect();
          this._strokeGradient = style.getGradient(ctx, stroke, rect);
        }
      } // Use the gradient or pattern


      if (hasFillGradient) {
        // PENDING If may have affect the state
        ctx.fillStyle = this._fillGradient;
      } else if (hasFillPattern) {
        ctx.fillStyle = getCanvasPattern.call(fill, ctx);
      }

      if (hasStrokeGradient) {
        ctx.strokeStyle = this._strokeGradient;
      } else if (hasStrokePattern) {
        ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
      }

      var lineDash = style.lineDash;
      var lineDashOffset = style.lineDashOffset;
      var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy

      var scale = this.getGlobalScale();
      path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context
      // Rebuild path in following 2 cases
      // 1. Path is dirty
      // 2. Path needs javascript implemented lineDash stroking.
      //    In this case, lineDash information will not be saved in PathProxy

      if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
        path.beginPath(ctx); // Setting line dash before build path

        if (lineDash && !ctxLineDash) {
          path.setLineDash(lineDash);
          path.setLineDashOffset(lineDashOffset);
        }

        this.buildPath(path, this.shape, false); // Clear path dirty flag

        if (this.path) {
          this.__dirtyPath = false;
        }
      } else {
        // Replay path building
        ctx.beginPath();
        this.path.rebuildPath(ctx);
      }

      if (hasFill) {
        if (style.fillOpacity != null) {
          var originalGlobalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = style.fillOpacity * style.opacity;
          path.fill(ctx);
          ctx.globalAlpha = originalGlobalAlpha;
        } else {
          path.fill(ctx);
        }
      }

      if (lineDash && ctxLineDash) {
        ctx.setLineDash(lineDash);
        ctx.lineDashOffset = lineDashOffset;
      }

      if (hasStroke) {
        if (style.strokeOpacity != null) {
          var originalGlobalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = style.strokeOpacity * style.opacity;
          path.stroke(ctx);
          ctx.globalAlpha = originalGlobalAlpha;
        } else {
          path.stroke(ctx);
        }
      }

      if (lineDash && ctxLineDash) {
        // PENDING
        // Remove lineDash
        ctx.setLineDash([]);
      } // Draw rect text


      if (style.text != null) {
        // Only restore transform when needs draw text.
        this.restoreTransform(ctx);
        this.drawRectText(ctx, this.getBoundingRect());
      }
    },
    // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
    // Like in circle
    buildPath: function (ctx, shapeCfg, inBundle) {},
    createPathProxy: function () {
      this.path = new PathProxy_1();
    },
    getBoundingRect: function () {
      var rect = this._rect;
      var style = this.style;
      var needsUpdateRect = !rect;

      if (needsUpdateRect) {
        var path = this.path;

        if (!path) {
          // Create path on demand.
          path = this.path = new PathProxy_1();
        }

        if (this.__dirtyPath) {
          path.beginPath();
          this.buildPath(path, this.shape, false);
        }

        rect = path.getBoundingRect();
      }

      this._rect = rect;

      if (style.hasStroke()) {
        // Needs update rect with stroke lineWidth when
        // 1. Element changes scale or lineWidth
        // 2. Shape is changed
        var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());

        if (this.__dirty || needsUpdateRect) {
          rectWithStroke.copy(rect); // FIXME Must after updateTransform

          var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical

          var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill

          if (!style.hasFill()) {
            w = Math.max(w, this.strokeContainThreshold || 4);
          } // Consider line width
          // Line scale can't be 0;


          if (lineScale > 1e-10) {
            rectWithStroke.width += w / lineScale;
            rectWithStroke.height += w / lineScale;
            rectWithStroke.x -= w / lineScale / 2;
            rectWithStroke.y -= w / lineScale / 2;
          }
        } // Return rect with stroke


        return rectWithStroke;
      }

      return rect;
    },
    contain: function (x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      var style = this.style;
      x = localPos[0];
      y = localPos[1];

      if (rect.contain(x, y)) {
        var pathData = this.path.data;

        if (style.hasStroke()) {
          var lineWidth = style.lineWidth;
          var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;

          if (lineScale > 1e-10) {
            // Only add extra hover lineWidth when there are no fill
            if (!style.hasFill()) {
              lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
            }

            if (path$1.containStroke(pathData, lineWidth / lineScale, x, y)) {
              return true;
            }
          }
        }

        if (style.hasFill()) {
          return path$1.contain(pathData, x, y);
        }
      }

      return false;
    },

    /**
     * @param  {boolean} dirtyPath
     */
    dirty: function (dirtyPath) {
      if (dirtyPath == null) {
        dirtyPath = true;
      } // Only mark dirty, not mark clean


      if (dirtyPath) {
        this.__dirtyPath = dirtyPath;
        this._rect = null;
      }

      this.__dirty = this.__dirtyText = true;
      this.__zr && this.__zr.refresh(); // Used as a clipping path

      if (this.__clipTarget) {
        this.__clipTarget.dirty();
      }
    },

    /**
     * Alias for animate('shape')
     * @param {boolean} loop
     */
    animateShape: function (loop) {
      return this.animate('shape', loop);
    },
    // Overwrite attrKV
    attrKV: function (key, value) {
      // FIXME
      if (key === 'shape') {
        this.setShape(value);
        this.__dirtyPath = true;
        this._rect = null;
      } else {
        Displayable_1.prototype.attrKV.call(this, key, value);
      }
    },

    /**
     * @param {Object|string} key
     * @param {*} value
     */
    setShape: function (key, value) {
      var shape = this.shape; // Path from string may not have shape

      if (shape) {
        if (util.isObject(key)) {
          for (var name in key) {
            if (key.hasOwnProperty(name)) {
              shape[name] = key[name];
            }
          }
        } else {
          shape[key] = value;
        }

        this.dirty(true);
      }

      return this;
    },
    getLineScale: function () {
      var m = this.transform; // Get the line scale.
      // Determinant of `m` means how much the area is enlarged by the
      // transformation. So its square root can be used as a scale factor
      // for width.

      return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
    }
  };
  /**
   * æ©å±ä¸ä¸ª Path element, æ¯å¦æå½¢ï¼åç­ã
   * Extend a path element
   * @param {Object} props
   * @param {string} props.type Path type
   * @param {Function} props.init Initialize
   * @param {Function} props.buildPath Overwrite buildPath method
   * @param {Object} [props.style] Extended default style config
   * @param {Object} [props.shape] Extended default shape config
   */

  Path.extend = function (defaults) {
    var Sub = function (opts) {
      Path.call(this, opts);

      if (defaults.style) {
        // Extend default style
        this.style.extendFrom(defaults.style, false);
      } // Extend default shape


      var defaultShape = defaults.shape;

      if (defaultShape) {
        this.shape = this.shape || {};
        var thisShape = this.shape;

        for (var name in defaultShape) {
          if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
            thisShape[name] = defaultShape[name];
          }
        }
      }

      defaults.init && defaults.init.call(this, opts);
    };

    util.inherits(Sub, Path); // FIXME ä¸è½ extend position, rotation ç­å¼ç¨å¯¹è±¡

    for (var name in defaults) {
      // Extending prototype values and methods
      if (name !== 'style' && name !== 'shape') {
        Sub.prototype[name] = defaults[name];
      }
    }

    return Sub;
  };

  util.inherits(Path, Displayable_1);
  var _default$w = Path;
  var Path_1 = _default$w;

  var v2ApplyTransform$1 = vector.applyTransform;
  var CMD$2 = PathProxy_1.CMD;
  var points = [[], [], []];
  var mathSqrt$2 = Math.sqrt;
  var mathAtan2 = Math.atan2;

  function _default$x(path, m) {
    var data = path.data;
    var cmd;
    var nPoint;
    var i;
    var j;
    var k;
    var p;
    var M = CMD$2.M;
    var C = CMD$2.C;
    var L = CMD$2.L;
    var R = CMD$2.R;
    var A = CMD$2.A;
    var Q = CMD$2.Q;

    for (i = 0, j = 0; i < data.length;) {
      cmd = data[i++];
      j = i;
      nPoint = 0;

      switch (cmd) {
        case M:
          nPoint = 1;
          break;

        case L:
          nPoint = 1;
          break;

        case C:
          nPoint = 3;
          break;

        case Q:
          nPoint = 2;
          break;

        case A:
          var x = m[4];
          var y = m[5];
          var sx = mathSqrt$2(m[0] * m[0] + m[1] * m[1]);
          var sy = mathSqrt$2(m[2] * m[2] + m[3] * m[3]);
          var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx

          data[i] *= sx;
          data[i++] += x; // cy

          data[i] *= sy;
          data[i++] += y; // Scale rx and ry
          // FIXME Assume psi is 0 here

          data[i++] *= sx;
          data[i++] *= sy; // Start angle

          data[i++] += angle; // end angle

          data[i++] += angle; // FIXME psi

          i += 2;
          j = i;
          break;

        case R:
          // x0, y0
          p[0] = data[i++];
          p[1] = data[i++];
          v2ApplyTransform$1(p, p, m);
          data[j++] = p[0];
          data[j++] = p[1]; // x1, y1

          p[0] += data[i++];
          p[1] += data[i++];
          v2ApplyTransform$1(p, p, m);
          data[j++] = p[0];
          data[j++] = p[1];
      }

      for (k = 0; k < nPoint; k++) {
        var p = points[k];
        p[0] = data[i++];
        p[1] = data[i++];
        v2ApplyTransform$1(p, p, m); // Write back

        data[j++] = p[0];
        data[j++] = p[1];
      }
    }
  }

  var transformPath = _default$x;

  // command chars
  // var cc = [
  //     'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
  //     'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
  // ];
  var mathSqrt$3 = Math.sqrt;
  var mathSin$2 = Math.sin;
  var mathCos$2 = Math.cos;
  var PI = Math.PI;

  var vMag = function (v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  };

  var vRatio = function (u, v) {
    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
  };

  var vAngle = function (u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
  };

  function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
    var psi = psiDeg * (PI / 180.0);
    var xp = mathCos$2(psi) * (x1 - x2) / 2.0 + mathSin$2(psi) * (y1 - y2) / 2.0;
    var yp = -1 * mathSin$2(psi) * (x1 - x2) / 2.0 + mathCos$2(psi) * (y1 - y2) / 2.0;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

    if (lambda > 1) {
      rx *= mathSqrt$3(lambda);
      ry *= mathSqrt$3(lambda);
    }

    var f = (fa === fs ? -1 : 1) * mathSqrt$3((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
    var cxp = f * rx * yp / ry;
    var cyp = f * -ry * xp / rx;
    var cx = (x1 + x2) / 2.0 + mathCos$2(psi) * cxp - mathSin$2(psi) * cyp;
    var cy = (y1 + y2) / 2.0 + mathSin$2(psi) * cxp + mathCos$2(psi) * cyp;
    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u, v);

    if (vRatio(u, v) <= -1) {
      dTheta = PI;
    }

    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }

    if (fs === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * PI;
    }

    if (fs === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * PI;
    }

    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
  }

  var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig; // Consider case:
  // (1) delimiter can be comma or space, where continuous commas
  // or spaces should be seen as one comma.
  // (2) value can be like:
  // '2e-4', 'l.5.9' (ignore 0), 'M-10-10', 'l-2.43e-1,34.9983',
  // 'l-.5E1,54', '121-23-44-11' (no delimiter)

  var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g; // var valueSplitReg = /[\s,]+/;

  function createPathProxyFromString(data) {
    if (!data) {
      return new PathProxy_1();
    } // var data = data.replace(/-/g, ' -')
    //     .replace(/  /g, ' ')
    //     .replace(/ /g, ',')
    //     .replace(/,,/g, ',');
    // var n;
    // create pipes so that we can split the data
    // for (n = 0; n < cc.length; n++) {
    //     cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
    // }
    // data = data.replace(/-/g, ',-');
    // create array
    // var arr = cs.split('|');
    // init context point


    var cpx = 0;
    var cpy = 0;
    var subpathX = cpx;
    var subpathY = cpy;
    var prevCmd;
    var path = new PathProxy_1();
    var CMD = PathProxy_1.CMD; // commandReg.lastIndex = 0;
    // var cmdResult;
    // while ((cmdResult = commandReg.exec(data)) != null) {
    //     var cmdStr = cmdResult[1];
    //     var cmdContent = cmdResult[2];

    var cmdList = data.match(commandReg);

    for (var l = 0; l < cmdList.length; l++) {
      var cmdText = cmdList[l];
      var cmdStr = cmdText.charAt(0);
      var cmd; // String#split is faster a little bit than String#replace or RegExp#exec.
      // var p = cmdContent.split(valueSplitReg);
      // var pLen = 0;
      // for (var i = 0; i < p.length; i++) {
      //     // '' and other invalid str => NaN
      //     var val = parseFloat(p[i]);
      //     !isNaN(val) && (p[pLen++] = val);
      // }

      var p = cmdText.match(numberReg) || [];
      var pLen = p.length;

      for (var i = 0; i < pLen; i++) {
        p[i] = parseFloat(p[i]);
      }

      var off = 0;

      while (off < pLen) {
        var ctlPtx;
        var ctlPty;
        var rx;
        var ry;
        var psi;
        var fa;
        var fs;
        var x1 = cpx;
        var y1 = cpy; // convert l, H, h, V, and v to L

        switch (cmdStr) {
          case 'l':
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;

          case 'L':
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;

          case 'm':
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD.M;
            path.addData(cmd, cpx, cpy);
            subpathX = cpx;
            subpathY = cpy;
            cmdStr = 'l';
            break;

          case 'M':
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD.M;
            path.addData(cmd, cpx, cpy);
            subpathX = cpx;
            subpathY = cpy;
            cmdStr = 'L';
            break;

          case 'h':
            cpx += p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;

          case 'H':
            cpx = p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;

          case 'v':
            cpy += p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;

          case 'V':
            cpy = p[off++];
            cmd = CMD.L;
            path.addData(cmd, cpx, cpy);
            break;

          case 'C':
            cmd = CMD.C;
            path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
            cpx = p[off - 2];
            cpy = p[off - 1];
            break;

          case 'c':
            cmd = CMD.C;
            path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
            cpx += p[off - 2];
            cpy += p[off - 1];
            break;

          case 'S':
            ctlPtx = cpx;
            ctlPty = cpy;
            var len = path.len();
            var pathData = path.data;

            if (prevCmd === CMD.C) {
              ctlPtx += cpx - pathData[len - 4];
              ctlPty += cpy - pathData[len - 3];
            }

            cmd = CMD.C;
            x1 = p[off++];
            y1 = p[off++];
            cpx = p[off++];
            cpy = p[off++];
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
            break;

          case 's':
            ctlPtx = cpx;
            ctlPty = cpy;
            var len = path.len();
            var pathData = path.data;

            if (prevCmd === CMD.C) {
              ctlPtx += cpx - pathData[len - 4];
              ctlPty += cpy - pathData[len - 3];
            }

            cmd = CMD.C;
            x1 = cpx + p[off++];
            y1 = cpy + p[off++];
            cpx += p[off++];
            cpy += p[off++];
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
            break;

          case 'Q':
            x1 = p[off++];
            y1 = p[off++];
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD.Q;
            path.addData(cmd, x1, y1, cpx, cpy);
            break;

          case 'q':
            x1 = p[off++] + cpx;
            y1 = p[off++] + cpy;
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD.Q;
            path.addData(cmd, x1, y1, cpx, cpy);
            break;

          case 'T':
            ctlPtx = cpx;
            ctlPty = cpy;
            var len = path.len();
            var pathData = path.data;

            if (prevCmd === CMD.Q) {
              ctlPtx += cpx - pathData[len - 4];
              ctlPty += cpy - pathData[len - 3];
            }

            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD.Q;
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
            break;

          case 't':
            ctlPtx = cpx;
            ctlPty = cpy;
            var len = path.len();
            var pathData = path.data;

            if (prevCmd === CMD.Q) {
              ctlPtx += cpx - pathData[len - 4];
              ctlPty += cpy - pathData[len - 3];
            }

            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD.Q;
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
            break;

          case 'A':
            rx = p[off++];
            ry = p[off++];
            psi = p[off++];
            fa = p[off++];
            fs = p[off++];
            x1 = cpx, y1 = cpy;
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD.A;
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
            break;

          case 'a':
            rx = p[off++];
            ry = p[off++];
            psi = p[off++];
            fa = p[off++];
            fs = p[off++];
            x1 = cpx, y1 = cpy;
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD.A;
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
            break;
        }
      }

      if (cmdStr === 'z' || cmdStr === 'Z') {
        cmd = CMD.Z;
        path.addData(cmd); // z may be in the middle of the path.

        cpx = subpathX;
        cpy = subpathY;
      }

      prevCmd = cmd;
    }

    path.toStatic();
    return path;
  } // TODO Optimize double memory cost problem


  function createPathOptions(str, opts) {
    var pathProxy = createPathProxyFromString(str);
    opts = opts || {};

    opts.buildPath = function (path) {
      if (path.setData) {
        path.setData(pathProxy.data); // Svg and vml renderer don't have context

        var ctx = path.getContext();

        if (ctx) {
          path.rebuildPath(ctx);
        }
      } else {
        var ctx = path;
        pathProxy.rebuildPath(ctx);
      }
    };

    opts.applyTransform = function (m) {
      transformPath(pathProxy, m);
      this.dirty(true);
    };

    return opts;
  }
  /**
   * Create a Path object from path string data
   * http://www.w3.org/TR/SVG/paths.html#PathData
   * @param  {Object} opts Other options
   */


  function createFromString(str, opts) {
    return new Path_1(createPathOptions(str, opts));
  }
  /**
   * Create a Path class from path string data
   * @param  {string} str
   * @param  {Object} opts Other options
   */


  function extendFromString(str, opts) {
    return Path_1.extend(createPathOptions(str, opts));
  }
  /**
   * Merge multiple paths
   */
  // TODO Apply transform
  // TODO stroke dash
  // TODO Optimize double memory cost problem


  function mergePath(pathEls, opts) {
    var pathList = [];
    var len = pathEls.length;

    for (var i = 0; i < len; i++) {
      var pathEl = pathEls[i];

      if (!pathEl.path) {
        pathEl.createPathProxy();
      }

      if (pathEl.__dirtyPath) {
        pathEl.buildPath(pathEl.path, pathEl.shape, true);
      }

      pathList.push(pathEl.path);
    }

    var pathBundle = new Path_1(opts); // Need path proxy.

    pathBundle.createPathProxy();

    pathBundle.buildPath = function (path) {
      path.appendPath(pathList); // Svg and vml renderer don't have context

      var ctx = path.getContext();

      if (ctx) {
        path.rebuildPath(ctx);
      }
    };

    return pathBundle;
  }

  var createFromString_1 = createFromString;
  var extendFromString_1 = extendFromString;
  var mergePath_1 = mergePath;

  var path$2 = {
  	createFromString: createFromString_1,
  	extendFromString: extendFromString_1,
  	mergePath: mergePath_1
  };

  var ContextCachedBy$3 = constant.ContextCachedBy;

  /**
   * @alias zrender/graphic/Text
   * @extends module:zrender/graphic/Displayable
   * @constructor
   * @param {Object} opts
   */
  var Text = function (opts) {
    // jshint ignore:line
    Displayable_1.call(this, opts);
  };

  Text.prototype = {
    constructor: Text,
    type: 'text',
    brush: function (ctx, prevEl) {
      var style = this.style; // Optimize, avoid normalize every time.

      this.__dirty && text$1.normalizeTextStyle(style, true); // Use props with prefix 'text'.

      style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
      var text = style.text; // Convert to string

      text != null && (text += ''); // Do not apply style.bind in Text node. Because the real bind job
      // is in textHelper.renderText, and performance of text render should
      // be considered.
      // style.bind(ctx, this, prevEl);

      if (!text$1.needDrawText(text, style)) {
        // The current el.style is not applied
        // and should not be used as cache.
        ctx.__attrCachedBy = ContextCachedBy$3.NONE;
        return;
      }

      this.setTransform(ctx);
      text$1.renderText(this, ctx, text, style, null, prevEl);
      this.restoreTransform(ctx);
    },
    getBoundingRect: function () {
      var style = this.style; // Optimize, avoid normalize every time.

      this.__dirty && text$1.normalizeTextStyle(style, true);

      if (!this._rect) {
        var text$2 = style.text;
        text$2 != null ? text$2 += '' : text$2 = '';
        var rect = text.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.textLineHeight, style.rich);
        rect.x += style.x || 0;
        rect.y += style.y || 0;

        if (text$1.getStroke(style.textStroke, style.textStrokeWidth)) {
          var w = style.textStrokeWidth;
          rect.x -= w / 2;
          rect.y -= w / 2;
          rect.width += w;
          rect.height += w;
        }

        this._rect = rect;
      }

      return this._rect;
    }
  };
  util.inherits(Text, Displayable_1);
  var _default$y = Text;
  var Text_1 = _default$y;

  /**
   * åå½¢
   * @module zrender/shape/Circle
   */
  var _default$z = Path_1.extend({
    type: 'circle',
    shape: {
      cx: 0,
      cy: 0,
      r: 0
    },
    buildPath: function (ctx, shape, inBundle) {
      // Better stroking in ShapeBundle
      // Always do it may have performence issue ( fill may be 2x more cost)
      if (inBundle) {
        ctx.moveTo(shape.cx + shape.r, shape.cy);
      } // else {
      //     if (ctx.allocate && !ctx.data.length) {
      //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
      //     }
      // }
      // Better stroking in ShapeBundle
      // ctx.moveTo(shape.cx + shape.r, shape.cy);


      ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
    }
  });

  var Circle = _default$z;

  // Fix weird bug in some version of IE11 (like 11.0.9600.178**),
  // where exception "unexpected call to method or property access"
  // might be thrown when calling ctx.fill or ctx.stroke after a path
  // whose area size is zero is drawn and ctx.clip() is called and
  // shadowBlur is set. See #4572, #3112, #5777.
  // (e.g.,
  //  ctx.moveTo(10, 10);
  //  ctx.lineTo(20, 10);
  //  ctx.closePath();
  //  ctx.clip();
  //  ctx.shadowBlur = 10;
  //  ...
  //  ctx.fill();
  // )
  var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];

  function _default$A(orignalBrush) {
    // version string can be: '11.0'
    return env_1.browser.ie && env_1.browser.version >= 11 ? function () {
      var clipPaths = this.__clipPaths;
      var style = this.style;
      var modified;

      if (clipPaths) {
        for (var i = 0; i < clipPaths.length; i++) {
          var clipPath = clipPaths[i];
          var shape = clipPath && clipPath.shape;
          var type = clipPath && clipPath.type;

          if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
            for (var j = 0; j < shadowTemp.length; j++) {
              // It is save to put shadowTemp static, because shadowTemp
              // will be all modified each item brush called.
              shadowTemp[j][2] = style[shadowTemp[j][0]];
              style[shadowTemp[j][0]] = shadowTemp[j][1];
            }

            modified = true;
            break;
          }
        }
      }

      orignalBrush.apply(this, arguments);

      if (modified) {
        for (var j = 0; j < shadowTemp.length; j++) {
          style[shadowTemp[j][0]] = shadowTemp[j][2];
        }
      }
    } : orignalBrush;
  }

  var fixClipWithShadow = _default$A;

  /**
   * æå½¢
   * @module zrender/graphic/shape/Sector
   */
  var _default$B = Path_1.extend({
    type: 'sector',
    shape: {
      cx: 0,
      cy: 0,
      r0: 0,
      r: 0,
      startAngle: 0,
      endAngle: Math.PI * 2,
      clockwise: true
    },
    brush: fixClipWithShadow(Path_1.prototype.brush),
    buildPath: function (ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var r0 = Math.max(shape.r0 || 0, 0);
      var r = Math.max(shape.r, 0);
      var startAngle = shape.startAngle;
      var endAngle = shape.endAngle;
      var clockwise = shape.clockwise;
      var unitX = Math.cos(startAngle);
      var unitY = Math.sin(startAngle);
      ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
      ctx.lineTo(unitX * r + x, unitY * r + y);
      ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
      ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);

      if (r0 !== 0) {
        ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
      }

      ctx.closePath();
    }
  });

  var Sector = _default$B;

  /**
   * åç¯
   * @module zrender/graphic/shape/Ring
   */
  var _default$C = Path_1.extend({
    type: 'ring',
    shape: {
      cx: 0,
      cy: 0,
      r: 0,
      r0: 0
    },
    buildPath: function (ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var PI2 = Math.PI * 2;
      ctx.moveTo(x + shape.r, y);
      ctx.arc(x, y, shape.r, 0, PI2, false);
      ctx.moveTo(x + shape.r0, y);
      ctx.arc(x, y, shape.r0, 0, PI2, true);
    }
  });

  var Ring = _default$C;

  var v2Distance = vector.distance;

  /**
   * Catmull-Rom spline æå¼æçº¿
   * @module zrender/shape/util/smoothSpline
   * @author pissang (https://www.github.com/pissang)
   *         Kener (@Kener-æå³°, kener.linfeng@gmail.com)
   *         errorrik (errorrik@gmail.com)
   */

  /**
   * @inner
   */
  function interpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  /**
   * @alias module:zrender/shape/util/smoothSpline
   * @param {Array} points çº¿æ®µé¡¶ç¹æ°ç»
   * @param {boolean} isLoop
   * @return {Array}
   */


  function _default$D(points, isLoop) {
    var len = points.length;
    var ret = [];
    var distance = 0;

    for (var i = 1; i < len; i++) {
      distance += v2Distance(points[i - 1], points[i]);
    }

    var segs = distance / 2;
    segs = segs < len ? len : segs;

    for (var i = 0; i < segs; i++) {
      var pos = i / (segs - 1) * (isLoop ? len : len - 1);
      var idx = Math.floor(pos);
      var w = pos - idx;
      var p0;
      var p1 = points[idx % len];
      var p2;
      var p3;

      if (!isLoop) {
        p0 = points[idx === 0 ? idx : idx - 1];
        p2 = points[idx > len - 2 ? len - 1 : idx + 1];
        p3 = points[idx > len - 3 ? len - 1 : idx + 2];
      } else {
        p0 = points[(idx - 1 + len) % len];
        p2 = points[(idx + 1) % len];
        p3 = points[(idx + 2) % len];
      }

      var w2 = w * w;
      var w3 = w * w2;
      ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
    }

    return ret;
  }

  var smoothSpline = _default$D;

  var v2Min = vector.min;
  var v2Max = vector.max;
  var v2Scale = vector.scale;
  var v2Distance$1 = vector.distance;
  var v2Add = vector.add;
  var v2Clone = vector.clone;
  var v2Sub = vector.sub;

  /**
   * è´å¡å°å¹³æ»æ²çº¿
   * @module zrender/shape/util/smoothBezier
   * @author pissang (https://www.github.com/pissang)
   *         Kener (@Kener-æå³°, kener.linfeng@gmail.com)
   *         errorrik (errorrik@gmail.com)
   */

  /**
   * è´å¡å°å¹³æ»æ²çº¿
   * @alias module:zrender/shape/util/smoothBezier
   * @param {Array} points çº¿æ®µé¡¶ç¹æ°ç»
   * @param {number} smooth å¹³æ»ç­çº§, 0-1
   * @param {boolean} isLoop
   * @param {Array} constraint å°è®¡ç®åºæ¥çæ§å¶ç¹çº¦æå¨ä¸ä¸ªåå´çå
   *                           æ¯å¦ [[0, 0], [100, 100]], è¿ä¸ªåå´çä¼ä¸
   *                           æ´ä¸ªæçº¿çåå´çåä¸ä¸ªå¹¶éç¨æ¥çº¦ææ§å¶ç¹ã
   * @param {Array} è®¡ç®åºæ¥çæ§å¶ç¹æ°ç»
   */
  function _default$E(points, smooth, isLoop, constraint) {
    var cps = [];
    var v = [];
    var v1 = [];
    var v2 = [];
    var prevPoint;
    var nextPoint;
    var min;
    var max;

    if (constraint) {
      min = [Infinity, Infinity];
      max = [-Infinity, -Infinity];

      for (var i = 0, len = points.length; i < len; i++) {
        v2Min(min, min, points[i]);
        v2Max(max, max, points[i]);
      } // ä¸æå®çåå´çåå¹¶é


      v2Min(min, min, constraint[0]);
      v2Max(max, max, constraint[1]);
    }

    for (var i = 0, len = points.length; i < len; i++) {
      var point = points[i];

      if (isLoop) {
        prevPoint = points[i ? i - 1 : len - 1];
        nextPoint = points[(i + 1) % len];
      } else {
        if (i === 0 || i === len - 1) {
          cps.push(v2Clone(points[i]));
          continue;
        } else {
          prevPoint = points[i - 1];
          nextPoint = points[i + 1];
        }
      }

      v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length

      v2Scale(v, v, smooth);
      var d0 = v2Distance$1(point, prevPoint);
      var d1 = v2Distance$1(point, nextPoint);
      var sum = d0 + d1;

      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }

      v2Scale(v1, v, -d0);
      v2Scale(v2, v, d1);
      var cp0 = v2Add([], point, v1);
      var cp1 = v2Add([], point, v2);

      if (constraint) {
        v2Max(cp0, cp0, min);
        v2Min(cp0, cp0, max);
        v2Max(cp1, cp1, min);
        v2Min(cp1, cp1, max);
      }

      cps.push(cp0);
      cps.push(cp1);
    }

    if (isLoop) {
      cps.push(cps.shift());
    }

    return cps;
  }

  var smoothBezier = _default$E;

  function buildPath$1(ctx, shape, closePath) {
    var points = shape.points;
    var smooth = shape.smooth;

    if (points && points.length >= 2) {
      if (smooth && smooth !== 'spline') {
        var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
        ctx.moveTo(points[0][0], points[0][1]);
        var len = points.length;

        for (var i = 0; i < (closePath ? len : len - 1); i++) {
          var cp1 = controlPoints[i * 2];
          var cp2 = controlPoints[i * 2 + 1];
          var p = points[(i + 1) % len];
          ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
        }
      } else {
        if (smooth === 'spline') {
          points = smoothSpline(points, closePath);
        }

        ctx.moveTo(points[0][0], points[0][1]);

        for (var i = 1, l = points.length; i < l; i++) {
          ctx.lineTo(points[i][0], points[i][1]);
        }
      }

      closePath && ctx.closePath();
    }
  }

  var buildPath_1$1 = buildPath$1;

  var poly = {
  	buildPath: buildPath_1$1
  };

  /**
   * å¤è¾¹å½¢
   * @module zrender/shape/Polygon
   */
  var _default$F = Path_1.extend({
    type: 'polygon',
    shape: {
      points: null,
      smooth: false,
      smoothConstraint: null
    },
    buildPath: function (ctx, shape) {
      poly.buildPath(ctx, shape, true);
    }
  });

  var Polygon = _default$F;

  /**
   * @module zrender/graphic/shape/Polyline
   */
  var _default$G = Path_1.extend({
    type: 'polyline',
    shape: {
      points: null,
      smooth: false,
      smoothConstraint: null
    },
    style: {
      stroke: '#000',
      fill: null
    },
    buildPath: function (ctx, shape) {
      poly.buildPath(ctx, shape, false);
    }
  });

  var Polyline = _default$G;

  /**
   * Sub-pixel optimize for canvas rendering, prevent from blur
   * when rendering a thin vertical/horizontal line.
   */
  var round = Math.round;
  /**
   * Sub pixel optimize line for canvas
   *
   * @param {Object} outputShape The modification will be performed on `outputShape`.
   *                 `outputShape` and `inputShape` can be the same object.
   *                 `outputShape` object can be used repeatly, because all of
   *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.
   * @param {Object} [inputShape]
   * @param {number} [inputShape.x1]
   * @param {number} [inputShape.y1]
   * @param {number} [inputShape.x2]
   * @param {number} [inputShape.y2]
   * @param {Object} [style]
   * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.
   */

  function subPixelOptimizeLine(outputShape, inputShape, style) {
    if (!inputShape) {
      return;
    }

    var x1 = inputShape.x1;
    var x2 = inputShape.x2;
    var y1 = inputShape.y1;
    var y2 = inputShape.y2;
    outputShape.x1 = x1;
    outputShape.x2 = x2;
    outputShape.y1 = y1;
    outputShape.y2 = y2;
    var lineWidth = style && style.lineWidth;

    if (!lineWidth) {
      return;
    }

    if (round(x1 * 2) === round(x2 * 2)) {
      outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
    }

    if (round(y1 * 2) === round(y2 * 2)) {
      outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
    }
  }
  /**
   * Sub pixel optimize rect for canvas
   *
   * @param {Object} outputShape The modification will be performed on `outputShape`.
   *                 `outputShape` and `inputShape` can be the same object.
   *                 `outputShape` object can be used repeatly, because all of
   *                 the `x`, `y`, `width`, `height` will be assigned in this method.
   * @param {Object} [inputShape]
   * @param {number} [inputShape.x]
   * @param {number} [inputShape.y]
   * @param {number} [inputShape.width]
   * @param {number} [inputShape.height]
   * @param {Object} [style]
   * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.
   */


  function subPixelOptimizeRect(outputShape, inputShape, style) {
    if (!inputShape) {
      return;
    }

    var originX = inputShape.x;
    var originY = inputShape.y;
    var originWidth = inputShape.width;
    var originHeight = inputShape.height;
    outputShape.x = originX;
    outputShape.y = originY;
    outputShape.width = originWidth;
    outputShape.height = originHeight;
    var lineWidth = style && style.lineWidth;

    if (!lineWidth) {
      return;
    }

    outputShape.x = subPixelOptimize(originX, lineWidth, true);
    outputShape.y = subPixelOptimize(originY, lineWidth, true);
    outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
    outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
  }
  /**
   * Sub pixel optimize for canvas
   *
   * @param {number} position Coordinate, such as x, y
   * @param {number} lineWidth If `null`/`undefined`/`0`, do not optimize.
   * @param {boolean=} positiveOrNegative Default false (negative).
   * @return {number} Optimized position.
   */


  function subPixelOptimize(position, lineWidth, positiveOrNegative) {
    if (!lineWidth) {
      return position;
    } // Assure that (position + lineWidth / 2) is near integer edge,
    // otherwise line will be fuzzy in canvas.


    var doubledPosition = round(position * 2);
    return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
  }

  var subPixelOptimizeLine_1 = subPixelOptimizeLine;
  var subPixelOptimizeRect_1 = subPixelOptimizeRect;
  var subPixelOptimize_2 = subPixelOptimize;

  var subPixelOptimize_1 = {
  	subPixelOptimizeLine: subPixelOptimizeLine_1,
  	subPixelOptimizeRect: subPixelOptimizeRect_1,
  	subPixelOptimize: subPixelOptimize_2
  };

  var subPixelOptimizeRect$1 = subPixelOptimize_1.subPixelOptimizeRect;

  /**
   * ç©å½¢
   * @module zrender/graphic/shape/Rect
   */
  // Avoid create repeatly.
  var subPixelOptimizeOutputShape = {};

  var _default$H = Path_1.extend({
    type: 'rect',
    shape: {
      // å·¦ä¸ãå³ä¸ãå³ä¸ãå·¦ä¸è§çåå¾ä¾æ¬¡ä¸ºr1ãr2ãr3ãr4
      // rç¼©åä¸º1         ç¸å½äº [1, 1, 1, 1]
      // rç¼©åä¸º[1]       ç¸å½äº [1, 1, 1, 1]
      // rç¼©åä¸º[1, 2]    ç¸å½äº [1, 2, 1, 2]
      // rç¼©åä¸º[1, 2, 3] ç¸å½äº [1, 2, 3, 2]
      r: 0,
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function (ctx, shape) {
      var x;
      var y;
      var width;
      var height;

      if (this.subPixelOptimize) {
        subPixelOptimizeRect$1(subPixelOptimizeOutputShape, shape, this.style);
        x = subPixelOptimizeOutputShape.x;
        y = subPixelOptimizeOutputShape.y;
        width = subPixelOptimizeOutputShape.width;
        height = subPixelOptimizeOutputShape.height;
        subPixelOptimizeOutputShape.r = shape.r;
        shape = subPixelOptimizeOutputShape;
      } else {
        x = shape.x;
        y = shape.y;
        width = shape.width;
        height = shape.height;
      }

      if (!shape.r) {
        ctx.rect(x, y, width, height);
      } else {
        roundRect.buildPath(ctx, shape);
      }

      ctx.closePath();
      return;
    }
  });

  var Rect = _default$H;

  var subPixelOptimizeLine$1 = subPixelOptimize_1.subPixelOptimizeLine;

  /**
   * ç´çº¿
   * @module zrender/graphic/shape/Line
   */
  // Avoid create repeatly.
  var subPixelOptimizeOutputShape$1 = {};

  var _default$I = Path_1.extend({
    type: 'line',
    shape: {
      // Start point
      x1: 0,
      y1: 0,
      // End point
      x2: 0,
      y2: 0,
      percent: 1
    },
    style: {
      stroke: '#000',
      fill: null
    },
    buildPath: function (ctx, shape) {
      var x1;
      var y1;
      var x2;
      var y2;

      if (this.subPixelOptimize) {
        subPixelOptimizeLine$1(subPixelOptimizeOutputShape$1, shape, this.style);
        x1 = subPixelOptimizeOutputShape$1.x1;
        y1 = subPixelOptimizeOutputShape$1.y1;
        x2 = subPixelOptimizeOutputShape$1.x2;
        y2 = subPixelOptimizeOutputShape$1.y2;
      } else {
        x1 = shape.x1;
        y1 = shape.y1;
        x2 = shape.x2;
        y2 = shape.y2;
      }

      var percent = shape.percent;

      if (percent === 0) {
        return;
      }

      ctx.moveTo(x1, y1);

      if (percent < 1) {
        x2 = x1 * (1 - percent) + x2 * percent;
        y2 = y1 * (1 - percent) + y2 * percent;
      }

      ctx.lineTo(x2, y2);
    },

    /**
     * Get point at percent
     * @param  {number} percent
     * @return {Array.<number>}
     */
    pointAt: function (p) {
      var shape = this.shape;
      return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
    }
  });

  var Line = _default$I;

  var quadraticSubdivide$1 = curve.quadraticSubdivide;
  var cubicSubdivide$1 = curve.cubicSubdivide;
  var quadraticAt$1 = curve.quadraticAt;
  var cubicAt$1 = curve.cubicAt;
  var quadraticDerivativeAt$1 = curve.quadraticDerivativeAt;
  var cubicDerivativeAt$1 = curve.cubicDerivativeAt;

  /**
   * è´å¡å°æ²çº¿
   * @module zrender/shape/BezierCurve
   */
  var out = [];

  function someVectorAt(shape, t, isTangent) {
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;

    if (cpx2 === null || cpy2 === null) {
      return [(isTangent ? cubicDerivativeAt$1 : cubicAt$1)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt$1 : cubicAt$1)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
    } else {
      return [(isTangent ? quadraticDerivativeAt$1 : quadraticAt$1)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt$1 : quadraticAt$1)(shape.y1, shape.cpy1, shape.y2, t)];
    }
  }

  var _default$J = Path_1.extend({
    type: 'bezier-curve',
    shape: {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      cpx1: 0,
      cpy1: 0,
      // cpx2: 0,
      // cpy2: 0
      // Curve show percent, for animating
      percent: 1
    },
    style: {
      stroke: '#000',
      fill: null
    },
    buildPath: function (ctx, shape) {
      var x1 = shape.x1;
      var y1 = shape.y1;
      var x2 = shape.x2;
      var y2 = shape.y2;
      var cpx1 = shape.cpx1;
      var cpy1 = shape.cpy1;
      var cpx2 = shape.cpx2;
      var cpy2 = shape.cpy2;
      var percent = shape.percent;

      if (percent === 0) {
        return;
      }

      ctx.moveTo(x1, y1);

      if (cpx2 == null || cpy2 == null) {
        if (percent < 1) {
          quadraticSubdivide$1(x1, cpx1, x2, percent, out);
          cpx1 = out[1];
          x2 = out[2];
          quadraticSubdivide$1(y1, cpy1, y2, percent, out);
          cpy1 = out[1];
          y2 = out[2];
        }

        ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
      } else {
        if (percent < 1) {
          cubicSubdivide$1(x1, cpx1, cpx2, x2, percent, out);
          cpx1 = out[1];
          cpx2 = out[2];
          x2 = out[3];
          cubicSubdivide$1(y1, cpy1, cpy2, y2, percent, out);
          cpy1 = out[1];
          cpy2 = out[2];
          y2 = out[3];
        }

        ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
      }
    },

    /**
     * Get point at percent
     * @param  {number} t
     * @return {Array.<number>}
     */
    pointAt: function (t) {
      return someVectorAt(this.shape, t, false);
    },

    /**
     * Get tangent at percent
     * @param  {number} t
     * @return {Array.<number>}
     */
    tangentAt: function (t) {
      var p = someVectorAt(this.shape, t, true);
      return vector.normalize(p, p);
    }
  });

  var BezierCurve = _default$J;

  /**
   * åå¼§
   * @module zrender/graphic/shape/Arc
   */
  var _default$K = Path_1.extend({
    type: 'arc',
    shape: {
      cx: 0,
      cy: 0,
      r: 0,
      startAngle: 0,
      endAngle: Math.PI * 2,
      clockwise: true
    },
    style: {
      stroke: '#000',
      fill: null
    },
    buildPath: function (ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var r = Math.max(shape.r, 0);
      var startAngle = shape.startAngle;
      var endAngle = shape.endAngle;
      var clockwise = shape.clockwise;
      var unitX = Math.cos(startAngle);
      var unitY = Math.sin(startAngle);
      ctx.moveTo(unitX * r + x, unitY * r + y);
      ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    }
  });

  var Arc = _default$K;

  // CompoundPath to improve performance
  var _default$L = Path_1.extend({
    type: 'compound',
    shape: {
      paths: null
    },
    _updatePathDirty: function () {
      var dirtyPath = this.__dirtyPath;
      var paths = this.shape.paths;

      for (var i = 0; i < paths.length; i++) {
        // Mark as dirty if any subpath is dirty
        dirtyPath = dirtyPath || paths[i].__dirtyPath;
      }

      this.__dirtyPath = dirtyPath;
      this.__dirty = this.__dirty || dirtyPath;
    },
    beforeBrush: function () {
      this._updatePathDirty();

      var paths = this.shape.paths || [];
      var scale = this.getGlobalScale(); // Update path scale

      for (var i = 0; i < paths.length; i++) {
        if (!paths[i].path) {
          paths[i].createPathProxy();
        }

        paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);
      }
    },
    buildPath: function (ctx, shape) {
      var paths = shape.paths || [];

      for (var i = 0; i < paths.length; i++) {
        paths[i].buildPath(ctx, paths[i].shape, true);
      }
    },
    afterBrush: function () {
      var paths = this.shape.paths || [];

      for (var i = 0; i < paths.length; i++) {
        paths[i].__dirtyPath = false;
      }
    },
    getBoundingRect: function () {
      this._updatePathDirty();

      return Path_1.prototype.getBoundingRect.call(this);
    }
  });

  var CompoundPath = _default$L;

  /**
   * @param {Array.<Object>} colorStops
   */
  var Gradient = function (colorStops) {
    this.colorStops = colorStops || [];
  };

  Gradient.prototype = {
    constructor: Gradient,
    addColorStop: function (offset, color) {
      this.colorStops.push({
        offset: offset,
        color: color
      });
    }
  };
  var _default$M = Gradient;
  var Gradient_1 = _default$M;

  /**
   * x, y, x2, y2 are all percent from 0 to 1
   * @param {number} [x=0]
   * @param {number} [y=0]
   * @param {number} [x2=1]
   * @param {number} [y2=0]
   * @param {Array.<Object>} colorStops
   * @param {boolean} [globalCoord=false]
   */
  var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
    // Should do nothing more in this constructor. Because gradient can be
    // declard by `color: {type: 'linear', colorStops: ...}`, where
    // this constructor will not be called.
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
    this.x2 = x2 == null ? 1 : x2;
    this.y2 = y2 == null ? 0 : y2; // Can be cloned

    this.type = 'linear'; // If use global coord

    this.global = globalCoord || false;
    Gradient_1.call(this, colorStops);
  };

  LinearGradient.prototype = {
    constructor: LinearGradient
  };
  util.inherits(LinearGradient, Gradient_1);
  var _default$N = LinearGradient;
  var LinearGradient_1 = _default$N;

  /**
   * x, y, r are all percent from 0 to 1
   * @param {number} [x=0.5]
   * @param {number} [y=0.5]
   * @param {number} [r=0.5]
   * @param {Array.<Object>} [colorStops]
   * @param {boolean} [globalCoord=false]
   */
  var RadialGradient = function (x, y, r, colorStops, globalCoord) {
    // Should do nothing more in this constructor. Because gradient can be
    // declard by `color: {type: 'radial', colorStops: ...}`, where
    // this constructor will not be called.
    this.x = x == null ? 0.5 : x;
    this.y = y == null ? 0.5 : y;
    this.r = r == null ? 0.5 : r; // Can be cloned

    this.type = 'radial'; // If use global coord

    this.global = globalCoord || false;
    Gradient_1.call(this, colorStops);
  };

  RadialGradient.prototype = {
    constructor: RadialGradient
  };
  util.inherits(RadialGradient, Gradient_1);
  var _default$O = RadialGradient;
  var RadialGradient_1 = _default$O;

  var inherits$1 = util.inherits;





  /**
   * Displayable for incremental rendering. It will be rendered in a separate layer
   * IncrementalDisplay have two main methods. `clearDisplayables` and `addDisplayables`
   * addDisplayables will render the added displayables incremetally.
   *
   * It use a not clearFlag to tell the painter don't clear the layer if it's the first element.
   */
  // TODO Style override ?
  function IncrementalDisplayble(opts) {
    Displayable_1.call(this, opts);
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
    this.notClear = true;
  }

  IncrementalDisplayble.prototype.incremental = true;

  IncrementalDisplayble.prototype.clearDisplaybles = function () {
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
    this.dirty();
    this.notClear = false;
  };

  IncrementalDisplayble.prototype.addDisplayable = function (displayable, notPersistent) {
    if (notPersistent) {
      this._temporaryDisplayables.push(displayable);
    } else {
      this._displayables.push(displayable);
    }

    this.dirty();
  };

  IncrementalDisplayble.prototype.addDisplayables = function (displayables, notPersistent) {
    notPersistent = notPersistent || false;

    for (var i = 0; i < displayables.length; i++) {
      this.addDisplayable(displayables[i], notPersistent);
    }
  };

  IncrementalDisplayble.prototype.eachPendingDisplayable = function (cb) {
    for (var i = this._cursor; i < this._displayables.length; i++) {
      cb && cb(this._displayables[i]);
    }

    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      cb && cb(this._temporaryDisplayables[i]);
    }
  };

  IncrementalDisplayble.prototype.update = function () {
    this.updateTransform();

    for (var i = this._cursor; i < this._displayables.length; i++) {
      var displayable = this._displayables[i]; // PENDING

      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }

    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      var displayable = this._temporaryDisplayables[i]; // PENDING

      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
  };

  IncrementalDisplayble.prototype.brush = function (ctx, prevEl) {
    // Render persistant displayables.
    for (var i = this._cursor; i < this._displayables.length; i++) {
      var displayable = this._displayables[i];
      displayable.beforeBrush && displayable.beforeBrush(ctx);
      displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]);
      displayable.afterBrush && displayable.afterBrush(ctx);
    }

    this._cursor = i; // Render temporary displayables.

    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      var displayable = this._temporaryDisplayables[i];
      displayable.beforeBrush && displayable.beforeBrush(ctx);
      displayable.brush(ctx, i === 0 ? null : this._temporaryDisplayables[i - 1]);
      displayable.afterBrush && displayable.afterBrush(ctx);
    }

    this._temporaryDisplayables = [];
    this.notClear = true;
  };

  var m = [];

  IncrementalDisplayble.prototype.getBoundingRect = function () {
    if (!this._rect) {
      var rect = new BoundingRect_1(Infinity, Infinity, -Infinity, -Infinity);

      for (var i = 0; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        var childRect = displayable.getBoundingRect().clone();

        if (displayable.needLocalTransform()) {
          childRect.applyTransform(displayable.getLocalTransform(m));
        }

        rect.union(childRect);
      }

      this._rect = rect;
    }

    return this._rect;
  };

  IncrementalDisplayble.prototype.contain = function (x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();

    if (rect.contain(localPos[0], localPos[1])) {
      for (var i = 0; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];

        if (displayable.contain(x, y)) {
          return true;
        }
      }
    }

    return false;
  };

  inherits$1(IncrementalDisplayble, Displayable_1);
  var _default$P = IncrementalDisplayble;
  var IncrementalDisplayable = _default$P;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

















  var Image$2 = Image$1;



  var Group_1$1 = Group_1;



  var Text_1$1 = Text_1;



  var Circle_1 = Circle;



  var Sector_1 = Sector;



  var Ring_1 = Ring;



  var Polygon_1 = Polygon;



  var Polyline_1 = Polyline;



  var Rect_1 = Rect;



  var Line_1 = Line;



  var BezierCurve_1 = BezierCurve;



  var Arc_1 = Arc;



  var CompoundPath_1 = CompoundPath;



  var LinearGradient_1$1 = LinearGradient_1;



  var RadialGradient_1$1 = RadialGradient_1;



  var BoundingRect_1$1 = BoundingRect_1;



  var IncrementalDisplayable_1 = IncrementalDisplayable;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var mathMax$3 = Math.max;
  var mathMin$3 = Math.min;
  var EMPTY_OBJ = {};
  var Z2_EMPHASIS_LIFT = 1; // key: label model property nane, value: style property name.

  var CACHED_LABEL_STYLE_PROPERTIES = {
    color: 'textFill',
    textBorderColor: 'textStroke',
    textBorderWidth: 'textStrokeWidth'
  };
  var EMPHASIS = 'emphasis';
  var NORMAL = 'normal'; // Reserve 0 as default.

  var _highlightNextDigit = 1;
  var _highlightKeyMap = {};
  var _customShapeMap = {};
  /**
   * Extend shape with parameters
   */

  function extendShape(opts) {
    return Path_1.extend(opts);
  }
  /**
   * Extend path
   */


  function extendPath(pathData, opts) {
    return path$2.extendFromString(pathData, opts);
  }
  /**
   * Register a user defined shape.
   * The shape class can be fetched by `getShapeClass`
   * This method will overwrite the registered shapes, including
   * the registered built-in shapes, if using the same `name`.
   * The shape can be used in `custom series` and
   * `graphic component` by declaring `{type: name}`.
   *
   * @param {string} name
   * @param {Object} ShapeClass Can be generated by `extendShape`.
   */


  function registerShape(name, ShapeClass) {
    _customShapeMap[name] = ShapeClass;
  }
  /**
   * Find shape class registered by `registerShape`. Usually used in
   * fetching user defined shape.
   *
   * [Caution]:
   * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared
   * to use user registered shapes.
   * Because the built-in shape (see `getBuiltInShape`) will be registered by
   * `registerShape` by default. That enables users to get both built-in
   * shapes as well as the shapes belonging to themsleves. But users can overwrite
   * the built-in shapes by using names like 'circle', 'rect' via calling
   * `registerShape`. So the echarts inner featrues should not fetch shapes from here
   * in case that it is overwritten by users, except that some features, like
   * `custom series`, `graphic component`, do it deliberately.
   *
   * (2) In the features like `custom series`, `graphic component`, the user input
   * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic
   * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names
   * are reserved names, that is, if some user register a shape named `'image'`,
   * the shape will not be used. If we intending to add some more reserved names
   * in feature, that might bring break changes (disable some existing user shape
   * names). But that case probably rearly happen. So we dont make more mechanism
   * to resolve this issue here.
   *
   * @param {string} name
   * @return {Object} The shape class. If not found, return nothing.
   */


  function getShapeClass(name) {
    if (_customShapeMap.hasOwnProperty(name)) {
      return _customShapeMap[name];
    }
  }
  /**
   * Create a path element from path data string
   * @param {string} pathData
   * @param {Object} opts
   * @param {module:zrender/core/BoundingRect} rect
   * @param {string} [layout=cover] 'center' or 'cover'
   */


  function makePath(pathData, opts, rect, layout) {
    var path = path$2.createFromString(pathData, opts);

    if (rect) {
      if (layout === 'center') {
        rect = centerGraphic(rect, path.getBoundingRect());
      }

      resizePath(path, rect);
    }

    return path;
  }
  /**
   * Create a image element from image url
   * @param {string} imageUrl image url
   * @param {Object} opts options
   * @param {module:zrender/core/BoundingRect} rect constrain rect
   * @param {string} [layout=cover] 'center' or 'cover'
   */


  function makeImage(imageUrl, rect, layout) {
    var path = new Image$1({
      style: {
        image: imageUrl,
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      onload: function (img) {
        if (layout === 'center') {
          var boundingRect = {
            width: img.width,
            height: img.height
          };
          path.setStyle(centerGraphic(rect, boundingRect));
        }
      }
    });
    return path;
  }
  /**
   * Get position of centered element in bounding box.
   *
   * @param  {Object} rect         element local bounding box
   * @param  {Object} boundingRect constraint bounding box
   * @return {Object} element position containing x, y, width, and height
   */


  function centerGraphic(rect, boundingRect) {
    // Set rect to center, keep width / height ratio.
    var aspect = boundingRect.width / boundingRect.height;
    var width = rect.height * aspect;
    var height;

    if (width <= rect.width) {
      height = rect.height;
    } else {
      width = rect.width;
      height = width / aspect;
    }

    var cx = rect.x + rect.width / 2;
    var cy = rect.y + rect.height / 2;
    return {
      x: cx - width / 2,
      y: cy - height / 2,
      width: width,
      height: height
    };
  }

  var mergePath$1 = path$2.mergePath;
  /**
   * Resize a path to fit the rect
   * @param {module:zrender/graphic/Path} path
   * @param {Object} rect
   */

  function resizePath(path, rect) {
    if (!path.applyTransform) {
      return;
    }

    var pathRect = path.getBoundingRect();
    var m = pathRect.calculateTransform(rect);
    path.applyTransform(m);
  }
  /**
   * Sub pixel optimize line for canvas
   *
   * @param {Object} param
   * @param {Object} [param.shape]
   * @param {number} [param.shape.x1]
   * @param {number} [param.shape.y1]
   * @param {number} [param.shape.x2]
   * @param {number} [param.shape.y2]
   * @param {Object} [param.style]
   * @param {number} [param.style.lineWidth]
   * @return {Object} Modified param
   */


  function subPixelOptimizeLine$2(param) {
    subPixelOptimize_1.subPixelOptimizeLine(param.shape, param.shape, param.style);
    return param;
  }
  /**
   * Sub pixel optimize rect for canvas
   *
   * @param {Object} param
   * @param {Object} [param.shape]
   * @param {number} [param.shape.x]
   * @param {number} [param.shape.y]
   * @param {number} [param.shape.width]
   * @param {number} [param.shape.height]
   * @param {Object} [param.style]
   * @param {number} [param.style.lineWidth]
   * @return {Object} Modified param
   */


  function subPixelOptimizeRect$2(param) {
    subPixelOptimize_1.subPixelOptimizeRect(param.shape, param.shape, param.style);
    return param;
  }
  /**
   * Sub pixel optimize for canvas
   *
   * @param {number} position Coordinate, such as x, y
   * @param {number} lineWidth Should be nonnegative integer.
   * @param {boolean=} positiveOrNegative Default false (negative).
   * @return {number} Optimized position.
   */


  var subPixelOptimize$1 = subPixelOptimize_1.subPixelOptimize;

  function hasFillOrStroke(fillOrStroke) {
    return fillOrStroke != null && fillOrStroke !== 'none';
  } // Most lifted color are duplicated.


  var liftedColorMap = util.createHashMap();
  var liftedColorCount = 0;

  function liftColor(color$1) {
    if (typeof color$1 !== 'string') {
      return color$1;
    }

    var liftedColor = liftedColorMap.get(color$1);

    if (!liftedColor) {
      liftedColor = color.lift(color$1, -0.1);

      if (liftedColorCount < 10000) {
        liftedColorMap.set(color$1, liftedColor);
        liftedColorCount++;
      }
    }

    return liftedColor;
  }

  function cacheElementStl(el) {
    if (!el.__hoverStlDirty) {
      return;
    }

    el.__hoverStlDirty = false;
    var hoverStyle = el.__hoverStl;

    if (!hoverStyle) {
      el.__cachedNormalStl = el.__cachedNormalZ2 = null;
      return;
    }

    var normalStyle = el.__cachedNormalStl = {};
    el.__cachedNormalZ2 = el.z2;
    var elStyle = el.style;

    for (var name in hoverStyle) {
      // See comment in `singleEnterEmphasis`.
      if (hoverStyle[name] != null) {
        normalStyle[name] = elStyle[name];
      }
    } // Always cache fill and stroke to normalStyle for lifting color.


    normalStyle.fill = elStyle.fill;
    normalStyle.stroke = elStyle.stroke;
  }

  function singleEnterEmphasis(el) {
    var hoverStl = el.__hoverStl;

    if (!hoverStl || el.__highlighted) {
      return;
    }

    var zr = el.__zr;
    var useHoverLayer = el.useHoverLayer && zr && zr.painter.type === 'canvas';
    el.__highlighted = useHoverLayer ? 'layer' : 'plain';

    if (el.isGroup || !zr && el.useHoverLayer) {
      return;
    }

    var elTarget = el;
    var targetStyle = el.style;

    if (useHoverLayer) {
      elTarget = zr.addHover(el);
      targetStyle = elTarget.style;
    }

    rollbackDefaultTextStyle(targetStyle);

    if (!useHoverLayer) {
      cacheElementStl(elTarget);
    } // styles can be:
    // {
    //    label: {
    //        show: false,
    //        position: 'outside',
    //        fontSize: 18
    //    },
    //    emphasis: {
    //        label: {
    //            show: true
    //        }
    //    }
    // },
    // where properties of `emphasis` may not appear in `normal`. We previously use
    // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.
    // But consider rich text and setOption in merge mode, it is impossible to cover
    // all properties in merge. So we use merge mode when setting style here.
    // But we choose the merge strategy that only properties that is not `null/undefined`.
    // Because when making a textStyle (espacially rich text), it is not easy to distinguish
    // `hasOwnProperty` and `null/undefined` in code, so we trade them as the same for simplicity.
    // But this strategy brings a trouble that `null/undefined` can not be used to remove
    // style any more in `emphasis`. Users can both set properties directly on normal and
    // emphasis to avoid this issue, or we might support `'none'` for this case if required.


    targetStyle.extendFrom(hoverStl);
    setDefaultHoverFillStroke(targetStyle, hoverStl, 'fill');
    setDefaultHoverFillStroke(targetStyle, hoverStl, 'stroke');
    applyDefaultTextStyle(targetStyle);

    if (!useHoverLayer) {
      el.dirty(false);
      el.z2 += Z2_EMPHASIS_LIFT;
    }
  }

  function setDefaultHoverFillStroke(targetStyle, hoverStyle, prop) {
    if (!hasFillOrStroke(hoverStyle[prop]) && hasFillOrStroke(targetStyle[prop])) {
      targetStyle[prop] = liftColor(targetStyle[prop]);
    }
  }

  function singleEnterNormal(el) {
    var highlighted = el.__highlighted;

    if (!highlighted) {
      return;
    }

    el.__highlighted = false;

    if (el.isGroup) {
      return;
    }

    if (highlighted === 'layer') {
      el.__zr && el.__zr.removeHover(el);
    } else {
      var style = el.style;
      var normalStl = el.__cachedNormalStl;

      if (normalStl) {
        rollbackDefaultTextStyle(style);
        el.setStyle(normalStl);
        applyDefaultTextStyle(style);
      } // `__cachedNormalZ2` will not be reset if calling `setElementHoverStyle`
      // when `el` is on emphasis state. So here by comparing with 1, we try
      // hard to make the bug case rare.


      var normalZ2 = el.__cachedNormalZ2;

      if (normalZ2 != null && el.z2 - normalZ2 === Z2_EMPHASIS_LIFT) {
        el.z2 = normalZ2;
      }
    }
  }

  function traverseUpdate(el, updater, commonParam) {
    // If root is group, also enter updater for `highDownOnUpdate`.
    var fromState = NORMAL;
    var toState = NORMAL;
    var trigger; // See the rule of `highDownOnUpdate` on `graphic.setAsHighDownDispatcher`.

    el.__highlighted && (fromState = EMPHASIS, trigger = true);
    updater(el, commonParam);
    el.__highlighted && (toState = EMPHASIS, trigger = true);
    el.isGroup && el.traverse(function (child) {
      !child.isGroup && updater(child, commonParam);
    });
    trigger && el.__highDownOnUpdate && el.__highDownOnUpdate(fromState, toState);
  }
  /**
   * Set hover style (namely "emphasis style") of element, based on the current
   * style of the given `el`.
   * This method should be called after all of the normal styles have been adopted
   * to the `el`. See the reason on `setHoverStyle`.
   *
   * @param {module:zrender/Element} el Should not be `zrender/container/Group`.
   * @param {Object} [el.hoverStyle] Can be set on el or its descendants,
   *        e.g., `el.hoverStyle = ...; graphic.setHoverStyle(el); `.
   *        Often used when item group has a label element and it's hoverStyle is different.
   * @param {Object|boolean} [hoverStl] The specified hover style.
   *        If set as `false`, disable the hover style.
   *        Similarly, The `el.hoverStyle` can alse be set
   *        as `false` to disable the hover style.
   *        Otherwise, use the default hover style if not provided.
   */


  function setElementHoverStyle(el, hoverStl) {
    // For performance consideration, it might be better to make the "hover style" only the
    // difference properties from the "normal style", but not a entire copy of all styles.
    hoverStl = el.__hoverStl = hoverStl !== false && (el.hoverStyle || hoverStl || {});
    el.__hoverStlDirty = true; // FIXME
    // It is not completely right to save "normal"/"emphasis" flag on elements.
    // It probably should be saved on `data` of series. Consider the cases:
    // (1) A highlighted elements are moved out of the view port and re-enter
    // again by dataZoom.
    // (2) call `setOption` and replace elements totally when they are highlighted.

    if (el.__highlighted) {
      // Consider the case:
      // The styles of a highlighted `el` is being updated. The new "emphasis style"
      // should be adapted to the `el`. Notice here new "normal styles" should have
      // been set outside and the cached "normal style" is out of date.
      el.__cachedNormalStl = null; // Do not clear `__cachedNormalZ2` here, because setting `z2` is not a constraint
      // of this method. In most cases, `z2` is not set and hover style should be able
      // to rollback. Of course, that would bring bug, but only in a rare case, see
      // `doSingleLeaveHover` for details.

      singleEnterNormal(el);
      singleEnterEmphasis(el);
    }
  }

  function onElementMouseOver(e) {
    !shouldSilent(this, e) // "emphasis" event highlight has higher priority than mouse highlight.
    && !this.__highByOuter && traverseUpdate(this, singleEnterEmphasis);
  }

  function onElementMouseOut(e) {
    !shouldSilent(this, e) // "emphasis" event highlight has higher priority than mouse highlight.
    && !this.__highByOuter && traverseUpdate(this, singleEnterNormal);
  }

  function onElementEmphasisEvent(highlightDigit) {
    this.__highByOuter |= 1 << (highlightDigit || 0);
    traverseUpdate(this, singleEnterEmphasis);
  }

  function onElementNormalEvent(highlightDigit) {
    !(this.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdate(this, singleEnterNormal);
  }

  function shouldSilent(el, e) {
    return el.__highDownSilentOnTouch && e.zrByTouch;
  }
  /**
   * Set hover style (namely "emphasis style") of element,
   * based on the current style of the given `el`.
   *
   * (1)
   * **CONSTRAINTS** for this method:
   * <A> This method MUST be called after all of the normal styles having been adopted
   * to the `el`.
   * <B> The input `hoverStyle` (that is, "emphasis style") MUST be the subset of the
   * "normal style" having been set to the el.
   * <C> `color` MUST be one of the "normal styles" (because color might be lifted as
   * a default hover style).
   *
   * The reason: this method treat the current style of the `el` as the "normal style"
   * and cache them when enter/update the "emphasis style". Consider the case: the `el`
   * is in "emphasis" state and `setOption`/`dispatchAction` trigger the style updating
   * logic, where the el should shift from the original emphasis style to the new
   * "emphasis style" and should be able to "downplay" back to the new "normal style".
   *
   * Indeed, it is error-prone to make a interface has so many constraints, but I have
   * not found a better solution yet to fit the backward compatibility, performance and
   * the current programming style.
   *
   * (2)
   * Call the method for a "root" element once. Do not call it for each descendants.
   * If the descendants elemenets of a group has itself hover style different from the
   * root group, we can simply mount the style on `el.hoverStyle` for them, but should
   * not call this method for them.
   *
   * (3) These input parameters can be set directly on `el`:
   *
   * @param {module:zrender/Element} el
   * @param {Object} [el.hoverStyle] See `graphic.setElementHoverStyle`.
   * @param {boolean} [el.highDownSilentOnTouch=false] See `graphic.setAsHighDownDispatcher`.
   * @param {Function} [el.highDownOnUpdate] See `graphic.setAsHighDownDispatcher`.
   * @param {Object|boolean} [hoverStyle] See `graphic.setElementHoverStyle`.
   */


  function setHoverStyle(el, hoverStyle) {
    setAsHighDownDispatcher(el, true);
    traverseUpdate(el, setElementHoverStyle, hoverStyle);
  }
  /**
   * @param {module:zrender/Element} el
   * @param {Function} [el.highDownOnUpdate] Called when state updated.
   *        Since `setHoverStyle` has the constraint that it must be called after
   *        all of the normal style updated, `highDownOnUpdate` is not needed to
   *        trigger if both `fromState` and `toState` is 'normal', and needed to
   *        trigger if both `fromState` and `toState` is 'emphasis', which enables
   *        to sync outside style settings to "emphasis" state.
   *        @this {string} This dispatcher `el`.
   *        @param {string} fromState Can be "normal" or "emphasis".
   *               `fromState` might equal to `toState`,
   *               for example, when this method is called when `el` is
   *               on "emphasis" state.
   *        @param {string} toState Can be "normal" or "emphasis".
   *
   *        FIXME
   *        CAUTION: Do not expose `highDownOnUpdate` outside echarts.
   *        Because it is not a complete solution. The update
   *        listener should not have been mount in element,
   *        and the normal/emphasis state should not have
   *        mantained on elements.
   *
   * @param {boolean} [el.highDownSilentOnTouch=false]
   *        In touch device, mouseover event will be trigger on touchstart event
   *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
   *        conveniently use hoverStyle when tap on touch screen without additional
   *        code for compatibility.
   *        But if the chart/component has select feature, which usually also use
   *        hoverStyle, there might be conflict between 'select-highlight' and
   *        'hover-highlight' especially when roam is enabled (see geo for example).
   *        In this case, `highDownSilentOnTouch` should be used to disable
   *        hover-highlight on touch device.
   * @param {boolean} [asDispatcher=true] If `false`, do not set as "highDownDispatcher".
   */


  function setAsHighDownDispatcher(el, asDispatcher) {
    var disable = asDispatcher === false; // Make `highDownSilentOnTouch` and `highDownOnUpdate` only work after
    // `setAsHighDownDispatcher` called. Avoid it is modified by user unexpectedly.

    el.__highDownSilentOnTouch = el.highDownSilentOnTouch;
    el.__highDownOnUpdate = el.highDownOnUpdate; // Simple optimize, since this method might be
    // called for each elements of a group in some cases.

    if (!disable || el.__highDownDispatcher) {
      var method = disable ? 'off' : 'on'; // Duplicated function will be auto-ignored, see Eventful.js.

      el[method]('mouseover', onElementMouseOver)[method]('mouseout', onElementMouseOut); // Emphasis, normal can be triggered manually by API or other components like hover link.

      el[method]('emphasis', onElementEmphasisEvent)[method]('normal', onElementNormalEvent); // Also keep previous record.

      el.__highByOuter = el.__highByOuter || 0;
      el.__highDownDispatcher = !disable;
    }
  }
  /**
   * @param {module:zrender/src/Element} el
   * @return {boolean}
   */


  function isHighDownDispatcher(el) {
    return !!(el && el.__highDownDispatcher);
  }
  /**
   * Support hightlight/downplay record on each elements.
   * For the case: hover highlight/downplay (legend, visualMap, ...) and
   * user triggerred hightlight/downplay should not conflict.
   * Only all of the highlightDigit cleared, return to normal.
   * @param {string} highlightKey
   * @return {number} highlightDigit
   */


  function getHighlightDigit(highlightKey) {
    var highlightDigit = _highlightKeyMap[highlightKey];

    if (highlightDigit == null && _highlightNextDigit <= 32) {
      highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
    }

    return highlightDigit;
  }
  /**
   * See more info in `setTextStyleCommon`.
   * @param {Object|module:zrender/graphic/Style} normalStyle
   * @param {Object} emphasisStyle
   * @param {module:echarts/model/Model} normalModel
   * @param {module:echarts/model/Model} emphasisModel
   * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.
   * @param {string|Function} [opt.defaultText]
   * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by
   *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex, opt.labelProp)`
   * @param {number} [opt.labelDataIndex] Fetch text by
   *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex, opt.labelProp)`
   * @param {number} [opt.labelDimIndex] Fetch text by
   *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex, opt.labelProp)`
   * @param {string} [opt.labelProp] Fetch text by
   *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex, opt.labelProp)`
   * @param {Object} [normalSpecified]
   * @param {Object} [emphasisSpecified]
   */


  function setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {
    opt = opt || EMPTY_OBJ;
    var labelFetcher = opt.labelFetcher;
    var labelDataIndex = opt.labelDataIndex;
    var labelDimIndex = opt.labelDimIndex;
    var labelProp = opt.labelProp; // This scenario, `label.normal.show = true; label.emphasis.show = false`,
    // is not supported util someone requests.

    var showNormal = normalModel.getShallow('show');
    var showEmphasis = emphasisModel.getShallow('show'); // Consider performance, only fetch label when necessary.
    // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,
    // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.

    var baseText;

    if (showNormal || showEmphasis) {
      if (labelFetcher) {
        baseText = labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex, labelProp);
      }

      if (baseText == null) {
        baseText = util.isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt) : opt.defaultText;
      }
    }

    var normalStyleText = showNormal ? baseText : null;
    var emphasisStyleText = showEmphasis ? util.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex, labelProp) : null, baseText) : null; // Optimize: If style.text is null, text will not be drawn.

    if (normalStyleText != null || emphasisStyleText != null) {
      // Always set `textStyle` even if `normalStyle.text` is null, because default
      // values have to be set on `normalStyle`.
      // If we set default values on `emphasisStyle`, consider case:
      // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`
      // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`
      // Then the 'red' will not work on emphasis.
      setTextStyle(normalStyle, normalModel, normalSpecified, opt);
      setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);
    }

    normalStyle.text = normalStyleText;
    emphasisStyle.text = emphasisStyleText;
  }
  /**
   * Modify label style manually.
   * Only works after `setLabelStyle` and `setElementHoverStyle` called.
   *
   * @param {module:zrender/src/Element} el
   * @param {Object} [normalStyleProps] optional
   * @param {Object} [emphasisStyleProps] optional
   */


  function modifyLabelStyle(el, normalStyleProps, emphasisStyleProps) {
    var elStyle = el.style;

    if (normalStyleProps) {
      rollbackDefaultTextStyle(elStyle);
      el.setStyle(normalStyleProps);
      applyDefaultTextStyle(elStyle);
    }

    elStyle = el.__hoverStl;

    if (emphasisStyleProps && elStyle) {
      rollbackDefaultTextStyle(elStyle);
      util.extend(elStyle, emphasisStyleProps);
      applyDefaultTextStyle(elStyle);
    }
  }
  /**
   * Set basic textStyle properties.
   * See more info in `setTextStyleCommon`.
   * @param {Object|module:zrender/graphic/Style} textStyle
   * @param {module:echarts/model/Model} model
   * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.
   * @param {Object} [opt] See `opt` of `setTextStyleCommon`.
   * @param {boolean} [isEmphasis]
   */


  function setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {
    setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);
    specifiedTextStyle && util.extend(textStyle, specifiedTextStyle); // textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);

    return textStyle;
  }
  /**
   * Set text option in the style.
   * See more info in `setTextStyleCommon`.
   * @deprecated
   * @param {Object} textStyle
   * @param {module:echarts/model/Model} labelModel
   * @param {string|boolean} defaultColor Default text color.
   *        If set as false, it will be processed as a emphasis style.
   */


  function setText(textStyle, labelModel, defaultColor) {
    var opt = {
      isRectText: true
    };
    var isEmphasis;

    if (defaultColor === false) {
      isEmphasis = true;
    } else {
      // Support setting color as 'auto' to get visual color.
      opt.autoColor = defaultColor;
    }

    setTextStyleCommon(textStyle, labelModel, opt, isEmphasis); // textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);
  }
  /**
   * The uniform entry of set text style, that is, retrieve style definitions
   * from `model` and set to `textStyle` object.
   *
   * Never in merge mode, but in overwrite mode, that is, all of the text style
   * properties will be set. (Consider the states of normal and emphasis and
   * default value can be adopted, merge would make the logic too complicated
   * to manage.)
   *
   * The `textStyle` object can either be a plain object or an instance of
   * `zrender/src/graphic/Style`, and either be the style of normal or emphasis.
   * After this mothod called, the `textStyle` object can then be used in
   * `el.setStyle(textStyle)` or `el.hoverStyle = textStyle`.
   *
   * Default value will be adopted and `insideRollbackOpt` will be created.
   * See `applyDefaultTextStyle` `rollbackDefaultTextStyle` for more details.
   *
   * opt: {
   *      disableBox: boolean, Whether diable drawing box of block (outer most).
   *      isRectText: boolean,
   *      autoColor: string, specify a color when color is 'auto',
   *              for textFill, textStroke, textBackgroundColor, and textBorderColor.
   *              If autoColor specified, it is used as default textFill.
   *      useInsideStyle:
   *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)
   *                  if `textFill` is not specified.
   *              `false`: Do not use inside style.
   *              `null/undefined`: use inside style if `isRectText` is true and
   *                  `textFill` is not specified and textPosition contains `'inside'`.
   *      forceRich: boolean
   * }
   */


  function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {
    // Consider there will be abnormal when merge hover style to normal style if given default value.
    opt = opt || EMPTY_OBJ;

    if (opt.isRectText) {
      var textPosition;

      if (opt.getTextPosition) {
        textPosition = opt.getTextPosition(textStyleModel, isEmphasis);
      } else {
        textPosition = textStyleModel.getShallow('position') || (isEmphasis ? null : 'inside'); // 'outside' is not a valid zr textPostion value, but used
        // in bar series, and magric type should be considered.

        textPosition === 'outside' && (textPosition = 'top');
      }

      textStyle.textPosition = textPosition;
      textStyle.textOffset = textStyleModel.getShallow('offset');
      var labelRotate = textStyleModel.getShallow('rotate');
      labelRotate != null && (labelRotate *= Math.PI / 180);
      textStyle.textRotation = labelRotate;
      textStyle.textDistance = util.retrieve2(textStyleModel.getShallow('distance'), isEmphasis ? null : 5);
    }

    var ecModel = textStyleModel.ecModel;
    var globalTextStyle = ecModel && ecModel.option.textStyle; // Consider case:
    // {
    //     data: [{
    //         value: 12,
    //         label: {
    //             rich: {
    //                 // no 'a' here but using parent 'a'.
    //             }
    //         }
    //     }],
    //     rich: {
    //         a: { ... }
    //     }
    // }

    var richItemNames = getRichItemNames(textStyleModel);
    var richResult;

    if (richItemNames) {
      richResult = {};

      for (var name in richItemNames) {
        if (richItemNames.hasOwnProperty(name)) {
          // Cascade is supported in rich.
          var richTextStyle = textStyleModel.getModel(['rich', name]); // In rich, never `disableBox`.
          // FIXME: consider `label: {formatter: '{a|xx}', color: 'blue', rich: {a: {}}}`,
          // the default color `'blue'` will not be adopted if no color declared in `rich`.
          // That might confuses users. So probably we should put `textStyleModel` as the
          // root ancestor of the `richTextStyle`. But that would be a break change.

          setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);
        }
      }
    }

    textStyle.rich = richResult;
    setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);

    if (opt.forceRich && !opt.textStyle) {
      opt.textStyle = {};
    }

    return textStyle;
  } // Consider case:
  // {
  //     data: [{
  //         value: 12,
  //         label: {
  //             rich: {
  //                 // no 'a' here but using parent 'a'.
  //             }
  //         }
  //     }],
  //     rich: {
  //         a: { ... }
  //     }
  // }


  function getRichItemNames(textStyleModel) {
    // Use object to remove duplicated names.
    var richItemNameMap;

    while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
      var rich = (textStyleModel.option || EMPTY_OBJ).rich;

      if (rich) {
        richItemNameMap = richItemNameMap || {};

        for (var name in rich) {
          if (rich.hasOwnProperty(name)) {
            richItemNameMap[name] = 1;
          }
        }
      }

      textStyleModel = textStyleModel.parentModel;
    }

    return richItemNameMap;
  }

  function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {
    // In merge mode, default value should not be given.
    globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;
    textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt) || globalTextStyle.color;
    textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt) || globalTextStyle.textBorderColor;
    textStyle.textStrokeWidth = util.retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);

    if (!isEmphasis) {
      if (isBlock) {
        textStyle.insideRollbackOpt = opt;
        applyDefaultTextStyle(textStyle);
      } // Set default finally.


      if (textStyle.textFill == null) {
        textStyle.textFill = opt.autoColor;
      }
    } // Do not use `getFont` here, because merge should be supported, where
    // part of these properties may be changed in emphasis style, and the
    // others should remain their original value got from normal style.


    textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;
    textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;
    textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;
    textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;
    textStyle.textAlign = textStyleModel.getShallow('align');
    textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign') || textStyleModel.getShallow('baseline');
    textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');
    textStyle.textWidth = textStyleModel.getShallow('width');
    textStyle.textHeight = textStyleModel.getShallow('height');
    textStyle.textTag = textStyleModel.getShallow('tag');

    if (!isBlock || !opt.disableBox) {
      textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);
      textStyle.textPadding = textStyleModel.getShallow('padding');
      textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);
      textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');
      textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');
      textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');
      textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');
      textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');
      textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');
    }

    textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor') || globalTextStyle.textShadowColor;
    textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur') || globalTextStyle.textShadowBlur;
    textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX') || globalTextStyle.textShadowOffsetX;
    textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY') || globalTextStyle.textShadowOffsetY;
  }

  function getAutoColor(color, opt) {
    return color !== 'auto' ? color : opt && opt.autoColor ? opt.autoColor : null;
  }
  /**
   * Give some default value to the input `textStyle` object, based on the current settings
   * in this `textStyle` object.
   *
   * The Scenario:
   * when text position is `inside` and `textFill` is not specified, we show
   * text border by default for better view. But it should be considered that text position
   * might be changed when hovering or being emphasis, where the `insideRollback` is used to
   * restore the style.
   *
   * Usage (& NOTICE):
   * When a style object (eithor plain object or instance of `zrender/src/graphic/Style`) is
   * about to be modified on its text related properties, `rollbackDefaultTextStyle` should
   * be called before the modification and `applyDefaultTextStyle` should be called after that.
   * (For the case that all of the text related properties is reset, like `setTextStyleCommon`
   * does, `rollbackDefaultTextStyle` is not needed to be called).
   */


  function applyDefaultTextStyle(textStyle) {
    var textPosition = textStyle.textPosition;
    var opt = textStyle.insideRollbackOpt;
    var insideRollback;

    if (opt && textStyle.textFill == null) {
      var autoColor = opt.autoColor;
      var isRectText = opt.isRectText;
      var useInsideStyle = opt.useInsideStyle;
      var useInsideStyleCache = useInsideStyle !== false && (useInsideStyle === true || isRectText && textPosition // textPosition can be [10, 30]
      && typeof textPosition === 'string' && textPosition.indexOf('inside') >= 0);
      var useAutoColorCache = !useInsideStyleCache && autoColor != null; // All of the props declared in `CACHED_LABEL_STYLE_PROPERTIES` are to be cached.

      if (useInsideStyleCache || useAutoColorCache) {
        insideRollback = {
          textFill: textStyle.textFill,
          textStroke: textStyle.textStroke,
          textStrokeWidth: textStyle.textStrokeWidth
        };
      }

      if (useInsideStyleCache) {
        textStyle.textFill = '#fff'; // Consider text with #fff overflow its container.

        if (textStyle.textStroke == null) {
          textStyle.textStroke = autoColor;
          textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);
        }
      }

      if (useAutoColorCache) {
        textStyle.textFill = autoColor;
      }
    } // Always set `insideRollback`, so that the previous one can be cleared.


    textStyle.insideRollback = insideRollback;
  }
  /**
   * Consider the case: in a scatter,
   * label: {
   *     normal: {position: 'inside'},
   *     emphasis: {position: 'top'}
   * }
   * In the normal state, the `textFill` will be set as '#fff' for pretty view (see
   * `applyDefaultTextStyle`), but when switching to emphasis state, the `textFill`
   * should be retured to 'autoColor', but not keep '#fff'.
   */


  function rollbackDefaultTextStyle(style) {
    var insideRollback = style.insideRollback;

    if (insideRollback) {
      // Reset all of the props in `CACHED_LABEL_STYLE_PROPERTIES`.
      style.textFill = insideRollback.textFill;
      style.textStroke = insideRollback.textStroke;
      style.textStrokeWidth = insideRollback.textStrokeWidth;
      style.insideRollback = null;
    }
  }

  function getFont(opt, ecModel) {
    var gTextStyleModel = ecModel && ecModel.getModel('textStyle');
    return util.trim([// FIXME in node-canvas fontWeight is before fontStyle
    opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' '));
  }

  function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
    if (typeof dataIndex === 'function') {
      cb = dataIndex;
      dataIndex = null;
    } // Do not check 'animation' property directly here. Consider this case:
    // animation model is an `itemModel`, whose does not have `isAnimationEnabled`
    // but its parent model (`seriesModel`) does.


    var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();

    if (animationEnabled) {
      var postfix = isUpdate ? 'Update' : '';
      var duration = animatableModel.getShallow('animationDuration' + postfix);
      var animationEasing = animatableModel.getShallow('animationEasing' + postfix);
      var animationDelay = animatableModel.getShallow('animationDelay' + postfix);

      if (typeof animationDelay === 'function') {
        animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
      }

      if (typeof duration === 'function') {
        duration = duration(dataIndex);
      }

      duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());
    } else {
      el.stopAnimation();
      el.attr(props);
      cb && cb();
    }
  }
  /**
   * Update graphic element properties with or without animation according to the
   * configuration in series.
   *
   * Caution: this method will stop previous animation.
   * So do not use this method to one element twice before
   * animation starts, unless you know what you are doing.
   *
   * @param {module:zrender/Element} el
   * @param {Object} props
   * @param {module:echarts/model/Model} [animatableModel]
   * @param {number} [dataIndex]
   * @param {Function} [cb]
   * @example
   *     graphic.updateProps(el, {
   *         position: [100, 100]
   *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
   *     // Or
   *     graphic.updateProps(el, {
   *         position: [100, 100]
   *     }, seriesModel, function () { console.log('Animation done!'); });
   */


  function updateProps(el, props, animatableModel, dataIndex, cb) {
    animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
  }
  /**
   * Init graphic element properties with or without animation according to the
   * configuration in series.
   *
   * Caution: this method will stop previous animation.
   * So do not use this method to one element twice before
   * animation starts, unless you know what you are doing.
   *
   * @param {module:zrender/Element} el
   * @param {Object} props
   * @param {module:echarts/model/Model} [animatableModel]
   * @param {number} [dataIndex]
   * @param {Function} cb
   */


  function initProps(el, props, animatableModel, dataIndex, cb) {
    animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
  }
  /**
   * Get transform matrix of target (param target),
   * in coordinate of its ancestor (param ancestor)
   *
   * @param {module:zrender/mixin/Transformable} target
   * @param {module:zrender/mixin/Transformable} [ancestor]
   */


  function getTransform(target, ancestor) {
    var mat = matrix.identity([]);

    while (target && target !== ancestor) {
      matrix.mul(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }

    return mat;
  }
  /**
   * Apply transform to an vertex.
   * @param {Array.<number>} target [x, y]
   * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:
   *      + Transform matrix: like [1, 0, 0, 1, 0, 0]
   *      + {position, rotation, scale}, the same as `zrender/Transformable`.
   * @param {boolean=} invert Whether use invert matrix.
   * @return {Array.<number>} [x, y]
   */


  function applyTransform$1(target, transform, invert) {
    if (transform && !util.isArrayLike(transform)) {
      transform = Transformable_1.getLocalTransform(transform);
    }

    if (invert) {
      transform = matrix.invert([], transform);
    }

    return vector.applyTransform([], target, transform);
  }
  /**
   * @param {string} direction 'left' 'right' 'top' 'bottom'
   * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
   * @param {boolean=} invert Whether use invert matrix.
   * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
   */


  function transformDirection(direction, transform, invert) {
    // Pick a base, ensure that transform result will not be (0, 0).
    var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
    var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
    var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];
    vertex = applyTransform$1(vertex, transform, invert);
    return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';
  }
  /**
   * Apply group transition animation from g1 to g2.
   * If no animatableModel, no animation.
   */


  function groupTransition(g1, g2, animatableModel, cb) {
    if (!g1 || !g2) {
      return;
    }

    function getElMap(g) {
      var elMap = {};
      g.traverse(function (el) {
        if (!el.isGroup && el.anid) {
          elMap[el.anid] = el;
        }
      });
      return elMap;
    }

    function getAnimatableProps(el) {
      var obj = {
        position: vector.clone(el.position),
        rotation: el.rotation
      };

      if (el.shape) {
        obj.shape = util.extend({}, el.shape);
      }

      return obj;
    }

    var elMap1 = getElMap(g1);
    g2.traverse(function (el) {
      if (!el.isGroup && el.anid) {
        var oldEl = elMap1[el.anid];

        if (oldEl) {
          var newProp = getAnimatableProps(el);
          el.attr(getAnimatableProps(oldEl));
          updateProps(el, newProp, animatableModel, el.dataIndex);
        } // else {
        //     if (el.previousProps) {
        //         graphic.updateProps
        //     }
        // }

      }
    });
  }
  /**
   * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]
   * @param {Object} rect {x, y, width, height}
   * @return {Array.<Array.<number>>} A new clipped points.
   */


  function clipPointsByRect(points, rect) {
    // FIXME: this way migth be incorrect when grpahic clipped by a corner.
    // and when element have border.
    return util.map(points, function (point) {
      var x = point[0];
      x = mathMax$3(x, rect.x);
      x = mathMin$3(x, rect.x + rect.width);
      var y = point[1];
      y = mathMax$3(y, rect.y);
      y = mathMin$3(y, rect.y + rect.height);
      return [x, y];
    });
  }
  /**
   * @param {Object} targetRect {x, y, width, height}
   * @param {Object} rect {x, y, width, height}
   * @return {Object} A new clipped rect. If rect size are negative, return undefined.
   */


  function clipRectByRect(targetRect, rect) {
    var x = mathMax$3(targetRect.x, rect.x);
    var x2 = mathMin$3(targetRect.x + targetRect.width, rect.x + rect.width);
    var y = mathMax$3(targetRect.y, rect.y);
    var y2 = mathMin$3(targetRect.y + targetRect.height, rect.y + rect.height); // If the total rect is cliped, nothing, including the border,
    // should be painted. So return undefined.

    if (x2 >= x && y2 >= y) {
      return {
        x: x,
        y: y,
        width: x2 - x,
        height: y2 - y
      };
    }
  }
  /**
   * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.
   * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.
   * @param {Object} [rect] {x, y, width, height}
   * @return {module:zrender/Element} Icon path or image element.
   */


  function createIcon(iconStr, opt, rect) {
    opt = util.extend({
      rectHover: true
    }, opt);
    var style = opt.style = {
      strokeNoScale: true
    };
    rect = rect || {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    };

    if (iconStr) {
      return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), util.defaults(style, rect), new Image$1(opt)) : makePath(iconStr.replace('path://', ''), opt, rect, 'center');
    }
  }
  /**
   * Return `true` if the given line (line `a`) and the given polygon
   * are intersect.
   * Note that we do not count colinear as intersect here because no
   * requirement for that. We could do that if required in future.
   *
   * @param {number} a1x
   * @param {number} a1y
   * @param {number} a2x
   * @param {number} a2y
   * @param {Array.<Array.<number>>} points Points of the polygon.
   * @return {boolean}
   */


  function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {
    for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {
      var p = points[i];

      if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
        return true;
      }

      p2 = p;
    }
  }
  /**
   * Return `true` if the given two lines (line `a` and line `b`)
   * are intersect.
   * Note that we do not count colinear as intersect here because no
   * requirement for that. We could do that if required in future.
   *
   * @param {number} a1x
   * @param {number} a1y
   * @param {number} a2x
   * @param {number} a2y
   * @param {number} b1x
   * @param {number} b1y
   * @param {number} b2x
   * @param {number} b2y
   * @return {boolean}
   */


  function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.
    var mx = a2x - a1x;
    var my = a2y - a1y;
    var nx = b2x - b1x;
    var ny = b2y - b1y; // `vec_m` and `vec_n` are parallel iff
    //     exising `k` such that `vec_m = k Â· vec_n`, equivalent to `vec_m X vec_n = 0`.

    var nmCrossProduct = crossProduct2d(nx, ny, mx, my);

    if (nearZero(nmCrossProduct)) {
      return false;
    } // `vec_m` and `vec_n` are intersect iff
    //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,
    //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`
    //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.


    var b1a1x = a1x - b1x;
    var b1a1y = a1y - b1y;
    var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;

    if (q < 0 || q > 1) {
      return false;
    }

    var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;

    if (p < 0 || p > 1) {
      return false;
    }

    return true;
  }
  /**
   * Cross product of 2-dimension vector.
   */


  function crossProduct2d(x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1;
  }

  function nearZero(val) {
    return val <= 1e-6 && val >= -1e-6;
  } // Register built-in shapes. These shapes might be overwirtten
  // by users, although we do not recommend that.


  registerShape('circle', Circle);
  registerShape('sector', Sector);
  registerShape('ring', Ring);
  registerShape('polygon', Polygon);
  registerShape('polyline', Polyline);
  registerShape('rect', Rect);
  registerShape('line', Line);
  registerShape('bezierCurve', BezierCurve);
  registerShape('arc', Arc);
  var Z2_EMPHASIS_LIFT_1 = Z2_EMPHASIS_LIFT;
  var CACHED_LABEL_STYLE_PROPERTIES_1 = CACHED_LABEL_STYLE_PROPERTIES;
  var extendShape_1 = extendShape;
  var extendPath_1 = extendPath;
  var registerShape_1 = registerShape;
  var getShapeClass_1 = getShapeClass;
  var makePath_1 = makePath;
  var makeImage_1 = makeImage;
  var mergePath_1$1 = mergePath$1;
  var resizePath_1 = resizePath;
  var subPixelOptimizeLine_1$1 = subPixelOptimizeLine$2;
  var subPixelOptimizeRect_1$1 = subPixelOptimizeRect$2;
  var subPixelOptimize_1$1 = subPixelOptimize$1;
  var setElementHoverStyle_1 = setElementHoverStyle;
  var setHoverStyle_1 = setHoverStyle;
  var setAsHighDownDispatcher_1 = setAsHighDownDispatcher;
  var isHighDownDispatcher_1 = isHighDownDispatcher;
  var getHighlightDigit_1 = getHighlightDigit;
  var setLabelStyle_1 = setLabelStyle;
  var modifyLabelStyle_1 = modifyLabelStyle;
  var setTextStyle_1 = setTextStyle;
  var setText_1 = setText;
  var getFont_1 = getFont;
  var updateProps_1 = updateProps;
  var initProps_1 = initProps;
  var getTransform_1 = getTransform;
  var applyTransform_1$1 = applyTransform$1;
  var transformDirection_1 = transformDirection;
  var groupTransition_1 = groupTransition;
  var clipPointsByRect_1 = clipPointsByRect;
  var clipRectByRect_1 = clipRectByRect;
  var createIcon_1 = createIcon;
  var linePolygonIntersect_1 = linePolygonIntersect;
  var lineLineIntersect_1 = lineLineIntersect;

  var graphic = {
  	Image: Image$2,
  	Group: Group_1$1,
  	Text: Text_1$1,
  	Circle: Circle_1,
  	Sector: Sector_1,
  	Ring: Ring_1,
  	Polygon: Polygon_1,
  	Polyline: Polyline_1,
  	Rect: Rect_1,
  	Line: Line_1,
  	BezierCurve: BezierCurve_1,
  	Arc: Arc_1,
  	CompoundPath: CompoundPath_1,
  	LinearGradient: LinearGradient_1$1,
  	RadialGradient: RadialGradient_1$1,
  	BoundingRect: BoundingRect_1$1,
  	IncrementalDisplayable: IncrementalDisplayable_1,
  	Z2_EMPHASIS_LIFT: Z2_EMPHASIS_LIFT_1,
  	CACHED_LABEL_STYLE_PROPERTIES: CACHED_LABEL_STYLE_PROPERTIES_1,
  	extendShape: extendShape_1,
  	extendPath: extendPath_1,
  	registerShape: registerShape_1,
  	getShapeClass: getShapeClass_1,
  	makePath: makePath_1,
  	makeImage: makeImage_1,
  	mergePath: mergePath_1$1,
  	resizePath: resizePath_1,
  	subPixelOptimizeLine: subPixelOptimizeLine_1$1,
  	subPixelOptimizeRect: subPixelOptimizeRect_1$1,
  	subPixelOptimize: subPixelOptimize_1$1,
  	setElementHoverStyle: setElementHoverStyle_1,
  	setHoverStyle: setHoverStyle_1,
  	setAsHighDownDispatcher: setAsHighDownDispatcher_1,
  	isHighDownDispatcher: isHighDownDispatcher_1,
  	getHighlightDigit: getHighlightDigit_1,
  	setLabelStyle: setLabelStyle_1,
  	modifyLabelStyle: modifyLabelStyle_1,
  	setTextStyle: setTextStyle_1,
  	setText: setText_1,
  	getFont: getFont_1,
  	updateProps: updateProps_1,
  	initProps: initProps_1,
  	getTransform: getTransform_1,
  	applyTransform: applyTransform_1$1,
  	transformDirection: transformDirection_1,
  	groupTransition: groupTransition_1,
  	clipPointsByRect: clipPointsByRect_1,
  	clipRectByRect: clipRectByRect_1,
  	createIcon: createIcon_1,
  	linePolygonIntersect: linePolygonIntersect_1,
  	lineLineIntersect: lineLineIntersect_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var PATH_COLOR = ['textStyle', 'color'];
  var _default$Q = {
    /**
     * Get color property or get color from option.textStyle.color
     * @param {boolean} [isEmphasis]
     * @return {string}
     */
    getTextColor: function (isEmphasis) {
      var ecModel = this.ecModel;
      return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
    },

    /**
     * Create font string from fontStyle, fontWeight, fontSize, fontFamily
     * @return {string}
     */
    getFont: function () {
      return graphic.getFont({
        fontStyle: this.getShallow('fontStyle'),
        fontWeight: this.getShallow('fontWeight'),
        fontSize: this.getShallow('fontSize'),
        fontFamily: this.getShallow('fontFamily')
      }, this.ecModel);
    },
    getTextRect: function (text$1) {
      return text.getBoundingRect(text$1, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('lineHeight'), this.getShallow('rich'), this.getShallow('truncateText'));
    }
  };
  var textStyle = _default$Q;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var getItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]);
  var _default$R = {
    getItemStyle: function (excludes, includes) {
      var style = getItemStyle(this, excludes, includes);
      var lineDash = this.getBorderLineDash();
      lineDash && (style.lineDash = lineDash);
      return style;
    },
    getBorderLineDash: function () {
      var lineType = this.get('borderType');
      return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [5, 5] : [1, 1];
    }
  };
  var itemStyle = _default$R;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  var makeInner$1 = model.makeInner;



  var enableClassExtend$1 = clazz.enableClassExtend;
  var enableClassCheck$1 = clazz.enableClassCheck;









  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @module echarts/model/Model
   */
  var mixin$1 = util.mixin;
  var inner = makeInner$1();
  /**
   * @alias module:echarts/model/Model
   * @constructor
   * @param {Object} [option]
   * @param {module:echarts/model/Model} [parentModel]
   * @param {module:echarts/model/Global} [ecModel]
   */

  function Model(option, parentModel, ecModel) {
    /**
     * @type {module:echarts/model/Model}
     * @readOnly
     */
    this.parentModel = parentModel;
    /**
     * @type {module:echarts/model/Global}
     * @readOnly
     */

    this.ecModel = ecModel;
    /**
     * @type {Object}
     * @protected
     */

    this.option = option; // Simple optimization
    // if (this.init) {
    //     if (arguments.length <= 4) {
    //         this.init(option, parentModel, ecModel, extraOpt);
    //     }
    //     else {
    //         this.init.apply(this, arguments);
    //     }
    // }
  }

  Model.prototype = {
    constructor: Model,

    /**
     * Model çåå§åå½æ°
     * @param {Object} option
     */
    init: null,

    /**
     * ä»æ°ç Option merge
     */
    mergeOption: function (option) {
      util.merge(this.option, option, true);
    },

    /**
     * @param {string|Array.<string>} path
     * @param {boolean} [ignoreParent=false]
     * @return {*}
     */
    get: function (path, ignoreParent) {
      if (path == null) {
        return this.option;
      }

      return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));
    },

    /**
     * @param {string} key
     * @param {boolean} [ignoreParent=false]
     * @return {*}
     */
    getShallow: function (key, ignoreParent) {
      var option = this.option;
      var val = option == null ? option : option[key];
      var parentModel = !ignoreParent && getParent(this, key);

      if (val == null && parentModel) {
        val = parentModel.getShallow(key);
      }

      return val;
    },

    /**
     * @param {string|Array.<string>} [path]
     * @param {module:echarts/model/Model} [parentModel]
     * @return {module:echarts/model/Model}
     */
    getModel: function (path, parentModel) {
      var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));
      var thisParentModel;
      parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);
      return new Model(obj, parentModel, this.ecModel);
    },

    /**
     * If model has option
     */
    isEmpty: function () {
      return this.option == null;
    },
    restoreData: function () {},
    // Pending
    clone: function () {
      var Ctor = this.constructor;
      return new Ctor(util.clone(this.option));
    },
    setReadOnly: function (properties) {// clazzUtil.setReadOnly(this, properties);
    },
    // If path is null/undefined, return null/undefined.
    parsePath: function (path) {
      if (typeof path === 'string') {
        path = path.split('.');
      }

      return path;
    },

    /**
     * @param {Function} getParentMethod
     *        param {Array.<string>|string} path
     *        return {module:echarts/model/Model}
     */
    customizeGetParent: function (getParentMethod) {
      inner(this).getParent = getParentMethod;
    },
    isAnimationEnabled: function () {
      if (!env_1.node) {
        if (this.option.animation != null) {
          return !!this.option.animation;
        } else if (this.parentModel) {
          return this.parentModel.isAnimationEnabled();
        }
      }
    }
  };

  function doGet(obj, pathArr, parentModel) {
    for (var i = 0; i < pathArr.length; i++) {
      // Ignore empty
      if (!pathArr[i]) {
        continue;
      } // obj could be number/string/... (like 0)


      obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;

      if (obj == null) {
        break;
      }
    }

    if (obj == null && parentModel) {
      obj = parentModel.get(pathArr);
    }

    return obj;
  } // `path` can be null/undefined


  function getParent(model, path) {
    var getParentMethod = inner(model).getParent;
    return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;
  } // Enable Model.extend.


  enableClassExtend$1(Model);
  enableClassCheck$1(Model);
  mixin$1(Model, lineStyle);
  mixin$1(Model, areaStyle);
  mixin$1(Model, textStyle);
  mixin$1(Model, itemStyle);
  var _default$S = Model;
  var Model_1 = _default$S;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  var parseClassType$1 = clazz.parseClassType;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var base = 0;
  /**
   * @public
   * @param {string} type
   * @return {string}
   */

  function getUID(type) {
    // Considering the case of crossing js context,
    // use Math.random to make id as unique as possible.
    return [type || '', base++, Math.random().toFixed(5)].join('_');
  }
  /**
   * @inner
   */


  function enableSubTypeDefaulter(entity) {
    var subTypeDefaulters = {};

    entity.registerSubTypeDefaulter = function (componentType, defaulter) {
      componentType = parseClassType$1(componentType);
      subTypeDefaulters[componentType.main] = defaulter;
    };

    entity.determineSubType = function (componentType, option) {
      var type = option.type;

      if (!type) {
        var componentTypeMain = parseClassType$1(componentType).main;

        if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
          type = subTypeDefaulters[componentTypeMain](option);
        }
      }

      return type;
    };

    return entity;
  }
  /**
   * Topological travel on Activity Network (Activity On Vertices).
   * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
   *
   * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
   *
   * If there is circle dependencey, Error will be thrown.
   *
   */


  function enableTopologicalTravel(entity, dependencyGetter) {
    /**
     * @public
     * @param {Array.<string>} targetNameList Target Component type list.
     *                                           Can be ['aa', 'bb', 'aa.xx']
     * @param {Array.<string>} fullNameList By which we can build dependency graph.
     * @param {Function} callback Params: componentType, dependencies.
     * @param {Object} context Scope of callback.
     */
    entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
      if (!targetNameList.length) {
        return;
      }

      var result = makeDepndencyGraph(fullNameList);
      var graph = result.graph;
      var stack = result.noEntryList;
      var targetNameSet = {};
      util.each(targetNameList, function (name) {
        targetNameSet[name] = true;
      });

      while (stack.length) {
        var currComponentType = stack.pop();
        var currVertex = graph[currComponentType];
        var isInTargetNameSet = !!targetNameSet[currComponentType];

        if (isInTargetNameSet) {
          callback.call(context, currComponentType, currVertex.originalDeps.slice());
          delete targetNameSet[currComponentType];
        }

        util.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
      }

      util.each(targetNameSet, function () {
        throw new Error('Circle dependency may exists');
      });

      function removeEdge(succComponentType) {
        graph[succComponentType].entryCount--;

        if (graph[succComponentType].entryCount === 0) {
          stack.push(succComponentType);
        }
      } // Consider this case: legend depends on series, and we call
      // chart.setOption({series: [...]}), where only series is in option.
      // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
      // not be called, but only sereis.mergeOption is called. Thus legend
      // have no chance to update its local record about series (like which
      // name of series is available in legend).


      function removeEdgeAndAdd(succComponentType) {
        targetNameSet[succComponentType] = true;
        removeEdge(succComponentType);
      }
    };
    /**
     * DepndencyGraph: {Object}
     * key: conponentType,
     * value: {
     *     successor: [conponentTypes...],
     *     originalDeps: [conponentTypes...],
     *     entryCount: {number}
     * }
     */


    function makeDepndencyGraph(fullNameList) {
      var graph = {};
      var noEntryList = [];
      util.each(fullNameList, function (name) {
        var thisItem = createDependencyGraphItem(graph, name);
        var originalDeps = thisItem.originalDeps = dependencyGetter(name);
        var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
        thisItem.entryCount = availableDeps.length;

        if (thisItem.entryCount === 0) {
          noEntryList.push(name);
        }

        util.each(availableDeps, function (dependentName) {
          if (util.indexOf(thisItem.predecessor, dependentName) < 0) {
            thisItem.predecessor.push(dependentName);
          }

          var thatItem = createDependencyGraphItem(graph, dependentName);

          if (util.indexOf(thatItem.successor, dependentName) < 0) {
            thatItem.successor.push(name);
          }
        });
      });
      return {
        graph: graph,
        noEntryList: noEntryList
      };
    }

    function createDependencyGraphItem(graph, name) {
      if (!graph[name]) {
        graph[name] = {
          predecessor: [],
          successor: []
        };
      }

      return graph[name];
    }

    function getAvailableDependencies(originalDeps, fullNameList) {
      var availableDeps = [];
      util.each(originalDeps, function (dep) {
        util.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
      });
      return availableDeps;
    }
  }

  var getUID_1 = getUID;
  var enableSubTypeDefaulter_1 = enableSubTypeDefaulter;
  var enableTopologicalTravel_1 = enableTopologicalTravel;

  var component = {
  	getUID: getUID_1,
  	enableSubTypeDefaulter: enableSubTypeDefaulter_1,
  	enableTopologicalTravel: enableTopologicalTravel_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * A third-party license is embeded for some of the code in this file:
  * The method "quantile" was copied from "d3.js".
  * (See more details in the comment of the method below.)
  * The use of the source code of this file is also subject to the terms
  * and consitions of the license of "d3.js" (BSD-3Clause, see
  * </licenses/LICENSE-d3>).
  */
  var RADIAN_EPSILON = 1e-4;

  function _trim(str) {
    return str.replace(/^\s+|\s+$/g, '');
  }
  /**
   * Linear mapping a value from domain to range
   * @memberOf module:echarts/util/number
   * @param  {(number|Array.<number>)} val
   * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]
   * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]
   * @param  {boolean} clamp
   * @return {(number|Array.<number>}
   */


  function linearMap(val, domain, range, clamp) {
    var subDomain = domain[1] - domain[0];
    var subRange = range[1] - range[0];

    if (subDomain === 0) {
      return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
    } // Avoid accuracy problem in edge, such as
    // 146.39 - 62.83 === 83.55999999999999.
    // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
    // It is a little verbose for efficiency considering this method
    // is a hotspot.


    if (clamp) {
      if (subDomain > 0) {
        if (val <= domain[0]) {
          return range[0];
        } else if (val >= domain[1]) {
          return range[1];
        }
      } else {
        if (val >= domain[0]) {
          return range[0];
        } else if (val <= domain[1]) {
          return range[1];
        }
      }
    } else {
      if (val === domain[0]) {
        return range[0];
      }

      if (val === domain[1]) {
        return range[1];
      }
    }

    return (val - domain[0]) / subDomain * subRange + range[0];
  }
  /**
   * Convert a percent string to absolute number.
   * Returns NaN if percent is not a valid string or number
   * @memberOf module:echarts/util/number
   * @param {string|number} percent
   * @param {number} all
   * @return {number}
   */


  function parsePercent$1(percent, all) {
    switch (percent) {
      case 'center':
      case 'middle':
        percent = '50%';
        break;

      case 'left':
      case 'top':
        percent = '0%';
        break;

      case 'right':
      case 'bottom':
        percent = '100%';
        break;
    }

    if (typeof percent === 'string') {
      if (_trim(percent).match(/%$/)) {
        return parseFloat(percent) / 100 * all;
      }

      return parseFloat(percent);
    }

    return percent == null ? NaN : +percent;
  }
  /**
   * (1) Fix rounding error of float numbers.
   * (2) Support return string to avoid scientific notation like '3.5e-7'.
   *
   * @param {number} x
   * @param {number} [precision]
   * @param {boolean} [returnStr]
   * @return {number|string}
   */


  function round$1(x, precision, returnStr) {
    if (precision == null) {
      precision = 10;
    } // Avoid range error


    precision = Math.min(Math.max(0, precision), 20);
    x = (+x).toFixed(precision);
    return returnStr ? x : +x;
  }
  /**
   * asc sort arr.
   * The input arr will be modified.
   *
   * @param {Array} arr
   * @return {Array} The input arr.
   */


  function asc(arr) {
    arr.sort(function (a, b) {
      return a - b;
    });
    return arr;
  }
  /**
   * Get precision
   * @param {number} val
   */


  function getPrecision(val) {
    val = +val;

    if (isNaN(val)) {
      return 0;
    } // It is much faster than methods converting number to string as follows
    //      var tmp = val.toString();
    //      return tmp.length - 1 - tmp.indexOf('.');
    // especially when precision is low


    var e = 1;
    var count = 0;

    while (Math.round(val * e) / e !== val) {
      e *= 10;
      count++;
    }

    return count;
  }
  /**
   * @param {string|number} val
   * @return {number}
   */


  function getPrecisionSafe(val) {
    var str = val.toString(); // Consider scientific notation: '3.4e-12' '3.4e+12'

    var eIndex = str.indexOf('e');

    if (eIndex > 0) {
      var precision = +str.slice(eIndex + 1);
      return precision < 0 ? -precision : 0;
    } else {
      var dotIndex = str.indexOf('.');
      return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
    }
  }
  /**
   * Minimal dicernible data precisioin according to a single pixel.
   *
   * @param {Array.<number>} dataExtent
   * @param {Array.<number>} pixelExtent
   * @return {number} precision
   */


  function getPixelPrecision(dataExtent, pixelExtent) {
    var log = Math.log;
    var LN10 = Math.LN10;
    var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
    var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20.

    var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
    return !isFinite(precision) ? 20 : precision;
  }
  /**
   * Get a data of given precision, assuring the sum of percentages
   * in valueList is 1.
   * The largest remainer method is used.
   * https://en.wikipedia.org/wiki/Largest_remainder_method
   *
   * @param {Array.<number>} valueList a list of all data
   * @param {number} idx index of the data to be processed in valueList
   * @param {number} precision integer number showing digits of precision
   * @return {number} percent ranging from 0 to 100
   */


  function getPercentWithPrecision(valueList, idx, precision) {
    if (!valueList[idx]) {
      return 0;
    }

    var sum = util.reduce(valueList, function (acc, val) {
      return acc + (isNaN(val) ? 0 : val);
    }, 0);

    if (sum === 0) {
      return 0;
    }

    var digits = Math.pow(10, precision);
    var votesPerQuota = util.map(valueList, function (val) {
      return (isNaN(val) ? 0 : val) / sum * digits * 100;
    });
    var targetSeats = digits * 100;
    var seats = util.map(votesPerQuota, function (votes) {
      // Assign automatic seats.
      return Math.floor(votes);
    });
    var currentSum = util.reduce(seats, function (acc, val) {
      return acc + val;
    }, 0);
    var remainder = util.map(votesPerQuota, function (votes, idx) {
      return votes - seats[idx];
    }); // Has remainding votes.

    while (currentSum < targetSeats) {
      // Find next largest remainder.
      var max = Number.NEGATIVE_INFINITY;
      var maxId = null;

      for (var i = 0, len = remainder.length; i < len; ++i) {
        if (remainder[i] > max) {
          max = remainder[i];
          maxId = i;
        }
      } // Add a vote to max remainder.


      ++seats[maxId];
      remainder[maxId] = 0;
      ++currentSum;
    }

    return seats[idx] / digits;
  } // Number.MAX_SAFE_INTEGER, ie do not support.


  var MAX_SAFE_INTEGER$2 = 9007199254740991;
  /**
   * To 0 - 2 * PI, considering negative radian.
   * @param {number} radian
   * @return {number}
   */

  function remRadian(radian) {
    var pi2 = Math.PI * 2;
    return (radian % pi2 + pi2) % pi2;
  }
  /**
   * @param {type} radian
   * @return {boolean}
   */


  function isRadianAroundZero(val) {
    return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
  }
  /* eslint-disable */


  var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; // jshint ignore:line

  /* eslint-enable */

  /**
   * @param {string|Date|number} value These values can be accepted:
   *   + An instance of Date, represent a time in its own time zone.
   *   + Or string in a subset of ISO 8601, only including:
   *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
   *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
   *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
   *     all of which will be treated as local time if time zone is not specified
   *     (see <https://momentjs.com/>).
   *   + Or other string format, including (all of which will be treated as loacal time):
   *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
   *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
   *   + a timestamp, which represent a time in UTC.
   * @return {Date} date
   */

  function parseDate(value) {
    if (value instanceof Date) {
      return value;
    } else if (typeof value === 'string') {
      // Different browsers parse date in different way, so we parse it manually.
      // Some other issues:
      // new Date('1970-01-01') is UTC,
      // new Date('1970/01/01') and new Date('1970-1-01') is local.
      // See issue #3623
      var match = TIME_REG.exec(value);

      if (!match) {
        // return Invalid Date.
        return new Date(NaN);
      } // Use local time when no timezone offset specifed.


      if (!match[8]) {
        // match[n] can only be string or undefined.
        // But take care of '12' + 1 => '121'.
        return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
      } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,
      // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).
      // For example, system timezone is set as "Time Zone: America/Toronto",
      // then these code will get different result:
      // `new Date(1478411999999).getTimezoneOffset();  // get 240`
      // `new Date(1478412000000).getTimezoneOffset();  // get 300`
      // So we should not use `new Date`, but use `Date.UTC`.
      else {
          var hour = +match[4] || 0;

          if (match[8].toUpperCase() !== 'Z') {
            hour -= match[8].slice(0, 3);
          }

          return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
        }
    } else if (value == null) {
      return new Date(NaN);
    }

    return new Date(Math.round(value));
  }
  /**
   * Quantity of a number. e.g. 0.1, 1, 10, 100
   *
   * @param  {number} val
   * @return {number}
   */


  function quantity(val) {
    return Math.pow(10, quantityExponent(val));
  }
  /**
   * Exponent of the quantity of a number
   * e.g., 1234 equals to 1.234*10^3, so quantityExponent(1234) is 3
   *
   * @param  {number} val non-negative value
   * @return {number}
   */


  function quantityExponent(val) {
    if (val === 0) {
      return 0;
    }

    var exp = Math.floor(Math.log(val) / Math.LN10);
    /**
     * exp is expected to be the rounded-down result of the base-10 log of val.
     * But due to the precision loss with Math.log(val), we need to restore it
     * using 10^exp to make sure we can get val back from exp. #11249
     */

    if (val / Math.pow(10, exp) >= 10) {
      exp++;
    }

    return exp;
  }
  /**
   * find a âniceâ number approximately equal to x. Round the number if round = true,
   * take ceiling if round = false. The primary observation is that the ânicestâ
   * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
   *
   * See "Nice Numbers for Graph Labels" of Graphic Gems.
   *
   * @param  {number} val Non-negative value.
   * @param  {boolean} round
   * @return {number}
   */


  function nice(val, round) {
    var exponent = quantityExponent(val);
    var exp10 = Math.pow(10, exponent);
    var f = val / exp10; // 1 <= f < 10

    var nf;

    if (round) {
      if (f < 1.5) {
        nf = 1;
      } else if (f < 2.5) {
        nf = 2;
      } else if (f < 4) {
        nf = 3;
      } else if (f < 7) {
        nf = 5;
      } else {
        nf = 10;
      }
    } else {
      if (f < 1) {
        nf = 1;
      } else if (f < 2) {
        nf = 2;
      } else if (f < 3) {
        nf = 3;
      } else if (f < 5) {
        nf = 5;
      } else {
        nf = 10;
      }
    }

    val = nf * exp10; // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).
    // 20 is the uppper bound of toFixed.

    return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
  }
  /**
   * This code was copied from "d3.js"
   * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/arrays/quantile.js>.
   * See the license statement at the head of this file.
   * @param {Array.<number>} ascArr
   */


  function quantile(ascArr, p) {
    var H = (ascArr.length - 1) * p + 1;
    var h = Math.floor(H);
    var v = +ascArr[h - 1];
    var e = H - h;
    return e ? v + e * (ascArr[h] - v) : v;
  }
  /**
   * Order intervals asc, and split them when overlap.
   * expect(numberUtil.reformIntervals([
   *     {interval: [18, 62], close: [1, 1]},
   *     {interval: [-Infinity, -70], close: [0, 0]},
   *     {interval: [-70, -26], close: [1, 1]},
   *     {interval: [-26, 18], close: [1, 1]},
   *     {interval: [62, 150], close: [1, 1]},
   *     {interval: [106, 150], close: [1, 1]},
   *     {interval: [150, Infinity], close: [0, 0]}
   * ])).toEqual([
   *     {interval: [-Infinity, -70], close: [0, 0]},
   *     {interval: [-70, -26], close: [1, 1]},
   *     {interval: [-26, 18], close: [0, 1]},
   *     {interval: [18, 62], close: [0, 1]},
   *     {interval: [62, 150], close: [0, 1]},
   *     {interval: [150, Infinity], close: [0, 0]}
   * ]);
   * @param {Array.<Object>} list, where `close` mean open or close
   *        of the interval, and Infinity can be used.
   * @return {Array.<Object>} The origin list, which has been reformed.
   */


  function reformIntervals(list) {
    list.sort(function (a, b) {
      return littleThan(a, b, 0) ? -1 : 1;
    });
    var curr = -Infinity;
    var currClose = 1;

    for (var i = 0; i < list.length;) {
      var interval = list[i].interval;
      var close = list[i].close;

      for (var lg = 0; lg < 2; lg++) {
        if (interval[lg] <= curr) {
          interval[lg] = curr;
          close[lg] = !lg ? 1 - currClose : 1;
        }

        curr = interval[lg];
        currClose = close[lg];
      }

      if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
        list.splice(i, 1);
      } else {
        i++;
      }
    }

    return list;

    function littleThan(a, b, lg) {
      return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));
    }
  }
  /**
   * parseFloat NaNs numeric-cast false positives (null|true|false|"")
   * ...but misinterprets leading-number strings, particularly hex literals ("0x...")
   * subtraction forces infinities to NaN
   *
   * @param {*} v
   * @return {boolean}
   */


  function isNumeric(v) {
    return v - parseFloat(v) >= 0;
  }

  var linearMap_1 = linearMap;
  var parsePercent_1$1 = parsePercent$1;
  var round_1 = round$1;
  var asc_1 = asc;
  var getPrecision_1 = getPrecision;
  var getPrecisionSafe_1 = getPrecisionSafe;
  var getPixelPrecision_1 = getPixelPrecision;
  var getPercentWithPrecision_1 = getPercentWithPrecision;
  var MAX_SAFE_INTEGER_1 = MAX_SAFE_INTEGER$2;
  var remRadian_1 = remRadian;
  var isRadianAroundZero_1 = isRadianAroundZero;
  var parseDate_1 = parseDate;
  var quantity_1 = quantity;
  var quantityExponent_1 = quantityExponent;
  var nice_1 = nice;
  var quantile_1 = quantile;
  var reformIntervals_1 = reformIntervals;
  var isNumeric_1 = isNumeric;

  var number = {
  	linearMap: linearMap_1,
  	parsePercent: parsePercent_1$1,
  	round: round_1,
  	asc: asc_1,
  	getPrecision: getPrecision_1,
  	getPrecisionSafe: getPrecisionSafe_1,
  	getPixelPrecision: getPixelPrecision_1,
  	getPercentWithPrecision: getPercentWithPrecision_1,
  	MAX_SAFE_INTEGER: MAX_SAFE_INTEGER_1,
  	remRadian: remRadian_1,
  	isRadianAroundZero: isRadianAroundZero_1,
  	parseDate: parseDate_1,
  	quantity: quantity_1,
  	quantityExponent: quantityExponent_1,
  	nice: nice_1,
  	quantile: quantile_1,
  	reformIntervals: reformIntervals_1,
  	isNumeric: isNumeric_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // import Text from 'zrender/src/graphic/Text';

  /**
   * add commas after every three numbers
   * @param {string|number} x
   * @return {string}
   */
  function addCommas(x) {
    if (isNaN(x)) {
      return '-';
    }

    x = (x + '').split('.');
    return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');
  }
  /**
   * @param {string} str
   * @param {boolean} [upperCaseFirst=false]
   * @return {string} str
   */


  function toCamelCase(str, upperCaseFirst) {
    str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
      return group1.toUpperCase();
    });

    if (upperCaseFirst && str) {
      str = str.charAt(0).toUpperCase() + str.slice(1);
    }

    return str;
  }

  var normalizeCssArray$2 = util.normalizeCssArray;
  var replaceReg = /([&<>"'])/g;
  var replaceMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#39;'
  };

  function encodeHTML(source) {
    return source == null ? '' : (source + '').replace(replaceReg, function (str, c) {
      return replaceMap[c];
    });
  }

  var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

  var wrapVar = function (varName, seriesIdx) {
    return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
  };
  /**
   * Template formatter
   * @param {string} tpl
   * @param {Array.<Object>|Object} paramsList
   * @param {boolean} [encode=false]
   * @return {string}
   */


  function formatTpl(tpl, paramsList, encode) {
    if (!util.isArray(paramsList)) {
      paramsList = [paramsList];
    }

    var seriesLen = paramsList.length;

    if (!seriesLen) {
      return '';
    }

    var $vars = paramsList[0].$vars || [];

    for (var i = 0; i < $vars.length; i++) {
      var alias = TPL_VAR_ALIAS[i];
      tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
    }

    for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
      for (var k = 0; k < $vars.length; k++) {
        var val = paramsList[seriesIdx][$vars[k]];
        tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
      }
    }

    return tpl;
  }
  /**
   * simple Template formatter
   *
   * @param {string} tpl
   * @param {Object} param
   * @param {boolean} [encode=false]
   * @return {string}
   */


  function formatTplSimple(tpl, param, encode) {
    util.each(param, function (value, key) {
      tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);
    });
    return tpl;
  }
  /**
   * @param {Object|string} [opt] If string, means color.
   * @param {string} [opt.color]
   * @param {string} [opt.extraCssText]
   * @param {string} [opt.type='item'] 'item' or 'subItem'
   * @param {string} [opt.renderMode='html'] render mode of tooltip, 'html' or 'richText'
   * @param {string} [opt.markerId='X'] id name for marker. If only one marker is in a rich text, this can be omitted.
   * @return {string}
   */


  function getTooltipMarker(opt, extraCssText) {
    opt = util.isString(opt) ? {
      color: opt,
      extraCssText: extraCssText
    } : opt || {};
    var color = opt.color;
    var type = opt.type;
    var extraCssText = opt.extraCssText;
    var renderMode = opt.renderMode || 'html';
    var markerId = opt.markerId || 'X';

    if (!color) {
      return '';
    }

    if (renderMode === 'html') {
      return type === 'subItem' ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;' + 'border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>' : '<span style="display:inline-block;margin-right:5px;' + 'border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>';
    } else {
      // Space for rich element marker
      return {
        renderMode: renderMode,
        content: '{marker' + markerId + '|}  ',
        style: {
          color: color
        }
      };
    }
  }

  function pad(str, len) {
    str += '';
    return '0000'.substr(0, len - str.length) + str;
  }
  /**
   * ISO Date format
   * @param {string} tpl
   * @param {number} value
   * @param {boolean} [isUTC=false] Default in local time.
   *           see `module:echarts/scale/Time`
   *           and `module:echarts/util/number#parseDate`.
   * @inner
   */


  function formatTime(tpl, value, isUTC) {
    if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
      tpl = 'MM-dd\nyyyy';
    }

    var date = number.parseDate(value);
    var utc = isUTC ? 'UTC' : '';
    var y = date['get' + utc + 'FullYear']();
    var M = date['get' + utc + 'Month']() + 1;
    var d = date['get' + utc + 'Date']();
    var h = date['get' + utc + 'Hours']();
    var m = date['get' + utc + 'Minutes']();
    var s = date['get' + utc + 'Seconds']();
    var S = date['get' + utc + 'Milliseconds']();
    tpl = tpl.replace('MM', pad(M, 2)).replace('M', M).replace('yyyy', y).replace('yy', y % 100).replace('dd', pad(d, 2)).replace('d', d).replace('hh', pad(h, 2)).replace('h', h).replace('mm', pad(m, 2)).replace('m', m).replace('ss', pad(s, 2)).replace('s', s).replace('SSS', pad(S, 3));
    return tpl;
  }
  /**
   * Capital first
   * @param {string} str
   * @return {string}
   */


  function capitalFirst(str) {
    return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
  }

  var truncateText$1 = text.truncateText;
  /**
   * @public
   * @param {Object} opt
   * @param {string} opt.text
   * @param {string} opt.font
   * @param {string} [opt.textAlign='left']
   * @param {string} [opt.textVerticalAlign='top']
   * @param {Array.<number>} [opt.textPadding]
   * @param {number} [opt.textLineHeight]
   * @param {Object} [opt.rich]
   * @param {Object} [opt.truncate]
   * @return {Object} {x, y, width, height, lineHeight}
   */

  function getTextBoundingRect(opt) {
    return text.getBoundingRect(opt.text, opt.font, opt.textAlign, opt.textVerticalAlign, opt.textPadding, opt.textLineHeight, opt.rich, opt.truncate);
  }
  /**
   * @deprecated
   * the `textLineHeight` was added later.
   * For backward compatiblility, put it as the last parameter.
   * But deprecated this interface. Please use `getTextBoundingRect` instead.
   */


  function getTextRect(text$1, font, textAlign, textVerticalAlign, textPadding, rich, truncate, textLineHeight) {
    return text.getBoundingRect(text$1, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate);
  }
  /**
   * open new tab
   * @param {string} link url
   * @param {string} target blank or self
   */


  function windowOpen(link, target) {
    if (target === '_blank' || target === 'blank') {
      var blank = window.open();
      blank.opener = null;
      blank.location = link;
    } else {
      window.open(link, target);
    }
  }

  var addCommas_1 = addCommas;
  var toCamelCase_1 = toCamelCase;
  var normalizeCssArray_1$1 = normalizeCssArray$2;
  var encodeHTML_1 = encodeHTML;
  var formatTpl_1 = formatTpl;
  var formatTplSimple_1 = formatTplSimple;
  var getTooltipMarker_1 = getTooltipMarker;
  var formatTime_1 = formatTime;
  var capitalFirst_1 = capitalFirst;
  var truncateText_1$1 = truncateText$1;
  var getTextBoundingRect_1 = getTextBoundingRect;
  var getTextRect_1 = getTextRect;
  var windowOpen_1 = windowOpen;

  var format$1 = {
  	addCommas: addCommas_1,
  	toCamelCase: toCamelCase_1,
  	normalizeCssArray: normalizeCssArray_1$1,
  	encodeHTML: encodeHTML_1,
  	formatTpl: formatTpl_1,
  	formatTplSimple: formatTplSimple_1,
  	getTooltipMarker: getTooltipMarker_1,
  	formatTime: formatTime_1,
  	capitalFirst: capitalFirst_1,
  	truncateText: truncateText_1$1,
  	getTextBoundingRect: getTextBoundingRect_1,
  	getTextRect: getTextRect_1,
  	windowOpen: windowOpen_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  var parsePercent$2 = number.parsePercent;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Layout helpers for each component positioning
  var each$3 = util.each;
  /**
   * @public
   */

  var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];
  /**
   * @public
   */

  var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];

  function boxLayout(orient, group, gap, maxWidth, maxHeight) {
    var x = 0;
    var y = 0;

    if (maxWidth == null) {
      maxWidth = Infinity;
    }

    if (maxHeight == null) {
      maxHeight = Infinity;
    }

    var currentLineMaxSize = 0;
    group.eachChild(function (child, idx) {
      var position = child.position;
      var rect = child.getBoundingRect();
      var nextChild = group.childAt(idx + 1);
      var nextChildRect = nextChild && nextChild.getBoundingRect();
      var nextX;
      var nextY;

      if (orient === 'horizontal') {
        var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
        nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group
        // FIXME compare before adding gap?

        if (nextX > maxWidth || child.newline) {
          x = 0;
          nextX = moveX;
          y += currentLineMaxSize + gap;
          currentLineMaxSize = rect.height;
        } else {
          // FIXME: consider rect.y is not `0`?
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
        }
      } else {
        var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
        nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group

        if (nextY > maxHeight || child.newline) {
          x += currentLineMaxSize + gap;
          y = 0;
          nextY = moveY;
          currentLineMaxSize = rect.width;
        } else {
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
        }
      }

      if (child.newline) {
        return;
      }

      position[0] = x;
      position[1] = y;
      orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;
    });
  }
  /**
   * VBox or HBox layouting
   * @param {string} orient
   * @param {module:zrender/container/Group} group
   * @param {number} gap
   * @param {number} [width=Infinity]
   * @param {number} [height=Infinity]
   */


  var box = boxLayout;
  /**
   * VBox layouting
   * @param {module:zrender/container/Group} group
   * @param {number} gap
   * @param {number} [width=Infinity]
   * @param {number} [height=Infinity]
   */

  var vbox = util.curry(boxLayout, 'vertical');
  /**
   * HBox layouting
   * @param {module:zrender/container/Group} group
   * @param {number} gap
   * @param {number} [width=Infinity]
   * @param {number} [height=Infinity]
   */

  var hbox = util.curry(boxLayout, 'horizontal');
  /**
   * If x or x2 is not specified or 'center' 'left' 'right',
   * the width would be as long as possible.
   * If y or y2 is not specified or 'middle' 'top' 'bottom',
   * the height would be as long as possible.
   *
   * @param {Object} positionInfo
   * @param {number|string} [positionInfo.x]
   * @param {number|string} [positionInfo.y]
   * @param {number|string} [positionInfo.x2]
   * @param {number|string} [positionInfo.y2]
   * @param {Object} containerRect {width, height}
   * @param {string|number} margin
   * @return {Object} {width, height}
   */

  function getAvailableSize(positionInfo, containerRect, margin) {
    var containerWidth = containerRect.width;
    var containerHeight = containerRect.height;
    var x = parsePercent$2(positionInfo.x, containerWidth);
    var y = parsePercent$2(positionInfo.y, containerHeight);
    var x2 = parsePercent$2(positionInfo.x2, containerWidth);
    var y2 = parsePercent$2(positionInfo.y2, containerHeight);
    (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
    (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
    (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
    (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
    margin = format$1.normalizeCssArray(margin || 0);
    return {
      width: Math.max(x2 - x - margin[1] - margin[3], 0),
      height: Math.max(y2 - y - margin[0] - margin[2], 0)
    };
  }
  /**
   * Parse position info.
   *
   * @param {Object} positionInfo
   * @param {number|string} [positionInfo.left]
   * @param {number|string} [positionInfo.top]
   * @param {number|string} [positionInfo.right]
   * @param {number|string} [positionInfo.bottom]
   * @param {number|string} [positionInfo.width]
   * @param {number|string} [positionInfo.height]
   * @param {number|string} [positionInfo.aspect] Aspect is width / height
   * @param {Object} containerRect
   * @param {string|number} [margin]
   *
   * @return {module:zrender/core/BoundingRect}
   */


  function getLayoutRect(positionInfo, containerRect, margin) {
    margin = format$1.normalizeCssArray(margin || 0);
    var containerWidth = containerRect.width;
    var containerHeight = containerRect.height;
    var left = parsePercent$2(positionInfo.left, containerWidth);
    var top = parsePercent$2(positionInfo.top, containerHeight);
    var right = parsePercent$2(positionInfo.right, containerWidth);
    var bottom = parsePercent$2(positionInfo.bottom, containerHeight);
    var width = parsePercent$2(positionInfo.width, containerWidth);
    var height = parsePercent$2(positionInfo.height, containerHeight);
    var verticalMargin = margin[2] + margin[0];
    var horizontalMargin = margin[1] + margin[3];
    var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right

    if (isNaN(width)) {
      width = containerWidth - right - horizontalMargin - left;
    }

    if (isNaN(height)) {
      height = containerHeight - bottom - verticalMargin - top;
    }

    if (aspect != null) {
      // If width and height are not given
      // 1. Graph should not exceeds the container
      // 2. Aspect must be keeped
      // 3. Graph should take the space as more as possible
      // FIXME
      // Margin is not considered, because there is no case that both
      // using margin and aspect so far.
      if (isNaN(width) && isNaN(height)) {
        if (aspect > containerWidth / containerHeight) {
          width = containerWidth * 0.8;
        } else {
          height = containerHeight * 0.8;
        }
      } // Calculate width or height with given aspect


      if (isNaN(width)) {
        width = aspect * height;
      }

      if (isNaN(height)) {
        height = width / aspect;
      }
    } // If left is not specified, calculate left from right and width


    if (isNaN(left)) {
      left = containerWidth - right - width - horizontalMargin;
    }

    if (isNaN(top)) {
      top = containerHeight - bottom - height - verticalMargin;
    } // Align left and top


    switch (positionInfo.left || positionInfo.right) {
      case 'center':
        left = containerWidth / 2 - width / 2 - margin[3];
        break;

      case 'right':
        left = containerWidth - width - horizontalMargin;
        break;
    }

    switch (positionInfo.top || positionInfo.bottom) {
      case 'middle':
      case 'center':
        top = containerHeight / 2 - height / 2 - margin[0];
        break;

      case 'bottom':
        top = containerHeight - height - verticalMargin;
        break;
    } // If something is wrong and left, top, width, height are calculated as NaN


    left = left || 0;
    top = top || 0;

    if (isNaN(width)) {
      // Width may be NaN if only one value is given except width
      width = containerWidth - horizontalMargin - left - (right || 0);
    }

    if (isNaN(height)) {
      // Height may be NaN if only one value is given except height
      height = containerHeight - verticalMargin - top - (bottom || 0);
    }

    var rect = new BoundingRect_1(left + margin[3], top + margin[0], width, height);
    rect.margin = margin;
    return rect;
  }
  /**
   * Position a zr element in viewport
   *  Group position is specified by either
   *  {left, top}, {right, bottom}
   *  If all properties exists, right and bottom will be igonred.
   *
   * Logic:
   *     1. Scale (against origin point in parent coord)
   *     2. Rotate (against origin point in parent coord)
   *     3. Traslate (with el.position by this method)
   * So this method only fixes the last step 'Traslate', which does not affect
   * scaling and rotating.
   *
   * If be called repeatly with the same input el, the same result will be gotten.
   *
   * @param {module:zrender/Element} el Should have `getBoundingRect` method.
   * @param {Object} positionInfo
   * @param {number|string} [positionInfo.left]
   * @param {number|string} [positionInfo.top]
   * @param {number|string} [positionInfo.right]
   * @param {number|string} [positionInfo.bottom]
   * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'
   * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'
   * @param {Object} containerRect
   * @param {string|number} margin
   * @param {Object} [opt]
   * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.
   * @param {Array.<number>} [opt.boundingMode='all']
   *        Specify how to calculate boundingRect when locating.
   *        'all': Position the boundingRect that is transformed and uioned
   *               both itself and its descendants.
   *               This mode simplies confine the elements in the bounding
   *               of their container (e.g., using 'right: 0').
   *        'raw': Position the boundingRect that is not transformed and only itself.
   *               This mode is useful when you want a element can overflow its
   *               container. (Consider a rotated circle needs to be located in a corner.)
   *               In this mode positionInfo.width/height can only be number.
   */


  function positionElement(el, positionInfo, containerRect, margin, opt) {
    var h = !opt || !opt.hv || opt.hv[0];
    var v = !opt || !opt.hv || opt.hv[1];
    var boundingMode = opt && opt.boundingMode || 'all';

    if (!h && !v) {
      return;
    }

    var rect;

    if (boundingMode === 'raw') {
      rect = el.type === 'group' ? new BoundingRect_1(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
    } else {
      rect = el.getBoundingRect();

      if (el.needLocalTransform()) {
        var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,
        // which should not be modified.

        rect = rect.clone();
        rect.applyTransform(transform);
      }
    } // The real width and height can not be specified but calculated by the given el.


    positionInfo = getLayoutRect(util.defaults({
      width: rect.width,
      height: rect.height
    }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform
    // (see zrender/core/Transformable#getLocalTransform),
    // we can just only modify el.position to get final result.

    var elPos = el.position;
    var dx = h ? positionInfo.x - rect.x : 0;
    var dy = v ? positionInfo.y - rect.y : 0;
    el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
  }
  /**
   * @param {Object} option Contains some of the properties in HV_NAMES.
   * @param {number} hvIdx 0: horizontal; 1: vertical.
   */


  function sizeCalculable(option, hvIdx) {
    return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
  }
  /**
   * Consider Case:
   * When defulat option has {left: 0, width: 100}, and we set {right: 0}
   * through setOption or media query, using normal zrUtil.merge will cause
   * {right: 0} does not take effect.
   *
   * @example
   * ComponentModel.extend({
   *     init: function () {
   *         ...
   *         var inputPositionParams = layout.getLayoutParams(option);
   *         this.mergeOption(inputPositionParams);
   *     },
   *     mergeOption: function (newOption) {
   *         newOption && zrUtil.merge(thisOption, newOption, true);
   *         layout.mergeLayoutParam(thisOption, newOption);
   *     }
   * });
   *
   * @param {Object} targetOption
   * @param {Object} newOption
   * @param {Object|string} [opt]
   * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components
   *  that width (or height) should not be calculated by left and right (or top and bottom).
   */


  function mergeLayoutParam(targetOption, newOption, opt) {
    !util.isObject(opt) && (opt = {});
    var ignoreSize = opt.ignoreSize;
    !util.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
    var hResult = merge(HV_NAMES[0], 0);
    var vResult = merge(HV_NAMES[1], 1);
    copy(HV_NAMES[0], targetOption, hResult);
    copy(HV_NAMES[1], targetOption, vResult);

    function merge(names, hvIdx) {
      var newParams = {};
      var newValueCount = 0;
      var merged = {};
      var mergedValueCount = 0;
      var enoughParamNumber = 2;
      each$3(names, function (name) {
        merged[name] = targetOption[name];
      });
      each$3(names, function (name) {
        // Consider case: newOption.width is null, which is
        // set by user for removing width setting.
        hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
        hasValue(newParams, name) && newValueCount++;
        hasValue(merged, name) && mergedValueCount++;
      });

      if (ignoreSize[hvIdx]) {
        // Only one of left/right is premitted to exist.
        if (hasValue(newOption, names[1])) {
          merged[names[2]] = null;
        } else if (hasValue(newOption, names[2])) {
          merged[names[1]] = null;
        }

        return merged;
      } // Case: newOption: {width: ..., right: ...},
      // or targetOption: {right: ...} and newOption: {width: ...},
      // There is no conflict when merged only has params count
      // little than enoughParamNumber.


      if (mergedValueCount === enoughParamNumber || !newValueCount) {
        return merged;
      } // Case: newOption: {width: ..., right: ...},
      // Than we can make sure user only want those two, and ignore
      // all origin params in targetOption.
      else if (newValueCount >= enoughParamNumber) {
          return newParams;
        } else {
          // Chose another param from targetOption by priority.
          for (var i = 0; i < names.length; i++) {
            var name = names[i];

            if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
              newParams[name] = targetOption[name];
              break;
            }
          }

          return newParams;
        }
    }

    function hasProp(obj, name) {
      return obj.hasOwnProperty(name);
    }

    function hasValue(obj, name) {
      return obj[name] != null && obj[name] !== 'auto';
    }

    function copy(names, target, source) {
      each$3(names, function (name) {
        target[name] = source[name];
      });
    }
  }
  /**
   * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
   * @param {Object} source
   * @return {Object} Result contains those props.
   */


  function getLayoutParams(source) {
    return copyLayoutParams({}, source);
  }
  /**
   * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
   * @param {Object} source
   * @return {Object} Result contains those props.
   */


  function copyLayoutParams(target, source) {
    source && target && each$3(LOCATION_PARAMS, function (name) {
      source.hasOwnProperty(name) && (target[name] = source[name]);
    });
    return target;
  }

  var LOCATION_PARAMS_1 = LOCATION_PARAMS;
  var HV_NAMES_1 = HV_NAMES;
  var box_1 = box;
  var vbox_1 = vbox;
  var hbox_1 = hbox;
  var getAvailableSize_1 = getAvailableSize;
  var getLayoutRect_1 = getLayoutRect;
  var positionElement_1 = positionElement;
  var sizeCalculable_1 = sizeCalculable;
  var mergeLayoutParam_1 = mergeLayoutParam;
  var getLayoutParams_1 = getLayoutParams;
  var copyLayoutParams_1 = copyLayoutParams;

  var layout = {
  	LOCATION_PARAMS: LOCATION_PARAMS_1,
  	HV_NAMES: HV_NAMES_1,
  	box: box_1,
  	vbox: vbox_1,
  	hbox: hbox_1,
  	getAvailableSize: getAvailableSize_1,
  	getLayoutRect: getLayoutRect_1,
  	positionElement: positionElement_1,
  	sizeCalculable: sizeCalculable_1,
  	mergeLayoutParam: mergeLayoutParam_1,
  	getLayoutParams: getLayoutParams_1,
  	copyLayoutParams: copyLayoutParams_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var _default$T = {
    getBoxLayoutParams: function () {
      return {
        left: this.get('left'),
        top: this.get('top'),
        right: this.get('right'),
        bottom: this.get('bottom'),
        width: this.get('width'),
        height: this.get('height')
      };
    }
  };
  var boxLayout$1 = _default$T;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  var enableClassManagement$1 = clazz.enableClassManagement;
  var parseClassType$2 = clazz.parseClassType;



  var makeInner$2 = model.makeInner;





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Component model
   *
   * @module echarts/model/Component
   */
  var inner$1 = makeInner$2();
  /**
   * @alias module:echarts/model/Component
   * @constructor
   * @param {Object} option
   * @param {module:echarts/model/Model} parentModel
   * @param {module:echarts/model/Model} ecModel
   */

  var ComponentModel = Model_1.extend({
    type: 'component',

    /**
     * @readOnly
     * @type {string}
     */
    id: '',

    /**
     * Because simplified concept is probably better, series.name (or component.name)
     * has been having too many resposibilities:
     * (1) Generating id (which requires name in option should not be modified).
     * (2) As an index to mapping series when merging option or calling API (a name
     * can refer to more then one components, which is convinient is some case).
     * (3) Display.
     * @readOnly
     */
    name: '',

    /**
     * @readOnly
     * @type {string}
     */
    mainType: '',

    /**
     * @readOnly
     * @type {string}
     */
    subType: '',

    /**
     * @readOnly
     * @type {number}
     */
    componentIndex: 0,

    /**
     * @type {Object}
     * @protected
     */
    defaultOption: null,

    /**
     * @type {module:echarts/model/Global}
     * @readOnly
     */
    ecModel: null,

    /**
     * key: componentType
     * value:  Component model list, can not be null.
     * @type {Object.<string, Array.<module:echarts/model/Model>>}
     * @readOnly
     */
    dependentModels: [],

    /**
     * @type {string}
     * @readOnly
     */
    uid: null,

    /**
     * Support merge layout params.
     * Only support 'box' now (left/right/top/bottom/width/height).
     * @type {string|Object} Object can be {ignoreSize: true}
     * @readOnly
     */
    layoutMode: null,
    $constructor: function (option, parentModel, ecModel, extraOpt) {
      Model_1.call(this, option, parentModel, ecModel, extraOpt);
      this.uid = component.getUID('ec_cpt_model');
    },
    init: function (option, parentModel, ecModel, extraOpt) {
      this.mergeDefaultAndTheme(option, ecModel);
    },
    mergeDefaultAndTheme: function (option, ecModel) {
      var layoutMode = this.layoutMode;
      var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
      var themeModel = ecModel.getTheme();
      util.merge(option, themeModel.get(this.mainType));
      util.merge(option, this.getDefaultOption());

      if (layoutMode) {
        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
      }
    },
    mergeOption: function (option, extraOpt) {
      util.merge(this.option, option, true);
      var layoutMode = this.layoutMode;

      if (layoutMode) {
        layout.mergeLayoutParam(this.option, option, layoutMode);
      }
    },
    // Hooker after init or mergeOption
    optionUpdated: function (newCptOption, isInit) {},
    getDefaultOption: function () {
      var fields = inner$1(this);

      if (!fields.defaultOption) {
        var optList = [];
        var Class = this.constructor;

        while (Class) {
          var opt = Class.prototype.defaultOption;
          opt && optList.push(opt);
          Class = Class.superClass;
        }

        var defaultOption = {};

        for (var i = optList.length - 1; i >= 0; i--) {
          defaultOption = util.merge(defaultOption, optList[i], true);
        }

        fields.defaultOption = defaultOption;
      }

      return fields.defaultOption;
    },
    getReferringComponents: function (mainType) {
      return this.ecModel.queryComponents({
        mainType: mainType,
        index: this.get(mainType + 'Index', true),
        id: this.get(mainType + 'Id', true)
      });
    }
  }); // Reset ComponentModel.extend, add preConstruct.
  // clazzUtil.enableClassExtend(
  //     ComponentModel,
  //     function (option, parentModel, ecModel, extraOpt) {
  //         // Set dependentModels, componentIndex, name, id, mainType, subType.
  //         zrUtil.extend(this, extraOpt);
  //         this.uid = componentUtil.getUID('componentModel');
  //         // this.setReadOnly([
  //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',
  //         //     'dependentModels', 'componentIndex'
  //         // ]);
  //     }
  // );
  // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

  enableClassManagement$1(ComponentModel, {
    registerWhenExtend: true
  });
  component.enableSubTypeDefaulter(ComponentModel); // Add capability of ComponentModel.topologicalTravel.

  component.enableTopologicalTravel(ComponentModel, getDependencies);

  function getDependencies(componentType) {
    var deps = [];
    util.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {
      deps = deps.concat(Clazz.prototype.dependencies || []);
    }); // Ensure main type.

    deps = util.map(deps, function (type) {
      return parseClassType$2(type).main;
    }); // Hack dataset for convenience.

    if (componentType !== 'dataset' && util.indexOf(deps, 'dataset') <= 0) {
      deps.unshift('dataset');
    }

    return deps;
  }

  util.mixin(ComponentModel, boxLayout$1);
  var _default$U = ComponentModel;
  var Component = _default$U;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var platform = ''; // Navigator not exists in node

  if (typeof navigator !== 'undefined') {
    platform = navigator.platform || '';
  }

  var _default$V = {
    // backgroundColor: 'rgba(0,0,0,0)',
    // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
    // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
    // Light colors:
    // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
    // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
    // Dark colors:
    color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'],
    gradientColor: ['#f6efa6', '#d88273', '#bf444c'],
    // If xAxis and yAxis declared, grid is created by default.
    // grid: {},
    textStyle: {
      // color: '#000',
      // decoration: 'none',
      // PENDING
      fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
      // fontFamily: 'Arial, Verdana, sans-serif',
      fontSize: 12,
      fontStyle: 'normal',
      fontWeight: 'normal'
    },
    // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
    // Default is source-over
    blendMode: null,
    animation: 'auto',
    animationDuration: 1000,
    animationDurationUpdate: 300,
    animationEasing: 'exponentialOut',
    animationEasingUpdate: 'cubicOut',
    animationThreshold: 2000,
    // Configuration for progressive/incremental rendering
    progressiveThreshold: 3000,
    progressive: 400,
    // Threshold of if use single hover layer to optimize.
    // It is recommended that `hoverLayerThreshold` is equivalent to or less than
    // `progressiveThreshold`, otherwise hover will cause restart of progressive,
    // which is unexpected.
    // see example <echarts/test/heatmap-large.html>.
    hoverLayerThreshold: 3000,
    // See: module:echarts/scale/Time
    useUTC: false
  };
  var globalDefault = _default$V;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var makeInner$3 = model.makeInner;
  var normalizeToArray$1 = model.normalizeToArray;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var inner$2 = makeInner$3();

  function getNearestColorPalette(colors, requestColorNum) {
    var paletteNum = colors.length; // TODO colors must be in order

    for (var i = 0; i < paletteNum; i++) {
      if (colors[i].length > requestColorNum) {
        return colors[i];
      }
    }

    return colors[paletteNum - 1];
  }

  var _default$W = {
    clearColorPalette: function () {
      inner$2(this).colorIdx = 0;
      inner$2(this).colorNameMap = {};
    },

    /**
     * @param {string} name MUST NOT be null/undefined. Otherwise call this function
     *                 twise with the same parameters will get different result.
     * @param {Object} [scope=this]
     * @param {Object} [requestColorNum]
     * @return {string} color string.
     */
    getColorFromPalette: function (name, scope, requestColorNum) {
      scope = scope || this;
      var scopeFields = inner$2(scope);
      var colorIdx = scopeFields.colorIdx || 0;
      var colorNameMap = scopeFields.colorNameMap = scopeFields.colorNameMap || {}; // Use `hasOwnProperty` to avoid conflict with Object.prototype.

      if (colorNameMap.hasOwnProperty(name)) {
        return colorNameMap[name];
      }

      var defaultColorPalette = normalizeToArray$1(this.get('color', true));
      var layeredColorPalette = this.get('colorLayer', true);
      var colorPalette = requestColorNum == null || !layeredColorPalette ? defaultColorPalette : getNearestColorPalette(layeredColorPalette, requestColorNum); // In case can't find in layered color palette.

      colorPalette = colorPalette || defaultColorPalette;

      if (!colorPalette || !colorPalette.length) {
        return;
      }

      var color = colorPalette[colorIdx];

      if (name) {
        colorNameMap[name] = color;
      }

      scopeFields.colorIdx = (colorIdx + 1) % colorPalette.length;
      return color;
    }
  };
  var colorPalette = _default$W;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Avoid typo.
  var SOURCE_FORMAT_ORIGINAL = 'original';
  var SOURCE_FORMAT_ARRAY_ROWS = 'arrayRows';
  var SOURCE_FORMAT_OBJECT_ROWS = 'objectRows';
  var SOURCE_FORMAT_KEYED_COLUMNS = 'keyedColumns';
  var SOURCE_FORMAT_UNKNOWN = 'unknown'; // ??? CHANGE A NAME

  var SOURCE_FORMAT_TYPED_ARRAY = 'typedArray';
  var SERIES_LAYOUT_BY_COLUMN = 'column';
  var SERIES_LAYOUT_BY_ROW = 'row';
  var SOURCE_FORMAT_ORIGINAL_1 = SOURCE_FORMAT_ORIGINAL;
  var SOURCE_FORMAT_ARRAY_ROWS_1 = SOURCE_FORMAT_ARRAY_ROWS;
  var SOURCE_FORMAT_OBJECT_ROWS_1 = SOURCE_FORMAT_OBJECT_ROWS;
  var SOURCE_FORMAT_KEYED_COLUMNS_1 = SOURCE_FORMAT_KEYED_COLUMNS;
  var SOURCE_FORMAT_UNKNOWN_1 = SOURCE_FORMAT_UNKNOWN;
  var SOURCE_FORMAT_TYPED_ARRAY_1 = SOURCE_FORMAT_TYPED_ARRAY;
  var SERIES_LAYOUT_BY_COLUMN_1 = SERIES_LAYOUT_BY_COLUMN;
  var SERIES_LAYOUT_BY_ROW_1 = SERIES_LAYOUT_BY_ROW;

  var sourceType = {
  	SOURCE_FORMAT_ORIGINAL: SOURCE_FORMAT_ORIGINAL_1,
  	SOURCE_FORMAT_ARRAY_ROWS: SOURCE_FORMAT_ARRAY_ROWS_1,
  	SOURCE_FORMAT_OBJECT_ROWS: SOURCE_FORMAT_OBJECT_ROWS_1,
  	SOURCE_FORMAT_KEYED_COLUMNS: SOURCE_FORMAT_KEYED_COLUMNS_1,
  	SOURCE_FORMAT_UNKNOWN: SOURCE_FORMAT_UNKNOWN_1,
  	SOURCE_FORMAT_TYPED_ARRAY: SOURCE_FORMAT_TYPED_ARRAY_1,
  	SERIES_LAYOUT_BY_COLUMN: SERIES_LAYOUT_BY_COLUMN_1,
  	SERIES_LAYOUT_BY_ROW: SERIES_LAYOUT_BY_ROW_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var createHashMap$1 = util.createHashMap;
  var isTypedArray$1 = util.isTypedArray;



  var enableClassCheck$2 = clazz.enableClassCheck;



  var SOURCE_FORMAT_ORIGINAL$1 = sourceType.SOURCE_FORMAT_ORIGINAL;
  var SERIES_LAYOUT_BY_COLUMN$1 = sourceType.SERIES_LAYOUT_BY_COLUMN;
  var SOURCE_FORMAT_UNKNOWN$1 = sourceType.SOURCE_FORMAT_UNKNOWN;
  var SOURCE_FORMAT_TYPED_ARRAY$1 = sourceType.SOURCE_FORMAT_TYPED_ARRAY;
  var SOURCE_FORMAT_KEYED_COLUMNS$1 = sourceType.SOURCE_FORMAT_KEYED_COLUMNS;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * [sourceFormat]
   *
   * + "original":
   * This format is only used in series.data, where
   * itemStyle can be specified in data item.
   *
   * + "arrayRows":
   * [
   *     ['product', 'score', 'amount'],
   *     ['Matcha Latte', 89.3, 95.8],
   *     ['Milk Tea', 92.1, 89.4],
   *     ['Cheese Cocoa', 94.4, 91.2],
   *     ['Walnut Brownie', 85.4, 76.9]
   * ]
   *
   * + "objectRows":
   * [
   *     {product: 'Matcha Latte', score: 89.3, amount: 95.8},
   *     {product: 'Milk Tea', score: 92.1, amount: 89.4},
   *     {product: 'Cheese Cocoa', score: 94.4, amount: 91.2},
   *     {product: 'Walnut Brownie', score: 85.4, amount: 76.9}
   * ]
   *
   * + "keyedColumns":
   * {
   *     'product': ['Matcha Latte', 'Milk Tea', 'Cheese Cocoa', 'Walnut Brownie'],
   *     'count': [823, 235, 1042, 988],
   *     'score': [95.8, 81.4, 91.2, 76.9]
   * }
   *
   * + "typedArray"
   *
   * + "unknown"
   */

  /**
   * @constructor
   * @param {Object} fields
   * @param {string} fields.sourceFormat
   * @param {Array|Object} fields.fromDataset
   * @param {Array|Object} [fields.data]
   * @param {string} [seriesLayoutBy='column']
   * @param {Array.<Object|string>} [dimensionsDefine]
   * @param {Objet|HashMap} [encodeDefine]
   * @param {number} [startIndex=0]
   * @param {number} [dimensionsDetectCount]
   */
  function Source(fields) {
    /**
     * @type {boolean}
     */
    this.fromDataset = fields.fromDataset;
    /**
     * Not null/undefined.
     * @type {Array|Object}
     */

    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS$1 ? {} : []);
    /**
     * See also "detectSourceFormat".
     * Not null/undefined.
     * @type {string}
     */

    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN$1;
    /**
     * 'row' or 'column'
     * Not null/undefined.
     * @type {string} seriesLayoutBy
     */

    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN$1;
    /**
     * dimensions definition in option.
     * can be null/undefined.
     * @type {Array.<Object|string>}
     */

    this.dimensionsDefine = fields.dimensionsDefine;
    /**
     * encode definition in option.
     * can be null/undefined.
     * @type {Objet|HashMap}
     */

    this.encodeDefine = fields.encodeDefine && createHashMap$1(fields.encodeDefine);
    /**
     * Not null/undefined, uint.
     * @type {number}
     */

    this.startIndex = fields.startIndex || 0;
    /**
     * Can be null/undefined (when unknown), uint.
     * @type {number}
     */

    this.dimensionsDetectCount = fields.dimensionsDetectCount;
  }
  /**
   * Wrap original series data for some compatibility cases.
   */


  Source.seriesDataToSource = function (data) {
    return new Source({
      data: data,
      sourceFormat: isTypedArray$1(data) ? SOURCE_FORMAT_TYPED_ARRAY$1 : SOURCE_FORMAT_ORIGINAL$1,
      fromDataset: false
    });
  };

  enableClassCheck$2(Source);
  var _default$X = Source;
  var Source_1 = _default$X;

  var makeInner$4 = model.makeInner;
  var getDataItemValue$1 = model.getDataItemValue;



  var createHashMap$2 = util.createHashMap;
  var each$4 = util.each;
  var map$1 = util.map;
  var isArray$4 = util.isArray;
  var isString$4 = util.isString;
  var isObject$6 = util.isObject;
  var isTypedArray$2 = util.isTypedArray;
  var isArrayLike$3 = util.isArrayLike;
  var extend$4 = util.extend;





  var SOURCE_FORMAT_ORIGINAL$2 = sourceType.SOURCE_FORMAT_ORIGINAL;
  var SOURCE_FORMAT_ARRAY_ROWS$1 = sourceType.SOURCE_FORMAT_ARRAY_ROWS;
  var SOURCE_FORMAT_OBJECT_ROWS$1 = sourceType.SOURCE_FORMAT_OBJECT_ROWS;
  var SOURCE_FORMAT_KEYED_COLUMNS$2 = sourceType.SOURCE_FORMAT_KEYED_COLUMNS;
  var SOURCE_FORMAT_UNKNOWN$2 = sourceType.SOURCE_FORMAT_UNKNOWN;
  var SOURCE_FORMAT_TYPED_ARRAY$2 = sourceType.SOURCE_FORMAT_TYPED_ARRAY;
  var SERIES_LAYOUT_BY_ROW$1 = sourceType.SERIES_LAYOUT_BY_ROW;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // The result of `guessOrdinal`.
  var BE_ORDINAL = {
    Must: 1,
    // Encounter string but not '-' and not number-like.
    Might: 2,
    // Encounter string but number-like.
    Not: 3 // Other cases

  };
  var inner$3 = makeInner$4();
  /**
   * @see {module:echarts/data/Source}
   * @param {module:echarts/component/dataset/DatasetModel} datasetModel
   * @return {string} sourceFormat
   */

  function detectSourceFormat(datasetModel) {
    var data = datasetModel.option.source;
    var sourceFormat = SOURCE_FORMAT_UNKNOWN$2;

    if (isTypedArray$2(data)) {
      sourceFormat = SOURCE_FORMAT_TYPED_ARRAY$2;
    } else if (isArray$4(data)) {
      // FIXME Whether tolerate null in top level array?
      if (data.length === 0) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS$1;
      }

      for (var i = 0, len = data.length; i < len; i++) {
        var item = data[i];

        if (item == null) {
          continue;
        } else if (isArray$4(item)) {
          sourceFormat = SOURCE_FORMAT_ARRAY_ROWS$1;
          break;
        } else if (isObject$6(item)) {
          sourceFormat = SOURCE_FORMAT_OBJECT_ROWS$1;
          break;
        }
      }
    } else if (isObject$6(data)) {
      for (var key in data) {
        if (data.hasOwnProperty(key) && isArrayLike$3(data[key])) {
          sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS$2;
          break;
        }
      }
    } else if (data != null) {
      throw new Error('Invalid data');
    }

    inner$3(datasetModel).sourceFormat = sourceFormat;
  }
  /**
   * [Scenarios]:
   * (1) Provide source data directly:
   *     series: {
   *         encode: {...},
   *         dimensions: [...]
   *         seriesLayoutBy: 'row',
   *         data: [[...]]
   *     }
   * (2) Refer to datasetModel.
   *     series: [{
   *         encode: {...}
   *         // Ignore datasetIndex means `datasetIndex: 0`
   *         // and the dimensions defination in dataset is used
   *     }, {
   *         encode: {...},
   *         seriesLayoutBy: 'column',
   *         datasetIndex: 1
   *     }]
   *
   * Get data from series itself or datset.
   * @return {module:echarts/data/Source} source
   */


  function getSource(seriesModel) {
    return inner$3(seriesModel).source;
  }
  /**
   * MUST be called before mergeOption of all series.
   * @param {module:echarts/model/Global} ecModel
   */


  function resetSourceDefaulter(ecModel) {
    // `datasetMap` is used to make default encode.
    inner$3(ecModel).datasetMap = createHashMap$2();
  }
  /**
   * [Caution]:
   * MUST be called after series option merged and
   * before "series.getInitailData()" called.
   *
   * [The rule of making default encode]:
   * Category axis (if exists) alway map to the first dimension.
   * Each other axis occupies a subsequent dimension.
   *
   * [Why make default encode]:
   * Simplify the typing of encode in option, avoiding the case like that:
   * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],
   * where the "y" have to be manually typed as "1, 2, 3, ...".
   *
   * @param {module:echarts/model/Series} seriesModel
   */


  function prepareSource(seriesModel) {
    var seriesOption = seriesModel.option;
    var data = seriesOption.data;
    var sourceFormat = isTypedArray$2(data) ? SOURCE_FORMAT_TYPED_ARRAY$2 : SOURCE_FORMAT_ORIGINAL$2;
    var fromDataset = false;
    var seriesLayoutBy = seriesOption.seriesLayoutBy;
    var sourceHeader = seriesOption.sourceHeader;
    var dimensionsDefine = seriesOption.dimensions;
    var datasetModel = getDatasetModel(seriesModel);

    if (datasetModel) {
      var datasetOption = datasetModel.option;
      data = datasetOption.source;
      sourceFormat = inner$3(datasetModel).sourceFormat;
      fromDataset = true; // These settings from series has higher priority.

      seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;
      sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);
      dimensionsDefine = dimensionsDefine || datasetOption.dimensions;
    }

    var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine);
    inner$3(seriesModel).source = new Source_1({
      data: data,
      fromDataset: fromDataset,
      seriesLayoutBy: seriesLayoutBy,
      sourceFormat: sourceFormat,
      dimensionsDefine: completeResult.dimensionsDefine,
      startIndex: completeResult.startIndex,
      dimensionsDetectCount: completeResult.dimensionsDetectCount,
      // Note: dataset option does not have `encode`.
      encodeDefine: seriesOption.encode
    });
  } // return {startIndex, dimensionsDefine, dimensionsCount}


  function completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
    if (!data) {
      return {
        dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)
      };
    }

    var dimensionsDetectCount;
    var startIndex;

    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS$1) {
      // Rule: Most of the first line are string: it is header.
      // Caution: consider a line with 5 string and 1 number,
      // it still can not be sure it is a head, because the
      // 5 string may be 5 values of category columns.
      if (sourceHeader === 'auto' || sourceHeader == null) {
        arrayRowsTravelFirst(function (val) {
          // '-' is regarded as null/undefined.
          if (val != null && val !== '-') {
            if (isString$4(val)) {
              startIndex == null && (startIndex = 1);
            } else {
              startIndex = 0;
            }
          } // 10 is an experience number, avoid long loop.

        }, seriesLayoutBy, data, 10);
      } else {
        startIndex = sourceHeader ? 1 : 0;
      }

      if (!dimensionsDefine && startIndex === 1) {
        dimensionsDefine = [];
        arrayRowsTravelFirst(function (val, index) {
          dimensionsDefine[index] = val != null ? val : '';
        }, seriesLayoutBy, data);
      }

      dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW$1 ? data.length : data[0] ? data[0].length : null;
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS$1) {
      if (!dimensionsDefine) {
        dimensionsDefine = objectRowsCollectDimensions(data);
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS$2) {
      if (!dimensionsDefine) {
        dimensionsDefine = [];
        each$4(data, function (colArr, key) {
          dimensionsDefine.push(key);
        });
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL$2) {
      var value0 = getDataItemValue$1(data[0]);
      dimensionsDetectCount = isArray$4(value0) && value0.length || 1;
    } else ;

    return {
      startIndex: startIndex,
      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),
      dimensionsDetectCount: dimensionsDetectCount
    };
  } // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],
  // which is reasonable. But dimension name is duplicated.
  // Returns undefined or an array contains only object without null/undefiend or string.


  function normalizeDimensionsDefine(dimensionsDefine) {
    if (!dimensionsDefine) {
      // The meaning of null/undefined is different from empty array.
      return;
    }

    var nameMap = createHashMap$2();
    return map$1(dimensionsDefine, function (item, index) {
      item = extend$4({}, isObject$6(item) ? item : {
        name: item
      }); // User can set null in dimensions.
      // We dont auto specify name, othewise a given name may
      // cause it be refered unexpectedly.

      if (item.name == null) {
        return item;
      } // Also consider number form like 2012.


      item.name += ''; // User may also specify displayName.
      // displayName will always exists except user not
      // specified or dim name is not specified or detected.
      // (A auto generated dim name will not be used as
      // displayName).

      if (item.displayName == null) {
        item.displayName = item.name;
      }

      var exist = nameMap.get(item.name);

      if (!exist) {
        nameMap.set(item.name, {
          count: 1
        });
      } else {
        item.name += '-' + exist.count++;
      }

      return item;
    });
  }

  function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
    maxLoop == null && (maxLoop = Infinity);

    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW$1) {
      for (var i = 0; i < data.length && i < maxLoop; i++) {
        cb(data[i] ? data[i][0] : null, i);
      }
    } else {
      var value0 = data[0] || [];

      for (var i = 0; i < value0.length && i < maxLoop; i++) {
        cb(value0[i], i);
      }
    }
  }

  function objectRowsCollectDimensions(data) {
    var firstIndex = 0;
    var obj;

    while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line


    if (obj) {
      var dimensions = [];
      each$4(obj, function (value, key) {
        dimensions.push(key);
      });
      return dimensions;
    }
  }
  /**
   * [The strategy of the arrengment of data dimensions for dataset]:
   * "value way": all axes are non-category axes. So series one by one take
   *     several (the number is coordSysDims.length) dimensions from dataset.
   *     The result of data arrengment of data dimensions like:
   *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |
   * "category way": at least one axis is category axis. So the the first data
   *     dimension is always mapped to the first category axis and shared by
   *     all of the series. The other data dimensions are taken by series like
   *     "value way" does.
   *     The result of data arrengment of data dimensions like:
   *     | ser_shared_x | ser0_y | ser1_y | ser2_y |
   *
   * @param {Array.<Object|string>} coordDimensions [{name: <string>, type: <string>, dimsDef: <Array>}, ...]
   * @param {module:model/Series} seriesModel
   * @param {module:data/Source} source
   * @return {Object} encode Never be `null/undefined`.
   */


  function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
    var encode = {};
    var datasetModel = getDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.

    if (!datasetModel || !coordDimensions) {
      return encode;
    }

    var encodeItemName = [];
    var encodeSeriesName = [];
    var ecModel = seriesModel.ecModel;
    var datasetMap = inner$3(ecModel).datasetMap;
    var key = datasetModel.uid + '_' + source.seriesLayoutBy;
    var baseCategoryDimIndex;
    var categoryWayValueDimStart;
    coordDimensions = coordDimensions.slice();
    each$4(coordDimensions, function (coordDimInfo, coordDimIdx) {
      !isObject$6(coordDimInfo) && (coordDimensions[coordDimIdx] = {
        name: coordDimInfo
      });

      if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {
        baseCategoryDimIndex = coordDimIdx;
        categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimensions[coordDimIdx]);
      }

      encode[coordDimInfo.name] = [];
    });
    var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
      categoryWayDim: categoryWayValueDimStart,
      valueWayDim: 0
    }); // TODO
    // Auto detect first time axis and do arrangement.

    each$4(coordDimensions, function (coordDimInfo, coordDimIdx) {
      var coordDimName = coordDimInfo.name;
      var count = getDataDimCountOnCoordDim(coordDimInfo); // In value way.

      if (baseCategoryDimIndex == null) {
        var start = datasetRecord.valueWayDim;
        pushDim(encode[coordDimName], start, count);
        pushDim(encodeSeriesName, start, count);
        datasetRecord.valueWayDim += count; // ??? TODO give a better default series name rule?
        // especially when encode x y specified.
        // consider: when mutiple series share one dimension
        // category axis, series name should better use
        // the other dimsion name. On the other hand, use
        // both dimensions name.
      } // In category way, the first category axis.
      else if (baseCategoryDimIndex === coordDimIdx) {
          pushDim(encode[coordDimName], 0, count);
          pushDim(encodeItemName, 0, count);
        } // In category way, the other axis.
        else {
            var start = datasetRecord.categoryWayDim;
            pushDim(encode[coordDimName], start, count);
            pushDim(encodeSeriesName, start, count);
            datasetRecord.categoryWayDim += count;
          }
    });

    function pushDim(dimIdxArr, idxFrom, idxCount) {
      for (var i = 0; i < idxCount; i++) {
        dimIdxArr.push(idxFrom + i);
      }
    }

    function getDataDimCountOnCoordDim(coordDimInfo) {
      var dimsDef = coordDimInfo.dimsDef;
      return dimsDef ? dimsDef.length : 1;
    }

    encodeItemName.length && (encode.itemName = encodeItemName);
    encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
    return encode;
  }
  /**
   * Work for data like [{name: ..., value: ...}, ...].
   *
   * @param {module:model/Series} seriesModel
   * @param {module:data/Source} source
   * @return {Object} encode Never be `null/undefined`.
   */


  function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
    var encode = {};
    var datasetModel = getDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.

    if (!datasetModel) {
      return encode;
    }

    var sourceFormat = source.sourceFormat;
    var dimensionsDefine = source.dimensionsDefine;
    var potentialNameDimIndex;

    if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS$1 || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS$2) {
      each$4(dimensionsDefine, function (dim, idx) {
        if ((isObject$6(dim) ? dim.name : dim) === 'name') {
          potentialNameDimIndex = idx;
        }
      });
    } // idxResult: {v, n}.


    var idxResult = function () {
      var idxRes0 = {};
      var idxRes1 = {};
      var guessRecords = []; // 5 is an experience value.

      for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {
        var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
        guessRecords.push(guessResult);
        var isPureNumber = guessResult === BE_ORDINAL.Not; // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,
        // and then find a name dim with the priority:
        // "BE_ORDINAL.Might|BE_ORDINAL.Must" > "other dim" > "the value dim itself".

        if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
          idxRes0.v = i;
        }

        if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
          idxRes0.n = i;
        }

        if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
          return idxRes0;
        } // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),
        // find the first BE_ORDINAL.Might as the value dim,
        // and then find a name dim with the priority:
        // "other dim" > "the value dim itself".
        // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be
        // treated as number.


        if (!isPureNumber) {
          if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
            idxRes1.v = i;
          }

          if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
            idxRes1.n = i;
          }
        }
      }

      function fulfilled(idxResult) {
        return idxResult.v != null && idxResult.n != null;
      }

      return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
    }();

    if (idxResult) {
      encode.value = idxResult.v; // `potentialNameDimIndex` has highest priority.

      var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n; // By default, label use itemName in charts.
      // So we dont set encodeLabel here.

      encode.itemName = [nameDimIndex];
      encode.seriesName = [nameDimIndex];
    }

    return encode;
  }
  /**
   * If return null/undefined, indicate that should not use datasetModel.
   */


  function getDatasetModel(seriesModel) {
    var option = seriesModel.option; // Caution: consider the scenario:
    // A dataset is declared and a series is not expected to use the dataset,
    // and at the beginning `setOption({series: { noData })` (just prepare other
    // option but no data), then `setOption({series: {data: [...]}); In this case,
    // the user should set an empty array to avoid that dataset is used by default.

    var thisData = option.data;

    if (!thisData) {
      return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);
    }
  }
  /**
   * The rule should not be complex, otherwise user might not
   * be able to known where the data is wrong.
   * The code is ugly, but how to make it neat?
   *
   * @param {module:echars/data/Source} source
   * @param {number} dimIndex
   * @return {BE_ORDINAL} guess result.
   */


  function guessOrdinal(source, dimIndex) {
    return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
  } // dimIndex may be overflow source data.
  // return {BE_ORDINAL}


  function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
    var result; // Experience value.

    var maxLoop = 5;

    if (isTypedArray$2(data)) {
      return BE_ORDINAL.Not;
    } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine
    // always exists in source.


    var dimName;
    var dimType;

    if (dimensionsDefine) {
      var dimDefItem = dimensionsDefine[dimIndex];

      if (isObject$6(dimDefItem)) {
        dimName = dimDefItem.name;
        dimType = dimDefItem.type;
      } else if (isString$4(dimDefItem)) {
        dimName = dimDefItem;
      }
    }

    if (dimType != null) {
      return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;
    }

    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS$1) {
      if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW$1) {
        var sample = data[dimIndex];

        for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
          if ((result = detectValue(sample[startIndex + i])) != null) {
            return result;
          }
        }
      } else {
        for (var i = 0; i < data.length && i < maxLoop; i++) {
          var row = data[startIndex + i];

          if (row && (result = detectValue(row[dimIndex])) != null) {
            return result;
          }
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS$1) {
      if (!dimName) {
        return BE_ORDINAL.Not;
      }

      for (var i = 0; i < data.length && i < maxLoop; i++) {
        var item = data[i];

        if (item && (result = detectValue(item[dimName])) != null) {
          return result;
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS$2) {
      if (!dimName) {
        return BE_ORDINAL.Not;
      }

      var sample = data[dimName];

      if (!sample || isTypedArray$2(sample)) {
        return BE_ORDINAL.Not;
      }

      for (var i = 0; i < sample.length && i < maxLoop; i++) {
        if ((result = detectValue(sample[i])) != null) {
          return result;
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL$2) {
      for (var i = 0; i < data.length && i < maxLoop; i++) {
        var item = data[i];
        var val = getDataItemValue$1(item);

        if (!isArray$4(val)) {
          return BE_ORDINAL.Not;
        }

        if ((result = detectValue(val[dimIndex])) != null) {
          return result;
        }
      }
    }

    function detectValue(val) {
      var beStr = isString$4(val); // Consider usage convenience, '1', '2' will be treated as "number".
      // `isFinit('')` get `true`.

      if (val != null && isFinite(val) && val !== '') {
        return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
      } else if (beStr && val !== '-') {
        return BE_ORDINAL.Must;
      }
    }

    return BE_ORDINAL.Not;
  }

  var BE_ORDINAL_1 = BE_ORDINAL;
  var detectSourceFormat_1 = detectSourceFormat;
  var getSource_1 = getSource;
  var resetSourceDefaulter_1 = resetSourceDefaulter;
  var prepareSource_1 = prepareSource;
  var makeSeriesEncodeForAxisCoordSys_1 = makeSeriesEncodeForAxisCoordSys;
  var makeSeriesEncodeForNameBased_1 = makeSeriesEncodeForNameBased;
  var guessOrdinal_1 = guessOrdinal;

  var sourceHelper = {
  	BE_ORDINAL: BE_ORDINAL_1,
  	detectSourceFormat: detectSourceFormat_1,
  	getSource: getSource_1,
  	resetSourceDefaulter: resetSourceDefaulter_1,
  	prepareSource: prepareSource_1,
  	makeSeriesEncodeForAxisCoordSys: makeSeriesEncodeForAxisCoordSys_1,
  	makeSeriesEncodeForNameBased: makeSeriesEncodeForNameBased_1,
  	guessOrdinal: guessOrdinal_1
  };

  var each$5 = util.each;
  var filter$1 = util.filter;
  var map$2 = util.map;
  var isArray$5 = util.isArray;
  var indexOf$3 = util.indexOf;
  var isObject$7 = util.isObject;
  var isString$5 = util.isString;
  var createHashMap$3 = util.createHashMap;
  var assert$1 = util.assert;
  var clone$4 = util.clone;
  var merge$1 = util.merge;
  var extend$5 = util.extend;
  var mixin$2 = util.mixin;













  var resetSourceDefaulter$1 = sourceHelper.resetSourceDefaulter;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * ECharts global model
   *
   * @module {echarts/model/Global}
   */

  /**
   * Caution: If the mechanism should be changed some day, these cases
   * should be considered:
   *
   * (1) In `merge option` mode, if using the same option to call `setOption`
   * many times, the result should be the same (try our best to ensure that).
   * (2) In `merge option` mode, if a component has no id/name specified, it
   * will be merged by index, and the result sequence of the components is
   * consistent to the original sequence.
   * (3) `reset` feature (in toolbox). Find detailed info in comments about
   * `mergeOption` in module:echarts/model/OptionManager.
   */
  var OPTION_INNER_KEY = '\0_ec_inner';
  /**
   * @alias module:echarts/model/Global
   *
   * @param {Object} option
   * @param {module:echarts/model/Model} parentModel
   * @param {Object} theme
   */

  var GlobalModel = Model_1.extend({
    init: function (option, parentModel, theme, optionManager) {
      theme = theme || {};
      this.option = null; // Mark as not initialized.

      /**
       * @type {module:echarts/model/Model}
       * @private
       */

      this._theme = new Model_1(theme);
      /**
       * @type {module:echarts/model/OptionManager}
       */

      this._optionManager = optionManager;
    },
    setOption: function (option, optionPreprocessorFuncs) {
      assert$1(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');

      this._optionManager.setOption(option, optionPreprocessorFuncs);

      this.resetOption(null);
    },

    /**
     * @param {string} type null/undefined: reset all.
     *                      'recreate': force recreate all.
     *                      'timeline': only reset timeline option
     *                      'media': only reset media query option
     * @return {boolean} Whether option changed.
     */
    resetOption: function (type) {
      var optionChanged = false;
      var optionManager = this._optionManager;

      if (!type || type === 'recreate') {
        var baseOption = optionManager.mountOption(type === 'recreate');

        if (!this.option || type === 'recreate') {
          initBase.call(this, baseOption);
        } else {
          this.restoreData();
          this.mergeOption(baseOption);
        }

        optionChanged = true;
      }

      if (type === 'timeline' || type === 'media') {
        this.restoreData();
      }

      if (!type || type === 'recreate' || type === 'timeline') {
        var timelineOption = optionManager.getTimelineOption(this);
        timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
      }

      if (!type || type === 'recreate' || type === 'media') {
        var mediaOptions = optionManager.getMediaOption(this, this._api);

        if (mediaOptions.length) {
          each$5(mediaOptions, function (mediaOption) {
            this.mergeOption(mediaOption, optionChanged = true);
          }, this);
        }
      }

      return optionChanged;
    },

    /**
     * @protected
     */
    mergeOption: function (newOption) {
      var option = this.option;
      var componentsMap = this._componentsMap;
      var newCptTypes = [];
      resetSourceDefaulter$1(this); // If no component class, merge directly.
      // For example: color, animaiton options, etc.

      each$5(newOption, function (componentOption, mainType) {
        if (componentOption == null) {
          return;
        }

        if (!Component.hasClass(mainType)) {
          // globalSettingTask.dirty();
          option[mainType] = option[mainType] == null ? clone$4(componentOption) : merge$1(option[mainType], componentOption, true);
        } else if (mainType) {
          newCptTypes.push(mainType);
        }
      });
      Component.topologicalTravel(newCptTypes, Component.getAllClassMainTypes(), visitComponent, this);

      function visitComponent(mainType, dependencies) {
        var newCptOptionList = model.normalizeToArray(newOption[mainType]);
        var mapResult = model.mappingToExists(componentsMap.get(mainType), newCptOptionList);
        model.makeIdAndName(mapResult); // Set mainType and complete subType.

        each$5(mapResult, function (item, index) {
          var opt = item.option;

          if (isObject$7(opt)) {
            item.keyInfo.mainType = mainType;
            item.keyInfo.subType = determineSubType(mainType, opt, item.exist);
          }
        });
        var dependentModels = getComponentsByTypes(componentsMap, dependencies);
        option[mainType] = [];
        componentsMap.set(mainType, []);
        each$5(mapResult, function (resultItem, index) {
          var componentModel = resultItem.exist;
          var newCptOption = resultItem.option;
          assert$1(isObject$7(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},
          // see removeEdgeAndAdd in topologicalTravel and
          // ComponentModel.getAllClassMainTypes.

          if (!newCptOption) {
            componentModel.mergeOption({}, this);
            componentModel.optionUpdated({}, false);
          } else {
            var ComponentModelClass = Component.getClass(mainType, resultItem.keyInfo.subType, true);

            if (componentModel && componentModel.constructor === ComponentModelClass) {
              componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();

              componentModel.mergeOption(newCptOption, this);
              componentModel.optionUpdated(newCptOption, false);
            } else {
              // PENDING Global as parent ?
              var extraOpt = extend$5({
                dependentModels: dependentModels,
                componentIndex: index
              }, resultItem.keyInfo);
              componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);
              extend$5(componentModel, extraOpt);
              componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.
              // newCptOption has been used as componentModel.option
              // and may be merged with theme and default, so pass null
              // to avoid confusion.

              componentModel.optionUpdated(null, true);
            }
          }

          componentsMap.get(mainType)[index] = componentModel;
          option[mainType][index] = componentModel.option;
        }, this); // Backup series for filtering.

        if (mainType === 'series') {
          createSeriesIndices(this, componentsMap.get('series'));
        }
      }

      this._seriesIndicesMap = createHashMap$3(this._seriesIndices = this._seriesIndices || []);
    },

    /**
     * Get option for output (cloned option and inner info removed)
     * @public
     * @return {Object}
     */
    getOption: function () {
      var option = clone$4(this.option);
      each$5(option, function (opts, mainType) {
        if (Component.hasClass(mainType)) {
          var opts = model.normalizeToArray(opts);

          for (var i = opts.length - 1; i >= 0; i--) {
            // Remove options with inner id.
            if (model.isIdInner(opts[i])) {
              opts.splice(i, 1);
            }
          }

          option[mainType] = opts;
        }
      });
      delete option[OPTION_INNER_KEY];
      return option;
    },

    /**
     * @return {module:echarts/model/Model}
     */
    getTheme: function () {
      return this._theme;
    },

    /**
     * @param {string} mainType
     * @param {number} [idx=0]
     * @return {module:echarts/model/Component}
     */
    getComponent: function (mainType, idx) {
      var list = this._componentsMap.get(mainType);

      if (list) {
        return list[idx || 0];
      }
    },

    /**
     * If none of index and id and name used, return all components with mainType.
     * @param {Object} condition
     * @param {string} condition.mainType
     * @param {string} [condition.subType] If ignore, only query by mainType
     * @param {number|Array.<number>} [condition.index] Either input index or id or name.
     * @param {string|Array.<string>} [condition.id] Either input index or id or name.
     * @param {string|Array.<string>} [condition.name] Either input index or id or name.
     * @return {Array.<module:echarts/model/Component>}
     */
    queryComponents: function (condition) {
      var mainType = condition.mainType;

      if (!mainType) {
        return [];
      }

      var index = condition.index;
      var id = condition.id;
      var name = condition.name;

      var cpts = this._componentsMap.get(mainType);

      if (!cpts || !cpts.length) {
        return [];
      }

      var result;

      if (index != null) {
        if (!isArray$5(index)) {
          index = [index];
        }

        result = filter$1(map$2(index, function (idx) {
          return cpts[idx];
        }), function (val) {
          return !!val;
        });
      } else if (id != null) {
        var isIdArray = isArray$5(id);
        result = filter$1(cpts, function (cpt) {
          return isIdArray && indexOf$3(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
        });
      } else if (name != null) {
        var isNameArray = isArray$5(name);
        result = filter$1(cpts, function (cpt) {
          return isNameArray && indexOf$3(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;
        });
      } else {
        // Return all components with mainType
        result = cpts.slice();
      }

      return filterBySubType(result, condition);
    },

    /**
     * The interface is different from queryComponents,
     * which is convenient for inner usage.
     *
     * @usage
     * var result = findComponents(
     *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
     * );
     * var result = findComponents(
     *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
     * );
     * var result = findComponents(
     *     {mainType: 'series',
     *     filter: function (model, index) {...}}
     * );
     * // result like [component0, componnet1, ...]
     *
     * @param {Object} condition
     * @param {string} condition.mainType Mandatory.
     * @param {string} [condition.subType] Optional.
     * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
     *        where xxx is mainType.
     *        If query attribute is null/undefined or has no index/id/name,
     *        do not filtering by query conditions, which is convenient for
     *        no-payload situations or when target of action is global.
     * @param {Function} [condition.filter] parameter: component, return boolean.
     * @return {Array.<module:echarts/model/Component>}
     */
    findComponents: function (condition) {
      var query = condition.query;
      var mainType = condition.mainType;
      var queryCond = getQueryCond(query);
      var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);
      return doFilter(filterBySubType(result, condition));

      function getQueryCond(q) {
        var indexAttr = mainType + 'Index';
        var idAttr = mainType + 'Id';
        var nameAttr = mainType + 'Name';
        return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
          mainType: mainType,
          // subType will be filtered finally.
          index: q[indexAttr],
          id: q[idAttr],
          name: q[nameAttr]
        } : null;
      }

      function doFilter(res) {
        return condition.filter ? filter$1(res, condition.filter) : res;
      }
    },

    /**
     * @usage
     * eachComponent('legend', function (legendModel, index) {
     *     ...
     * });
     * eachComponent(function (componentType, model, index) {
     *     // componentType does not include subType
     *     // (componentType is 'xxx' but not 'xxx.aa')
     * });
     * eachComponent(
     *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
     *     function (model, index) {...}
     * );
     * eachComponent(
     *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
     *     function (model, index) {...}
     * );
     *
     * @param {string|Object=} mainType When mainType is object, the definition
     *                                  is the same as the method 'findComponents'.
     * @param {Function} cb
     * @param {*} context
     */
    eachComponent: function (mainType, cb, context) {
      var componentsMap = this._componentsMap;

      if (typeof mainType === 'function') {
        context = cb;
        cb = mainType;
        componentsMap.each(function (components, componentType) {
          each$5(components, function (component, index) {
            cb.call(context, componentType, component, index);
          });
        });
      } else if (isString$5(mainType)) {
        each$5(componentsMap.get(mainType), cb, context);
      } else if (isObject$7(mainType)) {
        var queryResult = this.findComponents(mainType);
        each$5(queryResult, cb, context);
      }
    },

    /**
     * @param {string} name
     * @return {Array.<module:echarts/model/Series>}
     */
    getSeriesByName: function (name) {
      var series = this._componentsMap.get('series');

      return filter$1(series, function (oneSeries) {
        return oneSeries.name === name;
      });
    },

    /**
     * @param {number} seriesIndex
     * @return {module:echarts/model/Series}
     */
    getSeriesByIndex: function (seriesIndex) {
      return this._componentsMap.get('series')[seriesIndex];
    },

    /**
     * Get series list before filtered by type.
     * FIXME: rename to getRawSeriesByType?
     *
     * @param {string} subType
     * @return {Array.<module:echarts/model/Series>}
     */
    getSeriesByType: function (subType) {
      var series = this._componentsMap.get('series');

      return filter$1(series, function (oneSeries) {
        return oneSeries.subType === subType;
      });
    },

    /**
     * @return {Array.<module:echarts/model/Series>}
     */
    getSeries: function () {
      return this._componentsMap.get('series').slice();
    },

    /**
     * @return {number}
     */
    getSeriesCount: function () {
      return this._componentsMap.get('series').length;
    },

    /**
     * After filtering, series may be different
     * frome raw series.
     *
     * @param {Function} cb
     * @param {*} context
     */
    eachSeries: function (cb, context) {
      each$5(this._seriesIndices, function (rawSeriesIndex) {
        var series = this._componentsMap.get('series')[rawSeriesIndex];

        cb.call(context, series, rawSeriesIndex);
      }, this);
    },

    /**
     * Iterate raw series before filtered.
     *
     * @param {Function} cb
     * @param {*} context
     */
    eachRawSeries: function (cb, context) {
      each$5(this._componentsMap.get('series'), cb, context);
    },

    /**
     * After filtering, series may be different.
     * frome raw series.
     *
     * @param {string} subType.
     * @param {Function} cb
     * @param {*} context
     */
    eachSeriesByType: function (subType, cb, context) {
      each$5(this._seriesIndices, function (rawSeriesIndex) {
        var series = this._componentsMap.get('series')[rawSeriesIndex];

        if (series.subType === subType) {
          cb.call(context, series, rawSeriesIndex);
        }
      }, this);
    },

    /**
     * Iterate raw series before filtered of given type.
     *
     * @parma {string} subType
     * @param {Function} cb
     * @param {*} context
     */
    eachRawSeriesByType: function (subType, cb, context) {
      return each$5(this.getSeriesByType(subType), cb, context);
    },

    /**
     * @param {module:echarts/model/Series} seriesModel
     */
    isSeriesFiltered: function (seriesModel) {
      return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
    },

    /**
     * @return {Array.<number>}
     */
    getCurrentSeriesIndices: function () {
      return (this._seriesIndices || []).slice();
    },

    /**
     * @param {Function} cb
     * @param {*} context
     */
    filterSeries: function (cb, context) {
      var filteredSeries = filter$1(this._componentsMap.get('series'), cb, context);
      createSeriesIndices(this, filteredSeries);
    },
    restoreData: function (payload) {
      var componentsMap = this._componentsMap;
      createSeriesIndices(this, componentsMap.get('series'));
      var componentTypes = [];
      componentsMap.each(function (components, componentType) {
        componentTypes.push(componentType);
      });
      Component.topologicalTravel(componentTypes, Component.getAllClassMainTypes(), function (componentType, dependencies) {
        each$5(componentsMap.get(componentType), function (component) {
          (componentType !== 'series' || !isNotTargetSeries(component, payload)) && component.restoreData();
        });
      });
    }
  });

  function isNotTargetSeries(seriesModel, payload) {
    if (payload) {
      var index = payload.seiresIndex;
      var id = payload.seriesId;
      var name = payload.seriesName;
      return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;
    }
  }
  /**
   * @inner
   */


  function mergeTheme(option, theme) {
    // PENDING
    // NOT use `colorLayer` in theme if option has `color`
    var notMergeColorLayer = option.color && !option.colorLayer;
    each$5(theme, function (themeItem, name) {
      if (name === 'colorLayer' && notMergeColorLayer) {
        return;
      } // å¦ææ component model åæå·ä½ç merge é»è¾äº¤ç»è¯¥ model å¤ç


      if (!Component.hasClass(name)) {
        if (typeof themeItem === 'object') {
          option[name] = !option[name] ? clone$4(themeItem) : merge$1(option[name], themeItem, false);
        } else {
          if (option[name] == null) {
            option[name] = themeItem;
          }
        }
      }
    });
  }

  function initBase(baseOption) {
    baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,
    // i.e. `chart.setOption(chart.getModel().option);` is forbiden.

    this.option = {};
    this.option[OPTION_INNER_KEY] = 1;
    /**
     * Init with series: [], in case of calling findSeries method
     * before series initialized.
     * @type {Object.<string, Array.<module:echarts/model/Model>>}
     * @private
     */

    this._componentsMap = createHashMap$3({
      series: []
    });
    /**
     * Mapping between filtered series list and raw series list.
     * key: filtered series indices, value: raw series indices.
     * @type {Array.<nubmer>}
     * @private
     */

    this._seriesIndices;
    this._seriesIndicesMap;
    mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property

    merge$1(baseOption, globalDefault, false);
    this.mergeOption(baseOption);
  }
  /**
   * @inner
   * @param {Array.<string>|string} types model types
   * @return {Object} key: {string} type, value: {Array.<Object>} models
   */


  function getComponentsByTypes(componentsMap, types) {
    if (!isArray$5(types)) {
      types = types ? [types] : [];
    }

    var ret = {};
    each$5(types, function (type) {
      ret[type] = (componentsMap.get(type) || []).slice();
    });
    return ret;
  }
  /**
   * @inner
   */


  function determineSubType(mainType, newCptOption, existComponent) {
    var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.
    : Component.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType

    return subType;
  }
  /**
   * @inner
   */


  function createSeriesIndices(ecModel, seriesModels) {
    ecModel._seriesIndicesMap = createHashMap$3(ecModel._seriesIndices = map$2(seriesModels, function (series) {
      return series.componentIndex;
    }) || []);
  }
  /**
   * @inner
   */


  function filterBySubType(components, condition) {
    // Using hasOwnProperty for restrict. Consider
    // subType is undefined in user payload.
    return condition.hasOwnProperty('subType') ? filter$1(components, function (cpt) {
      return cpt.subType === condition.subType;
    }) : components;
  }

  mixin$2(GlobalModel, colorPalette);
  var _default$Y = GlobalModel;
  var Global = _default$Y;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var echartsAPIList = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel']; // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js

  function ExtensionAPI(chartInstance) {
    util.each(echartsAPIList, function (name) {
      this[name] = util.bind(chartInstance[name], chartInstance);
    }, this);
  }

  var _default$Z = ExtensionAPI;
  var ExtensionAPI_1 = _default$Z;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var coordinateSystemCreators = {};

  function CoordinateSystemManager() {
    this._coordinateSystems = [];
  }

  CoordinateSystemManager.prototype = {
    constructor: CoordinateSystemManager,
    create: function (ecModel, api) {
      var coordinateSystems = [];
      util.each(coordinateSystemCreators, function (creater, type) {
        var list = creater.create(ecModel, api);
        coordinateSystems = coordinateSystems.concat(list || []);
      });
      this._coordinateSystems = coordinateSystems;
    },
    update: function (ecModel, api) {
      util.each(this._coordinateSystems, function (coordSys) {
        coordSys.update && coordSys.update(ecModel, api);
      });
    },
    getCoordinateSystems: function () {
      return this._coordinateSystems.slice();
    }
  };

  CoordinateSystemManager.register = function (type, coordinateSystemCreator) {
    coordinateSystemCreators[type] = coordinateSystemCreator;
  };

  CoordinateSystemManager.get = function (type) {
    return coordinateSystemCreators[type];
  };

  var _default$_ = CoordinateSystemManager;
  var CoordinateSystem = _default$_;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * ECharts option manager
   *
   * @module {echarts/model/OptionManager}
   */
  var each$6 = util.each;
  var clone$5 = util.clone;
  var map$3 = util.map;
  var merge$2 = util.merge;
  var QUERY_REG = /^(min|max)?(.+)$/;
  /**
   * TERM EXPLANATIONS:
   *
   * [option]:
   *
   *     An object that contains definitions of components. For example:
   *     var option = {
   *         title: {...},
   *         legend: {...},
   *         visualMap: {...},
   *         series: [
   *             {data: [...]},
   *             {data: [...]},
   *             ...
   *         ]
   *     };
   *
   * [rawOption]:
   *
   *     An object input to echarts.setOption. 'rawOption' may be an
   *     'option', or may be an object contains multi-options. For example:
   *     var option = {
   *         baseOption: {
   *             title: {...},
   *             legend: {...},
   *             series: [
   *                 {data: [...]},
   *                 {data: [...]},
   *                 ...
   *             ]
   *         },
   *         timeline: {...},
   *         options: [
   *             {title: {...}, series: {data: [...]}},
   *             {title: {...}, series: {data: [...]}},
   *             ...
   *         ],
   *         media: [
   *             {
   *                 query: {maxWidth: 320},
   *                 option: {series: {x: 20}, visualMap: {show: false}}
   *             },
   *             {
   *                 query: {minWidth: 320, maxWidth: 720},
   *                 option: {series: {x: 500}, visualMap: {show: true}}
   *             },
   *             {
   *                 option: {series: {x: 1200}, visualMap: {show: true}}
   *             }
   *         ]
   *     };
   *
   * @alias module:echarts/model/OptionManager
   * @param {module:echarts/ExtensionAPI} api
   */

  function OptionManager(api) {
    /**
     * @private
     * @type {module:echarts/ExtensionAPI}
     */
    this._api = api;
    /**
     * @private
     * @type {Array.<number>}
     */

    this._timelineOptions = [];
    /**
     * @private
     * @type {Array.<Object>}
     */

    this._mediaList = [];
    /**
     * @private
     * @type {Object}
     */

    this._mediaDefault;
    /**
     * -1, means default.
     * empty means no media.
     * @private
     * @type {Array.<number>}
     */

    this._currentMediaIndices = [];
    /**
     * @private
     * @type {Object}
     */

    this._optionBackup;
    /**
     * @private
     * @type {Object}
     */

    this._newBaseOption;
  } // timeline.notMerge is not supported in ec3. Firstly there is rearly
  // case that notMerge is needed. Secondly supporting 'notMerge' requires
  // rawOption cloned and backuped when timeline changed, which does no
  // good to performance. What's more, that both timeline and setOption
  // method supply 'notMerge' brings complex and some problems.
  // Consider this case:
  // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
  // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);


  OptionManager.prototype = {
    constructor: OptionManager,

    /**
     * @public
     * @param {Object} rawOption Raw option.
     * @param {module:echarts/model/Global} ecModel
     * @param {Array.<Function>} optionPreprocessorFuncs
     * @return {Object} Init option
     */
    setOption: function (rawOption, optionPreprocessorFuncs) {
      if (rawOption) {
        // That set dat primitive is dangerous if user reuse the data when setOption again.
        util.each(model.normalizeToArray(rawOption.series), function (series) {
          series && series.data && util.isTypedArray(series.data) && util.setAsPrimitive(series.data);
        });
      } // Caution: some series modify option data, if do not clone,
      // it should ensure that the repeat modify correctly
      // (create a new object when modify itself).


      rawOption = clone$5(rawOption); // FIXME
      // å¦æ timeline options æè media ä¸­è®¾ç½®äºæä¸ªå±æ§ï¼èbaseOptionä¸­æ²¡æè®¾ç½®ï¼åè¿è¡è­¦åã

      var oldOptionBackup = this._optionBackup;
      var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
      this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);

      if (oldOptionBackup) {
        // Only baseOption can be merged.
        mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,
        // that is, if you `setOption` twice and both has timeline options, the latter
        // timeline opitons will not be merged to the formers, but just substitude them.

        if (newParsedOption.timelineOptions.length) {
          oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
        }

        if (newParsedOption.mediaList.length) {
          oldOptionBackup.mediaList = newParsedOption.mediaList;
        }

        if (newParsedOption.mediaDefault) {
          oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
        }
      } else {
        this._optionBackup = newParsedOption;
      }
    },

    /**
     * @param {boolean} isRecreate
     * @return {Object}
     */
    mountOption: function (isRecreate) {
      var optionBackup = this._optionBackup; // TODO
      // å¦ææ²¡æresetåè½åä¸cloneã

      this._timelineOptions = map$3(optionBackup.timelineOptions, clone$5);
      this._mediaList = map$3(optionBackup.mediaList, clone$5);
      this._mediaDefault = clone$5(optionBackup.mediaDefault);
      this._currentMediaIndices = [];
      return clone$5(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`
      // called, and is merged into every new option by inner method `mergeOption`
      // each time `setOption` called, can be only used in `isRecreate`, because
      // its reliability is under suspicion. In other cases option merge is
      // performed by `model.mergeOption`.
      ? optionBackup.baseOption : this._newBaseOption);
    },

    /**
     * @param {module:echarts/model/Global} ecModel
     * @return {Object}
     */
    getTimelineOption: function (ecModel) {
      var option;
      var timelineOptions = this._timelineOptions;

      if (timelineOptions.length) {
        // getTimelineOption can only be called after ecModel inited,
        // so we can get currentIndex from timelineModel.
        var timelineModel = ecModel.getComponent('timeline');

        if (timelineModel) {
          option = clone$5(timelineOptions[timelineModel.getCurrentIndex()], true);
        }
      }

      return option;
    },

    /**
     * @param {module:echarts/model/Global} ecModel
     * @return {Array.<Object>}
     */
    getMediaOption: function (ecModel) {
      var ecWidth = this._api.getWidth();

      var ecHeight = this._api.getHeight();

      var mediaList = this._mediaList;
      var mediaDefault = this._mediaDefault;
      var indices = [];
      var result = []; // No media defined.

      if (!mediaList.length && !mediaDefault) {
        return result;
      } // Multi media may be applied, the latter defined media has higher priority.


      for (var i = 0, len = mediaList.length; i < len; i++) {
        if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
          indices.push(i);
        }
      } // FIXME
      // æ¯å¦mediaDefaultåºè¯¥å¼ºå¶ç¨æ·è®¾ç½®ï¼å¦åå¯è½ä¿®æ¹ä¸è½åå½ã


      if (!indices.length && mediaDefault) {
        indices = [-1];
      }

      if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
        result = map$3(indices, function (index) {
          return clone$5(index === -1 ? mediaDefault.option : mediaList[index].option);
        });
      } // Otherwise return nothing.


      this._currentMediaIndices = indices;
      return result;
    }
  };

  function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
    var timelineOptions = [];
    var mediaList = [];
    var mediaDefault;
    var baseOption; // Compatible with ec2.

    var timelineOpt = rawOption.timeline;

    if (rawOption.baseOption) {
      baseOption = rawOption.baseOption;
    } // For timeline


    if (timelineOpt || rawOption.options) {
      baseOption = baseOption || {};
      timelineOptions = (rawOption.options || []).slice();
    } // For media query


    if (rawOption.media) {
      baseOption = baseOption || {};
      var media = rawOption.media;
      each$6(media, function (singleMedia) {
        if (singleMedia && singleMedia.option) {
          if (singleMedia.query) {
            mediaList.push(singleMedia);
          } else if (!mediaDefault) {
            // Use the first media default.
            mediaDefault = singleMedia;
          }
        }
      });
    } // For normal option


    if (!baseOption) {
      baseOption = rawOption;
    } // Set timelineOpt to baseOption in ec3,
    // which is convenient for merge option.


    if (!baseOption.timeline) {
      baseOption.timeline = timelineOpt;
    } // Preprocess.


    each$6([baseOption].concat(timelineOptions).concat(util.map(mediaList, function (media) {
      return media.option;
    })), function (option) {
      each$6(optionPreprocessorFuncs, function (preProcess) {
        preProcess(option, isNew);
      });
    });
    return {
      baseOption: baseOption,
      timelineOptions: timelineOptions,
      mediaDefault: mediaDefault,
      mediaList: mediaList
    };
  }
  /**
   * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
   * Support: width, height, aspectRatio
   * Can use max or min as prefix.
   */


  function applyMediaQuery(query, ecWidth, ecHeight) {
    var realMap = {
      width: ecWidth,
      height: ecHeight,
      aspectratio: ecWidth / ecHeight // lowser case for convenientce.

    };
    var applicatable = true;
    util.each(query, function (value, attr) {
      var matched = attr.match(QUERY_REG);

      if (!matched || !matched[1] || !matched[2]) {
        return;
      }

      var operator = matched[1];
      var realAttr = matched[2].toLowerCase();

      if (!compare(realMap[realAttr], value, operator)) {
        applicatable = false;
      }
    });
    return applicatable;
  }

  function compare(real, expect, operator) {
    if (operator === 'min') {
      return real >= expect;
    } else if (operator === 'max') {
      return real <= expect;
    } else {
      // Equals
      return real === expect;
    }
  }

  function indicesEquals(indices1, indices2) {
    // indices is always order by asc and has only finite number.
    return indices1.join(',') === indices2.join(',');
  }
  /**
   * Consider case:
   * `chart.setOption(opt1);`
   * Then user do some interaction like dataZoom, dataView changing.
   * `chart.setOption(opt2);`
   * Then user press 'reset button' in toolbox.
   *
   * After doing that all of the interaction effects should be reset, the
   * chart should be the same as the result of invoke
   * `chart.setOption(opt1); chart.setOption(opt2);`.
   *
   * Although it is not able ensure that
   * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
   * `chart.setOption(merge(opt1, opt2));` exactly,
   * this might be the only simple way to implement that feature.
   *
   * MEMO: We've considered some other approaches:
   * 1. Each model handle its self restoration but not uniform treatment.
   *     (Too complex in logic and error-prone)
   * 2. Use a shadow ecModel. (Performace expensive)
   */


  function mergeOption(oldOption, newOption) {
    newOption = newOption || {};
    each$6(newOption, function (newCptOpt, mainType) {
      if (newCptOpt == null) {
        return;
      }

      var oldCptOpt = oldOption[mainType];

      if (!Component.hasClass(mainType)) {
        oldOption[mainType] = merge$2(oldCptOpt, newCptOpt, true);
      } else {
        newCptOpt = model.normalizeToArray(newCptOpt);
        oldCptOpt = model.normalizeToArray(oldCptOpt);
        var mapResult = model.mappingToExists(oldCptOpt, newCptOpt);
        oldOption[mainType] = map$3(mapResult, function (item) {
          return item.option && item.exist ? merge$2(item.exist, item.option, true) : item.exist || item.option;
        });
      }
    });
  }

  var _default$$ = OptionManager;
  var OptionManager_1 = _default$$;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var each$7 = util.each;
  var isObject$8 = util.isObject;
  var POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];

  function compatEC2ItemStyle(opt) {
    var itemStyleOpt = opt && opt.itemStyle;

    if (!itemStyleOpt) {
      return;
    }

    for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
      var styleName = POSSIBLE_STYLES[i];
      var normalItemStyleOpt = itemStyleOpt.normal;
      var emphasisItemStyleOpt = itemStyleOpt.emphasis;

      if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
        opt[styleName] = opt[styleName] || {};

        if (!opt[styleName].normal) {
          opt[styleName].normal = normalItemStyleOpt[styleName];
        } else {
          util.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
        }

        normalItemStyleOpt[styleName] = null;
      }

      if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
        opt[styleName] = opt[styleName] || {};

        if (!opt[styleName].emphasis) {
          opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
        } else {
          util.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
        }

        emphasisItemStyleOpt[styleName] = null;
      }
    }
  }

  function convertNormalEmphasis(opt, optType, useExtend) {
    if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
      var normalOpt = opt[optType].normal;
      var emphasisOpt = opt[optType].emphasis;

      if (normalOpt) {
        // Timeline controlStyle has other properties besides normal and emphasis
        if (useExtend) {
          opt[optType].normal = opt[optType].emphasis = null;
          util.defaults(opt[optType], normalOpt);
        } else {
          opt[optType] = normalOpt;
        }
      }

      if (emphasisOpt) {
        opt.emphasis = opt.emphasis || {};
        opt.emphasis[optType] = emphasisOpt;
      }
    }
  }

  function removeEC3NormalStatus(opt) {
    convertNormalEmphasis(opt, 'itemStyle');
    convertNormalEmphasis(opt, 'lineStyle');
    convertNormalEmphasis(opt, 'areaStyle');
    convertNormalEmphasis(opt, 'label');
    convertNormalEmphasis(opt, 'labelLine'); // treemap

    convertNormalEmphasis(opt, 'upperLabel'); // graph

    convertNormalEmphasis(opt, 'edgeLabel');
  }

  function compatTextStyle(opt, propName) {
    // Check whether is not object (string\null\undefined ...)
    var labelOptSingle = isObject$8(opt) && opt[propName];
    var textStyle = isObject$8(labelOptSingle) && labelOptSingle.textStyle;

    if (textStyle) {
      for (var i = 0, len = model.TEXT_STYLE_OPTIONS.length; i < len; i++) {
        var propName = model.TEXT_STYLE_OPTIONS[i];

        if (textStyle.hasOwnProperty(propName)) {
          labelOptSingle[propName] = textStyle[propName];
        }
      }
    }
  }

  function compatEC3CommonStyles(opt) {
    if (opt) {
      removeEC3NormalStatus(opt);
      compatTextStyle(opt, 'label');
      opt.emphasis && compatTextStyle(opt.emphasis, 'label');
    }
  }

  function processSeries(seriesOpt) {
    if (!isObject$8(seriesOpt)) {
      return;
    }

    compatEC2ItemStyle(seriesOpt);
    removeEC3NormalStatus(seriesOpt);
    compatTextStyle(seriesOpt, 'label'); // treemap

    compatTextStyle(seriesOpt, 'upperLabel'); // graph

    compatTextStyle(seriesOpt, 'edgeLabel');

    if (seriesOpt.emphasis) {
      compatTextStyle(seriesOpt.emphasis, 'label'); // treemap

      compatTextStyle(seriesOpt.emphasis, 'upperLabel'); // graph

      compatTextStyle(seriesOpt.emphasis, 'edgeLabel');
    }

    var markPoint = seriesOpt.markPoint;

    if (markPoint) {
      compatEC2ItemStyle(markPoint);
      compatEC3CommonStyles(markPoint);
    }

    var markLine = seriesOpt.markLine;

    if (markLine) {
      compatEC2ItemStyle(markLine);
      compatEC3CommonStyles(markLine);
    }

    var markArea = seriesOpt.markArea;

    if (markArea) {
      compatEC3CommonStyles(markArea);
    }

    var data = seriesOpt.data; // Break with ec3: if `setOption` again, there may be no `type` in option,
    // then the backward compat based on option type will not be performed.

    if (seriesOpt.type === 'graph') {
      data = data || seriesOpt.nodes;
      var edgeData = seriesOpt.links || seriesOpt.edges;

      if (edgeData && !util.isTypedArray(edgeData)) {
        for (var i = 0; i < edgeData.length; i++) {
          compatEC3CommonStyles(edgeData[i]);
        }
      }

      util.each(seriesOpt.categories, function (opt) {
        removeEC3NormalStatus(opt);
      });
    }

    if (data && !util.isTypedArray(data)) {
      for (var i = 0; i < data.length; i++) {
        compatEC3CommonStyles(data[i]);
      }
    } // mark point data


    var markPoint = seriesOpt.markPoint;

    if (markPoint && markPoint.data) {
      var mpData = markPoint.data;

      for (var i = 0; i < mpData.length; i++) {
        compatEC3CommonStyles(mpData[i]);
      }
    } // mark line data


    var markLine = seriesOpt.markLine;

    if (markLine && markLine.data) {
      var mlData = markLine.data;

      for (var i = 0; i < mlData.length; i++) {
        if (util.isArray(mlData[i])) {
          compatEC3CommonStyles(mlData[i][0]);
          compatEC3CommonStyles(mlData[i][1]);
        } else {
          compatEC3CommonStyles(mlData[i]);
        }
      }
    } // Series


    if (seriesOpt.type === 'gauge') {
      compatTextStyle(seriesOpt, 'axisLabel');
      compatTextStyle(seriesOpt, 'title');
      compatTextStyle(seriesOpt, 'detail');
    } else if (seriesOpt.type === 'treemap') {
      convertNormalEmphasis(seriesOpt.breadcrumb, 'itemStyle');
      util.each(seriesOpt.levels, function (opt) {
        removeEC3NormalStatus(opt);
      });
    } else if (seriesOpt.type === 'tree') {
      removeEC3NormalStatus(seriesOpt.leaves);
    } // sunburst starts from ec4, so it does not need to compat levels.

  }

  function toArr(o) {
    return util.isArray(o) ? o : o ? [o] : [];
  }

  function toObj(o) {
    return (util.isArray(o) ? o[0] : o) || {};
  }

  function _default$10(option, isTheme) {
    each$7(toArr(option.series), function (seriesOpt) {
      isObject$8(seriesOpt) && processSeries(seriesOpt);
    });
    var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];
    isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');
    each$7(axes, function (axisName) {
      each$7(toArr(option[axisName]), function (axisOpt) {
        if (axisOpt) {
          compatTextStyle(axisOpt, 'axisLabel');
          compatTextStyle(axisOpt.axisPointer, 'label');
        }
      });
    });
    each$7(toArr(option.parallel), function (parallelOpt) {
      var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
      compatTextStyle(parallelAxisDefault, 'axisLabel');
      compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');
    });
    each$7(toArr(option.calendar), function (calendarOpt) {
      convertNormalEmphasis(calendarOpt, 'itemStyle');
      compatTextStyle(calendarOpt, 'dayLabel');
      compatTextStyle(calendarOpt, 'monthLabel');
      compatTextStyle(calendarOpt, 'yearLabel');
    }); // radar.name.textStyle

    each$7(toArr(option.radar), function (radarOpt) {
      compatTextStyle(radarOpt, 'name');
    });
    each$7(toArr(option.geo), function (geoOpt) {
      if (isObject$8(geoOpt)) {
        compatEC3CommonStyles(geoOpt);
        each$7(toArr(geoOpt.regions), function (regionObj) {
          compatEC3CommonStyles(regionObj);
        });
      }
    });
    each$7(toArr(option.timeline), function (timelineOpt) {
      compatEC3CommonStyles(timelineOpt);
      convertNormalEmphasis(timelineOpt, 'label');
      convertNormalEmphasis(timelineOpt, 'itemStyle');
      convertNormalEmphasis(timelineOpt, 'controlStyle', true);
      var data = timelineOpt.data;
      util.isArray(data) && util.each(data, function (item) {
        if (util.isObject(item)) {
          convertNormalEmphasis(item, 'label');
          convertNormalEmphasis(item, 'itemStyle');
        }
      });
    });
    each$7(toArr(option.toolbox), function (toolboxOpt) {
      convertNormalEmphasis(toolboxOpt, 'iconStyle');
      each$7(toolboxOpt.feature, function (featureOpt) {
        convertNormalEmphasis(featureOpt, 'iconStyle');
      });
    });
    compatTextStyle(toObj(option.axisPointer), 'label');
    compatTextStyle(toObj(option.tooltip).axisPointer, 'label');
  }

  var compatStyle = _default$10;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var each$8 = util.each;
  var isArray$6 = util.isArray;
  var isObject$9 = util.isObject;





  var normalizeToArray$2 = model.normalizeToArray;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Compatitable with 2.0
  function get$2(opt, path) {
    path = path.split(',');
    var obj = opt;

    for (var i = 0; i < path.length; i++) {
      obj = obj && obj[path[i]];

      if (obj == null) {
        break;
      }
    }

    return obj;
  }

  function set$4(opt, path, val, overwrite) {
    path = path.split(',');
    var obj = opt;
    var key;

    for (var i = 0; i < path.length - 1; i++) {
      key = path[i];

      if (obj[key] == null) {
        obj[key] = {};
      }

      obj = obj[key];
    }

    if (overwrite || obj[path[i]] == null) {
      obj[path[i]] = val;
    }
  }

  function compatLayoutProperties(option) {
    each$8(LAYOUT_PROPERTIES, function (prop) {
      if (prop[0] in option && !(prop[1] in option)) {
        option[prop[1]] = option[prop[0]];
      }
    });
  }

  var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];
  var COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];

  function _default$11(option, isTheme) {
    compatStyle(option, isTheme); // Make sure series array for model initialization.

    option.series = normalizeToArray$2(option.series);
    each$8(option.series, function (seriesOpt) {
      if (!isObject$9(seriesOpt)) {
        return;
      }

      var seriesType = seriesOpt.type;

      if (seriesType === 'line') {
        if (seriesOpt.clipOverflow != null) {
          seriesOpt.clip = seriesOpt.clipOverflow;
        }
      } else if (seriesType === 'pie' || seriesType === 'gauge') {
        if (seriesOpt.clockWise != null) {
          seriesOpt.clockwise = seriesOpt.clockWise;
        }
      } else if (seriesType === 'gauge') {
        var pointerColor = get$2(seriesOpt, 'pointer.color');
        pointerColor != null && set$4(seriesOpt, 'itemStyle.color', pointerColor);
      }

      compatLayoutProperties(seriesOpt);
    }); // dataRange has changed to visualMap

    if (option.dataRange) {
      option.visualMap = option.dataRange;
    }

    each$8(COMPATITABLE_COMPONENTS, function (componentName) {
      var options = option[componentName];

      if (options) {
        if (!isArray$6(options)) {
          options = [options];
        }

        each$8(options, function (option) {
          compatLayoutProperties(option);
        });
      }
    });
  }

  var backwardCompat = _default$11;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var createHashMap$4 = util.createHashMap;
  var each$9 = util.each;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // (1) [Caution]: the logic is correct based on the premises:
  //     data processing stage is blocked in stream.
  //     See <module:echarts/stream/Scheduler#performDataProcessorTasks>
  // (2) Only register once when import repeatly.
  //     Should be executed after series filtered and before stack calculation.
  function _default$12(ecModel) {
    var stackInfoMap = createHashMap$4();
    ecModel.eachSeries(function (seriesModel) {
      var stack = seriesModel.get('stack'); // Compatibal: when `stack` is set as '', do not stack.

      if (stack) {
        var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
        var data = seriesModel.getData();
        var stackInfo = {
          // Used for calculate axis extent automatically.
          stackResultDimension: data.getCalculationInfo('stackResultDimension'),
          stackedOverDimension: data.getCalculationInfo('stackedOverDimension'),
          stackedDimension: data.getCalculationInfo('stackedDimension'),
          stackedByDimension: data.getCalculationInfo('stackedByDimension'),
          isStackedByIndex: data.getCalculationInfo('isStackedByIndex'),
          data: data,
          seriesModel: seriesModel
        }; // If stacked on axis that do not support data stack.

        if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
          return;
        }

        stackInfoList.length && data.setCalculationInfo('stackedOnSeries', stackInfoList[stackInfoList.length - 1].seriesModel);
        stackInfoList.push(stackInfo);
      }
    });
    stackInfoMap.each(calculateStack);
  }

  function calculateStack(stackInfoList) {
    each$9(stackInfoList, function (targetStackInfo, idxInStack) {
      var resultVal = [];
      var resultNaN = [NaN, NaN];
      var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
      var targetData = targetStackInfo.data;
      var isStackedByIndex = targetStackInfo.isStackedByIndex; // Should not write on raw data, because stack series model list changes
      // depending on legend selection.

      var newData = targetData.map(dims, function (v0, v1, dataIndex) {
        var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex); // Consider `connectNulls` of line area, if value is NaN, stackedOver
        // should also be NaN, to draw a appropriate belt area.

        if (isNaN(sum)) {
          return resultNaN;
        }

        var byValue;
        var stackedDataRawIndex;

        if (isStackedByIndex) {
          stackedDataRawIndex = targetData.getRawIndex(dataIndex);
        } else {
          byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
        } // If stackOver is NaN, chart view will render point on value start.


        var stackedOver = NaN;

        for (var j = idxInStack - 1; j >= 0; j--) {
          var stackInfo = stackInfoList[j]; // Has been optimized by inverted indices on `stackedByDimension`.

          if (!isStackedByIndex) {
            stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
          }

          if (stackedDataRawIndex >= 0) {
            var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex); // Considering positive stack, negative stack and empty data

            if (sum >= 0 && val > 0 || // Positive stack
            sum <= 0 && val < 0 // Negative stack
            ) {
                sum += val;
                stackedOver = val;
                break;
              }
          }
        }

        resultVal[0] = sum;
        resultVal[1] = stackedOver;
        return resultVal;
      });
      targetData.hostModel.setData(newData); // Update for consequent calculation

      targetStackInfo.data = newData;
    });
  }

  var dataStack = _default$12;

  var extend$6 = util.extend;
  var each$a = util.each;
  var isObject$a = util.isObject;



  var getDataItemValue$2 = model.getDataItemValue;
  var isDataItemOption$1 = model.isDataItemOption;



  var parseDate$1 = number.parseDate;





  var SOURCE_FORMAT_TYPED_ARRAY$3 = sourceType.SOURCE_FORMAT_TYPED_ARRAY;
  var SOURCE_FORMAT_ARRAY_ROWS$2 = sourceType.SOURCE_FORMAT_ARRAY_ROWS;
  var SOURCE_FORMAT_ORIGINAL$3 = sourceType.SOURCE_FORMAT_ORIGINAL;
  var SOURCE_FORMAT_OBJECT_ROWS$2 = sourceType.SOURCE_FORMAT_OBJECT_ROWS;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // TODO
  // ??? refactor? check the outer usage of data provider.
  // merge with defaultDimValueGetter?

  /**
   * If normal array used, mutable chunk size is supported.
   * If typed array used, chunk size must be fixed.
   */
  function DefaultDataProvider(source, dimSize) {
    if (!Source_1.isInstance(source)) {
      source = Source_1.seriesDataToSource(source);
    }

    this._source = source;
    var data = this._data = source.data;
    var sourceFormat = source.sourceFormat; // Typed array. TODO IE10+?

    if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY$3) {
      this._offset = 0;
      this._dimSize = dimSize;
      this._data = data;
    }

    var methods = providerMethods[sourceFormat === SOURCE_FORMAT_ARRAY_ROWS$2 ? sourceFormat + '_' + source.seriesLayoutBy : sourceFormat];
    extend$6(this, methods);
  }

  var providerProto = DefaultDataProvider.prototype; // If data is pure without style configuration

  providerProto.pure = false; // If data is persistent and will not be released after use.

  providerProto.persistent = true; // ???! FIXME legacy data provider do not has method getSource

  providerProto.getSource = function () {
    return this._source;
  };

  var providerMethods = {
    'arrayRows_column': {
      pure: true,
      count: function () {
        return Math.max(0, this._data.length - this._source.startIndex);
      },
      getItem: function (idx) {
        return this._data[idx + this._source.startIndex];
      },
      appendData: appendDataSimply
    },
    'arrayRows_row': {
      pure: true,
      count: function () {
        var row = this._data[0];
        return row ? Math.max(0, row.length - this._source.startIndex) : 0;
      },
      getItem: function (idx) {
        idx += this._source.startIndex;
        var item = [];
        var data = this._data;

        for (var i = 0; i < data.length; i++) {
          var row = data[i];
          item.push(row ? row[idx] : null);
        }

        return item;
      },
      appendData: function () {
        throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
      }
    },
    'objectRows': {
      pure: true,
      count: countSimply,
      getItem: getItemSimply,
      appendData: appendDataSimply
    },
    'keyedColumns': {
      pure: true,
      count: function () {
        var dimName = this._source.dimensionsDefine[0].name;
        var col = this._data[dimName];
        return col ? col.length : 0;
      },
      getItem: function (idx) {
        var item = [];
        var dims = this._source.dimensionsDefine;

        for (var i = 0; i < dims.length; i++) {
          var col = this._data[dims[i].name];
          item.push(col ? col[idx] : null);
        }

        return item;
      },
      appendData: function (newData) {
        var data = this._data;
        each$a(newData, function (newCol, key) {
          var oldCol = data[key] || (data[key] = []);

          for (var i = 0; i < (newCol || []).length; i++) {
            oldCol.push(newCol[i]);
          }
        });
      }
    },
    'original': {
      count: countSimply,
      getItem: getItemSimply,
      appendData: appendDataSimply
    },
    'typedArray': {
      persistent: false,
      pure: true,
      count: function () {
        return this._data ? this._data.length / this._dimSize : 0;
      },
      getItem: function (idx, out) {
        idx = idx - this._offset;
        out = out || [];
        var offset = this._dimSize * idx;

        for (var i = 0; i < this._dimSize; i++) {
          out[i] = this._data[offset + i];
        }

        return out;
      },
      appendData: function (newData) {
        this._data = newData;
      },
      // Clean self if data is already used.
      clean: function () {
        // PENDING
        this._offset += this.count();
        this._data = null;
      }
    }
  };

  function countSimply() {
    return this._data.length;
  }

  function getItemSimply(idx) {
    return this._data[idx];
  }

  function appendDataSimply(newData) {
    for (var i = 0; i < newData.length; i++) {
      this._data.push(newData[i]);
    }
  }

  var rawValueGetters = {
    arrayRows: getRawValueSimply,
    objectRows: function (dataItem, dataIndex, dimIndex, dimName) {
      return dimIndex != null ? dataItem[dimName] : dataItem;
    },
    keyedColumns: getRawValueSimply,
    original: function (dataItem, dataIndex, dimIndex, dimName) {
      // FIXME
      // In some case (markpoint in geo (geo-map.html)), dataItem
      // is {coord: [...]}
      var value = getDataItemValue$2(dataItem);
      return dimIndex == null || !(value instanceof Array) ? value : value[dimIndex];
    },
    typedArray: getRawValueSimply
  };

  function getRawValueSimply(dataItem, dataIndex, dimIndex, dimName) {
    return dimIndex != null ? dataItem[dimIndex] : dataItem;
  }

  var defaultDimValueGetters = {
    arrayRows: getDimValueSimply,
    objectRows: function (dataItem, dimName, dataIndex, dimIndex) {
      return converDataValue(dataItem[dimName], this._dimensionInfos[dimName]);
    },
    keyedColumns: getDimValueSimply,
    original: function (dataItem, dimName, dataIndex, dimIndex) {
      // Performance sensitive, do not use modelUtil.getDataItemValue.
      // If dataItem is an plain object with no value field, the var `value`
      // will be assigned with the object, but it will be tread correctly
      // in the `convertDataValue`.
      var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value); // If any dataItem is like { value: 10 }

      if (!this._rawData.pure && isDataItemOption$1(dataItem)) {
        this.hasItemOption = true;
      }

      return converDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.
      : value, this._dimensionInfos[dimName]);
    },
    typedArray: function (dataItem, dimName, dataIndex, dimIndex) {
      return dataItem[dimIndex];
    }
  };

  function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {
    return converDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);
  }
  /**
   * This helper method convert value in data.
   * @param {string|number|Date} value
   * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.
   *        If "dimInfo.ordinalParseAndSave", ordinal value can be parsed.
   */


  function converDataValue(value, dimInfo) {
    // Performance sensitive.
    var dimType = dimInfo && dimInfo.type;

    if (dimType === 'ordinal') {
      // If given value is a category string
      var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
      return ordinalMeta ? ordinalMeta.parseAndCollect(value) : value;
    }

    if (dimType === 'time' // spead up when using timestamp
    && typeof value !== 'number' && value != null && value !== '-') {
      value = +parseDate$1(value);
    } // dimType defaults 'number'.
    // If dimType is not ordinal and value is null or undefined or NaN or '-',
    // parse to NaN.


    return value == null || value === '' ? NaN // If string (like '-'), using '+' parse to NaN
    // If object, also parse to NaN
    : +value;
  } // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,
  // Consider persistent.
  // Caution: why use raw value to display on label or tooltip?
  // A reason is to avoid format. For example time value we do not know
  // how to format is expected. More over, if stack is used, calculated
  // value may be 0.91000000001, which have brings trouble to display.
  // TODO: consider how to treat null/undefined/NaN when display?

  /**
   * @param {module:echarts/data/List} data
   * @param {number} dataIndex
   * @param {string|number} [dim] dimName or dimIndex
   * @return {Array.<number>|string|number} can be null/undefined.
   */


  function retrieveRawValue(data, dataIndex, dim) {
    if (!data) {
      return;
    } // Consider data may be not persistent.


    var dataItem = data.getRawDataItem(dataIndex);

    if (dataItem == null) {
      return;
    }

    var sourceFormat = data.getProvider().getSource().sourceFormat;
    var dimName;
    var dimIndex;
    var dimInfo = data.getDimensionInfo(dim);

    if (dimInfo) {
      dimName = dimInfo.name;
      dimIndex = dimInfo.index;
    }

    return rawValueGetters[sourceFormat](dataItem, dataIndex, dimIndex, dimName);
  }
  /**
   * Compatible with some cases (in pie, map) like:
   * data: [{name: 'xx', value: 5, selected: true}, ...]
   * where only sourceFormat is 'original' and 'objectRows' supported.
   *
   * ??? TODO
   * Supported detail options in data item when using 'arrayRows'.
   *
   * @param {module:echarts/data/List} data
   * @param {number} dataIndex
   * @param {string} attr like 'selected'
   */


  function retrieveRawAttr(data, dataIndex, attr) {
    if (!data) {
      return;
    }

    var sourceFormat = data.getProvider().getSource().sourceFormat;

    if (sourceFormat !== SOURCE_FORMAT_ORIGINAL$3 && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS$2) {
      return;
    }

    var dataItem = data.getRawDataItem(dataIndex);

    if (sourceFormat === SOURCE_FORMAT_ORIGINAL$3 && !isObject$a(dataItem)) {
      dataItem = null;
    }

    if (dataItem) {
      return dataItem[attr];
    }
  }

  var DefaultDataProvider_1 = DefaultDataProvider;
  var defaultDimValueGetters_1 = defaultDimValueGetters;
  var retrieveRawValue_1 = retrieveRawValue;
  var retrieveRawAttr_1 = retrieveRawAttr;

  var dataProvider = {
  	DefaultDataProvider: DefaultDataProvider_1,
  	defaultDimValueGetters: defaultDimValueGetters_1,
  	retrieveRawValue: retrieveRawValue_1,
  	retrieveRawAttr: retrieveRawAttr_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var retrieveRawValue$1 = dataProvider.retrieveRawValue;



  var getTooltipMarker$1 = format$1.getTooltipMarker;
  var formatTpl$1 = format$1.formatTpl;



  var getTooltipRenderMode$1 = model.getTooltipRenderMode;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var DIMENSION_LABEL_REG = /\{@(.+?)\}/g; // PENDING A little ugly

  var _default$13 = {
    /**
     * Get params for formatter
     * @param {number} dataIndex
     * @param {string} [dataType]
     * @return {Object}
     */
    getDataParams: function (dataIndex, dataType) {
      var data = this.getData(dataType);
      var rawValue = this.getRawValue(dataIndex, dataType);
      var rawDataIndex = data.getRawIndex(dataIndex);
      var name = data.getName(dataIndex);
      var itemOpt = data.getRawDataItem(dataIndex);
      var color = data.getItemVisual(dataIndex, 'color');
      var borderColor = data.getItemVisual(dataIndex, 'borderColor');
      var tooltipModel = this.ecModel.getComponent('tooltip');
      var renderModeOption = tooltipModel && tooltipModel.get('renderMode');
      var renderMode = getTooltipRenderMode$1(renderModeOption);
      var mainType = this.mainType;
      var isSeries = mainType === 'series';
      var userOutput = data.userOutput;
      return {
        componentType: mainType,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: isSeries ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: isSeries ? this.id : null,
        seriesName: isSeries ? this.name : null,
        name: name,
        dataIndex: rawDataIndex,
        data: itemOpt,
        dataType: dataType,
        value: rawValue,
        color: color,
        borderColor: borderColor,
        dimensionNames: userOutput ? userOutput.dimensionNames : null,
        encode: userOutput ? userOutput.encode : null,
        marker: getTooltipMarker$1({
          color: color,
          renderMode: renderMode
        }),
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ['seriesName', 'name', 'value']
      };
    },

    /**
     * Format label
     * @param {number} dataIndex
     * @param {string} [status='normal'] 'normal' or 'emphasis'
     * @param {string} [dataType]
     * @param {number} [dimIndex] Only used in some chart that
     *        use formatter in different dimensions, like radar.
     * @param {string} [labelProp='label']
     * @return {string} If not formatter, return null/undefined
     */
    getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {
      status = status || 'normal';
      var data = this.getData(dataType);
      var itemModel = data.getItemModel(dataIndex);
      var params = this.getDataParams(dataIndex, dataType);

      if (dimIndex != null && params.value instanceof Array) {
        params.value = params.value[dimIndex];
      }

      var formatter = itemModel.get(status === 'normal' ? [labelProp || 'label', 'formatter'] : [status, labelProp || 'label', 'formatter']);

      if (typeof formatter === 'function') {
        params.status = status;
        params.dimensionIndex = dimIndex;
        return formatter(params);
      } else if (typeof formatter === 'string') {
        var str = formatTpl$1(formatter, params); // Support 'aaa{@[3]}bbb{@product}ccc'.
        // Do not support '}' in dim name util have to.

        return str.replace(DIMENSION_LABEL_REG, function (origin, dim) {
          var len = dim.length;

          if (dim.charAt(0) === '[' && dim.charAt(len - 1) === ']') {
            dim = +dim.slice(1, len - 1); // Also: '[]' => 0
          }

          return retrieveRawValue$1(data, dataIndex, dim);
        });
      }
    },

    /**
     * Get raw value in option
     * @param {number} idx
     * @param {string} [dataType]
     * @return {Array|number|string}
     */
    getRawValue: function (idx, dataType) {
      return retrieveRawValue$1(this.getData(dataType), idx);
    },

    /**
     * Should be implemented.
     * @param {number} dataIndex
     * @param {boolean} [multipleSeries=false]
     * @param {number} [dataType]
     * @return {string} tooltip string
     */
    formatTooltip: function () {// Empty function
    }
  };
  var dataFormat = _default$13;

  var isArray$7 = util.isArray;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @param {Object} define
   * @return See the return of `createTask`.
   */
  function createTask(define) {
    return new Task(define);
  }
  /**
   * @constructor
   * @param {Object} define
   * @param {Function} define.reset Custom reset
   * @param {Function} [define.plan] Returns 'reset' indicate reset immediately.
   * @param {Function} [define.count] count is used to determin data task.
   * @param {Function} [define.onDirty] count is used to determin data task.
   */


  function Task(define) {
    define = define || {};
    this._reset = define.reset;
    this._plan = define.plan;
    this._count = define.count;
    this._onDirty = define.onDirty;
    this._dirty = true; // Context must be specified implicitly, to
    // avoid miss update context when model changed.

    this.context;
  }

  var taskProto = Task.prototype;
  /**
   * @param {Object} performArgs
   * @param {number} [performArgs.step] Specified step.
   * @param {number} [performArgs.skip] Skip customer perform call.
   * @param {number} [performArgs.modBy] Sampling window size.
   * @param {number} [performArgs.modDataCount] Sampling count.
   */

  taskProto.perform = function (performArgs) {
    var upTask = this._upstream;
    var skip = performArgs && performArgs.skip; // TODO some refactor.
    // Pull data. Must pull data each time, because context.data
    // may be updated by Series.setData.

    if (this._dirty && upTask) {
      var context = this.context;
      context.data = context.outputData = upTask.context.outputData;
    }

    if (this.__pipeline) {
      this.__pipeline.currentTask = this;
    }

    var planResult;

    if (this._plan && !skip) {
      planResult = this._plan(this.context);
    } // Support sharding by mod, which changes the render sequence and makes the rendered graphic
    // elements uniformed distributed when progress, especially when moving or zooming.


    var lastModBy = normalizeModBy(this._modBy);
    var lastModDataCount = this._modDataCount || 0;
    var modBy = normalizeModBy(performArgs && performArgs.modBy);
    var modDataCount = performArgs && performArgs.modDataCount || 0;

    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
      planResult = 'reset';
    }

    function normalizeModBy(val) {
      !(val >= 1) && (val = 1); // jshint ignore:line

      return val;
    }

    var forceFirstProgress;

    if (this._dirty || planResult === 'reset') {
      this._dirty = false;
      forceFirstProgress = reset(this, skip);
    }

    this._modBy = modBy;
    this._modDataCount = modDataCount;
    var step = performArgs && performArgs.step;

    if (upTask) {
      this._dueEnd = upTask._outputDueEnd;
    } // DataTask or overallTask
    else {
        this._dueEnd = this._count ? this._count(this.context) : Infinity;
      } // Note: Stubs, that its host overall task let it has progress, has progress.
    // If no progress, pass index from upstream to downstream each time plan called.


    if (this._progress) {
      var start = this._dueIndex;
      var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);

      if (!skip && (forceFirstProgress || start < end)) {
        var progress = this._progress;

        if (isArray$7(progress)) {
          for (var i = 0; i < progress.length; i++) {
            doProgress(this, progress[i], start, end, modBy, modDataCount);
          }
        } else {
          doProgress(this, progress, start, end, modBy, modDataCount);
        }
      }

      this._dueIndex = end; // If no `outputDueEnd`, assume that output data and
      // input data is the same, so use `dueIndex` as `outputDueEnd`.

      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;
      this._outputDueEnd = outputDueEnd;
    } else {
      // (1) Some overall task has no progress.
      // (2) Stubs, that its host overall task do not let it has progress, has no progress.
      // This should always be performed so it can be passed to downstream.
      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
    }

    return this.unfinished();
  };

  var iterator = function () {
    var end;
    var current;
    var modBy;
    var modDataCount;
    var winCount;
    var it = {
      reset: function (s, e, sStep, sCount) {
        current = s;
        end = e;
        modBy = sStep;
        modDataCount = sCount;
        winCount = Math.ceil(modDataCount / modBy);
        it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
      }
    };
    return it;

    function sequentialNext() {
      return current < end ? current++ : null;
    }

    function modNext() {
      var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
      var result = current >= end ? null : dataIndex < modDataCount ? dataIndex // If modDataCount is smaller than data.count() (consider `appendData` case),
      // Use normal linear rendering mode.
      : current;
      current++;
      return result;
    }
  }();

  taskProto.dirty = function () {
    this._dirty = true;
    this._onDirty && this._onDirty(this.context);
  };

  function doProgress(taskIns, progress, start, end, modBy, modDataCount) {
    iterator.reset(start, end, modBy, modDataCount);
    taskIns._callingProgress = progress;

    taskIns._callingProgress({
      start: start,
      end: end,
      count: end - start,
      next: iterator.next
    }, taskIns.context);
  }

  function reset(taskIns, skip) {
    taskIns._dueIndex = taskIns._outputDueEnd = taskIns._dueEnd = 0;
    taskIns._settedOutputEnd = null;
    var progress;
    var forceFirstProgress;

    if (!skip && taskIns._reset) {
      progress = taskIns._reset(taskIns.context);

      if (progress && progress.progress) {
        forceFirstProgress = progress.forceFirstProgress;
        progress = progress.progress;
      } // To simplify no progress checking, array must has item.


      if (isArray$7(progress) && !progress.length) {
        progress = null;
      }
    }

    taskIns._progress = progress;
    taskIns._modBy = taskIns._modDataCount = null;
    var downstream = taskIns._downstream;
    downstream && downstream.dirty();
    return forceFirstProgress;
  }
  /**
   * @return {boolean}
   */


  taskProto.unfinished = function () {
    return this._progress && this._dueIndex < this._dueEnd;
  };
  /**
   * @param {Object} downTask The downstream task.
   * @return {Object} The downstream task.
   */


  taskProto.pipe = function (downTask) {
    // If already downstream, do not dirty downTask.
    if (this._downstream !== downTask || this._dirty) {
      this._downstream = downTask;
      downTask._upstream = this;
      downTask.dirty();
    }
  };

  taskProto.dispose = function () {
    if (this._disposed) {
      return;
    }

    this._upstream && (this._upstream._downstream = null);
    this._downstream && (this._downstream._upstream = null);
    this._dirty = false;
    this._disposed = true;
  };

  taskProto.getUpstream = function () {
    return this._upstream;
  };

  taskProto.getDownstream = function () {
    return this._downstream;
  };

  taskProto.setOutputEnd = function (end) {
    // This only happend in dataTask, dataZoom, map, currently.
    // where dataZoom do not set end each time, but only set
    // when reset. So we should record the setted end, in case
    // that the stub of dataZoom perform again and earse the
    // setted end by upstream.
    this._outputDueEnd = this._settedOutputEnd = end;
  }; ///////////////////////////////////////////////////////////
  // For stream debug (Should be commented out after used!)
  // Usage: printTask(this, 'begin');
  // Usage: printTask(this, null, {someExtraProp});
  // function printTask(task, prefix, extra) {
  //     window.ecTaskUID == null && (window.ecTaskUID = 0);
  //     task.uidDebug == null && (task.uidDebug = `task_${window.ecTaskUID++}`);
  //     task.agent && task.agent.uidDebug == null && (task.agent.uidDebug = `task_${window.ecTaskUID++}`);
  //     var props = [];
  //     if (task.__pipeline) {
  //         var val = `${task.__idxInPipeline}/${task.__pipeline.tail.__idxInPipeline} ${task.agent ? '(stub)' : ''}`;
  //         props.push({text: 'idx', value: val});
  //     } else {
  //         var stubCount = 0;
  //         task.agentStubMap.each(() => stubCount++);
  //         props.push({text: 'idx', value: `overall (stubs: ${stubCount})`});
  //     }
  //     props.push({text: 'uid', value: task.uidDebug});
  //     if (task.__pipeline) {
  //         props.push({text: 'pid', value: task.__pipeline.id});
  //         task.agent && props.push(
  //             {text: 'stubFor', value: task.agent.uidDebug}
  //         );
  //     }
  //     props.push(
  //         {text: 'dirty', value: task._dirty},
  //         {text: 'dueIndex', value: task._dueIndex},
  //         {text: 'dueEnd', value: task._dueEnd},
  //         {text: 'outputDueEnd', value: task._outputDueEnd}
  //     );
  //     if (extra) {
  //         Object.keys(extra).forEach(key => {
  //             props.push({text: key, value: extra[key]});
  //         });
  //     }
  //     var args = ['color: blue'];
  //     var msg = `%c[${prefix || 'T'}] %c` + props.map(item => (
  //         args.push('color: black', 'color: red'),
  //         `${item.text}: %c${item.value}`
  //     )).join('%c, ');
  //     console.log.apply(console, [msg].concat(args));
  //     // console.log(this);
  // }


  var createTask_1 = createTask;

  var task$2 = {
  	createTask: createTask_1
  };

  var formatTime$1 = format$1.formatTime;
  var encodeHTML$1 = format$1.encodeHTML;
  var addCommas$1 = format$1.addCommas;
  var getTooltipMarker$2 = format$1.getTooltipMarker;











  var getLayoutParams$1 = layout.getLayoutParams;
  var mergeLayoutParam$1 = layout.mergeLayoutParam;



  var createTask$1 = task$2.createTask;



  var prepareSource$1 = sourceHelper.prepareSource;
  var getSource$1 = sourceHelper.getSource;



  var retrieveRawValue$2 = dataProvider.retrieveRawValue;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var inner$4 = model.makeInner();
  var SeriesModel = Component.extend({
    type: 'series.__base__',

    /**
     * @readOnly
     */
    seriesIndex: 0,
    // coodinateSystem will be injected in the echarts/CoordinateSystem
    coordinateSystem: null,

    /**
     * @type {Object}
     * @protected
     */
    defaultOption: null,

    /**
     * legend visual provider to the legend component
     * @type {Object}
     */
    // PENDING
    legendVisualProvider: null,

    /**
     * Access path of color for visual
     */
    visualColorAccessPath: 'itemStyle.color',

    /**
     * Access path of borderColor for visual
     */
    visualBorderColorAccessPath: 'itemStyle.borderColor',

    /**
     * Support merge layout params.
     * Only support 'box' now (left/right/top/bottom/width/height).
     * @type {string|Object} Object can be {ignoreSize: true}
     * @readOnly
     */
    layoutMode: null,
    init: function (option, parentModel, ecModel, extraOpt) {
      /**
       * @type {number}
       * @readOnly
       */
      this.seriesIndex = this.componentIndex;
      this.dataTask = createTask$1({
        count: dataTaskCount,
        reset: dataTaskReset
      });
      this.dataTask.context = {
        model: this
      };
      this.mergeDefaultAndTheme(option, ecModel);
      prepareSource$1(this);
      var data = this.getInitialData(option, ecModel);
      wrapData(data, this);
      this.dataTask.context.data = data;

      /**
       * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}
       * @private
       */
      inner$4(this).dataBeforeProcessed = data; // If we reverse the order (make data firstly, and then make
      // dataBeforeProcessed by cloneShallow), cloneShallow will
      // cause data.graph.data !== data when using
      // module:echarts/data/Graph or module:echarts/data/Tree.
      // See module:echarts/data/helper/linkList
      // Theoretically, it is unreasonable to call `seriesModel.getData()` in the model
      // init or merge stage, because the data can be restored. So we do not `restoreData`
      // and `setData` here, which forbids calling `seriesModel.getData()` in this stage.
      // Call `seriesModel.getRawData()` instead.
      // this.restoreData();

      autoSeriesName(this);
    },

    /**
     * Util for merge default and theme to option
     * @param  {Object} option
     * @param  {module:echarts/model/Global} ecModel
     */
    mergeDefaultAndTheme: function (option, ecModel) {
      var layoutMode = this.layoutMode;
      var inputPositionParams = layoutMode ? getLayoutParams$1(option) : {}; // Backward compat: using subType on theme.
      // But if name duplicate between series subType
      // (for example: parallel) add component mainType,
      // add suffix 'Series'.

      var themeSubType = this.subType;

      if (Component.hasClass(themeSubType)) {
        themeSubType += 'Series';
      }

      util.merge(option, ecModel.getTheme().get(this.subType));
      util.merge(option, this.getDefaultOption()); // Default label emphasis `show`

      model.defaultEmphasis(option, 'label', ['show']);
      this.fillDataTextStyle(option.data);

      if (layoutMode) {
        mergeLayoutParam$1(option, inputPositionParams, layoutMode);
      }
    },
    mergeOption: function (newSeriesOption, ecModel) {
      // this.settingTask.dirty();
      newSeriesOption = util.merge(this.option, newSeriesOption, true);
      this.fillDataTextStyle(newSeriesOption.data);
      var layoutMode = this.layoutMode;

      if (layoutMode) {
        mergeLayoutParam$1(this.option, newSeriesOption, layoutMode);
      }

      prepareSource$1(this);
      var data = this.getInitialData(newSeriesOption, ecModel);
      wrapData(data, this);
      this.dataTask.dirty();
      this.dataTask.context.data = data;
      inner$4(this).dataBeforeProcessed = data;
      autoSeriesName(this);
    },
    fillDataTextStyle: function (data) {
      // Default data label emphasis `show`
      // FIXME Tree structure data ?
      // FIXME Performance ?
      if (data && !util.isTypedArray(data)) {
        var props = ['show'];

        for (var i = 0; i < data.length; i++) {
          if (data[i] && data[i].label) {
            model.defaultEmphasis(data[i], 'label', props);
          }
        }
      }
    },

    /**
     * Init a data structure from data related option in series
     * Must be overwritten
     */
    getInitialData: function () {},

    /**
     * Append data to list
     * @param {Object} params
     * @param {Array|TypedArray} params.data
     */
    appendData: function (params) {
      // FIXME ???
      // (1) If data from dataset, forbidden append.
      // (2) support append data of dataset.
      var data = this.getRawData();
      data.appendData(params.data);
    },

    /**
     * Consider some method like `filter`, `map` need make new data,
     * We should make sure that `seriesModel.getData()` get correct
     * data in the stream procedure. So we fetch data from upstream
     * each time `task.perform` called.
     * @param {string} [dataType]
     * @return {module:echarts/data/List}
     */
    getData: function (dataType) {
      var task = getCurrentTask(this);

      if (task) {
        var data = task.context.data;
        return dataType == null ? data : data.getLinkedData(dataType);
      } else {
        // When series is not alive (that may happen when click toolbox
        // restore or setOption with not merge mode), series data may
        // be still need to judge animation or something when graphic
        // elements want to know whether fade out.
        return inner$4(this).data;
      }
    },

    /**
     * @param {module:echarts/data/List} data
     */
    setData: function (data) {
      var task = getCurrentTask(this);

      if (task) {
        var context = task.context; // Consider case: filter, data sample.

        if (context.data !== data && task.modifyOutputEnd) {
          task.setOutputEnd(data.count());
        }

        context.outputData = data; // Caution: setData should update context.data,
        // Because getData may be called multiply in a
        // single stage and expect to get the data just
        // set. (For example, AxisProxy, x y both call
        // getData and setDate sequentially).
        // So the context.data should be fetched from
        // upstream each time when a stage starts to be
        // performed.

        if (task !== this.dataTask) {
          context.data = data;
        }
      }

      inner$4(this).data = data;
    },

    /**
     * @see {module:echarts/data/helper/sourceHelper#getSource}
     * @return {module:echarts/data/Source} source
     */
    getSource: function () {
      return getSource$1(this);
    },

    /**
     * Get data before processed
     * @return {module:echarts/data/List}
     */
    getRawData: function () {
      return inner$4(this).dataBeforeProcessed;
    },

    /**
     * Get base axis if has coordinate system and has axis.
     * By default use coordSys.getBaseAxis();
     * Can be overrided for some chart.
     * @return {type} description
     */
    getBaseAxis: function () {
      var coordSys = this.coordinateSystem;
      return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
    },
    // FIXME

    /**
     * Default tooltip formatter
     *
     * @param {number} dataIndex
     * @param {boolean} [multipleSeries=false]
     * @param {number} [dataType]
     * @param {string} [renderMode='html'] valid values: 'html' and 'richText'.
     *                                     'html' is used for rendering tooltip in extra DOM form, and the result
     *                                     string is used as DOM HTML content.
     *                                     'richText' is used for rendering tooltip in rich text form, for those where
     *                                     DOM operation is not supported.
     * @return {Object} formatted tooltip with `html` and `markers`
     */
    formatTooltip: function (dataIndex, multipleSeries, dataType, renderMode) {
      var series = this;
      renderMode = renderMode || 'html';
      var newLine = renderMode === 'html' ? '<br/>' : '\n';
      var isRichText = renderMode === 'richText';
      var markers = {};
      var markerId = 0;

      function formatArrayValue(value) {
        // ??? TODO refactor these logic.
        // check: category-no-encode-has-axis-data in dataset.html
        var vertially = util.reduce(value, function (vertially, val, idx) {
          var dimItem = data.getDimensionInfo(idx);
          return vertially |= dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
        }, 0);
        var result = [];
        tooltipDims.length ? util.each(tooltipDims, function (dim) {
          setEachItem(retrieveRawValue$2(data, dataIndex, dim), dim);
        }) // By default, all dims is used on tooltip.
        : util.each(value, setEachItem);

        function setEachItem(val, dim) {
          var dimInfo = data.getDimensionInfo(dim); // If `dimInfo.tooltip` is not set, show tooltip.

          if (!dimInfo || dimInfo.otherDims.tooltip === false) {
            return;
          }

          var dimType = dimInfo.type;
          var markName = 'sub' + series.seriesIndex + 'at' + markerId;
          var dimHead = getTooltipMarker$2({
            color: color,
            type: 'subItem',
            renderMode: renderMode,
            markerId: markName
          });
          var dimHeadStr = typeof dimHead === 'string' ? dimHead : dimHead.content;
          var valStr = (vertially ? dimHeadStr + encodeHTML$1(dimInfo.displayName || '-') + ': ' : '') + // FIXME should not format time for raw data?
          encodeHTML$1(dimType === 'ordinal' ? val + '' : dimType === 'time' ? multipleSeries ? '' : formatTime$1('yyyy/MM/dd hh:mm:ss', val) : addCommas$1(val));
          valStr && result.push(valStr);

          if (isRichText) {
            markers[markName] = color;
            ++markerId;
          }
        }

        var newLine = vertially ? isRichText ? '\n' : '<br/>' : '';
        var content = newLine + result.join(newLine || ', ');
        return {
          renderMode: renderMode,
          content: content,
          style: markers
        };
      }

      function formatSingleValue(val) {
        // return encodeHTML(addCommas(val));
        return {
          renderMode: renderMode,
          content: encodeHTML$1(addCommas$1(val)),
          style: markers
        };
      }

      var data = this.getData();
      var tooltipDims = data.mapDimension('defaultedTooltip', true);
      var tooltipDimLen = tooltipDims.length;
      var value = this.getRawValue(dataIndex);
      var isValueArr = util.isArray(value);
      var color = data.getItemVisual(dataIndex, 'color');

      if (util.isObject(color) && color.colorStops) {
        color = (color.colorStops[0] || {}).color;
      }

      color = color || 'transparent'; // Complicated rule for pretty tooltip.

      var formattedValue = tooltipDimLen > 1 || isValueArr && !tooltipDimLen ? formatArrayValue(value) : tooltipDimLen ? formatSingleValue(retrieveRawValue$2(data, dataIndex, tooltipDims[0])) : formatSingleValue(isValueArr ? value[0] : value);
      var content = formattedValue.content;
      var markName = series.seriesIndex + 'at' + markerId;
      var colorEl = getTooltipMarker$2({
        color: color,
        type: 'item',
        renderMode: renderMode,
        markerId: markName
      });
      markers[markName] = color;
      ++markerId;
      var name = data.getName(dataIndex);
      var seriesName = this.name;

      if (!model.isNameSpecified(this)) {
        seriesName = '';
      }

      seriesName = seriesName ? encodeHTML$1(seriesName) + (!multipleSeries ? newLine : ': ') : '';
      var colorStr = typeof colorEl === 'string' ? colorEl : colorEl.content;
      var html = !multipleSeries ? seriesName + colorStr + (name ? encodeHTML$1(name) + ': ' + content : content) : colorStr + seriesName + content;
      return {
        html: html,
        markers: markers
      };
    },

    /**
     * @return {boolean}
     */
    isAnimationEnabled: function () {
      if (env_1.node) {
        return false;
      }

      var animationEnabled = this.getShallow('animation');

      if (animationEnabled) {
        if (this.getData().count() > this.getShallow('animationThreshold')) {
          animationEnabled = false;
        }
      }

      return animationEnabled;
    },
    restoreData: function () {
      this.dataTask.dirty();
    },
    getColorFromPalette: function (name, scope, requestColorNum) {
      var ecModel = this.ecModel; // PENDING

      var color = colorPalette.getColorFromPalette.call(this, name, scope, requestColorNum);

      if (!color) {
        color = ecModel.getColorFromPalette(name, scope, requestColorNum);
      }

      return color;
    },

    /**
     * Use `data.mapDimension(coordDim, true)` instead.
     * @deprecated
     */
    coordDimToDataDim: function (coordDim) {
      return this.getRawData().mapDimension(coordDim, true);
    },

    /**
     * Get progressive rendering count each step
     * @return {number}
     */
    getProgressive: function () {
      return this.get('progressive');
    },

    /**
     * Get progressive rendering count each step
     * @return {number}
     */
    getProgressiveThreshold: function () {
      return this.get('progressiveThreshold');
    },

    /**
     * Get data indices for show tooltip content. See tooltip.
     * @abstract
     * @param {Array.<string>|string} dim
     * @param {Array.<number>} value
     * @param {module:echarts/coord/single/SingleAxis} baseAxis
     * @return {Object} {dataIndices, nestestValue}.
     */
    getAxisTooltipData: null,

    /**
     * See tooltip.
     * @abstract
     * @param {number} dataIndex
     * @return {Array.<number>} Point of tooltip. null/undefined can be returned.
     */
    getTooltipPosition: null,

    /**
     * @see {module:echarts/stream/Scheduler}
     */
    pipeTask: null,

    /**
     * Convinient for override in extended class.
     * @protected
     * @type {Function}
     */
    preventIncremental: null,

    /**
     * @public
     * @readOnly
     * @type {Object}
     */
    pipelineContext: null
  });
  util.mixin(SeriesModel, dataFormat);
  util.mixin(SeriesModel, colorPalette);
  /**
   * MUST be called after `prepareSource` called
   * Here we need to make auto series, especially for auto legend. But we
   * do not modify series.name in option to avoid side effects.
   */

  function autoSeriesName(seriesModel) {
    // User specified name has higher priority, otherwise it may cause
    // series can not be queried unexpectedly.
    var name = seriesModel.name;

    if (!model.isNameSpecified(seriesModel)) {
      seriesModel.name = getSeriesAutoName(seriesModel) || name;
    }
  }

  function getSeriesAutoName(seriesModel) {
    var data = seriesModel.getRawData();
    var dataDims = data.mapDimension('seriesName', true);
    var nameArr = [];
    util.each(dataDims, function (dataDim) {
      var dimInfo = data.getDimensionInfo(dataDim);
      dimInfo.displayName && nameArr.push(dimInfo.displayName);
    });
    return nameArr.join(' ');
  }

  function dataTaskCount(context) {
    return context.model.getRawData().count();
  }

  function dataTaskReset(context) {
    var seriesModel = context.model;
    seriesModel.setData(seriesModel.getRawData().cloneShallow());
    return dataTaskProgress;
  }

  function dataTaskProgress(param, context) {
    // Avoid repead cloneShallow when data just created in reset.
    if (context.outputData && param.end > context.outputData.count()) {
      context.model.getRawData().cloneShallow(context.outputData);
    }
  } // TODO refactor


  function wrapData(data, seriesModel) {
    util.each(data.CHANGABLE_METHODS, function (methodName) {
      data.wrapMethod(methodName, util.curry(onDataSelfChange, seriesModel));
    });
  }

  function onDataSelfChange(seriesModel) {
    var task = getCurrentTask(seriesModel);

    if (task) {
      // Consider case: filter, selectRange
      task.setOutputEnd(this.count());
    }
  }

  function getCurrentTask(seriesModel) {
    var scheduler = (seriesModel.ecModel || {}).scheduler;
    var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);

    if (pipeline) {
      // When pipline finished, the currrentTask keep the last
      // task (renderTask).
      var task = pipeline.currentTask;

      if (task) {
        var agentStubMap = task.agentStubMap;

        if (agentStubMap) {
          task = agentStubMap.get(seriesModel.uid);
        }
      }

      return task;
    }
  }

  var _default$14 = SeriesModel;
  var Series = _default$14;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var Component$1 = function () {
    /**
     * @type {module:zrender/container/Group}
     * @readOnly
     */
    this.group = new Group_1();
    /**
     * @type {string}
     * @readOnly
     */

    this.uid = component.getUID('viewComponent');
  };

  Component$1.prototype = {
    constructor: Component$1,
    init: function (ecModel, api) {},
    render: function (componentModel, ecModel, api, payload) {},
    dispose: function () {},

    /**
     * @param {string} eventType
     * @param {Object} query
     * @param {module:zrender/Element} targetEl
     * @param {Object} packedEvent
     * @return {boolen} Pass only when return `true`.
     */
    filterForExposedEvent: null
  };
  var componentProto = Component$1.prototype;

  componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {// Do nothing;
  }; // Enable Component.extend.


  clazz.enableClassExtend(Component$1); // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

  clazz.enableClassManagement(Component$1, {
    registerWhenExtend: true
  });
  var _default$15 = Component$1;
  var Component_1 = _default$15;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var makeInner$5 = model.makeInner;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @return {string} If large mode changed, return string 'reset';
   */
  function _default$16() {
    var inner = makeInner$5();
    return function (seriesModel) {
      var fields = inner(seriesModel);
      var pipelineContext = seriesModel.pipelineContext;
      var originalLarge = fields.large;
      var originalProgressive = fields.progressiveRender; // FIXME: if the planner works on a filtered series, `pipelineContext` does not
      // exists. See #11611 . Probably we need to modify this structure, see the comment
      // on `performRawSeries` in `Schedular.js`.

      var large = fields.large = pipelineContext && pipelineContext.large;
      var progressive = fields.progressiveRender = pipelineContext && pipelineContext.progressiveRender;
      return !!(originalLarge ^ large || originalProgressive ^ progressive) && 'reset';
    };
  }

  var createRenderPlanner = _default$16;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var each$b = util.each;













  var createTask$2 = task$2.createTask;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var inner$5 = model.makeInner();
  var renderPlanner = createRenderPlanner();

  function Chart() {
    /**
     * @type {module:zrender/container/Group}
     * @readOnly
     */
    this.group = new Group_1();
    /**
     * @type {string}
     * @readOnly
     */

    this.uid = component.getUID('viewChart');
    this.renderTask = createTask$2({
      plan: renderTaskPlan,
      reset: renderTaskReset
    });
    this.renderTask.context = {
      view: this
    };
  }

  Chart.prototype = {
    type: 'chart',

    /**
     * Init the chart.
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */
    init: function (ecModel, api) {},

    /**
     * Render the chart.
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */
    render: function (seriesModel, ecModel, api, payload) {},

    /**
     * Highlight series or specified data item.
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */
    highlight: function (seriesModel, ecModel, api, payload) {
      toggleHighlight(seriesModel.getData(), payload, 'emphasis');
    },

    /**
     * Downplay series or specified data item.
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */
    downplay: function (seriesModel, ecModel, api, payload) {
      toggleHighlight(seriesModel.getData(), payload, 'normal');
    },

    /**
     * Remove self.
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */
    remove: function (ecModel, api) {
      this.group.removeAll();
    },

    /**
     * Dispose self.
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */
    dispose: function () {},

    /**
     * Rendering preparation in progressive mode.
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */
    incrementalPrepareRender: null,

    /**
     * Render in progressive mode.
     * @param  {Object} params See taskParams in `stream/task.js`
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     */
    incrementalRender: null,

    /**
     * Update transform directly.
     * @param  {module:echarts/model/Series} seriesModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @param  {Object} payload
     * @return {Object} {update: true}
     */
    updateTransform: null,

    /**
     * The view contains the given point.
     * @interface
     * @param {Array.<number>} point
     * @return {boolean}
     */
    // containPoint: function () {}

    /**
     * @param {string} eventType
     * @param {Object} query
     * @param {module:zrender/Element} targetEl
     * @param {Object} packedEvent
     * @return {boolen} Pass only when return `true`.
     */
    filterForExposedEvent: null
  };
  var chartProto = Chart.prototype;

  chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  /**
   * Set state of single element
   * @param {module:zrender/Element} el
   * @param {string} state 'normal'|'emphasis'
   * @param {number} highlightDigit
   */


  function elSetState(el, state, highlightDigit) {
    if (el) {
      el.trigger(state, highlightDigit);

      if (el.isGroup // Simple optimize.
      && !graphic.isHighDownDispatcher(el)) {
        for (var i = 0, len = el.childCount(); i < len; i++) {
          elSetState(el.childAt(i), state, highlightDigit);
        }
      }
    }
  }
  /**
   * @param {module:echarts/data/List} data
   * @param {Object} payload
   * @param {string} state 'normal'|'emphasis'
   */


  function toggleHighlight(data, payload, state) {
    var dataIndex = model.queryDataIndex(data, payload);
    var highlightDigit = payload && payload.highlightKey != null ? graphic.getHighlightDigit(payload.highlightKey) : null;

    if (dataIndex != null) {
      each$b(model.normalizeToArray(dataIndex), function (dataIdx) {
        elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
      });
    } else {
      data.eachItemGraphicEl(function (el) {
        elSetState(el, state, highlightDigit);
      });
    }
  } // Enable Chart.extend.


  clazz.enableClassExtend(Chart, ['dispose']); // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.

  clazz.enableClassManagement(Chart, {
    registerWhenExtend: true
  });

  Chart.markUpdateMethod = function (payload, methodName) {
    inner$5(payload).updateMethod = methodName;
  };

  function renderTaskPlan(context) {
    return renderPlanner(context.model);
  }

  function renderTaskReset(context) {
    var seriesModel = context.model;
    var ecModel = context.ecModel;
    var api = context.api;
    var payload = context.payload; // ???! remove updateView updateVisual

    var progressiveRender = seriesModel.pipelineContext.progressiveRender;
    var view = context.view;
    var updateMethod = payload && inner$5(payload).updateMethod;
    var methodName = progressiveRender ? 'incrementalPrepareRender' : updateMethod && view[updateMethod] ? updateMethod // `appendData` is also supported when data amount
    // is less than progressive threshold.
    : 'render';

    if (methodName !== 'render') {
      view[methodName](seriesModel, ecModel, api, payload);
    }

    return progressMethodMap[methodName];
  }

  var progressMethodMap = {
    incrementalPrepareRender: {
      progress: function (params, context) {
        context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
      }
    },
    render: {
      // Put view.render in `progress` to support appendData. But in this case
      // view.render should not be called in reset, otherwise it will be called
      // twise. Use `forceFirstProgress` to make sure that view.render is called
      // in any cases.
      forceFirstProgress: true,
      progress: function (params, context) {
        context.view.render(context.model, context.ecModel, context.api, context.payload);
      }
    }
  };
  var _default$17 = Chart;
  var Chart_1 = _default$17;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var ORIGIN_METHOD = '\0__throttleOriginMethod';
  var RATE = '\0__throttleRate';
  var THROTTLE_TYPE = '\0__throttleType';
  /**
   * @public
   * @param {(Function)} fn
   * @param {number} [delay=0] Unit: ms.
   * @param {boolean} [debounce=false]
   *        true: If call interval less than `delay`, only the last call works.
   *        false: If call interval less than `delay, call works on fixed rate.
   * @return {(Function)} throttled fn.
   */

  function throttle$1(fn, delay, debounce) {
    var currCall;
    var lastCall = 0;
    var lastExec = 0;
    var timer = null;
    var diff;
    var scope;
    var args;
    var debounceNextCall;
    delay = delay || 0;

    function exec() {
      lastExec = new Date().getTime();
      timer = null;
      fn.apply(scope, args || []);
    }

    var cb = function () {
      currCall = new Date().getTime();
      scope = this;
      args = arguments;
      var thisDelay = debounceNextCall || delay;
      var thisDebounce = debounceNextCall || debounce;
      debounceNextCall = null;
      diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
      clearTimeout(timer); // Here we should make sure that: the `exec` SHOULD NOT be called later
      // than a new call of `cb`, that is, preserving the command order. Consider
      // calculating "scale rate" when roaming as an example. When a call of `cb`
      // happens, either the `exec` is called dierectly, or the call is delayed.
      // But the delayed call should never be later than next call of `cb`. Under
      // this assurance, we can simply update view state each time `dispatchAction`
      // triggered by user roaming, but not need to add extra code to avoid the
      // state being "rolled-back".

      if (thisDebounce) {
        timer = setTimeout(exec, thisDelay);
      } else {
        if (diff >= 0) {
          exec();
        } else {
          timer = setTimeout(exec, -diff);
        }
      }

      lastCall = currCall;
    };
    /**
     * Clear throttle.
     * @public
     */


    cb.clear = function () {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    /**
     * Enable debounce once.
     */


    cb.debounceNextCall = function (debounceDelay) {
      debounceNextCall = debounceDelay;
    };

    return cb;
  }
  /**
   * Create throttle method or update throttle rate.
   *
   * @example
   * ComponentView.prototype.render = function () {
   *     ...
   *     throttle.createOrUpdate(
   *         this,
   *         '_dispatchAction',
   *         this.model.get('throttle'),
   *         'fixRate'
   *     );
   * };
   * ComponentView.prototype.remove = function () {
   *     throttle.clear(this, '_dispatchAction');
   * };
   * ComponentView.prototype.dispose = function () {
   *     throttle.clear(this, '_dispatchAction');
   * };
   *
   * @public
   * @param {Object} obj
   * @param {string} fnAttr
   * @param {number} [rate]
   * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'
   * @return {Function} throttled function.
   */


  function createOrUpdate(obj, fnAttr, rate, throttleType) {
    var fn = obj[fnAttr];

    if (!fn) {
      return;
    }

    var originFn = fn[ORIGIN_METHOD] || fn;
    var lastThrottleType = fn[THROTTLE_TYPE];
    var lastRate = fn[RATE];

    if (lastRate !== rate || lastThrottleType !== throttleType) {
      if (rate == null || !throttleType) {
        return obj[fnAttr] = originFn;
      }

      fn = obj[fnAttr] = throttle$1(originFn, rate, throttleType === 'debounce');
      fn[ORIGIN_METHOD] = originFn;
      fn[THROTTLE_TYPE] = throttleType;
      fn[RATE] = rate;
    }

    return fn;
  }
  /**
   * Clear throttle. Example see throttle.createOrUpdate.
   *
   * @public
   * @param {Object} obj
   * @param {string} fnAttr
   */


  function clear$1(obj, fnAttr) {
    var fn = obj[fnAttr];

    if (fn && fn[ORIGIN_METHOD]) {
      obj[fnAttr] = fn[ORIGIN_METHOD];
    }
  }

  var throttle_2 = throttle$1;
  var createOrUpdate_1 = createOrUpdate;
  var clear_1 = clear$1;

  var throttle_1 = {
  	throttle: throttle_2,
  	createOrUpdate: createOrUpdate_1,
  	clear: clear_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  var isFunction$3 = util.isFunction;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var _default$18 = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function (seriesModel, ecModel) {
      var data = seriesModel.getData();
      var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.color').split('.'); // Set in itemStyle

      var color = seriesModel.get(colorAccessPath);
      var colorCallback = isFunction$3(color) && !(color instanceof Gradient_1) ? color : null; // Default color

      if (!color || colorCallback) {
        color = seriesModel.getColorFromPalette( // TODO series count changed.
        seriesModel.name, null, ecModel.getSeriesCount());
      }

      data.setVisual('color', color);
      var borderColorAccessPath = (seriesModel.visualBorderColorAccessPath || 'itemStyle.borderColor').split('.');
      var borderColor = seriesModel.get(borderColorAccessPath);
      data.setVisual('borderColor', borderColor); // Only visible series has each data be visual encoded

      if (!ecModel.isSeriesFiltered(seriesModel)) {
        if (colorCallback) {
          data.each(function (idx) {
            data.setItemVisual(idx, 'color', colorCallback(seriesModel.getDataParams(idx)));
          });
        } // itemStyle in each data item


        var dataEach = function (data, idx) {
          var itemModel = data.getItemModel(idx);
          var color = itemModel.get(colorAccessPath, true);
          var borderColor = itemModel.get(borderColorAccessPath, true);

          if (color != null) {
            data.setItemVisual(idx, 'color', color);
          }

          if (borderColor != null) {
            data.setItemVisual(idx, 'borderColor', borderColor);
          }
        };

        return {
          dataEach: data.hasItemOption ? dataEach : null
        };
      }
    }
  };
  var seriesColor = _default$18;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Language: (Simplified) Chinese.
   */
  var _default$19 = {
    legend: {
      selector: {
        all: 'å¨é',
        inverse: 'åé'
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: 'ç©å½¢éæ©',
          polygon: 'åé',
          lineX: 'æ¨ªåéæ©',
          lineY: 'çºµåéæ©',
          keep: 'ä¿æéæ©',
          clear: 'æ¸é¤éæ©'
        }
      },
      dataView: {
        title: 'æ°æ®è§å¾',
        lang: ['æ°æ®è§å¾', 'å³é­', 'å·æ°']
      },
      dataZoom: {
        title: {
          zoom: 'åºåç¼©æ¾',
          back: 'åºåç¼©æ¾è¿å'
        }
      },
      magicType: {
        title: {
          line: 'åæ¢ä¸ºæçº¿å¾',
          bar: 'åæ¢ä¸ºæ±ç¶å¾',
          stack: 'åæ¢ä¸ºå å ',
          tiled: 'åæ¢ä¸ºå¹³éº'
        }
      },
      restore: {
        title: 'è¿å'
      },
      saveAsImage: {
        title: 'ä¿å­ä¸ºå¾ç',
        lang: ['å³é®å¦å­ä¸ºå¾ç']
      }
    },
    series: {
      typeNames: {
        pie: 'é¥¼å¾',
        bar: 'æ±ç¶å¾',
        line: 'æçº¿å¾',
        scatter: 'æ£ç¹å¾',
        effectScatter: 'æ¶æ¼ªæ£ç¹å¾',
        radar: 'é·è¾¾å¾',
        tree: 'æ å¾',
        treemap: 'ç©å½¢æ å¾',
        boxplot: 'ç®±åå¾',
        candlestick: 'Kçº¿å¾',
        k: 'Kçº¿å¾',
        heatmap: 'ç­åå¾',
        map: 'å°å¾',
        parallel: 'å¹³è¡åæ å¾',
        lines: 'çº¿å¾',
        graph: 'å³ç³»å¾',
        sankey: 'æ¡åºå¾',
        funnel: 'æ¼æå¾',
        gauge: 'ä»ªè¡¨çå¾',
        pictorialBar: 'è±¡å½¢æ±å¾',
        themeRiver: 'ä¸»é¢æ²³æµå¾',
        sunburst: 'æ­æ¥å¾'
      }
    },
    aria: {
      general: {
        withTitle: 'è¿æ¯ä¸ä¸ªå³äºâ{title}âçå¾è¡¨ã',
        withoutTitle: 'è¿æ¯ä¸ä¸ªå¾è¡¨ï¼'
      },
      series: {
        single: {
          prefix: '',
          withName: 'å¾è¡¨ç±»åæ¯{seriesType}ï¼è¡¨ç¤º{seriesName}ã',
          withoutName: 'å¾è¡¨ç±»åæ¯{seriesType}ã'
        },
        multiple: {
          prefix: 'å®ç±{seriesCount}ä¸ªå¾è¡¨ç³»åç»æã',
          withName: 'ç¬¬{seriesId}ä¸ªç³»åæ¯ä¸ä¸ªè¡¨ç¤º{seriesName}ç{seriesType}ï¼',
          withoutName: 'ç¬¬{seriesId}ä¸ªç³»åæ¯ä¸ä¸ª{seriesType}ï¼',
          separator: {
            middle: 'ï¼',
            end: 'ã'
          }
        }
      },
      data: {
        allData: 'å¶æ°æ®æ¯ââ',
        partialData: 'å¶ä¸­ï¼å{displayCnt}é¡¹æ¯ââ',
        withName: '{name}çæ°æ®æ¯{value}',
        withoutName: '{value}',
        separator: {
          middle: 'ï¼',
          end: ''
        }
      }
    }
  };
  var lang = _default$19;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  var retrieveRawValue$3 = dataProvider.retrieveRawValue;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function _default$1a(dom, ecModel) {
    var ariaModel = ecModel.getModel('aria');

    if (!ariaModel.get('show')) {
      return;
    } else if (ariaModel.get('description')) {
      dom.setAttribute('aria-label', ariaModel.get('description'));
      return;
    }

    var seriesCnt = 0;
    ecModel.eachSeries(function (seriesModel, idx) {
      ++seriesCnt;
    }, this);
    var maxDataCnt = ariaModel.get('data.maxCount') || 10;
    var maxSeriesCnt = ariaModel.get('series.maxCount') || 10;
    var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
    var ariaLabel;

    if (seriesCnt < 1) {
      // No series, no aria label
      return;
    } else {
      var title = getTitle();

      if (title) {
        ariaLabel = replace(getConfig('general.withTitle'), {
          title: title
        });
      } else {
        ariaLabel = getConfig('general.withoutTitle');
      }

      var seriesLabels = [];
      var prefix = seriesCnt > 1 ? 'series.multiple.prefix' : 'series.single.prefix';
      ariaLabel += replace(getConfig(prefix), {
        seriesCount: seriesCnt
      });
      ecModel.eachSeries(function (seriesModel, idx) {
        if (idx < displaySeriesCnt) {
          var seriesLabel;
          var seriesName = seriesModel.get('name');
          var seriesTpl = 'series.' + (seriesCnt > 1 ? 'multiple' : 'single') + '.';
          seriesLabel = getConfig(seriesName ? seriesTpl + 'withName' : seriesTpl + 'withoutName');
          seriesLabel = replace(seriesLabel, {
            seriesId: seriesModel.seriesIndex,
            seriesName: seriesModel.get('name'),
            seriesType: getSeriesTypeName(seriesModel.subType)
          });
          var data = seriesModel.getData();
          window.data = data;

          if (data.count() > maxDataCnt) {
            // Show part of data
            seriesLabel += replace(getConfig('data.partialData'), {
              displayCnt: maxDataCnt
            });
          } else {
            seriesLabel += getConfig('data.allData');
          }

          var dataLabels = [];

          for (var i = 0; i < data.count(); i++) {
            if (i < maxDataCnt) {
              var name = data.getName(i);
              var value = retrieveRawValue$3(data, i);
              dataLabels.push(replace(name ? getConfig('data.withName') : getConfig('data.withoutName'), {
                name: name,
                value: value
              }));
            }
          }

          seriesLabel += dataLabels.join(getConfig('data.separator.middle')) + getConfig('data.separator.end');
          seriesLabels.push(seriesLabel);
        }
      });
      ariaLabel += seriesLabels.join(getConfig('series.multiple.separator.middle')) + getConfig('series.multiple.separator.end');
      dom.setAttribute('aria-label', ariaLabel);
    }

    function replace(str, keyValues) {
      if (typeof str !== 'string') {
        return str;
      }

      var result = str;
      util.each(keyValues, function (value, key) {
        result = result.replace(new RegExp('\\{\\s*' + key + '\\s*\\}', 'g'), value);
      });
      return result;
    }

    function getConfig(path) {
      var userConfig = ariaModel.get(path);

      if (userConfig == null) {
        var pathArr = path.split('.');
        var result = lang.aria;

        for (var i = 0; i < pathArr.length; ++i) {
          result = result[pathArr[i]];
        }

        return result;
      } else {
        return userConfig;
      }
    }

    function getTitle() {
      var title = ecModel.getModel('title').option;

      if (title && title.length) {
        title = title[0];
      }

      return title && title.text;
    }

    function getSeriesTypeName(type) {
      return lang.series.typeNames[type] || 'èªå®ä¹å¾';
    }
  }

  var aria = _default$1a;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var PI$1 = Math.PI;
  /**
   * @param {module:echarts/ExtensionAPI} api
   * @param {Object} [opts]
   * @param {string} [opts.text]
   * @param {string} [opts.color]
   * @param {string} [opts.textColor]
   * @return {module:zrender/Element}
   */

  function _default$1b(api, opts) {
    opts = opts || {};
    util.defaults(opts, {
      text: 'loading',
      textColor: '#000',
      fontSize: '12px',
      maskColor: 'rgba(255, 255, 255, 0.8)',
      showSpinner: true,
      color: '#c23531',
      spinnerRadius: 10,
      lineWidth: 5,
      zlevel: 0
    });
    var group = new graphic.Group();
    var mask = new graphic.Rect({
      style: {
        fill: opts.maskColor
      },
      zlevel: opts.zlevel,
      z: 10000
    });
    group.add(mask);
    var font = opts.fontSize + ' sans-serif';
    var labelRect = new graphic.Rect({
      style: {
        fill: 'none',
        text: opts.text,
        font: font,
        textPosition: 'right',
        textDistance: 10,
        textFill: opts.textColor
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    group.add(labelRect);

    if (opts.showSpinner) {
      var arc = new graphic.Arc({
        shape: {
          startAngle: -PI$1 / 2,
          endAngle: -PI$1 / 2 + 0.1,
          r: opts.spinnerRadius
        },
        style: {
          stroke: opts.color,
          lineCap: 'round',
          lineWidth: opts.lineWidth
        },
        zlevel: opts.zlevel,
        z: 10001
      });
      arc.animateShape(true).when(1000, {
        endAngle: PI$1 * 3 / 2
      }).start('circularInOut');
      arc.animateShape(true).when(1000, {
        startAngle: PI$1 * 3 / 2
      }).delay(300).start('circularInOut');
      group.add(arc);
    } // Inject resize


    group.resize = function () {
      var textWidth = text.getWidth(opts.text, font);
      var r = opts.showSpinner ? opts.spinnerRadius : 0; // cx = (containerWidth - arcDiameter - textDistance - textWidth) / 2
      // textDistance needs to be calculated when both animation and text exist

      var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 // only show the text
      - (opts.showSpinner ? 0 : textWidth / 2);
      var cy = api.getHeight() / 2;
      opts.showSpinner && arc.setShape({
        cx: cx,
        cy: cy
      });
      labelRect.setShape({
        x: cx - r,
        y: cy - r,
        width: r * 2,
        height: r * 2
      });
      mask.setShape({
        x: 0,
        y: 0,
        width: api.getWidth(),
        height: api.getHeight()
      });
    };

    group.resize();
    return group;
  }

  var _default_1 = _default$1b;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var each$c = util.each;
  var map$4 = util.map;
  var isFunction$4 = util.isFunction;
  var createHashMap$5 = util.createHashMap;
  var noop$2 = util.noop;



  var createTask$3 = task$2.createTask;



  var getUID$1 = component.getUID;







  var normalizeToArray$3 = model.normalizeToArray;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @module echarts/stream/Scheduler
   */

  /**
   * @constructor
   */
  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {
    this.ecInstance = ecInstance;
    this.api = api;
    this.unfinished; // Fix current processors in case that in some rear cases that
    // processors might be registered after echarts instance created.
    // Register processors incrementally for a echarts instance is
    // not supported by this stream architecture.

    var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
    var visualHandlers = this._visualHandlers = visualHandlers.slice();
    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
    /**
     * @private
     * @type {
     *     [handlerUID: string]: {
     *         seriesTaskMap?: {
     *             [seriesUID: string]: Task
     *         },
     *         overallTask?: Task
     *     }
     * }
     */

    this._stageTaskMap = createHashMap$5();
  }

  var proto = Scheduler.prototype;
  /**
   * @param {module:echarts/model/Global} ecModel
   * @param {Object} payload
   */

  proto.restoreData = function (ecModel, payload) {
    // TODO: Only restore needed series and components, but not all components.
    // Currently `restoreData` of all of the series and component will be called.
    // But some independent components like `title`, `legend`, `graphic`, `toolbox`,
    // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,
    // and some components like coordinate system, axes, dataZoom, visualMap only
    // need their target series refresh.
    // (1) If we are implementing this feature some day, we should consider these cases:
    // if a data processor depends on a component (e.g., dataZoomProcessor depends
    // on the settings of `dataZoom`), it should be re-performed if the component
    // is modified by `setOption`.
    // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,
    // it should be re-performed when the result array of `getTargetSeries` changed.
    // We use `dependencies` to cover these issues.
    // (3) How to update target series when coordinate system related components modified.
    // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,
    // and this case all of the tasks will be set as dirty.
    ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also
    // depends on all of the series.
    // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks
    // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure
    // that the overall task is set as dirty and to be performed, otherwise it probably cause
    // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it
    // probably cause state chaos (consider `dataZoomProcessor`).

    this._stageTaskMap.each(function (taskRecord) {
      var overallTask = taskRecord.overallTask;
      overallTask && overallTask.dirty();
    });
  }; // If seriesModel provided, incremental threshold is check by series data.


  proto.getPerformArgs = function (task, isBlock) {
    // For overall task
    if (!task.__pipeline) {
      return;
    }

    var pipeline = this._pipelineMap.get(task.__pipeline.id);

    var pCtx = pipeline.context;
    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
    var step = incremental ? pipeline.step : null;
    var modDataCount = pCtx && pCtx.modDataCount;
    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
    return {
      step: step,
      modBy: modBy,
      modDataCount: modDataCount
    };
  };

  proto.getPipeline = function (pipelineId) {
    return this._pipelineMap.get(pipelineId);
  };
  /**
   * Current, progressive rendering starts from visual and layout.
   * Always detect render mode in the same stage, avoiding that incorrect
   * detection caused by data filtering.
   * Caution:
   * `updateStreamModes` use `seriesModel.getData()`.
   */


  proto.updateStreamModes = function (seriesModel, view) {
    var pipeline = this._pipelineMap.get(seriesModel.uid);

    var data = seriesModel.getData();
    var dataLen = data.count(); // `progressiveRender` means that can render progressively in each
    // animation frame. Note that some types of series do not provide
    // `view.incrementalPrepareRender` but support `chart.appendData`. We
    // use the term `incremental` but not `progressive` to describe the
    // case that `chart.appendData`.

    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.
    // see `test/candlestick-large3.html`

    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;
    seriesModel.pipelineContext = pipeline.context = {
      progressiveRender: progressiveRender,
      modDataCount: modDataCount,
      large: large
    };
  };

  proto.restorePipelines = function (ecModel) {
    var scheduler = this;
    var pipelineMap = scheduler._pipelineMap = createHashMap$5();
    ecModel.eachSeries(function (seriesModel) {
      var progressive = seriesModel.getProgressive();
      var pipelineId = seriesModel.uid;
      pipelineMap.set(pipelineId, {
        id: pipelineId,
        head: null,
        tail: null,
        threshold: seriesModel.getProgressiveThreshold(),
        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
        blockIndex: -1,
        step: Math.round(progressive || 700),
        count: 0
      });
      pipe(scheduler, seriesModel, seriesModel.dataTask);
    });
  };

  proto.prepareStageTasks = function () {
    var stageTaskMap = this._stageTaskMap;
    var ecModel = this.ecInstance.getModel();
    var api = this.api;
    each$c(this._allHandlers, function (handler) {
      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);
      handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);
      handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);
    }, this);
  };

  proto.prepareView = function (view, model, ecModel, api) {
    var renderTask = view.renderTask;
    var context = renderTask.context;
    context.model = model;
    context.ecModel = ecModel;
    context.api = api;
    renderTask.__block = !view.incrementalPrepareRender;
    pipe(this, model, renderTask);
  };

  proto.performDataProcessorTasks = function (ecModel, payload) {
    // If we do not use `block` here, it should be considered when to update modes.
    performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {
      block: true
    });
  }; // opt
  // opt.visualType: 'visual' or 'layout'
  // opt.setDirty


  proto.performVisualTasks = function (ecModel, payload, opt) {
    performStageTasks(this, this._visualHandlers, ecModel, payload, opt);
  };

  function performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {
    opt = opt || {};
    var unfinished;
    each$c(stageHandlers, function (stageHandler, idx) {
      if (opt.visualType && opt.visualType !== stageHandler.visualType) {
        return;
      }

      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);

      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
      var overallTask = stageHandlerRecord.overallTask;

      if (overallTask) {
        var overallNeedDirty;
        var agentStubMap = overallTask.agentStubMap;
        agentStubMap.each(function (stub) {
          if (needSetDirty(opt, stub)) {
            stub.dirty();
            overallNeedDirty = true;
          }
        });
        overallNeedDirty && overallTask.dirty();
        updatePayload(overallTask, payload);
        var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,
        // then execute the overall task. And stub will call seriesModel.setData,
        // which ensures that in the overallTask seriesModel.getData() will not
        // return incorrect data.

        agentStubMap.each(function (stub) {
          stub.perform(performArgs);
        });
        unfinished |= overallTask.perform(performArgs);
      } else if (seriesTaskMap) {
        seriesTaskMap.each(function (task, pipelineId) {
          if (needSetDirty(opt, task)) {
            task.dirty();
          }

          var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME
          // if intending to decalare `performRawSeries` in handlers, only
          // stream-independent (specifically, data item independent) operations can be
          // performed. Because is a series is filtered, most of the tasks will not
          // be performed. A stream-dependent operation probably cause wrong biz logic.
          // Perhaps we should not provide a separate callback for this case instead
          // of providing the config `performRawSeries`. The stream-dependent operaions
          // and stream-independent operations should better not be mixed.

          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
          updatePayload(task, payload);
          unfinished |= task.perform(performArgs);
        });
      }
    });

    function needSetDirty(opt, task) {
      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));
    }

    scheduler.unfinished |= unfinished;
  }

  proto.performSeriesTasks = function (ecModel) {
    var unfinished;
    ecModel.eachSeries(function (seriesModel) {
      // Progress to the end for dataInit and dataRestore.
      unfinished |= seriesModel.dataTask.perform();
    });
    this.unfinished |= unfinished;
  };

  proto.plan = function () {
    // Travel pipelines, check block.
    this._pipelineMap.each(function (pipeline) {
      var task = pipeline.tail;

      do {
        if (task.__block) {
          pipeline.blockIndex = task.__idxInPipeline;
          break;
        }

        task = task.getUpstream();
      } while (task);
    });
  };

  var updatePayload = proto.updatePayload = function (task, payload) {
    payload !== 'remain' && (task.context.payload = payload);
  };

  function createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
    var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap$5());
    var seriesType = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,
    // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,
    // it works but it may cause other irrelevant charts blocked.

    if (stageHandler.createOnAllSeries) {
      ecModel.eachRawSeries(create);
    } else if (seriesType) {
      ecModel.eachRawSeriesByType(seriesType, create);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(create);
    }

    function create(seriesModel) {
      var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.
      // Reuse original task instance.

      var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask$3({
        plan: seriesTaskPlan,
        reset: seriesTaskReset,
        count: seriesTaskCount
      }));
      task.context = {
        model: seriesModel,
        ecModel: ecModel,
        api: api,
        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
        plan: stageHandler.plan,
        reset: stageHandler.reset,
        scheduler: scheduler
      };
      pipe(scheduler, seriesModel, task);
    } // Clear unused series tasks.


    var pipelineMap = scheduler._pipelineMap;
    seriesTaskMap.each(function (task, pipelineId) {
      if (!pipelineMap.get(pipelineId)) {
        task.dispose();
        seriesTaskMap.removeKey(pipelineId);
      }
    });
  }

  function createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.
    || createTask$3({
      reset: overallTaskReset
    });
    overallTask.context = {
      ecModel: ecModel,
      api: api,
      overallReset: stageHandler.overallReset,
      scheduler: scheduler
    }; // Reuse orignal stubs.

    var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap$5();
    var seriesType = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    var overallProgress = true;
    var modifyOutputEnd = stageHandler.modifyOutputEnd; // An overall task with seriesType detected or has `getTargetSeries`, we add
    // stub in each pipelines, it will set the overall task dirty when the pipeline
    // progress. Moreover, to avoid call the overall task each frame (too frequent),
    // we set the pipeline block.

    if (seriesType) {
      ecModel.eachRawSeriesByType(seriesType, createStub);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(createStub);
    } // Otherwise, (usually it is legancy case), the overall task will only be
    // executed when upstream dirty. Otherwise the progressive rendering of all
    // pipelines will be disabled unexpectedly. But it still needs stubs to receive
    // dirty info from upsteam.
    else {
        overallProgress = false;
        each$c(ecModel.getSeries(), createStub);
      }

    function createStub(seriesModel) {
      var pipelineId = seriesModel.uid;
      var stub = agentStubMap.get(pipelineId);

      if (!stub) {
        stub = agentStubMap.set(pipelineId, createTask$3({
          reset: stubReset,
          onDirty: stubOnDirty
        })); // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.

        overallTask.dirty();
      }

      stub.context = {
        model: seriesModel,
        overallProgress: overallProgress,
        modifyOutputEnd: modifyOutputEnd
      };
      stub.agent = overallTask;
      stub.__block = overallProgress;
      pipe(scheduler, seriesModel, stub);
    } // Clear unused stubs.


    var pipelineMap = scheduler._pipelineMap;
    agentStubMap.each(function (stub, pipelineId) {
      if (!pipelineMap.get(pipelineId)) {
        stub.dispose(); // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.

        overallTask.dirty();
        agentStubMap.removeKey(pipelineId);
      }
    });
  }

  function overallTaskReset(context) {
    context.overallReset(context.ecModel, context.api, context.payload);
  }

  function stubReset(context, upstreamContext) {
    return context.overallProgress && stubProgress;
  }

  function stubProgress() {
    this.agent.dirty();
    this.getDownstream().dirty();
  }

  function stubOnDirty() {
    this.agent && this.agent.dirty();
  }

  function seriesTaskPlan(context) {
    return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);
  }

  function seriesTaskReset(context) {
    if (context.useClearVisual) {
      context.data.clearAllVisual();
    }

    var resetDefines = context.resetDefines = normalizeToArray$3(context.reset(context.model, context.ecModel, context.api, context.payload));
    return resetDefines.length > 1 ? map$4(resetDefines, function (v, idx) {
      return makeSeriesTaskProgress(idx);
    }) : singleSeriesTaskProgress;
  }

  var singleSeriesTaskProgress = makeSeriesTaskProgress(0);

  function makeSeriesTaskProgress(resetDefineIdx) {
    return function (params, context) {
      var data = context.data;
      var resetDefine = context.resetDefines[resetDefineIdx];

      if (resetDefine && resetDefine.dataEach) {
        for (var i = params.start; i < params.end; i++) {
          resetDefine.dataEach(data, i);
        }
      } else if (resetDefine && resetDefine.progress) {
        resetDefine.progress(params, data);
      }
    };
  }

  function seriesTaskCount(context) {
    return context.data.count();
  }

  function pipe(scheduler, seriesModel, task) {
    var pipelineId = seriesModel.uid;

    var pipeline = scheduler._pipelineMap.get(pipelineId);

    !pipeline.head && (pipeline.head = task);
    pipeline.tail && pipeline.tail.pipe(task);
    pipeline.tail = task;
    task.__idxInPipeline = pipeline.count++;
    task.__pipeline = pipeline;
  }

  Scheduler.wrapStageHandler = function (stageHandler, visualType) {
    if (isFunction$4(stageHandler)) {
      stageHandler = {
        overallReset: stageHandler,
        seriesType: detectSeriseType(stageHandler)
      };
    }

    stageHandler.uid = getUID$1('stageHandler');
    visualType && (stageHandler.visualType = visualType);
    return stageHandler;
  };
  /**
   * Only some legacy stage handlers (usually in echarts extensions) are pure function.
   * To ensure that they can work normally, they should work in block mode, that is,
   * they should not be started util the previous tasks finished. So they cause the
   * progressive rendering disabled. We try to detect the series type, to narrow down
   * the block range to only the series type they concern, but not all series.
   */


  function detectSeriseType(legacyFunc) {
    seriesType = null;

    try {
      // Assume there is no async when calling `eachSeriesByType`.
      legacyFunc(ecModelMock, apiMock);
    } catch (e) {}

    return seriesType;
  }

  var ecModelMock = {};
  var apiMock = {};
  var seriesType;
  mockMethods(ecModelMock, Global);
  mockMethods(apiMock, ExtensionAPI_1);

  ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {
    seriesType = type;
  };

  ecModelMock.eachComponent = function (cond) {
    if (cond.mainType === 'series' && cond.subType) {
      seriesType = cond.subType;
    }
  };

  function mockMethods(target, Clz) {
    /* eslint-disable */
    for (var name in Clz.prototype) {
      // Do not use hasOwnProperty
      target[name] = noop$2;
    }
    /* eslint-enable */

  }

  var _default$1c = Scheduler;
  var Scheduler_1 = _default$1c;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var colorAll = ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF'];
  var _default$1d = {
    color: colorAll,
    colorLayer: [['#37A2DA', '#ffd85c', '#fd7b5f'], ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'], ['#37A2DA', '#32C5E9', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#e7bcf3', '#8378EA', '#96BFFF'], colorAll]
  };
  var light = _default$1d;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var contrastColor = '#eee';

  var axisCommon = function () {
    return {
      axisLine: {
        lineStyle: {
          color: contrastColor
        }
      },
      axisTick: {
        lineStyle: {
          color: contrastColor
        }
      },
      axisLabel: {
        textStyle: {
          color: contrastColor
        }
      },
      splitLine: {
        lineStyle: {
          type: 'dashed',
          color: '#aaa'
        }
      },
      splitArea: {
        areaStyle: {
          color: contrastColor
        }
      }
    };
  };

  var colorPalette$1 = ['#dd6b66', '#759aa0', '#e69d87', '#8dc1a9', '#ea7e53', '#eedd78', '#73a373', '#73b9bc', '#7289ab', '#91ca8c', '#f49f42'];
  var theme = {
    color: colorPalette$1,
    backgroundColor: '#333',
    tooltip: {
      axisPointer: {
        lineStyle: {
          color: contrastColor
        },
        crossStyle: {
          color: contrastColor
        },
        label: {
          color: '#000'
        }
      }
    },
    legend: {
      textStyle: {
        color: contrastColor
      }
    },
    textStyle: {
      color: contrastColor
    },
    title: {
      textStyle: {
        color: contrastColor
      }
    },
    toolbox: {
      iconStyle: {
        normal: {
          borderColor: contrastColor
        }
      }
    },
    dataZoom: {
      textStyle: {
        color: contrastColor
      }
    },
    visualMap: {
      textStyle: {
        color: contrastColor
      }
    },
    timeline: {
      lineStyle: {
        color: contrastColor
      },
      itemStyle: {
        normal: {
          color: colorPalette$1[1]
        }
      },
      label: {
        normal: {
          textStyle: {
            color: contrastColor
          }
        }
      },
      controlStyle: {
        normal: {
          color: contrastColor,
          borderColor: contrastColor
        }
      }
    },
    timeAxis: axisCommon(),
    logAxis: axisCommon(),
    valueAxis: axisCommon(),
    categoryAxis: axisCommon(),
    line: {
      symbol: 'circle'
    },
    graph: {
      color: colorPalette$1
    },
    gauge: {
      title: {
        textStyle: {
          color: contrastColor
        }
      }
    },
    candlestick: {
      itemStyle: {
        normal: {
          color: '#FD1050',
          color0: '#0CF49B',
          borderColor: '#FD1050',
          borderColor0: '#0CF49B'
        }
      }
    }
  };
  theme.categoryAxis.splitLine.show = false;
  var _default$1e = theme;
  var dark = _default$1e;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  var detectSourceFormat$1 = sourceHelper.detectSourceFormat;



  var SERIES_LAYOUT_BY_COLUMN$2 = sourceType.SERIES_LAYOUT_BY_COLUMN;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * This module is imported by echarts directly.
   *
   * Notice:
   * Always keep this file exists for backward compatibility.
   * Because before 4.1.0, dataset is an optional component,
   * some users may import this module manually.
   */
  Component.extend({
    type: 'dataset',

    /**
     * @protected
     */
    defaultOption: {
      // 'row', 'column'
      seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN$2,
      // null/'auto': auto detect header, see "module:echarts/data/helper/sourceHelper"
      sourceHeader: null,
      dimensions: null,
      source: null
    },
    optionUpdated: function () {
      detectSourceFormat$1(this);
    }
  });
  Component_1.extend({
    type: 'dataset'
  });

  /**
   * æ¤­åå½¢ç¶
   * @module zrender/graphic/shape/Ellipse
   */
  var _default$1f = Path_1.extend({
    type: 'ellipse',
    shape: {
      cx: 0,
      cy: 0,
      rx: 0,
      ry: 0
    },
    buildPath: function (ctx, shape) {
      var k = 0.5522848;
      var x = shape.cx;
      var y = shape.cy;
      var a = shape.rx;
      var b = shape.ry;
      var ox = a * k; // æ°´å¹³æ§å¶ç¹åç§»é

      var oy = b * k; // åç´æ§å¶ç¹åç§»é
      // ä»æ¤­åçå·¦ç«¯ç¹å¼å§é¡ºæ¶éç»å¶åæ¡ä¸æ¬¡è´å¡å°æ²çº¿

      ctx.moveTo(x - a, y);
      ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
      ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
      ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
      ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
      ctx.closePath();
    }
  });

  var Ellipse = _default$1f;

  var createFromString$1 = path$2.createFromString;



  var isString$6 = util.isString;
  var extend$7 = util.extend;
  var defaults$1 = util.defaults;
  var trim$3 = util.trim;
  var each$d = util.each;
  // import RadialGradient from '../graphic/RadialGradient';
  // import Pattern from '../graphic/Pattern';
  // import * as vector from '../core/vector';
  // Most of the values can be separated by comma and/or white space.
  var DILIMITER_REG = /[\s,]+/;
  /**
   * For big svg string, this method might be time consuming.
   *
   * @param {string} svg xml string
   * @return {Object} xml root.
   */

  function parseXML(svg) {
    if (isString$6(svg)) {
      var parser = new DOMParser();
      svg = parser.parseFromString(svg, 'text/xml');
    } // Document node. If using $.get, doc node may be input.


    if (svg.nodeType === 9) {
      svg = svg.firstChild;
    } // nodeName of <!DOCTYPE svg> is also 'svg'.


    while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {
      svg = svg.nextSibling;
    }

    return svg;
  }

  function SVGParser() {
    this._defs = {};
    this._root = null;
    this._isDefine = false;
    this._isText = false;
  }

  SVGParser.prototype.parse = function (xml, opt) {
    opt = opt || {};
    var svg = parseXML(xml);

    if (!svg) {
      throw new Error('Illegal svg');
    }

    var root = new Group_1();
    this._root = root; // parse view port

    var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means "100%" of `opt.width/height`.
    // TODO: Other percent value not supported yet.

    var width = parseFloat(svg.getAttribute('width') || opt.width);
    var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.

    isNaN(width) && (width = null);
    isNaN(height) && (height = null); // Apply inline style on svg element.

    parseAttributes(svg, root, null, true);
    var child = svg.firstChild;

    while (child) {
      this._parseNode(child, root);

      child = child.nextSibling;
    }

    var viewBoxRect;
    var viewBoxTransform;

    if (viewBox) {
      var viewBoxArr = trim$3(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.

      if (viewBoxArr.length >= 4) {
        viewBoxRect = {
          x: parseFloat(viewBoxArr[0] || 0),
          y: parseFloat(viewBoxArr[1] || 0),
          width: parseFloat(viewBoxArr[2]),
          height: parseFloat(viewBoxArr[3])
        };
      }
    }

    if (viewBoxRect && width != null && height != null) {
      viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);

      if (!opt.ignoreViewBox) {
        // If set transform on the output group, it probably bring trouble when
        // some users only intend to show the clipped content inside the viewBox,
        // but not intend to transform the output group. So we keep the output
        // group no transform. If the user intend to use the viewBox as a
        // camera, just set `opt.ignoreViewBox` as `true` and set transfrom
        // manually according to the viewBox info in the output of this method.
        var elRoot = root;
        root = new Group_1();
        root.add(elRoot);
        elRoot.scale = viewBoxTransform.scale.slice();
        elRoot.position = viewBoxTransform.position.slice();
      }
    } // Some shapes might be overflow the viewport, which should be
    // clipped despite whether the viewBox is used, as the SVG does.


    if (!opt.ignoreRootClip && width != null && height != null) {
      root.setClipPath(new Rect({
        shape: {
          x: 0,
          y: 0,
          width: width,
          height: height
        }
      }));
    } // Set width/height on group just for output the viewport size.


    return {
      root: root,
      width: width,
      height: height,
      viewBoxRect: viewBoxRect,
      viewBoxTransform: viewBoxTransform
    };
  };

  SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {
    var nodeName = xmlNode.nodeName.toLowerCase(); // TODO
    // support <style>...</style> in svg, where nodeName is 'style',
    // CSS classes is defined globally wherever the style tags are declared.

    if (nodeName === 'defs') {
      // define flag
      this._isDefine = true;
    } else if (nodeName === 'text') {
      this._isText = true;
    }

    var el;

    if (this._isDefine) {
      var parser = defineParsers[nodeName];

      if (parser) {
        var def = parser.call(this, xmlNode);
        var id = xmlNode.getAttribute('id');

        if (id) {
          this._defs[id] = def;
        }
      }
    } else {
      var parser = nodeParsers[nodeName];

      if (parser) {
        el = parser.call(this, xmlNode, parentGroup);
        parentGroup.add(el);
      }
    }

    var child = xmlNode.firstChild;

    while (child) {
      if (child.nodeType === 1) {
        this._parseNode(child, el);
      } // Is text


      if (child.nodeType === 3 && this._isText) {
        this._parseText(child, el);
      }

      child = child.nextSibling;
    } // Quit define


    if (nodeName === 'defs') {
      this._isDefine = false;
    } else if (nodeName === 'text') {
      this._isText = false;
    }
  };

  SVGParser.prototype._parseText = function (xmlNode, parentGroup) {
    if (xmlNode.nodeType === 1) {
      var dx = xmlNode.getAttribute('dx') || 0;
      var dy = xmlNode.getAttribute('dy') || 0;
      this._textX += parseFloat(dx);
      this._textY += parseFloat(dy);
    }

    var text = new Text_1({
      style: {
        text: xmlNode.textContent,
        transformText: true
      },
      position: [this._textX || 0, this._textY || 0]
    });
    inheritStyle(parentGroup, text);
    parseAttributes(xmlNode, text, this._defs);
    var fontSize = text.style.fontSize;

    if (fontSize && fontSize < 9) {
      // PENDING
      text.style.fontSize = 9;
      text.scale = text.scale || [1, 1];
      text.scale[0] *= fontSize / 9;
      text.scale[1] *= fontSize / 9;
    }

    var rect = text.getBoundingRect();
    this._textX += rect.width;
    parentGroup.add(text);
    return text;
  };

  var nodeParsers = {
    'g': function (xmlNode, parentGroup) {
      var g = new Group_1();
      inheritStyle(parentGroup, g);
      parseAttributes(xmlNode, g, this._defs);
      return g;
    },
    'rect': function (xmlNode, parentGroup) {
      var rect = new Rect();
      inheritStyle(parentGroup, rect);
      parseAttributes(xmlNode, rect, this._defs);
      rect.setShape({
        x: parseFloat(xmlNode.getAttribute('x') || 0),
        y: parseFloat(xmlNode.getAttribute('y') || 0),
        width: parseFloat(xmlNode.getAttribute('width') || 0),
        height: parseFloat(xmlNode.getAttribute('height') || 0)
      }); // console.log(xmlNode.getAttribute('transform'));
      // console.log(rect.transform);

      return rect;
    },
    'circle': function (xmlNode, parentGroup) {
      var circle = new Circle();
      inheritStyle(parentGroup, circle);
      parseAttributes(xmlNode, circle, this._defs);
      circle.setShape({
        cx: parseFloat(xmlNode.getAttribute('cx') || 0),
        cy: parseFloat(xmlNode.getAttribute('cy') || 0),
        r: parseFloat(xmlNode.getAttribute('r') || 0)
      });
      return circle;
    },
    'line': function (xmlNode, parentGroup) {
      var line = new Line();
      inheritStyle(parentGroup, line);
      parseAttributes(xmlNode, line, this._defs);
      line.setShape({
        x1: parseFloat(xmlNode.getAttribute('x1') || 0),
        y1: parseFloat(xmlNode.getAttribute('y1') || 0),
        x2: parseFloat(xmlNode.getAttribute('x2') || 0),
        y2: parseFloat(xmlNode.getAttribute('y2') || 0)
      });
      return line;
    },
    'ellipse': function (xmlNode, parentGroup) {
      var ellipse = new Ellipse();
      inheritStyle(parentGroup, ellipse);
      parseAttributes(xmlNode, ellipse, this._defs);
      ellipse.setShape({
        cx: parseFloat(xmlNode.getAttribute('cx') || 0),
        cy: parseFloat(xmlNode.getAttribute('cy') || 0),
        rx: parseFloat(xmlNode.getAttribute('rx') || 0),
        ry: parseFloat(xmlNode.getAttribute('ry') || 0)
      });
      return ellipse;
    },
    'polygon': function (xmlNode, parentGroup) {
      var points = xmlNode.getAttribute('points');

      if (points) {
        points = parsePoints(points);
      }

      var polygon = new Polygon({
        shape: {
          points: points || []
        }
      });
      inheritStyle(parentGroup, polygon);
      parseAttributes(xmlNode, polygon, this._defs);
      return polygon;
    },
    'polyline': function (xmlNode, parentGroup) {
      var path = new Path_1();
      inheritStyle(parentGroup, path);
      parseAttributes(xmlNode, path, this._defs);
      var points = xmlNode.getAttribute('points');

      if (points) {
        points = parsePoints(points);
      }

      var polyline = new Polyline({
        shape: {
          points: points || []
        }
      });
      return polyline;
    },
    'image': function (xmlNode, parentGroup) {
      var img = new Image$1();
      inheritStyle(parentGroup, img);
      parseAttributes(xmlNode, img, this._defs);
      img.setStyle({
        image: xmlNode.getAttribute('xlink:href'),
        x: xmlNode.getAttribute('x'),
        y: xmlNode.getAttribute('y'),
        width: xmlNode.getAttribute('width'),
        height: xmlNode.getAttribute('height')
      });
      return img;
    },
    'text': function (xmlNode, parentGroup) {
      var x = xmlNode.getAttribute('x') || 0;
      var y = xmlNode.getAttribute('y') || 0;
      var dx = xmlNode.getAttribute('dx') || 0;
      var dy = xmlNode.getAttribute('dy') || 0;
      this._textX = parseFloat(x) + parseFloat(dx);
      this._textY = parseFloat(y) + parseFloat(dy);
      var g = new Group_1();
      inheritStyle(parentGroup, g);
      parseAttributes(xmlNode, g, this._defs);
      return g;
    },
    'tspan': function (xmlNode, parentGroup) {
      var x = xmlNode.getAttribute('x');
      var y = xmlNode.getAttribute('y');

      if (x != null) {
        // new offset x
        this._textX = parseFloat(x);
      }

      if (y != null) {
        // new offset y
        this._textY = parseFloat(y);
      }

      var dx = xmlNode.getAttribute('dx') || 0;
      var dy = xmlNode.getAttribute('dy') || 0;
      var g = new Group_1();
      inheritStyle(parentGroup, g);
      parseAttributes(xmlNode, g, this._defs);
      this._textX += dx;
      this._textY += dy;
      return g;
    },
    'path': function (xmlNode, parentGroup) {
      // TODO svg fill rule
      // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule
      // path.style.globalCompositeOperation = 'xor';
      var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.

      var path = createFromString$1(d);
      inheritStyle(parentGroup, path);
      parseAttributes(xmlNode, path, this._defs);
      return path;
    }
  };
  var defineParsers = {
    'lineargradient': function (xmlNode) {
      var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);
      var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);
      var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);
      var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);
      var gradient = new LinearGradient_1(x1, y1, x2, y2);

      _parseGradientColorStops(xmlNode, gradient);

      return gradient;
    },
    'radialgradient': function (xmlNode) {}
  };

  function _parseGradientColorStops(xmlNode, gradient) {
    var stop = xmlNode.firstChild;

    while (stop) {
      if (stop.nodeType === 1) {
        var offset = stop.getAttribute('offset');

        if (offset.indexOf('%') > 0) {
          // percentage
          offset = parseInt(offset, 10) / 100;
        } else if (offset) {
          // number from 0 to 1
          offset = parseFloat(offset);
        } else {
          offset = 0;
        }

        var stopColor = stop.getAttribute('stop-color') || '#000000';
        gradient.addColorStop(offset, stopColor);
      }

      stop = stop.nextSibling;
    }
  }

  function inheritStyle(parent, child) {
    if (parent && parent.__inheritedStyle) {
      if (!child.__inheritedStyle) {
        child.__inheritedStyle = {};
      }

      defaults$1(child.__inheritedStyle, parent.__inheritedStyle);
    }
  }

  function parsePoints(pointsString) {
    var list = trim$3(pointsString).split(DILIMITER_REG);
    var points = [];

    for (var i = 0; i < list.length; i += 2) {
      var x = parseFloat(list[i]);
      var y = parseFloat(list[i + 1]);
      points.push([x, y]);
    }

    return points;
  }

  var attributesMap = {
    'fill': 'fill',
    'stroke': 'stroke',
    'stroke-width': 'lineWidth',
    'opacity': 'opacity',
    'fill-opacity': 'fillOpacity',
    'stroke-opacity': 'strokeOpacity',
    'stroke-dasharray': 'lineDash',
    'stroke-dashoffset': 'lineDashOffset',
    'stroke-linecap': 'lineCap',
    'stroke-linejoin': 'lineJoin',
    'stroke-miterlimit': 'miterLimit',
    'font-family': 'fontFamily',
    'font-size': 'fontSize',
    'font-style': 'fontStyle',
    'font-weight': 'fontWeight',
    'text-align': 'textAlign',
    'alignment-baseline': 'textBaseline'
  };

  function parseAttributes(xmlNode, el, defs, onlyInlineStyle) {
    var zrStyle = el.__inheritedStyle || {};
    var isTextEl = el.type === 'text'; // TODO Shadow

    if (xmlNode.nodeType === 1) {
      parseTransformAttribute(xmlNode, el);
      extend$7(zrStyle, parseStyleAttribute(xmlNode));

      if (!onlyInlineStyle) {
        for (var svgAttrName in attributesMap) {
          if (attributesMap.hasOwnProperty(svgAttrName)) {
            var attrValue = xmlNode.getAttribute(svgAttrName);

            if (attrValue != null) {
              zrStyle[attributesMap[svgAttrName]] = attrValue;
            }
          }
        }
      }
    }

    var elFillProp = isTextEl ? 'textFill' : 'fill';
    var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';
    el.style = el.style || new Style_1();
    var elStyle = el.style;
    zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));
    zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));
    each$d(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {
      var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;
      zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));
    });

    if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {
      zrStyle.textBaseline = 'alphabetic';
    }

    if (zrStyle.textBaseline === 'alphabetic') {
      zrStyle.textBaseline = 'bottom';
    }

    if (zrStyle.textAlign === 'start') {
      zrStyle.textAlign = 'left';
    }

    if (zrStyle.textAlign === 'end') {
      zrStyle.textAlign = 'right';
    }

    each$d(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {
      zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);
    });

    if (zrStyle.lineDash) {
      el.style.lineDash = trim$3(zrStyle.lineDash).split(DILIMITER_REG);
    }

    if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {
      // enable stroke
      el[elStrokeProp] = true;
    }

    el.__inheritedStyle = zrStyle;
  }

  var urlRegex = /url\(\s*#(.*?)\)/;

  function getPaint(str, defs) {
    // if (str === 'none') {
    //     return;
    // }
    var urlMatch = defs && str && str.match(urlRegex);

    if (urlMatch) {
      var url = trim$3(urlMatch[1]);
      var def = defs[url];
      return def;
    }

    return str;
  }

  var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;

  function parseTransformAttribute(xmlNode, node) {
    var transform = xmlNode.getAttribute('transform');

    if (transform) {
      transform = transform.replace(/,/g, ' ');
      var m = null;
      var transformOps = [];
      transform.replace(transformRegex, function (str, type, value) {
        transformOps.push(type, value);
      });

      for (var i = transformOps.length - 1; i > 0; i -= 2) {
        var value = transformOps[i];
        var type = transformOps[i - 1];
        m = m || matrix.create();

        switch (type) {
          case 'translate':
            value = trim$3(value).split(DILIMITER_REG);
            matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);
            break;

          case 'scale':
            value = trim$3(value).split(DILIMITER_REG);
            matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);
            break;

          case 'rotate':
            value = trim$3(value).split(DILIMITER_REG);
            matrix.rotate(m, m, parseFloat(value[0]));
            break;

          case 'skew':
            value = trim$3(value).split(DILIMITER_REG);
            console.warn('Skew transform is not supported yet');
            break;

          case 'matrix':
            var value = trim$3(value).split(DILIMITER_REG);
            m[0] = parseFloat(value[0]);
            m[1] = parseFloat(value[1]);
            m[2] = parseFloat(value[2]);
            m[3] = parseFloat(value[3]);
            m[4] = parseFloat(value[4]);
            m[5] = parseFloat(value[5]);
            break;
        }
      }

      node.setLocalTransform(m);
    }
  } // Value may contain space.


  var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;

  function parseStyleAttribute(xmlNode) {
    var style = xmlNode.getAttribute('style');
    var result = {};

    if (!style) {
      return result;
    }

    var styleList = {};
    styleRegex.lastIndex = 0;
    var styleRegResult;

    while ((styleRegResult = styleRegex.exec(style)) != null) {
      styleList[styleRegResult[1]] = styleRegResult[2];
    }

    for (var svgAttrName in attributesMap) {
      if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {
        result[attributesMap[svgAttrName]] = styleList[svgAttrName];
      }
    }

    return result;
  }
  /**
   * @param {Array.<number>} viewBoxRect
   * @param {number} width
   * @param {number} height
   * @return {Object} {scale, position}
   */


  function makeViewBoxTransform(viewBoxRect, width, height) {
    var scaleX = width / viewBoxRect.width;
    var scaleY = height / viewBoxRect.height;
    var scale = Math.min(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'

    var viewBoxScale = [scale, scale];
    var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];
    return {
      scale: viewBoxScale,
      position: viewBoxPosition
    };
  }
  /**
   * @param {string|XMLElement} xml
   * @param {Object} [opt]
   * @param {number} [opt.width] Default width if svg width not specified or is a percent value.
   * @param {number} [opt.height] Default height if svg height not specified or is a percent value.
   * @param {boolean} [opt.ignoreViewBox]
   * @param {boolean} [opt.ignoreRootClip]
   * @return {Object} result:
   * {
   *     root: Group, The root of the the result tree of zrender shapes,
   *     width: number, the viewport width of the SVG,
   *     height: number, the viewport height of the SVG,
   *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,
   *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.
   * }
   */


  function parseSVG(xml, opt) {
    var parser = new SVGParser();
    return parser.parse(xml, opt);
  }

  var parseXML_1 = parseXML;
  var makeViewBoxTransform_1 = makeViewBoxTransform;
  var parseSVG_2 = parseSVG;

  var parseSVG_1 = {
  	parseXML: parseXML_1,
  	makeViewBoxTransform: makeViewBoxTransform_1,
  	parseSVG: parseSVG_2
  };

  var createHashMap$6 = util.createHashMap;
  var isString$7 = util.isString;
  var isArray$8 = util.isArray;
  var each$e = util.each;



  var parseXML$1 = parseSVG_1.parseXML;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var storage = createHashMap$6(); // For minimize the code size of common echarts package,
  // do not put too much logic in this module.

  var _default$1g = {
    // The format of record: see `echarts.registerMap`.
    // Compatible with previous `echarts.registerMap`.
    registerMap: function (mapName, rawGeoJson, rawSpecialAreas) {
      var records;

      if (isArray$8(rawGeoJson)) {
        records = rawGeoJson;
      } else if (rawGeoJson.svg) {
        records = [{
          type: 'svg',
          source: rawGeoJson.svg,
          specialAreas: rawGeoJson.specialAreas
        }];
      } else {
        // Backward compatibility.
        if (rawGeoJson.geoJson && !rawGeoJson.features) {
          rawSpecialAreas = rawGeoJson.specialAreas;
          rawGeoJson = rawGeoJson.geoJson;
        }

        records = [{
          type: 'geoJSON',
          source: rawGeoJson,
          specialAreas: rawSpecialAreas
        }];
      }

      each$e(records, function (record) {
        var type = record.type;
        type === 'geoJson' && (type = record.type = 'geoJSON');
        var parse = parsers[type];
        parse(record);
      });
      return storage.set(mapName, records);
    },
    retrieveMap: function (mapName) {
      return storage.get(mapName);
    }
  };
  var parsers = {
    geoJSON: function (record) {
      var source = record.source;
      record.geoJSON = !isString$7(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();
    },
    // Only perform parse to XML object here, which might be time
    // consiming for large SVG.
    // Although convert XML to zrender element is also time consiming,
    // if we do it here, the clone of zrender elements has to be
    // required. So we do it once for each geo instance, util real
    // performance issues call for optimizing it.
    svg: function (record) {
      record.svgXML = parseXML$1(record.source);
    }
  };
  var mapDataStorage = _default$1g;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function defaultKeyGetter(item) {
    return item;
  }
  /**
   * @param {Array} oldArr
   * @param {Array} newArr
   * @param {Function} oldKeyGetter
   * @param {Function} newKeyGetter
   * @param {Object} [context] Can be visited by this.context in callback.
   */


  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
    this.context = context;
  }

  DataDiffer.prototype = {
    constructor: DataDiffer,

    /**
     * Callback function when add a data
     */
    add: function (func) {
      this._add = func;
      return this;
    },

    /**
     * Callback function when update a data
     */
    update: function (func) {
      this._update = func;
      return this;
    },

    /**
     * Callback function when remove a data
     */
    remove: function (func) {
      this._remove = func;
      return this;
    },
    execute: function () {
      var oldArr = this._old;
      var newArr = this._new;
      var oldDataIndexMap = {};
      var newDataIndexMap = {};
      var oldDataKeyArr = [];
      var newDataKeyArr = [];
      var i;
      initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);
      initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this);

      for (i = 0; i < oldArr.length; i++) {
        var key = oldDataKeyArr[i];
        var idx = newDataIndexMap[key]; // idx can never be empty array here. see 'set null' logic below.

        if (idx != null) {
          // Consider there is duplicate key (for example, use dataItem.name as key).
          // We should make sure every item in newArr and oldArr can be visited.
          var len = idx.length;

          if (len) {
            len === 1 && (newDataIndexMap[key] = null);
            idx = idx.shift();
          } else {
            newDataIndexMap[key] = null;
          }

          this._update && this._update(idx, i);
        } else {
          this._remove && this._remove(i);
        }
      }

      for (var i = 0; i < newDataKeyArr.length; i++) {
        var key = newDataKeyArr[i];

        if (newDataIndexMap.hasOwnProperty(key)) {
          var idx = newDataIndexMap[key];

          if (idx == null) {
            continue;
          } // idx can never be empty array here. see 'set null' logic above.


          if (!idx.length) {
            this._add && this._add(idx);
          } else {
            for (var j = 0, len = idx.length; j < len; j++) {
              this._add && this._add(idx[j]);
            }
          }
        }
      }
    }
  };

  function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {
    for (var i = 0; i < arr.length; i++) {
      // Add prefix to avoid conflict with Object.prototype.
      var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);
      var existence = map[key];

      if (existence == null) {
        keyArr.push(key);
        map[key] = i;
      } else {
        if (!existence.length) {
          map[key] = existence = [existence];
        }

        existence.push(i);
      }
    }
  }

  var _default$1h = DataDiffer;
  var DataDiffer_1 = _default$1h;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var each$f = util.each;
  var createHashMap$7 = util.createHashMap;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var OTHER_DIMENSIONS = createHashMap$7(['tooltip', 'label', 'itemName', 'itemId', 'seriesName']);

  function summarizeDimensions(data) {
    var summary = {};
    var encode = summary.encode = {};
    var notExtraCoordDimMap = createHashMap$7();
    var defaultedLabel = [];
    var defaultedTooltip = []; // See the comment of `List.js#userOutput`.

    var userOutput = summary.userOutput = {
      dimensionNames: data.dimensions.slice(),
      encode: {}
    };
    each$f(data.dimensions, function (dimName) {
      var dimItem = data.getDimensionInfo(dimName);
      var coordDim = dimItem.coordDim;

      if (coordDim) {
        var coordDimIndex = dimItem.coordDimIndex;
        getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;

        if (!dimItem.isExtraCoord) {
          notExtraCoordDimMap.set(coordDim, 1); // Use the last coord dim (and label friendly) as default label,
          // because when dataset is used, it is hard to guess which dimension
          // can be value dimension. If both show x, y on label is not look good,
          // and conventionally y axis is focused more.

          if (mayLabelDimType(dimItem.type)) {
            defaultedLabel[0] = dimName;
          } // User output encode do not contain generated coords.
          // And it only has index. User can use index to retrieve value from the raw item array.


          getOrCreateEncodeArr(userOutput.encode, coordDim)[coordDimIndex] = dimItem.index;
        }

        if (dimItem.defaultTooltip) {
          defaultedTooltip.push(dimName);
        }
      }

      OTHER_DIMENSIONS.each(function (v, otherDim) {
        var encodeArr = getOrCreateEncodeArr(encode, otherDim);
        var dimIndex = dimItem.otherDims[otherDim];

        if (dimIndex != null && dimIndex !== false) {
          encodeArr[dimIndex] = dimItem.name;
        }
      });
    });
    var dataDimsOnCoord = [];
    var encodeFirstDimNotExtra = {};
    notExtraCoordDimMap.each(function (v, coordDim) {
      var dimArr = encode[coordDim]; // ??? FIXME extra coord should not be set in dataDimsOnCoord.
      // But should fix the case that radar axes: simplify the logic
      // of `completeDimension`, remove `extraPrefix`.

      encodeFirstDimNotExtra[coordDim] = dimArr[0]; // Not necessary to remove duplicate, because a data
      // dim canot on more than one coordDim.

      dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
    });
    summary.dataDimsOnCoord = dataDimsOnCoord;
    summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
    var encodeLabel = encode.label; // FIXME `encode.label` is not recommanded, because formatter can not be set
    // in this way. Use label.formatter instead. May be remove this approach someday.

    if (encodeLabel && encodeLabel.length) {
      defaultedLabel = encodeLabel.slice();
    }

    var encodeTooltip = encode.tooltip;

    if (encodeTooltip && encodeTooltip.length) {
      defaultedTooltip = encodeTooltip.slice();
    } else if (!defaultedTooltip.length) {
      defaultedTooltip = defaultedLabel.slice();
    }

    encode.defaultedLabel = defaultedLabel;
    encode.defaultedTooltip = defaultedTooltip;
    return summary;
  }

  function getOrCreateEncodeArr(encode, dim) {
    if (!encode.hasOwnProperty(dim)) {
      encode[dim] = [];
    }

    return encode[dim];
  }

  function getDimensionTypeByAxis(axisType) {
    return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';
  }

  function mayLabelDimType(dimType) {
    // In most cases, ordinal and time do not suitable for label.
    // Ordinal info can be displayed on axis. Time is too long.
    return !(dimType === 'ordinal' || dimType === 'time');
  } // function findTheLastDimMayLabel(data) {
  //     // Get last value dim
  //     var dimensions = data.dimensions.slice();
  //     var valueType;
  //     var valueDim;
  //     while (dimensions.length && (
  //         valueDim = dimensions.pop(),
  //         valueType = data.getDimensionInfo(valueDim).type,
  //         valueType === 'ordinal' || valueType === 'time'
  //     )) {} // jshint ignore:line
  //     return valueDim;
  // }


  var OTHER_DIMENSIONS_1 = OTHER_DIMENSIONS;
  var summarizeDimensions_1 = summarizeDimensions;
  var getDimensionTypeByAxis_1 = getDimensionTypeByAxis;

  var dimensionHelper = {
  	OTHER_DIMENSIONS: OTHER_DIMENSIONS_1,
  	summarizeDimensions: summarizeDimensions_1,
  	getDimensionTypeByAxis: getDimensionTypeByAxis_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @class
   * @param {Object|DataDimensionInfo} [opt] All of the fields will be shallow copied.
   */
  function DataDimensionInfo(opt) {
    if (opt != null) {
      util.extend(this, opt);
    }
    /**
     * Dimension name.
     * Mandatory.
     * @type {string}
     */
    // this.name;

    /**
     * The origin name in dimsDef, see source helper.
     * If displayName given, the tooltip will displayed vertically.
     * Optional.
     * @type {string}
     */
    // this.displayName;

    /**
     * Which coordSys dimension this dimension mapped to.
     * A `coordDim` can be a "coordSysDim" that the coordSys required
     * (for example, an item in `coordSysDims` of `model/referHelper#CoordSysInfo`),
     * or an generated "extra coord name" if does not mapped to any "coordSysDim"
     * (That is determined by whether `isExtraCoord` is `true`).
     * Mandatory.
     * @type {string}
     */
    // this.coordDim;

    /**
     * The index of this dimension in `series.encode[coordDim]`.
     * Mandatory.
     * @type {number}
     */
    // this.coordDimIndex;

    /**
     * Dimension type. The enumerable values are the key of
     * `dataCtors` of `data/List`.
     * Optional.
     * @type {string}
     */
    // this.type;

    /**
     * This index of this dimension info in `data/List#_dimensionInfos`.
     * Mandatory after added to `data/List`.
     * @type {number}
     */
    // this.index;

    /**
     * The format of `otherDims` is:
     * ```js
     * {
     *     tooltip: number optional,
     *     label: number optional,
     *     itemName: number optional,
     *     seriesName: number optional,
     * }
     * ```
     *
     * A `series.encode` can specified these fields:
     * ```js
     * encode: {
     *     // "3, 1, 5" is the index of data dimension.
     *     tooltip: [3, 1, 5],
     *     label: [0, 3],
     *     ...
     * }
     * ```
     * `otherDims` is the parse result of the `series.encode` above, like:
     * ```js
     * // Suppose the index of this data dimension is `3`.
     * this.otherDims = {
     *     // `3` is at the index `0` of the `encode.tooltip`
     *     tooltip: 0,
     *     // `3` is at the index `1` of the `encode.tooltip`
     *     label: 1
     * };
     * ```
     *
     * This prop should never be `null`/`undefined` after initialized.
     * @type {Object}
     */


    this.otherDims = {};
    /**
     * Be `true` if this dimension is not mapped to any "coordSysDim" that the
     * "coordSys" required.
     * Mandatory.
     * @type {boolean}
     */
    // this.isExtraCoord;

    /**
     * @type {module:data/OrdinalMeta}
     */
    // this.ordinalMeta;

    /**
     * Whether to create inverted indices.
     * @type {boolean}
     */
    // this.createInvertedIndices;
  }
  var _default$1i = DataDimensionInfo;
  var DataDimensionInfo_1 = _default$1i;

  var defaultDimValueGetters$1 = dataProvider.defaultDimValueGetters;
  var DefaultDataProvider$1 = dataProvider.DefaultDataProvider;



  var summarizeDimensions$1 = dimensionHelper.summarizeDimensions;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /* global Float64Array, Int32Array, Uint32Array, Uint16Array */

  /**
   * List for data storage
   * @module echarts/data/List
   */
  var isObject$b = util.isObject;
  var UNDEFINED = 'undefined';
  var INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],
  // which will cause weird udpate animation.

  var ID_PREFIX = 'e\0\0';
  var dataCtors = {
    'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,
    'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,
    // Ordinal data type can be string or int
    'ordinal': Array,
    'number': Array,
    'time': Array
  }; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is
  // different from the Ctor of typed array.

  var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
  var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
  var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;

  function getIndicesCtor(list) {
    // The possible max value in this._indicies is always this._rawCount despite of filtering.
    return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
  }

  function cloneChunk(originalChunk) {
    var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.

    return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
  }

  var TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];
  var CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];

  function transferProperties(target, source) {
    util.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {
      if (source.hasOwnProperty(propName)) {
        target[propName] = source[propName];
      }
    });
    target.__wrappedMethods = source.__wrappedMethods;
    util.each(CLONE_PROPERTIES, function (propName) {
      target[propName] = util.clone(source[propName]);
    });
    target._calculationInfo = util.extend(source._calculationInfo);
  }
  /**
   * @constructor
   * @alias module:echarts/data/List
   *
   * @param {Array.<string|Object|module:data/DataDimensionInfo>} dimensions
   *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
   *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
   * @param {module:echarts/model/Model} hostModel
   */


  var List = function (dimensions, hostModel) {
    dimensions = dimensions || ['x', 'y'];
    var dimensionInfos = {};
    var dimensionNames = [];
    var invertedIndicesMap = {};

    for (var i = 0; i < dimensions.length; i++) {
      // Use the original dimensions[i], where other flag props may exists.
      var dimensionInfo = dimensions[i];

      if (util.isString(dimensionInfo)) {
        dimensionInfo = new DataDimensionInfo_1({
          name: dimensionInfo
        });
      } else if (!(dimensionInfo instanceof DataDimensionInfo_1)) {
        dimensionInfo = new DataDimensionInfo_1(dimensionInfo);
      }

      var dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || 'float';

      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }

      dimensionInfo.otherDims = dimensionInfo.otherDims || {};
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;
      dimensionInfo.index = i;

      if (dimensionInfo.createInvertedIndices) {
        invertedIndicesMap[dimensionName] = [];
      }
    }
    /**
     * @readOnly
     * @type {Array.<string>}
     */


    this.dimensions = dimensionNames;
    /**
     * Infomation of each data dimension, like data type.
     * @type {Object}
     */

    this._dimensionInfos = dimensionInfos;
    /**
     * @type {module:echarts/model/Model}
     */

    this.hostModel = hostModel;
    /**
     * @type {module:echarts/model/Model}
     */

    this.dataType;
    /**
     * Indices stores the indices of data subset after filtered.
     * This data subset will be used in chart.
     * @type {Array.<number>}
     * @readOnly
     */

    this._indices = null;
    this._count = 0;
    this._rawCount = 0;
    /**
     * Data storage
     * @type {Object.<key, Array.<TypedArray|Array>>}
     * @private
     */

    this._storage = {};
    /**
     * @type {Array.<string>}
     */

    this._nameList = [];
    /**
     * @type {Array.<string>}
     */

    this._idList = [];
    /**
     * Models of data option is stored sparse for optimizing memory cost
     * @type {Array.<module:echarts/model/Model>}
     * @private
     */

    this._optionModels = [];
    /**
     * Global visual properties after visual coding
     * @type {Object}
     * @private
     */

    this._visual = {};
    /**
     * Globel layout properties.
     * @type {Object}
     * @private
     */

    this._layout = {};
    /**
     * Item visual properties after visual coding
     * @type {Array.<Object>}
     * @private
     */

    this._itemVisuals = [];
    /**
     * Key: visual type, Value: boolean
     * @type {Object}
     * @readOnly
     */

    this.hasItemVisual = {};
    /**
     * Item layout properties after layout
     * @type {Array.<Object>}
     * @private
     */

    this._itemLayouts = [];
    /**
     * Graphic elemnents
     * @type {Array.<module:zrender/Element>}
     * @private
     */

    this._graphicEls = [];
    /**
     * Max size of each chunk.
     * @type {number}
     * @private
     */

    this._chunkSize = 1e5;
    /**
     * @type {number}
     * @private
     */

    this._chunkCount = 0;
    /**
     * @type {Array.<Array|Object>}
     * @private
     */

    this._rawData;
    /**
     * Raw extent will not be cloned, but only transfered.
     * It will not be calculated util needed.
     * key: dim,
     * value: {end: number, extent: Array.<number>}
     * @type {Object}
     * @private
     */

    this._rawExtent = {};
    /**
     * @type {Object}
     * @private
     */

    this._extent = {};
    /**
     * key: dim
     * value: extent
     * @type {Object}
     * @private
     */

    this._approximateExtent = {};
    /**
     * Cache summary info for fast visit. See "dimensionHelper".
     * @type {Object}
     * @private
     */

    this._dimensionsSummary = summarizeDimensions$1(this);
    /**
     * @type {Object.<Array|TypedArray>}
     * @private
     */

    this._invertedIndicesMap = invertedIndicesMap;
    /**
     * @type {Object}
     * @private
     */

    this._calculationInfo = {};
    /**
     * User output info of this data.
     * DO NOT use it in other places!
     *
     * When preparing user params for user callbacks, we have
     * to clone these inner data structures to prevent users
     * from modifying them to effect built-in logic. And for
     * performance consideration we make this `userOutput` to
     * avoid clone them too many times.
     *
     * @type {Object}
     * @readOnly
     */

    this.userOutput = this._dimensionsSummary.userOutput;
  };

  var listProto = List.prototype;
  listProto.type = 'list';
  /**
   * If each data item has it's own option
   * @type {boolean}
   */

  listProto.hasItemOption = true;
  /**
   * The meanings of the input parameter `dim`:
   *
   * + If dim is a number (e.g., `1`), it means the index of the dimension.
   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.
   * + If dim is a number-like string (e.g., `"1"`):
   *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.
   *     + If not, it will be converted to a number, which means the index of the dimension.
   *        (why? because of the backward compatbility. We have been tolerating number-like string in
   *        dimension setting, although now it seems that it is not a good idea.)
   *     For example, `visualMap[i].dimension: "1"` is the same meaning as `visualMap[i].dimension: 1`,
   *     if no dimension name is defined as `"1"`.
   * + If dim is a not-number-like string, it means the concrete dim name.
   *   For example, it can be be default name `"x"`, `"y"`, `"z"`, `"lng"`, `"lat"`, `"angle"`, `"radius"`,
   *   or customized in `dimensions` property of option like `"age"`.
   *
   * Get dimension name
   * @param {string|number} dim See above.
   * @return {string} Concrete dim name.
   */

  listProto.getDimension = function (dim) {
    if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.
    || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {
      dim = this.dimensions[dim];
    }

    return dim;
  };
  /**
   * Get type and calculation info of particular dimension
   * @param {string|number} dim
   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
   */


  listProto.getDimensionInfo = function (dim) {
    // Do not clone, because there may be categories in dimInfo.
    return this._dimensionInfos[this.getDimension(dim)];
  };
  /**
   * @return {Array.<string>} concrete dimension name list on coord.
   */


  listProto.getDimensionsOnCoord = function () {
    return this._dimensionsSummary.dataDimsOnCoord.slice();
  };
  /**
   * @param {string} coordDim
   * @param {number} [idx] A coordDim may map to more than one data dim.
   *        If idx is `true`, return a array of all mapped dims.
   *        If idx is not specified, return the first dim not extra.
   * @return {string|Array.<string>} concrete data dim.
   *        If idx is number, and not found, return null/undefined.
   *        If idx is `true`, and not found, return empty array (always return array).
   */


  listProto.mapDimension = function (coordDim, idx) {
    var dimensionsSummary = this._dimensionsSummary;

    if (idx == null) {
      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
    }

    var dims = dimensionsSummary.encode[coordDim];
    return idx === true // always return array if idx is `true`
    ? (dims || []).slice() : dims && dims[idx];
  };
  /**
   * Initialize from data
   * @param {Array.<Object|number|Array>} data source or data or data provider.
   * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and
   *        default label/tooltip.
   *        A name can be specified in encode.itemName,
   *        or dataItem.name (only for series option data),
   *        or provided in nameList from outside.
   * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number
   */


  listProto.initData = function (data, nameList, dimValueGetter) {
    var notProvider = Source_1.isInstance(data) || util.isArrayLike(data);

    if (notProvider) {
      data = new DefaultDataProvider$1(data, this.dimensions.length);
    }

    this._rawData = data; // Clear

    this._storage = {};
    this._indices = null;
    this._nameList = nameList || [];
    this._idList = [];
    this._nameRepeatCount = {};

    if (!dimValueGetter) {
      this.hasItemOption = false;
    }
    /**
     * @readOnly
     */


    this.defaultDimValueGetter = defaultDimValueGetters$1[this._rawData.getSource().sourceFormat]; // Default dim value getter

    this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;
    this._dimValueGetterArrayRows = defaultDimValueGetters$1.arrayRows; // Reset raw extent.

    this._rawExtent = {};

    this._initDataFromProvider(0, data.count()); // If data has no item option.


    if (data.pure) {
      this.hasItemOption = false;
    }
  };

  listProto.getProvider = function () {
    return this._rawData;
  };
  /**
   * Caution: Can be only called on raw data (before `this._indices` created).
   */


  listProto.appendData = function (data) {
    var rawData = this._rawData;
    var start = this.count();
    rawData.appendData(data);
    var end = rawData.count();

    if (!rawData.persistent) {
      end += start;
    }

    this._initDataFromProvider(start, end);
  };
  /**
   * Caution: Can be only called on raw data (before `this._indices` created).
   * This method does not modify `rawData` (`dataProvider`), but only
   * add values to storage.
   *
   * The final count will be increased by `Math.max(values.length, names.length)`.
   *
   * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like
   *        [
   *            [12, 33, 44],
   *            [NaN, 43, 1],
   *            ['-', 'asdf', 0]
   *        ]
   *        Each item is exaclty cooresponding to a dimension.
   * @param {Array.<string>} [names]
   */


  listProto.appendValues = function (values, names) {
    var chunkSize = this._chunkSize;
    var storage = this._storage;
    var dimensions = this.dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var start = this.count();
    var end = start + Math.max(values.length, names ? names.length : 0);
    var originalChunkCount = this._chunkCount;

    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];

      if (!rawExtent[dim]) {
        rawExtent[dim] = getInitialExtent();
      }

      if (!storage[dim]) {
        storage[dim] = [];
      }

      prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);
      this._chunkCount = storage[dim].length;
    }

    var emptyDataItem = new Array(dimLen);

    for (var idx = start; idx < end; idx++) {
      var sourceIdx = idx - start;
      var chunkIndex = Math.floor(idx / chunkSize);
      var chunkOffset = idx % chunkSize; // Store the data by dimensions

      for (var k = 0; k < dimLen; k++) {
        var dim = dimensions[k];

        var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);

        storage[dim][chunkIndex][chunkOffset] = val;
        var dimRawExtent = rawExtent[dim];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      }

      if (names) {
        this._nameList[idx] = names[sourceIdx];
      }
    }

    this._rawCount = this._count = end; // Reset data extent

    this._extent = {};
    prepareInvertedIndex(this);
  };

  listProto._initDataFromProvider = function (start, end) {
    // Optimize.
    if (start >= end) {
      return;
    }

    var chunkSize = this._chunkSize;
    var rawData = this._rawData;
    var storage = this._storage;
    var dimensions = this.dimensions;
    var dimLen = dimensions.length;
    var dimensionInfoMap = this._dimensionInfos;
    var nameList = this._nameList;
    var idList = this._idList;
    var rawExtent = this._rawExtent;
    var nameRepeatCount = this._nameRepeatCount = {};
    var nameDimIdx;
    var originalChunkCount = this._chunkCount;

    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];

      if (!rawExtent[dim]) {
        rawExtent[dim] = getInitialExtent();
      }

      var dimInfo = dimensionInfoMap[dim];

      if (dimInfo.otherDims.itemName === 0) {
        nameDimIdx = this._nameDimIdx = i;
      }

      if (dimInfo.otherDims.itemId === 0) {
        this._idDimIdx = i;
      }

      if (!storage[dim]) {
        storage[dim] = [];
      }

      prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);
      this._chunkCount = storage[dim].length;
    }

    var dataItem = new Array(dimLen);

    for (var idx = start; idx < end; idx++) {
      // NOTICE: Try not to write things into dataItem
      dataItem = rawData.getItem(idx, dataItem); // Each data item is value
      // [1, 2]
      // 2
      // Bar chart, line chart which uses category axis
      // only gives the 'y' value. 'x' value is the indices of category
      // Use a tempValue to normalize the value to be a (x, y) value

      var chunkIndex = Math.floor(idx / chunkSize);
      var chunkOffset = idx % chunkSize; // Store the data by dimensions

      for (var k = 0; k < dimLen; k++) {
        var dim = dimensions[k];
        var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero

        var val = this._dimValueGetter(dataItem, dim, idx, k);

        dimStorage[chunkOffset] = val;
        var dimRawExtent = rawExtent[dim];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      } // ??? FIXME not check by pure but sourceFormat?
      // TODO refactor these logic.


      if (!rawData.pure) {
        var name = nameList[idx];

        if (dataItem && name == null) {
          // If dataItem is {name: ...}, it has highest priority.
          // That is appropriate for many common cases.
          if (dataItem.name != null) {
            // There is no other place to persistent dataItem.name,
            // so save it to nameList.
            nameList[idx] = name = dataItem.name;
          } else if (nameDimIdx != null) {
            var nameDim = dimensions[nameDimIdx];
            var nameDimChunk = storage[nameDim][chunkIndex];

            if (nameDimChunk) {
              name = nameDimChunk[chunkOffset];
              var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;

              if (ordinalMeta && ordinalMeta.categories.length) {
                name = ordinalMeta.categories[name];
              }
            }
          }
        } // Try using the id in option
        // id or name is used on dynamical data, mapping old and new items.


        var id = dataItem == null ? null : dataItem.id;

        if (id == null && name != null) {
          // Use name as id and add counter to avoid same name
          nameRepeatCount[name] = nameRepeatCount[name] || 0;
          id = name;

          if (nameRepeatCount[name] > 0) {
            id += '__ec__' + nameRepeatCount[name];
          }

          nameRepeatCount[name]++;
        }

        id != null && (idList[idx] = id);
      }
    }

    if (!rawData.persistent && rawData.clean) {
      // Clean unused data if data source is typed array.
      rawData.clean();
    }

    this._rawCount = this._count = end; // Reset data extent

    this._extent = {};
    prepareInvertedIndex(this);
  };

  function prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {
    var DataCtor = dataCtors[dimInfo.type];
    var lastChunkIndex = chunkCount - 1;
    var dim = dimInfo.name;
    var resizeChunkArray = storage[dim][lastChunkIndex];

    if (resizeChunkArray && resizeChunkArray.length < chunkSize) {
      var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable
      // within the initial chunkSize.

      for (var j = 0; j < resizeChunkArray.length; j++) {
        newStore[j] = resizeChunkArray[j];
      }

      storage[dim][lastChunkIndex] = newStore;
    } // Create new chunks.


    for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {
      storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));
    }
  }

  function prepareInvertedIndex(list) {
    var invertedIndicesMap = list._invertedIndicesMap;
    util.each(invertedIndicesMap, function (invertedIndices, dim) {
      var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.

      var ordinalMeta = dimInfo.ordinalMeta;

      if (ordinalMeta) {
        invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss
        // mapping to 0, we should set it as INDEX_NOT_FOUND.

        for (var i = 0; i < invertedIndices.length; i++) {
          invertedIndices[i] = INDEX_NOT_FOUND;
        }

        for (var i = 0; i < list._count; i++) {
          // Only support the case that all values are distinct.
          invertedIndices[list.get(dim, i)] = i;
        }
      }
    });
  }

  function getRawValueFromStore(list, dimIndex, rawIndex) {
    var val;

    if (dimIndex != null) {
      var chunkSize = list._chunkSize;
      var chunkIndex = Math.floor(rawIndex / chunkSize);
      var chunkOffset = rawIndex % chunkSize;
      var dim = list.dimensions[dimIndex];
      var chunk = list._storage[dim][chunkIndex];

      if (chunk) {
        val = chunk[chunkOffset];
        var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;

        if (ordinalMeta && ordinalMeta.categories.length) {
          val = ordinalMeta.categories[val];
        }
      }
    }

    return val;
  }
  /**
   * @return {number}
   */


  listProto.count = function () {
    return this._count;
  };

  listProto.getIndices = function () {
    var newIndices;
    var indices = this._indices;

    if (indices) {
      var Ctor = indices.constructor;
      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.

      if (Ctor === Array) {
        newIndices = new Ctor(thisCount);

        for (var i = 0; i < thisCount; i++) {
          newIndices[i] = indices[i];
        }
      } else {
        newIndices = new Ctor(indices.buffer, 0, thisCount);
      }
    } else {
      var Ctor = getIndicesCtor(this);
      var newIndices = new Ctor(this.count());

      for (var i = 0; i < newIndices.length; i++) {
        newIndices[i] = i;
      }
    }

    return newIndices;
  };
  /**
   * Get value. Return NaN if idx is out of range.
   * @param {string} dim Dim must be concrete name.
   * @param {number} idx
   * @param {boolean} stack
   * @return {number}
   */


  listProto.get = function (dim, idx
  /*, stack */
  ) {
    if (!(idx >= 0 && idx < this._count)) {
      return NaN;
    }

    var storage = this._storage;

    if (!storage[dim]) {
      // TODO Warn ?
      return NaN;
    }

    idx = this.getRawIndex(idx);
    var chunkIndex = Math.floor(idx / this._chunkSize);
    var chunkOffset = idx % this._chunkSize;
    var chunkStore = storage[dim][chunkIndex];
    var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable
    // if (stack) {
    //     var dimensionInfo = this._dimensionInfos[dim];
    //     if (dimensionInfo && dimensionInfo.stackable) {
    //         var stackedOn = this.stackedOn;
    //         while (stackedOn) {
    //             // Get no stacked data of stacked on
    //             var stackedValue = stackedOn.get(dim, idx);
    //             // Considering positive stack, negative stack and empty data
    //             if ((value >= 0 && stackedValue > 0)  // Positive stack
    //                 || (value <= 0 && stackedValue < 0) // Negative stack
    //             ) {
    //                 value += stackedValue;
    //             }
    //             stackedOn = stackedOn.stackedOn;
    //         }
    //     }
    // }

    return value;
  };
  /**
   * @param {string} dim concrete dim
   * @param {number} rawIndex
   * @return {number|string}
   */


  listProto.getByRawIndex = function (dim, rawIdx) {
    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
      return NaN;
    }

    var dimStore = this._storage[dim];

    if (!dimStore) {
      // TODO Warn ?
      return NaN;
    }

    var chunkIndex = Math.floor(rawIdx / this._chunkSize);
    var chunkOffset = rawIdx % this._chunkSize;
    var chunkStore = dimStore[chunkIndex];
    return chunkStore[chunkOffset];
  };
  /**
   * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).
   * Hack a much simpler _getFast
   * @private
   */


  listProto._getFast = function (dim, rawIdx) {
    var chunkIndex = Math.floor(rawIdx / this._chunkSize);
    var chunkOffset = rawIdx % this._chunkSize;
    var chunkStore = this._storage[dim][chunkIndex];
    return chunkStore[chunkOffset];
  };
  /**
   * Get value for multi dimensions.
   * @param {Array.<string>} [dimensions] If ignored, using all dimensions.
   * @param {number} idx
   * @return {number}
   */


  listProto.getValues = function (dimensions, idx
  /*, stack */
  ) {
    var values = [];

    if (!util.isArray(dimensions)) {
      // stack = idx;
      idx = dimensions;
      dimensions = this.dimensions;
    }

    for (var i = 0, len = dimensions.length; i < len; i++) {
      values.push(this.get(dimensions[i], idx
      /*, stack */
      ));
    }

    return values;
  };
  /**
   * If value is NaN. Inlcuding '-'
   * Only check the coord dimensions.
   * @param {string} dim
   * @param {number} idx
   * @return {number}
   */


  listProto.hasValue = function (idx) {
    var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;

    for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {
      // Ordinal type originally can be string or number.
      // But when an ordinal type is used on coord, it can
      // not be string but only number. So we can also use isNaN.
      if (isNaN(this.get(dataDimsOnCoord[i], idx))) {
        return false;
      }
    }

    return true;
  };
  /**
   * Get extent of data in one dimension
   * @param {string} dim
   * @param {boolean} stack
   */


  listProto.getDataExtent = function (dim
  /*, stack */
  ) {
    // Make sure use concrete dim as cache name.
    dim = this.getDimension(dim);
    var dimData = this._storage[dim];
    var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));

    if (!dimData) {
      return initialExtent;
    } // Make more strict checkings to ensure hitting cache.


    var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');
    // var cacheName = dim;
    // Consider the most cases when using data zoom, `getDataExtent`
    // happened before filtering. We cache raw extent, which is not
    // necessary to be cleared and recalculated when restore data.

    var useRaw = !this._indices; // && !stack;

    var dimExtent;

    if (useRaw) {
      return this._rawExtent[dim].slice();
    }

    dimExtent = this._extent[dim];

    if (dimExtent) {
      return dimExtent.slice();
    }

    dimExtent = initialExtent;
    var min = dimExtent[0];
    var max = dimExtent[1];

    for (var i = 0; i < currEnd; i++) {
      // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));
      var value = this._getFast(dim, this.getRawIndex(i));

      value < min && (min = value);
      value > max && (max = value);
    }

    dimExtent = [min, max];
    this._extent[dim] = dimExtent;
    return dimExtent;
  };
  /**
   * Optimize for the scenario that data is filtered by a given extent.
   * Consider that if data amount is more than hundreds of thousand,
   * extent calculation will cost more than 10ms and the cache will
   * be erased because of the filtering.
   */


  listProto.getApproximateExtent = function (dim
  /*, stack */
  ) {
    dim = this.getDimension(dim);
    return this._approximateExtent[dim] || this.getDataExtent(dim
    /*, stack */
    );
  };

  listProto.setApproximateExtent = function (extent, dim
  /*, stack */
  ) {
    dim = this.getDimension(dim);
    this._approximateExtent[dim] = extent.slice();
  };
  /**
   * @param {string} key
   * @return {*}
   */


  listProto.getCalculationInfo = function (key) {
    return this._calculationInfo[key];
  };
  /**
   * @param {string|Object} key or k-v object
   * @param {*} [value]
   */


  listProto.setCalculationInfo = function (key, value) {
    isObject$b(key) ? util.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
  };
  /**
   * Get sum of data in one dimension
   * @param {string} dim
   */


  listProto.getSum = function (dim
  /*, stack */
  ) {
    var dimData = this._storage[dim];
    var sum = 0;

    if (dimData) {
      for (var i = 0, len = this.count(); i < len; i++) {
        var value = this.get(dim, i
        /*, stack */
        );

        if (!isNaN(value)) {
          sum += value;
        }
      }
    }

    return sum;
  };
  /**
   * Get median of data in one dimension
   * @param {string} dim
   */


  listProto.getMedian = function (dim
  /*, stack */
  ) {
    var dimDataArray = []; // map all data of one dimension

    this.each(dim, function (val, idx) {
      if (!isNaN(val)) {
        dimDataArray.push(val);
      }
    }); // TODO
    // Use quick select?
    // immutability & sort

    var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {
      return a - b;
    });
    var len = this.count(); // calculate median

    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;
  }; // /**
  //  * Retreive the index with given value
  //  * @param {string} dim Concrete dimension.
  //  * @param {number} value
  //  * @return {number}
  //  */
  // Currently incorrect: should return dataIndex but not rawIndex.
  // Do not fix it until this method is to be used somewhere.
  // FIXME Precision of float value
  // listProto.indexOf = function (dim, value) {
  //     var storage = this._storage;
  //     var dimData = storage[dim];
  //     var chunkSize = this._chunkSize;
  //     if (dimData) {
  //         for (var i = 0, len = this.count(); i < len; i++) {
  //             var chunkIndex = Math.floor(i / chunkSize);
  //             var chunkOffset = i % chunkSize;
  //             if (dimData[chunkIndex][chunkOffset] === value) {
  //                 return i;
  //             }
  //         }
  //     }
  //     return -1;
  // };

  /**
   * Only support the dimension which inverted index created.
   * Do not support other cases until required.
   * @param {string} concrete dim
   * @param {number|string} value
   * @return {number} rawIndex
   */


  listProto.rawIndexOf = function (dim, value) {
    var invertedIndices = dim && this._invertedIndicesMap[dim];
    var rawIndex = invertedIndices[value];

    if (rawIndex == null || isNaN(rawIndex)) {
      return INDEX_NOT_FOUND;
    }

    return rawIndex;
  };
  /**
   * Retreive the index with given name
   * @param {number} idx
   * @param {number} name
   * @return {number}
   */


  listProto.indexOfName = function (name) {
    for (var i = 0, len = this.count(); i < len; i++) {
      if (this.getName(i) === name) {
        return i;
      }
    }

    return -1;
  };
  /**
   * Retreive the index with given raw data index
   * @param {number} idx
   * @param {number} name
   * @return {number}
   */


  listProto.indexOfRawIndex = function (rawIndex) {
    if (rawIndex >= this._rawCount || rawIndex < 0) {
      return -1;
    }

    if (!this._indices) {
      return rawIndex;
    } // Indices are ascending


    var indices = this._indices; // If rawIndex === dataIndex

    var rawDataIndex = indices[rawIndex];

    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
      return rawIndex;
    }

    var left = 0;
    var right = this._count - 1;

    while (left <= right) {
      var mid = (left + right) / 2 | 0;

      if (indices[mid] < rawIndex) {
        left = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right = mid - 1;
      } else {
        return mid;
      }
    }

    return -1;
  };
  /**
   * Retreive the index of nearest value
   * @param {string} dim
   * @param {number} value
   * @param {number} [maxDistance=Infinity]
   * @return {Array.<number>} If and only if multiple indices has
   *        the same value, they are put to the result.
   */


  listProto.indicesOfNearest = function (dim, value, maxDistance) {
    var storage = this._storage;
    var dimData = storage[dim];
    var nearestIndices = [];

    if (!dimData) {
      return nearestIndices;
    }

    if (maxDistance == null) {
      maxDistance = Infinity;
    }

    var minDist = Infinity;
    var minDiff = -1;
    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/List.js`.

    for (var i = 0, len = this.count(); i < len; i++) {
      var diff = value - this.get(dim, i);
      var dist = Math.abs(diff);

      if (dist <= maxDistance) {
        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,
        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to
        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).
        // So we chose the one that `diff >= 0` in this csae.
        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them
        // should be push to `nearestIndices`.
        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {
          minDist = dist;
          minDiff = diff;
          nearestIndicesLen = 0;
        }

        if (diff === minDiff) {
          nearestIndices[nearestIndicesLen++] = i;
        }
      }
    }

    nearestIndices.length = nearestIndicesLen;
    return nearestIndices;
  };
  /**
   * Get raw data index
   * @param {number} idx
   * @return {number}
   */


  listProto.getRawIndex = getRawIndexWithoutIndices;

  function getRawIndexWithoutIndices(idx) {
    return idx;
  }

  function getRawIndexWithIndices(idx) {
    if (idx < this._count && idx >= 0) {
      return this._indices[idx];
    }

    return -1;
  }
  /**
   * Get raw data item
   * @param {number} idx
   * @return {number}
   */


  listProto.getRawDataItem = function (idx) {
    if (!this._rawData.persistent) {
      var val = [];

      for (var i = 0; i < this.dimensions.length; i++) {
        var dim = this.dimensions[i];
        val.push(this.get(dim, idx));
      }

      return val;
    } else {
      return this._rawData.getItem(this.getRawIndex(idx));
    }
  };
  /**
   * @param {number} idx
   * @param {boolean} [notDefaultIdx=false]
   * @return {string}
   */


  listProto.getName = function (idx) {
    var rawIndex = this.getRawIndex(idx);
    return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';
  };
  /**
   * @param {number} idx
   * @param {boolean} [notDefaultIdx=false]
   * @return {string}
   */


  listProto.getId = function (idx) {
    return getId(this, this.getRawIndex(idx));
  };

  function getId(list, rawIndex) {
    var id = list._idList[rawIndex];

    if (id == null) {
      id = getRawValueFromStore(list, list._idDimIdx, rawIndex);
    }

    if (id == null) {
      // FIXME Check the usage in graph, should not use prefix.
      id = ID_PREFIX + rawIndex;
    }

    return id;
  }

  function normalizeDimensions(dimensions) {
    if (!util.isArray(dimensions)) {
      dimensions = [dimensions];
    }

    return dimensions;
  }
  /**
   * Data iteration
   * @param {string|Array.<string>}
   * @param {Function} cb
   * @param {*} [context=this]
   *
   * @example
   *  list.each('x', function (x, idx) {});
   *  list.each(['x', 'y'], function (x, y, idx) {});
   *  list.each(function (idx) {})
   */


  listProto.each = function (dims, cb, context, contextCompat) {

    if (!this._count) {
      return;
    }

    if (typeof dims === 'function') {
      contextCompat = context;
      context = cb;
      cb = dims;
      dims = [];
    } // contextCompat just for compat echarts3


    context = context || contextCompat || this;
    dims = util.map(normalizeDimensions(dims), this.getDimension, this);
    var dimSize = dims.length;

    for (var i = 0; i < this.count(); i++) {
      // Simple optimization
      switch (dimSize) {
        case 0:
          cb.call(context, i);
          break;

        case 1:
          cb.call(context, this.get(dims[0], i), i);
          break;

        case 2:
          cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);
          break;

        default:
          var k = 0;
          var value = [];

          for (; k < dimSize; k++) {
            value[k] = this.get(dims[k], i);
          } // Index


          value[k] = i;
          cb.apply(context, value);
      }
    }
  };
  /**
   * Data filter
   * @param {string|Array.<string>}
   * @param {Function} cb
   * @param {*} [context=this]
   */


  listProto.filterSelf = function (dimensions, cb, context, contextCompat) {

    if (!this._count) {
      return;
    }

    if (typeof dimensions === 'function') {
      contextCompat = context;
      context = cb;
      cb = dimensions;
      dimensions = [];
    } // contextCompat just for compat echarts3


    context = context || contextCompat || this;
    dimensions = util.map(normalizeDimensions(dimensions), this.getDimension, this);
    var count = this.count();
    var Ctor = getIndicesCtor(this);
    var newIndices = new Ctor(count);
    var value = [];
    var dimSize = dimensions.length;
    var offset = 0;
    var dim0 = dimensions[0];

    for (var i = 0; i < count; i++) {
      var keep;
      var rawIdx = this.getRawIndex(i); // Simple optimization

      if (dimSize === 0) {
        keep = cb.call(context, i);
      } else if (dimSize === 1) {
        var val = this._getFast(dim0, rawIdx);

        keep = cb.call(context, val, i);
      } else {
        for (var k = 0; k < dimSize; k++) {
          value[k] = this._getFast(dim0, rawIdx);
        }

        value[k] = i;
        keep = cb.apply(context, value);
      }

      if (keep) {
        newIndices[offset++] = rawIdx;
      }
    } // Set indices after filtered.


    if (offset < count) {
      this._indices = newIndices;
    }

    this._count = offset; // Reset data extent

    this._extent = {};
    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
    return this;
  };
  /**
   * Select data in range. (For optimization of filter)
   * (Manually inline code, support 5 million data filtering in data zoom.)
   */


  listProto.selectRange = function (range) {

    if (!this._count) {
      return;
    }

    var dimensions = [];

    for (var dim in range) {
      if (range.hasOwnProperty(dim)) {
        dimensions.push(dim);
      }
    }

    var dimSize = dimensions.length;

    if (!dimSize) {
      return;
    }

    var originalCount = this.count();
    var Ctor = getIndicesCtor(this);
    var newIndices = new Ctor(originalCount);
    var offset = 0;
    var dim0 = dimensions[0];
    var min = range[dim0][0];
    var max = range[dim0][1];
    var quickFinished = false;

    if (!this._indices) {
      // Extreme optimization for common case. About 2x faster in chrome.
      var idx = 0;

      if (dimSize === 1) {
        var dimStorage = this._storage[dimensions[0]];

        for (var k = 0; k < this._chunkCount; k++) {
          var chunkStorage = dimStorage[k];
          var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);

          for (var i = 0; i < len; i++) {
            var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty
            // value indicates the line should be broken. But for the case like
            // scatter plot, a data item with empty value will not be rendered,
            // but the axis extent may be effected if some other dim of the data
            // item has value. Fortunately it is not a significant negative effect.

            if (val >= min && val <= max || isNaN(val)) {
              newIndices[offset++] = idx;
            }

            idx++;
          }
        }

        quickFinished = true;
      } else if (dimSize === 2) {
        var dimStorage = this._storage[dim0];
        var dimStorage2 = this._storage[dimensions[1]];
        var min2 = range[dimensions[1]][0];
        var max2 = range[dimensions[1]][1];

        for (var k = 0; k < this._chunkCount; k++) {
          var chunkStorage = dimStorage[k];
          var chunkStorage2 = dimStorage2[k];
          var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);

          for (var i = 0; i < len; i++) {
            var val = chunkStorage[i];
            var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.

            if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {
              newIndices[offset++] = idx;
            }

            idx++;
          }
        }

        quickFinished = true;
      }
    }

    if (!quickFinished) {
      if (dimSize === 1) {
        for (var i = 0; i < originalCount; i++) {
          var rawIndex = this.getRawIndex(i);

          var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.


          if (val >= min && val <= max || isNaN(val)) {
            newIndices[offset++] = rawIndex;
          }
        }
      } else {
        for (var i = 0; i < originalCount; i++) {
          var keep = true;
          var rawIndex = this.getRawIndex(i);

          for (var k = 0; k < dimSize; k++) {
            var dimk = dimensions[k];

            var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.


            if (val < range[dimk][0] || val > range[dimk][1]) {
              keep = false;
            }
          }

          if (keep) {
            newIndices[offset++] = this.getRawIndex(i);
          }
        }
      }
    } // Set indices after filtered.


    if (offset < originalCount) {
      this._indices = newIndices;
    }

    this._count = offset; // Reset data extent

    this._extent = {};
    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
    return this;
  };
  /**
   * Data mapping to a plain array
   * @param {string|Array.<string>} [dimensions]
   * @param {Function} cb
   * @param {*} [context=this]
   * @return {Array}
   */


  listProto.mapArray = function (dimensions, cb, context, contextCompat) {

    if (typeof dimensions === 'function') {
      contextCompat = context;
      context = cb;
      cb = dimensions;
      dimensions = [];
    } // contextCompat just for compat echarts3


    context = context || contextCompat || this;
    var result = [];
    this.each(dimensions, function () {
      result.push(cb && cb.apply(this, arguments));
    }, context);
    return result;
  }; // Data in excludeDimensions is copied, otherwise transfered.


  function cloneListForMapAndSample(original, excludeDimensions) {
    var allDimensions = original.dimensions;
    var list = new List(util.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked

    transferProperties(list, original);
    var storage = list._storage = {};
    var originalStorage = original._storage; // Init storage

    for (var i = 0; i < allDimensions.length; i++) {
      var dim = allDimensions[i];

      if (originalStorage[dim]) {
        // Notice that we do not reset invertedIndicesMap here, becuase
        // there is no scenario of mapping or sampling ordinal dimension.
        if (util.indexOf(excludeDimensions, dim) >= 0) {
          storage[dim] = cloneDimStore(originalStorage[dim]);
          list._rawExtent[dim] = getInitialExtent();
          list._extent[dim] = null;
        } else {
          // Direct reference for other dimensions
          storage[dim] = originalStorage[dim];
        }
      }
    }

    return list;
  }

  function cloneDimStore(originalDimStore) {
    var newDimStore = new Array(originalDimStore.length);

    for (var j = 0; j < originalDimStore.length; j++) {
      newDimStore[j] = cloneChunk(originalDimStore[j]);
    }

    return newDimStore;
  }

  function getInitialExtent() {
    return [Infinity, -Infinity];
  }
  /**
   * Data mapping to a new List with given dimensions
   * @param {string|Array.<string>} dimensions
   * @param {Function} cb
   * @param {*} [context=this]
   * @return {Array}
   */


  listProto.map = function (dimensions, cb, context, contextCompat) {

    context = context || contextCompat || this;
    dimensions = util.map(normalizeDimensions(dimensions), this.getDimension, this);
    var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.
    // So we can reference to the same value

    list._indices = this._indices;
    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
    var storage = list._storage;
    var tmpRetValue = [];
    var chunkSize = this._chunkSize;
    var dimSize = dimensions.length;
    var dataCount = this.count();
    var values = [];
    var rawExtent = list._rawExtent;

    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
      for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {
        values[dimIndex] = this.get(dimensions[dimIndex], dataIndex
        /*, stack */
        );
      }

      values[dimSize] = dataIndex;
      var retValue = cb && cb.apply(context, values);

      if (retValue != null) {
        // a number or string (in oridinal dimension)?
        if (typeof retValue !== 'object') {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }

        var rawIndex = this.getRawIndex(dataIndex);
        var chunkIndex = Math.floor(rawIndex / chunkSize);
        var chunkOffset = rawIndex % chunkSize;

        for (var i = 0; i < retValue.length; i++) {
          var dim = dimensions[i];
          var val = retValue[i];
          var rawExtentOnDim = rawExtent[dim];
          var dimStore = storage[dim];

          if (dimStore) {
            dimStore[chunkIndex][chunkOffset] = val;
          }

          if (val < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = val;
          }

          if (val > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = val;
          }
        }
      }
    }

    return list;
  };
  /**
   * Large data down sampling on given dimension
   * @param {string} dimension
   * @param {number} rate
   * @param {Function} sampleValue
   * @param {Function} sampleIndex Sample index for name and id
   */


  listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {
    var list = cloneListForMapAndSample(this, [dimension]);
    var targetStorage = list._storage;
    var frameValues = [];
    var frameSize = Math.floor(1 / rate);
    var dimStore = targetStorage[dimension];
    var len = this.count();
    var chunkSize = this._chunkSize;
    var rawExtentOnDim = list._rawExtent[dimension];
    var newIndices = new (getIndicesCtor(this))(len);
    var offset = 0;

    for (var i = 0; i < len; i += frameSize) {
      // Last frame
      if (frameSize > len - i) {
        frameSize = len - i;
        frameValues.length = frameSize;
      }

      for (var k = 0; k < frameSize; k++) {
        var dataIdx = this.getRawIndex(i + k);
        var originalChunkIndex = Math.floor(dataIdx / chunkSize);
        var originalChunkOffset = dataIdx % chunkSize;
        frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];
      }

      var value = sampleValue(frameValues);
      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));
      var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);
      var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data

      dimStore[sampleChunkIndex][sampleChunkOffset] = value;

      if (value < rawExtentOnDim[0]) {
        rawExtentOnDim[0] = value;
      }

      if (value > rawExtentOnDim[1]) {
        rawExtentOnDim[1] = value;
      }

      newIndices[offset++] = sampleFrameIdx;
    }

    list._count = offset;
    list._indices = newIndices;
    list.getRawIndex = getRawIndexWithIndices;
    return list;
  };
  /**
   * Get model of one data item.
   *
   * @param {number} idx
   */
  // FIXME Model proxy ?


  listProto.getItemModel = function (idx) {
    var hostModel = this.hostModel;
    return new Model_1(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);
  };
  /**
   * Create a data differ
   * @param {module:echarts/data/List} otherList
   * @return {module:echarts/data/DataDiffer}
   */


  listProto.diff = function (otherList) {
    var thisList = this;
    return new DataDiffer_1(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {
      return getId(otherList, idx);
    }, function (idx) {
      return getId(thisList, idx);
    });
  };
  /**
   * Get visual property.
   * @param {string} key
   */


  listProto.getVisual = function (key) {
    var visual = this._visual;
    return visual && visual[key];
  };
  /**
   * Set visual property
   * @param {string|Object} key
   * @param {*} [value]
   *
   * @example
   *  setVisual('color', color);
   *  setVisual({
   *      'color': color
   *  });
   */


  listProto.setVisual = function (key, val) {
    if (isObject$b(key)) {
      for (var name in key) {
        if (key.hasOwnProperty(name)) {
          this.setVisual(name, key[name]);
        }
      }

      return;
    }

    this._visual = this._visual || {};
    this._visual[key] = val;
  };
  /**
   * Set layout property.
   * @param {string|Object} key
   * @param {*} [val]
   */


  listProto.setLayout = function (key, val) {
    if (isObject$b(key)) {
      for (var name in key) {
        if (key.hasOwnProperty(name)) {
          this.setLayout(name, key[name]);
        }
      }

      return;
    }

    this._layout[key] = val;
  };
  /**
   * Get layout property.
   * @param  {string} key.
   * @return {*}
   */


  listProto.getLayout = function (key) {
    return this._layout[key];
  };
  /**
   * Get layout of single data item
   * @param {number} idx
   */


  listProto.getItemLayout = function (idx) {
    return this._itemLayouts[idx];
  };
  /**
   * Set layout of single data item
   * @param {number} idx
   * @param {Object} layout
   * @param {boolean=} [merge=false]
   */


  listProto.setItemLayout = function (idx, layout, merge) {
    this._itemLayouts[idx] = merge ? util.extend(this._itemLayouts[idx] || {}, layout) : layout;
  };
  /**
   * Clear all layout of single data item
   */


  listProto.clearItemLayouts = function () {
    this._itemLayouts.length = 0;
  };
  /**
   * Get visual property of single data item
   * @param {number} idx
   * @param {string} key
   * @param {boolean} [ignoreParent=false]
   */


  listProto.getItemVisual = function (idx, key, ignoreParent) {
    var itemVisual = this._itemVisuals[idx];
    var val = itemVisual && itemVisual[key];

    if (val == null && !ignoreParent) {
      // Use global visual property
      return this.getVisual(key);
    }

    return val;
  };
  /**
   * Set visual property of single data item
   *
   * @param {number} idx
   * @param {string|Object} key
   * @param {*} [value]
   *
   * @example
   *  setItemVisual(0, 'color', color);
   *  setItemVisual(0, {
   *      'color': color
   *  });
   */


  listProto.setItemVisual = function (idx, key, value) {
    var itemVisual = this._itemVisuals[idx] || {};
    var hasItemVisual = this.hasItemVisual;
    this._itemVisuals[idx] = itemVisual;

    if (isObject$b(key)) {
      for (var name in key) {
        if (key.hasOwnProperty(name)) {
          itemVisual[name] = key[name];
          hasItemVisual[name] = true;
        }
      }

      return;
    }

    itemVisual[key] = value;
    hasItemVisual[key] = true;
  };
  /**
   * Clear itemVisuals and list visual.
   */


  listProto.clearAllVisual = function () {
    this._visual = {};
    this._itemVisuals = [];
    this.hasItemVisual = {};
  };

  var setItemDataAndSeriesIndex = function (child) {
    child.seriesIndex = this.seriesIndex;
    child.dataIndex = this.dataIndex;
    child.dataType = this.dataType;
  };
  /**
   * Set graphic element relative to data. It can be set as null
   * @param {number} idx
   * @param {module:zrender/Element} [el]
   */


  listProto.setItemGraphicEl = function (idx, el) {
    var hostModel = this.hostModel;

    if (el) {
      // Add data index and series index for indexing the data by element
      // Useful in tooltip
      el.dataIndex = idx;
      el.dataType = this.dataType;
      el.seriesIndex = hostModel && hostModel.seriesIndex;

      if (el.type === 'group') {
        el.traverse(setItemDataAndSeriesIndex, el);
      }
    }

    this._graphicEls[idx] = el;
  };
  /**
   * @param {number} idx
   * @return {module:zrender/Element}
   */


  listProto.getItemGraphicEl = function (idx) {
    return this._graphicEls[idx];
  };
  /**
   * @param {Function} cb
   * @param {*} context
   */


  listProto.eachItemGraphicEl = function (cb, context) {
    util.each(this._graphicEls, function (el, idx) {
      if (el) {
        cb && cb.call(context, el, idx);
      }
    });
  };
  /**
   * Shallow clone a new list except visual and layout properties, and graph elements.
   * New list only change the indices.
   */


  listProto.cloneShallow = function (list) {
    if (!list) {
      var dimensionInfoList = util.map(this.dimensions, this.getDimensionInfo, this);
      list = new List(dimensionInfoList, this.hostModel);
    } // FIXME


    list._storage = this._storage;
    transferProperties(list, this); // Clone will not change the data extent and indices

    if (this._indices) {
      var Ctor = this._indices.constructor;
      list._indices = new Ctor(this._indices);
    } else {
      list._indices = null;
    }

    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
    return list;
  };
  /**
   * Wrap some method to add more feature
   * @param {string} methodName
   * @param {Function} injectFunction
   */


  listProto.wrapMethod = function (methodName, injectFunction) {
    var originalMethod = this[methodName];

    if (typeof originalMethod !== 'function') {
      return;
    }

    this.__wrappedMethods = this.__wrappedMethods || [];

    this.__wrappedMethods.push(methodName);

    this[methodName] = function () {
      var res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(util.slice(arguments)));
    };
  }; // Methods that create a new list based on this list should be listed here.
  // Notice that those method should `RETURN` the new list.


  listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.

  listProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];
  var _default$1j = List;
  var List_1 = _default$1j;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var createHashMap$8 = util.createHashMap;
  var each$g = util.each;
  var isString$8 = util.isString;
  var defaults$2 = util.defaults;
  var extend$8 = util.extend;
  var isObject$c = util.isObject;
  var clone$6 = util.clone;



  var normalizeToArray$4 = model.normalizeToArray;



  var guessOrdinal$1 = sourceHelper.guessOrdinal;
  var BE_ORDINAL$1 = sourceHelper.BE_ORDINAL;





  var OTHER_DIMENSIONS$1 = dimensionHelper.OTHER_DIMENSIONS;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @deprecated
   * Use `echarts/data/helper/createDimensions` instead.
   */

  /**
   * @see {module:echarts/test/ut/spec/data/completeDimensions}
   *
   * This method builds the relationship between:
   * + "what the coord sys or series requires (see `sysDims`)",
   * + "what the user defines (in `encode` and `dimensions`, see `opt.dimsDef` and `opt.encodeDef`)"
   * + "what the data source provids (see `source`)".
   *
   * Some guess strategy will be adapted if user does not define something.
   * If no 'value' dimension specified, the first no-named dimension will be
   * named as 'value'.
   *
   * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which
   *      provides not only dim template, but also default order.
   *      properties: 'name', 'type', 'displayName'.
   *      `name` of each item provides default coord name.
   *      [{dimsDef: [string|Object, ...]}, ...] dimsDef of sysDim item provides default dim name, and
   *                                    provide dims count that the sysDim required.
   *      [{ordinalMeta}] can be specified.
   * @param {module:echarts/data/Source|Array|Object} source or data (for compatibal with pervious)
   * @param {Object} [opt]
   * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions
   *      For example: ['asdf', {name, type}, ...].
   * @param {Object|HashMap} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}
   * @param {Function} [opt.encodeDefaulter] Called if no `opt.encodeDef` exists.
   *      If not specified, auto find the next available data dim.
   *      param source {module:data/Source}
   *      param dimCount {number}
   *      return {Object} encode Never be `null/undefined`.
   * @param {string} [opt.generateCoord] Generate coord dim with the given name.
   *      If not specified, extra dim names will be:
   *      'value', 'value0', 'value1', ...
   * @param {number} [opt.generateCoordCount] By default, the generated dim name is `generateCoord`.
   *      If `generateCoordCount` specified, the generated dim names will be:
   *      `generateCoord` + 0, `generateCoord` + 1, ...
   *      can be Infinity, indicate that use all of the remain columns.
   * @param {number} [opt.dimCount] If not specified, guess by the first data item.
   * @return {Array.<module:data/DataDimensionInfo>}
   */
  function completeDimensions(sysDims, source, opt) {
    if (!Source_1.isInstance(source)) {
      source = Source_1.seriesDataToSource(source);
    }

    opt = opt || {};
    sysDims = (sysDims || []).slice();
    var dimsDef = (opt.dimsDef || []).slice();
    var dataDimNameMap = createHashMap$8();
    var coordDimNameMap = createHashMap$8(); // var valueCandidate;

    var result = [];
    var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimCount); // Apply user defined dims (`name` and `type`) and init result.

    for (var i = 0; i < dimCount; i++) {
      var dimDefItem = dimsDef[i] = extend$8({}, isObject$c(dimsDef[i]) ? dimsDef[i] : {
        name: dimsDef[i]
      });
      var userDimName = dimDefItem.name;
      var resultItem = result[i] = new DataDimensionInfo_1(); // Name will be applied later for avoiding duplication.

      if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
        // Only if `series.dimensions` is defined in option
        // displayName, will be set, and dimension will be diplayed vertically in
        // tooltip by default.
        resultItem.name = resultItem.displayName = userDimName;
        dataDimNameMap.set(userDimName, i);
      }

      dimDefItem.type != null && (resultItem.type = dimDefItem.type);
      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);
    }

    var encodeDef = opt.encodeDef;

    if (!encodeDef && opt.encodeDefaulter) {
      encodeDef = opt.encodeDefaulter(source, dimCount);
    }

    encodeDef = createHashMap$8(encodeDef); // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.

    encodeDef.each(function (dataDims, coordDim) {
      dataDims = normalizeToArray$4(dataDims).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is
      // `{encode: {x: -1, y: 1}}`. Should not filter anything in
      // this case.

      if (dataDims.length === 1 && !isString$8(dataDims[0]) && dataDims[0] < 0) {
        encodeDef.set(coordDim, false);
        return;
      }

      var validDataDims = encodeDef.set(coordDim, []);
      each$g(dataDims, function (resultDimIdx, idx) {
        // The input resultDimIdx can be dim name or index.
        isString$8(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));

        if (resultDimIdx != null && resultDimIdx < dimCount) {
          validDataDims[idx] = resultDimIdx;
          applyDim(result[resultDimIdx], coordDim, idx);
        }
      });
    }); // Apply templetes and default order from `sysDims`.

    var availDimIdx = 0;
    each$g(sysDims, function (sysDimItem, sysDimIndex) {
      var coordDim;
      var sysDimItem;
      var sysDimItemDimsDef;
      var sysDimItemOtherDims;

      if (isString$8(sysDimItem)) {
        coordDim = sysDimItem;
        sysDimItem = {};
      } else {
        coordDim = sysDimItem.name;
        var ordinalMeta = sysDimItem.ordinalMeta;
        sysDimItem.ordinalMeta = null;
        sysDimItem = clone$6(sysDimItem);
        sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.

        sysDimItemDimsDef = sysDimItem.dimsDef;
        sysDimItemOtherDims = sysDimItem.otherDims;
        sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
      }

      var dataDims = encodeDef.get(coordDim); // negative resultDimIdx means no need to mapping.

      if (dataDims === false) {
        return;
      }

      var dataDims = normalizeToArray$4(dataDims); // dimensions provides default dim sequences.

      if (!dataDims.length) {
        for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
          while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {
            availDimIdx++;
          }

          availDimIdx < result.length && dataDims.push(availDimIdx++);
        }
      } // Apply templates.


      each$g(dataDims, function (resultDimIdx, coordDimIndex) {
        var resultItem = result[resultDimIdx];
        applyDim(defaults$2(resultItem, sysDimItem), coordDim, coordDimIndex);

        if (resultItem.name == null && sysDimItemDimsDef) {
          var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
          !isObject$c(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
            name: sysDimItemDimsDefItem
          });
          resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;
          resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
        } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}


        sysDimItemOtherDims && defaults$2(resultItem.otherDims, sysDimItemOtherDims);
      });
    });

    function applyDim(resultItem, coordDim, coordDimIndex) {
      if (OTHER_DIMENSIONS$1.get(coordDim) != null) {
        resultItem.otherDims[coordDim] = coordDimIndex;
      } else {
        resultItem.coordDim = coordDim;
        resultItem.coordDimIndex = coordDimIndex;
        coordDimNameMap.set(coordDim, true);
      }
    } // Make sure the first extra dim is 'value'.


    var generateCoord = opt.generateCoord;
    var generateCoordCount = opt.generateCoordCount;
    var fromZero = generateCoordCount != null;
    generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
    var extra = generateCoord || 'value'; // Set dim `name` and other `coordDim` and other props.

    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
      var resultItem = result[resultDimIdx] = result[resultDimIdx] || new DataDimensionInfo_1();
      var coordDim = resultItem.coordDim;

      if (coordDim == null) {
        resultItem.coordDim = genName(extra, coordDimNameMap, fromZero);
        resultItem.coordDimIndex = 0;

        if (!generateCoord || generateCoordCount <= 0) {
          resultItem.isExtraCoord = true;
        }

        generateCoordCount--;
      }

      resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));

      if (resultItem.type == null && (guessOrdinal$1(source, resultDimIdx, resultItem.name) === BE_ORDINAL$1.Must // Consider the case:
      // {
      //    dataset: {source: [
      //        ['2001', 123],
      //        ['2002', 456],
      //        ...
      //        ['The others', 987],
      //    ]},
      //    series: {type: 'pie'}
      // }
      // The first colum should better be treated as a "ordinal" although it
      // might not able to be detected as an "ordinal" by `guessOrdinal`.
      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
        resultItem.type = 'ordinal';
      }
    }

    return result;
  } // ??? TODO
  // Originally detect dimCount by data[0]. Should we
  // optimize it to only by sysDims and dimensions and encode.
  // So only necessary dims will be initialized.
  // But
  // (1) custom series should be considered. where other dims
  // may be visited.
  // (2) sometimes user need to calcualte bubble size or use visualMap
  // on other dimensions besides coordSys needed.
  // So, dims that is not used by system, should be shared in storage?


  function getDimCount(source, sysDims, dimsDef, optDimCount) {
    // Note that the result dimCount should not small than columns count
    // of data, otherwise `dataDimNameMap` checking will be incorrect.
    var dimCount = Math.max(source.dimensionsDetectCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
    each$g(sysDims, function (sysDimItem) {
      var sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));
    });
    return dimCount;
  }

  function genName(name, map, fromZero) {
    if (fromZero || map.get(name) != null) {
      var i = 0;

      while (map.get(name + i) != null) {
        i++;
      }

      name += i;
    }

    map.set(name, true);
    return name;
  }

  var _default$1k = completeDimensions;
  var completeDimensions_1 = _default$1k;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Substitute `completeDimensions`.
   * `completeDimensions` is to be deprecated.
   */

  /**
   * @param {module:echarts/data/Source|module:echarts/data/List} source or data.
   * @param {Object|Array} [opt]
   * @param {Array.<string|Object>} [opt.coordDimensions=[]]
   * @param {number} [opt.dimensionsCount]
   * @param {string} [opt.generateCoord]
   * @param {string} [opt.generateCoordCount]
   * @param {Array.<string|Object>} [opt.dimensionsDefine=source.dimensionsDefine] Overwrite source define.
   * @param {Object|HashMap} [opt.encodeDefine=source.encodeDefine] Overwrite source define.
   * @param {Function} [opt.encodeDefaulter] Make default encode if user not specified.
   * @return {Array.<Object>} dimensionsInfo
   */
  function _default$1l(source, opt) {
    opt = opt || {};
    return completeDimensions_1(opt.coordDimensions || [], source, {
      dimsDef: opt.dimensionsDefine || source.dimensionsDefine,
      encodeDef: opt.encodeDefine || source.encodeDefine,
      dimCount: opt.dimensionsCount,
      encodeDefaulter: opt.encodeDefaulter,
      generateCoord: opt.generateCoord,
      generateCoordCount: opt.generateCoordCount
    });
  }

  var createDimensions = _default$1l;

  var createHashMap$9 = util.createHashMap;
  var each$h = util.each;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Helper for model references.
   * There are many manners to refer axis/coordSys.
   */
  // TODO
  // merge relevant logic to this file?
  // check: "modelHelper" of tooltip and "BrushTargetManager".

  /**
   * @class
   * For example:
   * {
   *     coordSysName: 'cartesian2d',
   *     coordSysDims: ['x', 'y', ...],
   *     axisMap: HashMap({
   *         x: xAxisModel,
   *         y: yAxisModel
   *     }),
   *     categoryAxisMap: HashMap({
   *         x: xAxisModel,
   *         y: undefined
   *     }),
   *     // The index of the first category axis in `coordSysDims`.
   *     // `null/undefined` means no category axis exists.
   *     firstCategoryDimIndex: 1,
   *     // To replace user specified encode.
   * }
   */
  function CoordSysInfo(coordSysName) {
    /**
     * @type {string}
     */
    this.coordSysName = coordSysName;
    /**
     * @type {Array.<string>}
     */

    this.coordSysDims = [];
    /**
     * @type {module:zrender/core/util#HashMap}
     */

    this.axisMap = createHashMap$9();
    /**
     * @type {module:zrender/core/util#HashMap}
     */

    this.categoryAxisMap = createHashMap$9();
    /**
     * @type {number}
     */

    this.firstCategoryDimIndex = null;
  }
  /**
   * @return {module:model/referHelper#CoordSysInfo}
   */


  function getCoordSysInfoBySeries(seriesModel) {
    var coordSysName = seriesModel.get('coordinateSystem');
    var result = new CoordSysInfo(coordSysName);
    var fetch = fetchers[coordSysName];

    if (fetch) {
      fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
      return result;
    }
  }

  var fetchers = {
    cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {
      var xAxisModel = seriesModel.getReferringComponents('xAxis')[0];
      var yAxisModel = seriesModel.getReferringComponents('yAxis')[0];
      result.coordSysDims = ['x', 'y'];
      axisMap.set('x', xAxisModel);
      axisMap.set('y', yAxisModel);

      if (isCategory(xAxisModel)) {
        categoryAxisMap.set('x', xAxisModel);
        result.firstCategoryDimIndex = 0;
      }

      if (isCategory(yAxisModel)) {
        categoryAxisMap.set('y', yAxisModel);
        result.firstCategoryDimIndex == null & (result.firstCategoryDimIndex = 1);
      }
    },
    singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {
      var singleAxisModel = seriesModel.getReferringComponents('singleAxis')[0];
      result.coordSysDims = ['single'];
      axisMap.set('single', singleAxisModel);

      if (isCategory(singleAxisModel)) {
        categoryAxisMap.set('single', singleAxisModel);
        result.firstCategoryDimIndex = 0;
      }
    },
    polar: function (seriesModel, result, axisMap, categoryAxisMap) {
      var polarModel = seriesModel.getReferringComponents('polar')[0];
      var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
      var angleAxisModel = polarModel.findAxisModel('angleAxis');
      result.coordSysDims = ['radius', 'angle'];
      axisMap.set('radius', radiusAxisModel);
      axisMap.set('angle', angleAxisModel);

      if (isCategory(radiusAxisModel)) {
        categoryAxisMap.set('radius', radiusAxisModel);
        result.firstCategoryDimIndex = 0;
      }

      if (isCategory(angleAxisModel)) {
        categoryAxisMap.set('angle', angleAxisModel);
        result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
      }
    },
    geo: function (seriesModel, result, axisMap, categoryAxisMap) {
      result.coordSysDims = ['lng', 'lat'];
    },
    parallel: function (seriesModel, result, axisMap, categoryAxisMap) {
      var ecModel = seriesModel.ecModel;
      var parallelModel = ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));
      var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
      each$h(parallelModel.parallelAxisIndex, function (axisIndex, index) {
        var axisModel = ecModel.getComponent('parallelAxis', axisIndex);
        var axisDim = coordSysDims[index];
        axisMap.set(axisDim, axisModel);

        if (isCategory(axisModel) && result.firstCategoryDimIndex == null) {
          categoryAxisMap.set(axisDim, axisModel);
          result.firstCategoryDimIndex = index;
        }
      });
    }
  };

  function isCategory(axisModel) {
    return axisModel.get('type') === 'category';
  }

  var getCoordSysInfoBySeries_1 = getCoordSysInfoBySeries;

  var referHelper = {
  	getCoordSysInfoBySeries: getCoordSysInfoBySeries_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var each$i = util.each;
  var isString$9 = util.isString;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Note that it is too complicated to support 3d stack by value
   * (have to create two-dimension inverted index), so in 3d case
   * we just support that stacked by index.
   *
   * @param {module:echarts/model/Series} seriesModel
   * @param {Array.<string|Object>} dimensionInfoList The same as the input of <module:echarts/data/List>.
   *        The input dimensionInfoList will be modified.
   * @param {Object} [opt]
   * @param {boolean} [opt.stackedCoordDimension=''] Specify a coord dimension if needed.
   * @param {boolean} [opt.byIndex=false]
   * @return {Object} calculationInfo
   * {
   *     stackedDimension: string
   *     stackedByDimension: string
   *     isStackedByIndex: boolean
   *     stackedOverDimension: string
   *     stackResultDimension: string
   * }
   */
  function enableDataStack(seriesModel, dimensionInfoList, opt) {
    opt = opt || {};
    var byIndex = opt.byIndex;
    var stackedCoordDimension = opt.stackedCoordDimension; // Compatibal: when `stack` is set as '', do not stack.

    var mayStack = !!(seriesModel && seriesModel.get('stack'));
    var stackedByDimInfo;
    var stackedDimInfo;
    var stackResultDimension;
    var stackedOverDimension;
    each$i(dimensionInfoList, function (dimensionInfo, index) {
      if (isString$9(dimensionInfo)) {
        dimensionInfoList[index] = dimensionInfo = {
          name: dimensionInfo
        };
      }

      if (mayStack && !dimensionInfo.isExtraCoord) {
        // Find the first ordinal dimension as the stackedByDimInfo.
        if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
          stackedByDimInfo = dimensionInfo;
        } // Find the first stackable dimension as the stackedDimInfo.


        if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
          stackedDimInfo = dimensionInfo;
        }
      }
    });

    if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
      // Compatible with previous design, value axis (time axis) only stack by index.
      // It may make sense if the user provides elaborately constructed data.
      byIndex = true;
    } // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.
    // That put stack logic in List is for using conveniently in echarts extensions, but it
    // might not be a good way.


    if (stackedDimInfo) {
      // Use a weird name that not duplicated with other names.
      stackResultDimension = '__\0ecstackresult';
      stackedOverDimension = '__\0ecstackedover'; // Create inverted index to fast query index by value.

      if (stackedByDimInfo) {
        stackedByDimInfo.createInvertedIndices = true;
      }

      var stackedDimCoordDim = stackedDimInfo.coordDim;
      var stackedDimType = stackedDimInfo.type;
      var stackedDimCoordIndex = 0;
      each$i(dimensionInfoList, function (dimensionInfo) {
        if (dimensionInfo.coordDim === stackedDimCoordDim) {
          stackedDimCoordIndex++;
        }
      });
      dimensionInfoList.push({
        name: stackResultDimension,
        coordDim: stackedDimCoordDim,
        coordDimIndex: stackedDimCoordIndex,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true
      });
      stackedDimCoordIndex++;
      dimensionInfoList.push({
        name: stackedOverDimension,
        // This dimension contains stack base (generally, 0), so do not set it as
        // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
        coordDim: stackedOverDimension,
        coordDimIndex: stackedDimCoordIndex,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true
      });
    }

    return {
      stackedDimension: stackedDimInfo && stackedDimInfo.name,
      stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
      isStackedByIndex: byIndex,
      stackedOverDimension: stackedOverDimension,
      stackResultDimension: stackResultDimension
    };
  }
  /**
   * @param {module:echarts/data/List} data
   * @param {string} stackedDim
   */


  function isDimensionStacked(data, stackedDim
  /*, stackedByDim*/
  ) {
    // Each single series only maps to one pair of axis. So we do not need to
    // check stackByDim, whatever stacked by a dimension or stacked by index.
    return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension'); // && (
    //     stackedByDim != null
    //         ? stackedByDim === data.getCalculationInfo('stackedByDimension')
    //         : data.getCalculationInfo('isStackedByIndex')
    // );
  }
  /**
   * @param {module:echarts/data/List} data
   * @param {string} targetDim
   * @param {string} [stackedByDim] If not input this parameter, check whether
   *                                stacked by index.
   * @return {string} dimension
   */


  function getStackedDimension(data, targetDim) {
    return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;
  }

  var enableDataStack_1 = enableDataStack;
  var isDimensionStacked_1 = isDimensionStacked;
  var getStackedDimension_1 = getStackedDimension;

  var dataStackHelper = {
  	enableDataStack: enableDataStack_1,
  	isDimensionStacked: isDimensionStacked_1,
  	getStackedDimension: getStackedDimension_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  var SOURCE_FORMAT_ORIGINAL$4 = sourceType.SOURCE_FORMAT_ORIGINAL;



  var getDimensionTypeByAxis$1 = dimensionHelper.getDimensionTypeByAxis;



  var getDataItemValue$3 = model.getDataItemValue;





  var getCoordSysInfoBySeries$1 = referHelper.getCoordSysInfoBySeries;





  var enableDataStack$1 = dataStackHelper.enableDataStack;



  var makeSeriesEncodeForAxisCoordSys$1 = sourceHelper.makeSeriesEncodeForAxisCoordSys;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @param {module:echarts/data/Source|Array} source Or raw data.
   * @param {module:echarts/model/Series} seriesModel
   * @param {Object} [opt]
   * @param {string} [opt.generateCoord]
   * @param {boolean} [opt.useEncodeDefaulter]
   */
  function createListFromArray(source, seriesModel, opt) {
    opt = opt || {};

    if (!Source_1.isInstance(source)) {
      source = Source_1.seriesDataToSource(source);
    }

    var coordSysName = seriesModel.get('coordinateSystem');
    var registeredCoordSys = CoordinateSystem.get(coordSysName);
    var coordSysInfo = getCoordSysInfoBySeries$1(seriesModel);
    var coordSysDimDefs;

    if (coordSysInfo) {
      coordSysDimDefs = util.map(coordSysInfo.coordSysDims, function (dim) {
        var dimInfo = {
          name: dim
        };
        var axisModel = coordSysInfo.axisMap.get(dim);

        if (axisModel) {
          var axisType = axisModel.get('type');
          dimInfo.type = getDimensionTypeByAxis$1(axisType); // dimInfo.stackable = isStackable(axisType);
        }

        return dimInfo;
      });
    }

    if (!coordSysDimDefs) {
      // Get dimensions from registered coordinate system
      coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];
    }

    var dimInfoList = createDimensions(source, {
      coordDimensions: coordSysDimDefs,
      generateCoord: opt.generateCoord,
      encodeDefaulter: opt.useEncodeDefaulter ? util.curry(makeSeriesEncodeForAxisCoordSys$1, coordSysDimDefs, seriesModel) : null
    });
    var firstCategoryDimIndex;
    var hasNameEncode;
    coordSysInfo && util.each(dimInfoList, function (dimInfo, dimIndex) {
      var coordDim = dimInfo.coordDim;
      var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);

      if (categoryAxisModel) {
        if (firstCategoryDimIndex == null) {
          firstCategoryDimIndex = dimIndex;
        }

        dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
      }

      if (dimInfo.otherDims.itemName != null) {
        hasNameEncode = true;
      }
    });

    if (!hasNameEncode && firstCategoryDimIndex != null) {
      dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
    }

    var stackCalculationInfo = enableDataStack$1(seriesModel, dimInfoList);
    var list = new List_1(dimInfoList, seriesModel);
    list.setCalculationInfo(stackCalculationInfo);
    var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {
      // Use dataIndex as ordinal value in categoryAxis
      return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
    } : null;
    list.hasItemOption = false;
    list.initData(source, null, dimValueGetter);
    return list;
  }

  function isNeedCompleteOrdinalData(source) {
    if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL$4) {
      var sampleItem = firstDataNotNull(source.data || []);
      return sampleItem != null && !util.isArray(getDataItemValue$3(sampleItem));
    }
  }

  function firstDataNotNull(data) {
    var i = 0;

    while (i < data.length && data[i] == null) {
      i++;
    }

    return data[i];
  }

  var _default$1m = createListFromArray;
  var createListFromArray_1 = _default$1m;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * // Scale class management
   * @module echarts/scale/Scale
   */

  /**
   * @param {Object} [setting]
   */
  function Scale(setting) {
    this._setting = setting || {};
    /**
     * Extent
     * @type {Array.<number>}
     * @protected
     */

    this._extent = [Infinity, -Infinity];
    /**
     * Step is calculated in adjustExtent
     * @type {Array.<number>}
     * @protected
     */

    this._interval = 0;
    this.init && this.init.apply(this, arguments);
  }
  /**
   * Parse input val to valid inner number.
   * @param {*} val
   * @return {number}
   */


  Scale.prototype.parse = function (val) {
    // Notice: This would be a trap here, If the implementation
    // of this method depends on extent, and this method is used
    // before extent set (like in dataZoom), it would be wrong.
    // Nevertheless, parse does not depend on extent generally.
    return val;
  };

  Scale.prototype.getSetting = function (name) {
    return this._setting[name];
  };

  Scale.prototype.contain = function (val) {
    var extent = this._extent;
    return val >= extent[0] && val <= extent[1];
  };
  /**
   * Normalize value to linear [0, 1], return 0.5 if extent span is 0
   * @param {number} val
   * @return {number}
   */


  Scale.prototype.normalize = function (val) {
    var extent = this._extent;

    if (extent[1] === extent[0]) {
      return 0.5;
    }

    return (val - extent[0]) / (extent[1] - extent[0]);
  };
  /**
   * Scale normalized value
   * @param {number} val
   * @return {number}
   */


  Scale.prototype.scale = function (val) {
    var extent = this._extent;
    return val * (extent[1] - extent[0]) + extent[0];
  };
  /**
   * Set extent from data
   * @param {Array.<number>} other
   */


  Scale.prototype.unionExtent = function (other) {
    var extent = this._extent;
    other[0] < extent[0] && (extent[0] = other[0]);
    other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power
    // this.setExtent(extent[0], extent[1]);
  };
  /**
   * Set extent from data
   * @param {module:echarts/data/List} data
   * @param {string} dim
   */


  Scale.prototype.unionExtentFromData = function (data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  /**
   * Get extent
   * @return {Array.<number>}
   */


  Scale.prototype.getExtent = function () {
    return this._extent.slice();
  };
  /**
   * Set extent
   * @param {number} start
   * @param {number} end
   */


  Scale.prototype.setExtent = function (start, end) {
    var thisExtent = this._extent;

    if (!isNaN(start)) {
      thisExtent[0] = start;
    }

    if (!isNaN(end)) {
      thisExtent[1] = end;
    }
  };
  /**
   * When axis extent depends on data and no data exists,
   * axis ticks should not be drawn, which is named 'blank'.
   */


  Scale.prototype.isBlank = function () {
    return this._isBlank;
  },
  /**
   * When axis extent depends on data and no data exists,
   * axis ticks should not be drawn, which is named 'blank'.
   */
  Scale.prototype.setBlank = function (isBlank) {
    this._isBlank = isBlank;
  };
  /**
   * @abstract
   * @param {*} tick
   * @return {string} label of the tick.
   */

  Scale.prototype.getLabel = null;
  clazz.enableClassExtend(Scale);
  clazz.enableClassManagement(Scale, {
    registerWhenExtend: true
  });
  var _default$1n = Scale;
  var Scale_1 = _default$1n;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var createHashMap$a = util.createHashMap;
  var isObject$d = util.isObject;
  var map$5 = util.map;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @constructor
   * @param {Object} [opt]
   * @param {Object} [opt.categories=[]]
   * @param {Object} [opt.needCollect=false]
   * @param {Object} [opt.deduplication=false]
   */
  function OrdinalMeta(opt) {
    /**
     * @readOnly
     * @type {Array.<string>}
     */
    this.categories = opt.categories || [];
    /**
     * @private
     * @type {boolean}
     */

    this._needCollect = opt.needCollect;
    /**
     * @private
     * @type {boolean}
     */

    this._deduplication = opt.deduplication;
    /**
     * @private
     * @type {boolean}
     */

    this._map;
  }
  /**
   * @param {module:echarts/model/Model} axisModel
   * @return {module:echarts/data/OrdinalMeta}
   */


  OrdinalMeta.createByAxisModel = function (axisModel) {
    var option = axisModel.option;
    var data = option.data;
    var categories = data && map$5(data, getName);
    return new OrdinalMeta({
      categories: categories,
      needCollect: !categories,
      // deduplication is default in axis.
      deduplication: option.dedplication !== false
    });
  };

  var proto$1 = OrdinalMeta.prototype;
  /**
   * @param {string} category
   * @return {number} ordinal
   */

  proto$1.getOrdinal = function (category) {
    return getOrCreateMap(this).get(category);
  };
  /**
   * @param {*} category
   * @return {number} The ordinal. If not found, return NaN.
   */


  proto$1.parseAndCollect = function (category) {
    var index;
    var needCollect = this._needCollect; // The value of category dim can be the index of the given category set.
    // This feature is only supported when !needCollect, because we should
    // consider a common case: a value is 2017, which is a number but is
    // expected to be tread as a category. This case usually happen in dataset,
    // where it happent to be no need of the index feature.

    if (typeof category !== 'string' && !needCollect) {
      return category;
    } // Optimize for the scenario:
    // category is ['2012-01-01', '2012-01-02', ...], where the input
    // data has been ensured not duplicate and is large data.
    // Notice, if a dataset dimension provide categroies, usually echarts
    // should remove duplication except user tell echarts dont do that
    // (set axis.deduplication = false), because echarts do not know whether
    // the values in the category dimension has duplication (consider the
    // parallel-aqi example)


    if (needCollect && !this._deduplication) {
      index = this.categories.length;
      this.categories[index] = category;
      return index;
    }

    var map = getOrCreateMap(this);
    index = map.get(category);

    if (index == null) {
      if (needCollect) {
        index = this.categories.length;
        this.categories[index] = category;
        map.set(category, index);
      } else {
        index = NaN;
      }
    }

    return index;
  }; // Consider big data, do not create map until needed.


  function getOrCreateMap(ordinalMeta) {
    return ordinalMeta._map || (ordinalMeta._map = createHashMap$a(ordinalMeta.categories));
  }

  function getName(obj) {
    if (isObject$d(obj) && obj.value != null) {
      return obj.value;
    } else {
      return obj + '';
    }
  }

  var _default$1o = OrdinalMeta;
  var OrdinalMeta_1 = _default$1o;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Linear continuous scale
   * @module echarts/coord/scale/Ordinal
   *
   * http://en.wikipedia.org/wiki/Level_of_measurement
   */
  // FIXME only one data
  var scaleProto = Scale_1.prototype;
  var OrdinalScale = Scale_1.extend({
    type: 'ordinal',

    /**
     * @param {module:echarts/data/OrdianlMeta|Array.<string>} ordinalMeta
     */
    init: function (ordinalMeta, extent) {
      // Caution: Should not use instanceof, consider ec-extensions using
      // import approach to get OrdinalMeta class.
      if (!ordinalMeta || util.isArray(ordinalMeta)) {
        ordinalMeta = new OrdinalMeta_1({
          categories: ordinalMeta
        });
      }

      this._ordinalMeta = ordinalMeta;
      this._extent = extent || [0, ordinalMeta.categories.length - 1];
    },
    parse: function (val) {
      return typeof val === 'string' ? this._ordinalMeta.getOrdinal(val) // val might be float.
      : Math.round(val);
    },
    contain: function (rank) {
      rank = this.parse(rank);
      return scaleProto.contain.call(this, rank) && this._ordinalMeta.categories[rank] != null;
    },

    /**
     * Normalize given rank or name to linear [0, 1]
     * @param {number|string} [val]
     * @return {number}
     */
    normalize: function (val) {
      return scaleProto.normalize.call(this, this.parse(val));
    },
    scale: function (val) {
      return Math.round(scaleProto.scale.call(this, val));
    },

    /**
     * @return {Array}
     */
    getTicks: function () {
      var ticks = [];
      var extent = this._extent;
      var rank = extent[0];

      while (rank <= extent[1]) {
        ticks.push(rank);
        rank++;
      }

      return ticks;
    },

    /**
     * Get item on rank n
     * @param {number} n
     * @return {string}
     */
    getLabel: function (n) {
      if (!this.isBlank()) {
        // Note that if no data, ordinalMeta.categories is an empty array.
        return this._ordinalMeta.categories[n];
      }
    },

    /**
     * @return {number}
     */
    count: function () {
      return this._extent[1] - this._extent[0] + 1;
    },

    /**
     * @override
     */
    unionExtentFromData: function (data, dim) {
      this.unionExtent(data.getApproximateExtent(dim));
    },
    getOrdinalMeta: function () {
      return this._ordinalMeta;
    },
    niceTicks: util.noop,
    niceExtent: util.noop
  });
  /**
   * @return {module:echarts/scale/Time}
   */

  OrdinalScale.create = function () {
    return new OrdinalScale();
  };

  var _default$1p = OrdinalScale;
  var Ordinal = _default$1p;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * For testable.
   */
  var roundNumber = number.round;
  /**
   * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.
   *                                Should be extent[0] < extent[1].
   * @param {number} splitNumber splitNumber should be >= 1.
   * @param {number} [minInterval]
   * @param {number} [maxInterval]
   * @return {Object} {interval, intervalPrecision, niceTickExtent}
   */

  function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
    var result = {};
    var span = extent[1] - extent[0];
    var interval = result.interval = number.nice(span / splitNumber, true);

    if (minInterval != null && interval < minInterval) {
      interval = result.interval = minInterval;
    }

    if (maxInterval != null && interval > maxInterval) {
      interval = result.interval = maxInterval;
    } // Tow more digital for tick.


    var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent

    var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];
    fixExtent(niceTickExtent, extent);
    return result;
  }
  /**
   * @param {number} interval
   * @return {number} interval precision
   */


  function getIntervalPrecision(interval) {
    // Tow more digital for tick.
    return number.getPrecisionSafe(interval) + 2;
  }

  function clamp(niceTickExtent, idx, extent) {
    niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
  } // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.


  function fixExtent(niceTickExtent, extent) {
    !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
    !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
    clamp(niceTickExtent, 0, extent);
    clamp(niceTickExtent, 1, extent);

    if (niceTickExtent[0] > niceTickExtent[1]) {
      niceTickExtent[0] = niceTickExtent[1];
    }
  }

  var intervalScaleNiceTicks_1 = intervalScaleNiceTicks;
  var getIntervalPrecision_1 = getIntervalPrecision;
  var fixExtent_1 = fixExtent;

  var helper = {
  	intervalScaleNiceTicks: intervalScaleNiceTicks_1,
  	getIntervalPrecision: getIntervalPrecision_1,
  	fixExtent: fixExtent_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Interval scale
   * @module echarts/scale/Interval
   */
  var roundNumber$1 = number.round;
  /**
   * @alias module:echarts/coord/scale/Interval
   * @constructor
   */

  var IntervalScale = Scale_1.extend({
    type: 'interval',
    _interval: 0,
    _intervalPrecision: 2,
    setExtent: function (start, end) {
      var thisExtent = this._extent; //start,end may be a Number like '25',so...

      if (!isNaN(start)) {
        thisExtent[0] = parseFloat(start);
      }

      if (!isNaN(end)) {
        thisExtent[1] = parseFloat(end);
      }
    },
    unionExtent: function (other) {
      var extent = this._extent;
      other[0] < extent[0] && (extent[0] = other[0]);
      other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes

      IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
    },

    /**
     * Get interval
     */
    getInterval: function () {
      return this._interval;
    },

    /**
     * Set interval
     */
    setInterval: function (interval) {
      this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent
      // We assume user wan't to set both interval, min, max to get a better result

      this._niceExtent = this._extent.slice();
      this._intervalPrecision = helper.getIntervalPrecision(interval);
    },

    /**
     * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.
     * @return {Array.<number>}
     */
    getTicks: function (expandToNicedExtent) {
      var interval = this._interval;
      var extent = this._extent;
      var niceTickExtent = this._niceExtent;
      var intervalPrecision = this._intervalPrecision;
      var ticks = []; // If interval is 0, return [];

      if (!interval) {
        return ticks;
      } // Consider this case: using dataZoom toolbox, zoom and zoom.


      var safeLimit = 10000;

      if (extent[0] < niceTickExtent[0]) {
        if (expandToNicedExtent) {
          ticks.push(roundNumber$1(niceTickExtent[0] - interval, intervalPrecision));
        } else {
          ticks.push(extent[0]);
        }
      }

      var tick = niceTickExtent[0];

      while (tick <= niceTickExtent[1]) {
        ticks.push(tick); // Avoid rounding error

        tick = roundNumber$1(tick + interval, intervalPrecision);

        if (tick === ticks[ticks.length - 1]) {
          // Consider out of safe float point, e.g.,
          // -3711126.9907707 + 2e-10 === -3711126.9907707
          break;
        }

        if (ticks.length > safeLimit) {
          return [];
        }
      } // Consider this case: the last item of ticks is smaller
      // than niceTickExtent[1] and niceTickExtent[1] === extent[1].


      var lastNiceTick = ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1];

      if (extent[1] > lastNiceTick) {
        if (expandToNicedExtent) {
          ticks.push(roundNumber$1(lastNiceTick + interval, intervalPrecision));
        } else {
          ticks.push(extent[1]);
        }
      }

      return ticks;
    },

    /**
     * @param {number} [splitNumber=5]
     * @return {Array.<Array.<number>>}
     */
    getMinorTicks: function (splitNumber) {
      var ticks = this.getTicks(true);
      var minorTicks = [];
      var extent = this.getExtent();

      for (var i = 1; i < ticks.length; i++) {
        var nextTick = ticks[i];
        var prevTick = ticks[i - 1];
        var count = 0;
        var minorTicksGroup = [];
        var interval = nextTick - prevTick;
        var minorInterval = interval / splitNumber;

        while (count < splitNumber - 1) {
          var minorTick = number.round(prevTick + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.

          if (minorTick > extent[0] && minorTick < extent[1]) {
            minorTicksGroup.push(minorTick);
          }

          count++;
        }

        minorTicks.push(minorTicksGroup);
      }

      return minorTicks;
    },

    /**
     * @param {number} data
     * @param {Object} [opt]
     * @param {number|string} [opt.precision] If 'auto', use nice presision.
     * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.
     * @return {string}
     */
    getLabel: function (data, opt) {
      if (data == null) {
        return '';
      }

      var precision = opt && opt.precision;

      if (precision == null) {
        precision = number.getPrecisionSafe(data) || 0;
      } else if (precision === 'auto') {
        // Should be more precise then tick.
        precision = this._intervalPrecision;
      } // (1) If `precision` is set, 12.005 should be display as '12.00500'.
      // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.


      data = roundNumber$1(data, precision, true);
      return format$1.addCommas(data);
    },

    /**
     * Update interval and extent of intervals for nice ticks
     *
     * @param {number} [splitNumber = 5] Desired number of ticks
     * @param {number} [minInterval]
     * @param {number} [maxInterval]
     */
    niceTicks: function (splitNumber, minInterval, maxInterval) {
      splitNumber = splitNumber || 5;
      var extent = this._extent;
      var span = extent[1] - extent[0];

      if (!isFinite(span)) {
        return;
      } // User may set axis min 0 and data are all negative
      // FIXME If it needs to reverse ?


      if (span < 0) {
        span = -span;
        extent.reverse();
      }

      var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
      this._intervalPrecision = result.intervalPrecision;
      this._interval = result.interval;
      this._niceExtent = result.niceTickExtent;
    },

    /**
     * Nice extent.
     * @param {Object} opt
     * @param {number} [opt.splitNumber = 5] Given approx tick number
     * @param {boolean} [opt.fixMin=false]
     * @param {boolean} [opt.fixMax=false]
     * @param {boolean} [opt.minInterval]
     * @param {boolean} [opt.maxInterval]
     */
    niceExtent: function (opt) {
      var extent = this._extent; // If extent start and end are same, expand them

      if (extent[0] === extent[1]) {
        if (extent[0] !== 0) {
          // Expand extent
          var expandSize = extent[0]; // In the fowllowing case
          //      Axis has been fixed max 100
          //      Plus data are all 100 and axis extent are [100, 100].
          // Extend to the both side will cause expanded max is larger than fixed max.
          // So only expand to the smaller side.

          if (!opt.fixMax) {
            extent[1] += expandSize / 2;
            extent[0] -= expandSize / 2;
          } else {
            extent[0] -= expandSize / 2;
          }
        } else {
          extent[1] = 1;
        }
      }

      var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]

      if (!isFinite(span)) {
        extent[0] = 0;
        extent[1] = 1;
      }

      this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;

      var interval = this._interval;

      if (!opt.fixMin) {
        extent[0] = roundNumber$1(Math.floor(extent[0] / interval) * interval);
      }

      if (!opt.fixMax) {
        extent[1] = roundNumber$1(Math.ceil(extent[1] / interval) * interval);
      }
    }
  });
  /**
   * @return {module:echarts/scale/Time}
   */

  IntervalScale.create = function () {
    return new IntervalScale();
  };

  var _default$1q = IntervalScale;
  var Interval = _default$1q;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  var parsePercent$3 = number.parsePercent;



  var isDimensionStacked$1 = dataStackHelper.isDimensionStacked;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /* global Float32Array */
  var STACK_PREFIX = '__ec_stack_';
  var LARGE_BAR_MIN_WIDTH = 0.5;
  var LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;

  function getSeriesStackId(seriesModel) {
    return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;
  }

  function getAxisKey(axis) {
    return axis.dim + axis.index;
  }
  /**
   * @param {Object} opt
   * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.
   * @param {number} opt.count Positive interger.
   * @param {number} [opt.barWidth]
   * @param {number} [opt.barMaxWidth]
   * @param {number} [opt.barMinWidth]
   * @param {number} [opt.barGap]
   * @param {number} [opt.barCategoryGap]
   * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
   */


  function getLayoutOnAxis(opt) {
    var params = [];
    var baseAxis = opt.axis;
    var axisKey = 'axis0';

    if (baseAxis.type !== 'category') {
      return;
    }

    var bandWidth = baseAxis.getBandWidth();

    for (var i = 0; i < opt.count || 0; i++) {
      params.push(util.defaults({
        bandWidth: bandWidth,
        axisKey: axisKey,
        stackId: STACK_PREFIX + i
      }, opt));
    }

    var widthAndOffsets = doCalBarWidthAndOffset(params);
    var result = [];

    for (var i = 0; i < opt.count; i++) {
      var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
      item.offsetCenter = item.offset + item.width / 2;
      result.push(item);
    }

    return result;
  }

  function prepareLayoutBarSeries(seriesType, ecModel) {
    var seriesModels = [];
    ecModel.eachSeriesByType(seriesType, function (seriesModel) {
      // Check series coordinate, do layout for cartesian2d only
      if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {
        seriesModels.push(seriesModel);
      }
    });
    return seriesModels;
  }
  /**
   * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent
   * values.
   * This works for time axes, value axes, and log axes.
   * For a single time axis, return value is in the form like
   * {'x_0': [1000000]}.
   * The value of 1000000 is in milliseconds.
   */


  function getValueAxesMinGaps(barSeries) {
    /**
     * Map from axis.index to values.
     * For a single time axis, axisValues is in the form like
     * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.
     * Items in axisValues[x], e.g. 1495555200000, are time values of all
     * series.
     */
    var axisValues = {};
    util.each(barSeries, function (seriesModel) {
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();

      if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {
        return;
      }

      var data = seriesModel.getData();
      var key = baseAxis.dim + '_' + baseAxis.index;
      var dim = data.mapDimension(baseAxis.dim);

      for (var i = 0, cnt = data.count(); i < cnt; ++i) {
        var value = data.get(dim, i);

        if (!axisValues[key]) {
          // No previous data for the axis
          axisValues[key] = [value];
        } else {
          // No value in previous series
          axisValues[key].push(value);
        } // Ignore duplicated time values in the same axis

      }
    });
    var axisMinGaps = [];

    for (var key in axisValues) {
      if (axisValues.hasOwnProperty(key)) {
        var valuesInAxis = axisValues[key];

        if (valuesInAxis) {
          // Sort axis values into ascending order to calculate gaps
          valuesInAxis.sort(function (a, b) {
            return a - b;
          });
          var min = null;

          for (var j = 1; j < valuesInAxis.length; ++j) {
            var delta = valuesInAxis[j] - valuesInAxis[j - 1];

            if (delta > 0) {
              // Ignore 0 delta because they are of the same axis value
              min = min === null ? delta : Math.min(min, delta);
            }
          } // Set to null if only have one data


          axisMinGaps[key] = min;
        }
      }
    }

    return axisMinGaps;
  }

  function makeColumnLayout(barSeries) {
    var axisMinGaps = getValueAxesMinGaps(barSeries);
    var seriesInfoList = [];
    util.each(barSeries, function (seriesModel) {
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var axisExtent = baseAxis.getExtent();
      var bandWidth;

      if (baseAxis.type === 'category') {
        bandWidth = baseAxis.getBandWidth();
      } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {
        var key = baseAxis.dim + '_' + baseAxis.index;
        var minGap = axisMinGaps[key];
        var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
        var scale = baseAxis.scale.getExtent();
        var scaleSpan = Math.abs(scale[1] - scale[0]);
        bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value
      } else {
        var data = seriesModel.getData();
        bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
      }

      var barWidth = parsePercent$3(seriesModel.get('barWidth'), bandWidth);
      var barMaxWidth = parsePercent$3(seriesModel.get('barMaxWidth'), bandWidth);
      var barMinWidth = parsePercent$3( // barMinWidth by default is 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 1.
      seriesModel.get('barMinWidth') || 1, bandWidth);
      var barGap = seriesModel.get('barGap');
      var barCategoryGap = seriesModel.get('barCategoryGap');
      seriesInfoList.push({
        bandWidth: bandWidth,
        barWidth: barWidth,
        barMaxWidth: barMaxWidth,
        barMinWidth: barMinWidth,
        barGap: barGap,
        barCategoryGap: barCategoryGap,
        axisKey: getAxisKey(baseAxis),
        stackId: getSeriesStackId(seriesModel)
      });
    });
    return doCalBarWidthAndOffset(seriesInfoList);
  }

  function doCalBarWidthAndOffset(seriesInfoList) {
    // Columns info on each category axis. Key is cartesian name
    var columnsMap = {};
    util.each(seriesInfoList, function (seriesInfo, idx) {
      var axisKey = seriesInfo.axisKey;
      var bandWidth = seriesInfo.bandWidth;
      var columnsOnAxis = columnsMap[axisKey] || {
        bandWidth: bandWidth,
        remainedWidth: bandWidth,
        autoWidthCount: 0,
        categoryGap: '20%',
        gap: '30%',
        stacks: {}
      };
      var stacks = columnsOnAxis.stacks;
      columnsMap[axisKey] = columnsOnAxis;
      var stackId = seriesInfo.stackId;

      if (!stacks[stackId]) {
        columnsOnAxis.autoWidthCount++;
      }

      stacks[stackId] = stacks[stackId] || {
        width: 0,
        maxWidth: 0
      }; // Caution: In a single coordinate system, these barGrid attributes
      // will be shared by series. Consider that they have default values,
      // only the attributes set on the last series will work.
      // Do not change this fact unless there will be a break change.

      var barWidth = seriesInfo.barWidth;

      if (barWidth && !stacks[stackId].width) {
        // See #6312, do not restrict width.
        stacks[stackId].width = barWidth;
        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
        columnsOnAxis.remainedWidth -= barWidth;
      }

      var barMaxWidth = seriesInfo.barMaxWidth;
      barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
      var barMinWidth = seriesInfo.barMinWidth;
      barMinWidth && (stacks[stackId].minWidth = barMinWidth);
      var barGap = seriesInfo.barGap;
      barGap != null && (columnsOnAxis.gap = barGap);
      var barCategoryGap = seriesInfo.barCategoryGap;
      barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
    });
    var result = {};
    util.each(columnsMap, function (columnsOnAxis, coordSysName) {
      result[coordSysName] = {};
      var stacks = columnsOnAxis.stacks;
      var bandWidth = columnsOnAxis.bandWidth;
      var categoryGap = parsePercent$3(columnsOnAxis.categoryGap, bandWidth);
      var barGapPercent = parsePercent$3(columnsOnAxis.gap, 1);
      var remainedWidth = columnsOnAxis.remainedWidth;
      var autoWidthCount = columnsOnAxis.autoWidthCount;
      var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth

      util.each(stacks, function (column) {
        var maxWidth = column.maxWidth;
        var minWidth = column.minWidth;

        if (!column.width) {
          var finalWidth = autoWidth;

          if (maxWidth && maxWidth < finalWidth) {
            finalWidth = Math.min(maxWidth, remainedWidth);
          } // `minWidth` has higher priority. `minWidth` decide that wheter the
          // bar is able to be visible. So `minWidth` should not be restricted
          // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In
          // the extreme cases for `value` axis, bars are allowed to overlap
          // with each other if `minWidth` specified.


          if (minWidth && minWidth > finalWidth) {
            finalWidth = minWidth;
          }

          if (finalWidth !== autoWidth) {
            column.width = finalWidth;
            remainedWidth -= finalWidth + barGapPercent * finalWidth;
            autoWidthCount--;
          }
        } else {
          // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as
          // CSS does. Becuase barWidth can be a percent value, where
          // `barMaxWidth` can be used to restrict the final width.
          var finalWidth = column.width;

          if (maxWidth) {
            finalWidth = Math.min(finalWidth, maxWidth);
          } // `minWidth` has higher priority, as described above


          if (minWidth) {
            finalWidth = Math.max(finalWidth, minWidth);
          }

          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      }); // Recalculate width again

      autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      var widthSum = 0;
      var lastColumn;
      util.each(stacks, function (column, idx) {
        if (!column.width) {
          column.width = autoWidth;
        }

        lastColumn = column;
        widthSum += column.width * (1 + barGapPercent);
      });

      if (lastColumn) {
        widthSum -= lastColumn.width * barGapPercent;
      }

      var offset = -widthSum / 2;
      util.each(stacks, function (column, stackId) {
        result[coordSysName][stackId] = result[coordSysName][stackId] || {
          bandWidth: bandWidth,
          offset: offset,
          width: column.width
        };
        offset += column.width * (1 + barGapPercent);
      });
    });
    return result;
  }
  /**
   * @param {Object} barWidthAndOffset The result of makeColumnLayout
   * @param {module:echarts/coord/Axis} axis
   * @param {module:echarts/model/Series} [seriesModel] If not provided, return all.
   * @return {Object} {stackId: {offset, width}} or {offset, width} if seriesModel provided.
   */


  function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
    if (barWidthAndOffset && axis) {
      var result = barWidthAndOffset[getAxisKey(axis)];

      if (result != null && seriesModel != null) {
        result = result[getSeriesStackId(seriesModel)];
      }

      return result;
    }
  }
  /**
   * @param {string} seriesType
   * @param {module:echarts/model/Global} ecModel
   */


  function layout$1(seriesType, ecModel) {
    var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);
    var barWidthAndOffset = makeColumnLayout(seriesModels);
    var lastStackCoords = {};
    util.each(seriesModels, function (seriesModel) {
      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var stackId = getSeriesStackId(seriesModel);
      var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
      var columnOffset = columnLayoutInfo.offset;
      var columnWidth = columnLayoutInfo.width;
      var valueAxis = cartesian.getOtherAxis(baseAxis);
      var barMinHeight = seriesModel.get('barMinHeight') || 0;
      lastStackCoords[stackId] = lastStackCoords[stackId] || [];

      data.setLayout({
        bandWidth: columnLayoutInfo.bandWidth,
        offset: columnOffset,
        size: columnWidth
      });
      var valueDim = data.mapDimension(valueAxis.dim);
      var baseDim = data.mapDimension(baseAxis.dim);
      var stacked = isDimensionStacked$1(data, valueDim
      /*, baseDim*/
      );
      var isValueAxisH = valueAxis.isHorizontal();
      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);

      for (var idx = 0, len = data.count(); idx < len; idx++) {
        var value = data.get(valueDim, idx);
        var baseValue = data.get(baseDim, idx);
        var sign = value >= 0 ? 'p' : 'n';
        var baseCoord = valueAxisStart; // Because of the barMinHeight, we can not use the value in
        // stackResultDimension directly.

        if (stacked) {
          // Only ordinal axis can be stacked.
          if (!lastStackCoords[stackId][baseValue]) {
            lastStackCoords[stackId][baseValue] = {
              p: valueAxisStart,
              // Positive stack
              n: valueAxisStart // Negative stack

            };
          } // Should also consider #4243


          baseCoord = lastStackCoords[stackId][baseValue][sign];
        }

        var x;
        var y;
        var width;
        var height;

        if (isValueAxisH) {
          var coord = cartesian.dataToPoint([value, baseValue]);
          x = baseCoord;
          y = coord[1] + columnOffset;
          width = coord[0] - valueAxisStart;
          height = columnWidth;

          if (Math.abs(width) < barMinHeight) {
            width = (width < 0 ? -1 : 1) * barMinHeight;
          } // Ignore stack from NaN value


          if (!isNaN(width)) {
            stacked && (lastStackCoords[stackId][baseValue][sign] += width);
          }
        } else {
          var coord = cartesian.dataToPoint([baseValue, value]);
          x = coord[0] + columnOffset;
          y = baseCoord;
          width = columnWidth;
          height = coord[1] - valueAxisStart;

          if (Math.abs(height) < barMinHeight) {
            // Include zero to has a positive bar
            height = (height <= 0 ? -1 : 1) * barMinHeight;
          } // Ignore stack from NaN value


          if (!isNaN(height)) {
            stacked && (lastStackCoords[stackId][baseValue][sign] += height);
          }
        }

        data.setItemLayout(idx, {
          x: x,
          y: y,
          width: width,
          height: height
        });
      }
    }, this);
  } // TODO: Do not support stack in large mode yet.


  var largeLayout = {
    seriesType: 'bar',
    plan: createRenderPlanner(),
    reset: function (seriesModel) {
      if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {
        return;
      }

      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var coordLayout = cartesian.grid.getRect();
      var baseAxis = cartesian.getBaseAxis();
      var valueAxis = cartesian.getOtherAxis(baseAxis);
      var valueDim = data.mapDimension(valueAxis.dim);
      var baseDim = data.mapDimension(baseAxis.dim);
      var valueAxisHorizontal = valueAxis.isHorizontal();
      var valueDimIdx = valueAxisHorizontal ? 0 : 1;
      var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;

      if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {
        // jshint ignore:line
        barWidth = LARGE_BAR_MIN_WIDTH;
      }

      return {
        progress: progress
      };

      function progress(params, data) {
        var count = params.count;
        var largePoints = new LargeArr(count * 2);
        var largeBackgroundPoints = new LargeArr(count * 2);
        var largeDataIndices = new LargeArr(count);
        var dataIndex;
        var coord = [];
        var valuePair = [];
        var pointsOffset = 0;
        var idxOffset = 0;

        while ((dataIndex = params.next()) != null) {
          valuePair[valueDimIdx] = data.get(valueDim, dataIndex);
          valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);
          coord = cartesian.dataToPoint(valuePair, null, coord); // Data index might not be in order, depends on `progressiveChunkMode`.

          largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];
          largePoints[pointsOffset++] = coord[0];
          largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;
          largePoints[pointsOffset++] = coord[1];
          largeDataIndices[idxOffset++] = dataIndex;
        }

        data.setLayout({
          largePoints: largePoints,
          largeDataIndices: largeDataIndices,
          largeBackgroundPoints: largeBackgroundPoints,
          barWidth: barWidth,
          valueAxisStart: getValueAxisStart(baseAxis, valueAxis),
          backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,
          valueAxisHorizontal: valueAxisHorizontal
        });
      }
    }
  };

  function isOnCartesian(seriesModel) {
    return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';
  }

  function isInLargeMode(seriesModel) {
    return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
  } // See cases in `test/bar-start.html` and `#7412`, `#8747`.


  function getValueAxisStart(baseAxis, valueAxis, stacked) {
    return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));
  }

  var getLayoutOnAxis_1 = getLayoutOnAxis;
  var prepareLayoutBarSeries_1 = prepareLayoutBarSeries;
  var makeColumnLayout_1 = makeColumnLayout;
  var retrieveColumnLayout_1 = retrieveColumnLayout;
  var layout_1 = layout$1;
  var largeLayout_1 = largeLayout;

  var barGrid = {
  	getLayoutOnAxis: getLayoutOnAxis_1,
  	prepareLayoutBarSeries: prepareLayoutBarSeries_1,
  	makeColumnLayout: makeColumnLayout_1,
  	retrieveColumnLayout: retrieveColumnLayout_1,
  	layout: layout_1,
  	largeLayout: largeLayout_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */











  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * A third-party license is embeded for some of the code in this file:
  * The "scaleLevels" was originally copied from "d3.js" with some
  * modifications made for this project.
  * (See more details in the comment on the definition of "scaleLevels" below.)
  * The use of the source code of this file is also subject to the terms
  * and consitions of the license of "d3.js" (BSD-3Clause, see
  * </licenses/LICENSE-d3>).
  */
  // [About UTC and local time zone]:
  // In most cases, `number.parseDate` will treat input data string as local time
  // (except time zone is specified in time string). And `format.formateTime` returns
  // local time by default. option.useUTC is false by default. This design have
  // concidered these common case:
  // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed
  // in local time by default.
  // (2) By default, the input data string (e.g., '2011-01-02') should be displayed
  // as its original time, without any time difference.
  var intervalScaleProto = Interval.prototype;
  var mathCeil = Math.ceil;
  var mathFloor = Math.floor;
  var ONE_SECOND = 1000;
  var ONE_MINUTE = ONE_SECOND * 60;
  var ONE_HOUR = ONE_MINUTE * 60;
  var ONE_DAY = ONE_HOUR * 24; // FIXME å¬ç¨ï¼

  var bisect = function (a, x, lo, hi) {
    while (lo < hi) {
      var mid = lo + hi >>> 1;

      if (a[mid][1] < x) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }

    return lo;
  };
  /**
   * @alias module:echarts/coord/scale/Time
   * @constructor
   */


  var TimeScale = Interval.extend({
    type: 'time',

    /**
     * @override
     */
    getLabel: function (val) {
      var stepLvl = this._stepLvl;
      var date = new Date(val);
      return format$1.formatTime(stepLvl[0], date, this.getSetting('useUTC'));
    },

    /**
     * @override
     */
    niceExtent: function (opt) {
      var extent = this._extent; // If extent start and end are same, expand them

      if (extent[0] === extent[1]) {
        // Expand extent
        extent[0] -= ONE_DAY;
        extent[1] += ONE_DAY;
      } // If there are no data and extent are [Infinity, -Infinity]


      if (extent[1] === -Infinity && extent[0] === Infinity) {
        var d = new Date();
        extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
        extent[0] = extent[1] - ONE_DAY;
      }

      this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;

      var interval = this._interval;

      if (!opt.fixMin) {
        extent[0] = number.round(mathFloor(extent[0] / interval) * interval);
      }

      if (!opt.fixMax) {
        extent[1] = number.round(mathCeil(extent[1] / interval) * interval);
      }
    },

    /**
     * @override
     */
    niceTicks: function (approxTickNum, minInterval, maxInterval) {
      approxTickNum = approxTickNum || 10;
      var extent = this._extent;
      var span = extent[1] - extent[0];
      var approxInterval = span / approxTickNum;

      if (minInterval != null && approxInterval < minInterval) {
        approxInterval = minInterval;
      }

      if (maxInterval != null && approxInterval > maxInterval) {
        approxInterval = maxInterval;
      }

      var scaleLevelsLen = scaleLevels.length;
      var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
      var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
      var interval = level[1]; // Same with interval scale if span is much larger than 1 year

      if (level[0] === 'year') {
        var yearSpan = span / interval; // From "Nice Numbers for Graph Labels" of Graphic Gems
        // var niceYearSpan = numberUtil.nice(yearSpan, false);

        var yearStep = number.nice(yearSpan / approxTickNum, true);
        interval *= yearStep;
      }

      var timezoneOffset = this.getSetting('useUTC') ? 0 : new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 60 * 1000;
      var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];
      helper.fixExtent(niceExtent, extent);
      this._stepLvl = level; // Interval will be used in getTicks

      this._interval = interval;
      this._niceExtent = niceExtent;
    },
    parse: function (val) {
      // val might be float.
      return +number.parseDate(val);
    }
  });
  util.each(['contain', 'normalize'], function (methodName) {
    TimeScale.prototype[methodName] = function (val) {
      return intervalScaleProto[methodName].call(this, this.parse(val));
    };
  });
  /**
   * This implementation was originally copied from "d3.js"
   * <https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/time/scale.js>
   * with some modifications made for this program.
   * See the license statement at the head of this file.
   */

  var scaleLevels = [// Format              interval
  ['hh:mm:ss', ONE_SECOND], // 1s
  ['hh:mm:ss', ONE_SECOND * 5], // 5s
  ['hh:mm:ss', ONE_SECOND * 10], // 10s
  ['hh:mm:ss', ONE_SECOND * 15], // 15s
  ['hh:mm:ss', ONE_SECOND * 30], // 30s
  ['hh:mm\nMM-dd', ONE_MINUTE], // 1m
  ['hh:mm\nMM-dd', ONE_MINUTE * 5], // 5m
  ['hh:mm\nMM-dd', ONE_MINUTE * 10], // 10m
  ['hh:mm\nMM-dd', ONE_MINUTE * 15], // 15m
  ['hh:mm\nMM-dd', ONE_MINUTE * 30], // 30m
  ['hh:mm\nMM-dd', ONE_HOUR], // 1h
  ['hh:mm\nMM-dd', ONE_HOUR * 2], // 2h
  ['hh:mm\nMM-dd', ONE_HOUR * 6], // 6h
  ['hh:mm\nMM-dd', ONE_HOUR * 12], // 12h
  ['MM-dd\nyyyy', ONE_DAY], // 1d
  ['MM-dd\nyyyy', ONE_DAY * 2], // 2d
  ['MM-dd\nyyyy', ONE_DAY * 3], // 3d
  ['MM-dd\nyyyy', ONE_DAY * 4], // 4d
  ['MM-dd\nyyyy', ONE_DAY * 5], // 5d
  ['MM-dd\nyyyy', ONE_DAY * 6], // 6d
  ['week', ONE_DAY * 7], // 7d
  ['MM-dd\nyyyy', ONE_DAY * 10], // 10d
  ['week', ONE_DAY * 14], // 2w
  ['week', ONE_DAY * 21], // 3w
  ['month', ONE_DAY * 31], // 1M
  ['week', ONE_DAY * 42], // 6w
  ['month', ONE_DAY * 62], // 2M
  ['week', ONE_DAY * 70], // 10w
  ['quarter', ONE_DAY * 95], // 3M
  ['month', ONE_DAY * 31 * 4], // 4M
  ['month', ONE_DAY * 31 * 5], // 5M
  ['half-year', ONE_DAY * 380 / 2], // 6M
  ['month', ONE_DAY * 31 * 8], // 8M
  ['month', ONE_DAY * 31 * 10], // 10M
  ['year', ONE_DAY * 380] // 1Y
  ];
  /**
   * @param {module:echarts/model/Model}
   * @return {module:echarts/scale/Time}
   */

  TimeScale.create = function (model) {
    return new TimeScale({
      useUTC: model.ecModel.get('useUTC')
    });
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Log scale
   * @module echarts/scale/Log
   */
  // Use some method of IntervalScale
  var scaleProto$1 = Scale_1.prototype;
  var intervalScaleProto$1 = Interval.prototype;
  var getPrecisionSafe$1 = number.getPrecisionSafe;
  var roundingErrorFix = number.round;
  var mathFloor$1 = Math.floor;
  var mathCeil$1 = Math.ceil;
  var mathPow$1 = Math.pow;
  var mathLog = Math.log;
  var LogScale = Scale_1.extend({
    type: 'log',
    base: 10,
    $constructor: function () {
      Scale_1.apply(this, arguments);
      this._originalScale = new Interval();
    },

    /**
     * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.
     * @return {Array.<number>}
     */
    getTicks: function (expandToNicedExtent) {
      var originalScale = this._originalScale;
      var extent = this._extent;
      var originalExtent = originalScale.getExtent();
      return util.map(intervalScaleProto$1.getTicks.call(this, expandToNicedExtent), function (val) {
        var powVal = number.round(mathPow$1(this.base, val)); // Fix #4158

        powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
        powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
        return powVal;
      }, this);
    },

    /**
     * @param {number} splitNumber
     * @return {Array.<Array.<number>>}
     */
    getMinorTicks: intervalScaleProto$1.getMinorTicks,

    /**
     * @param {number} val
     * @return {string}
     */
    getLabel: intervalScaleProto$1.getLabel,

    /**
     * @param  {number} val
     * @return {number}
     */
    scale: function (val) {
      val = scaleProto$1.scale.call(this, val);
      return mathPow$1(this.base, val);
    },

    /**
     * @param {number} start
     * @param {number} end
     */
    setExtent: function (start, end) {
      var base = this.base;
      start = mathLog(start) / mathLog(base);
      end = mathLog(end) / mathLog(base);
      intervalScaleProto$1.setExtent.call(this, start, end);
    },

    /**
     * @return {number} end
     */
    getExtent: function () {
      var base = this.base;
      var extent = scaleProto$1.getExtent.call(this);
      extent[0] = mathPow$1(base, extent[0]);
      extent[1] = mathPow$1(base, extent[1]); // Fix #4158

      var originalScale = this._originalScale;
      var originalExtent = originalScale.getExtent();
      originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
      originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
      return extent;
    },

    /**
     * @param  {Array.<number>} extent
     */
    unionExtent: function (extent) {
      this._originalScale.unionExtent(extent);

      var base = this.base;
      extent[0] = mathLog(extent[0]) / mathLog(base);
      extent[1] = mathLog(extent[1]) / mathLog(base);
      scaleProto$1.unionExtent.call(this, extent);
    },

    /**
     * @override
     */
    unionExtentFromData: function (data, dim) {
      // TODO
      // filter value that <= 0
      this.unionExtent(data.getApproximateExtent(dim));
    },

    /**
     * Update interval and extent of intervals for nice ticks
     * @param  {number} [approxTickNum = 10] Given approx tick number
     */
    niceTicks: function (approxTickNum) {
      approxTickNum = approxTickNum || 10;
      var extent = this._extent;
      var span = extent[1] - extent[0];

      if (span === Infinity || span <= 0) {
        return;
      }

      var interval = number.quantity(span);
      var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.

      if (err <= 0.5) {
        interval *= 10;
      } // Interval should be integer


      while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
        interval *= 10;
      }

      var niceExtent = [number.round(mathCeil$1(extent[0] / interval) * interval), number.round(mathFloor$1(extent[1] / interval) * interval)];
      this._interval = interval;
      this._niceExtent = niceExtent;
    },

    /**
     * Nice extent.
     * @override
     */
    niceExtent: function (opt) {
      intervalScaleProto$1.niceExtent.call(this, opt);
      var originalScale = this._originalScale;
      originalScale.__fixMin = opt.fixMin;
      originalScale.__fixMax = opt.fixMax;
    }
  });
  util.each(['contain', 'normalize'], function (methodName) {
    LogScale.prototype[methodName] = function (val) {
      val = mathLog(val) / mathLog(this.base);
      return scaleProto$1[methodName].call(this, val);
    };
  });

  LogScale.create = function () {
    return new LogScale();
  };

  function fixRoundingError(val, originalVal) {
    return roundingErrorFix(val, getPrecisionSafe$1(originalVal));
  }

  var _default$1r = LogScale;
  var Log = _default$1r;

  var prepareLayoutBarSeries$1 = barGrid.prepareLayoutBarSeries;
  var makeColumnLayout$1 = barGrid.makeColumnLayout;
  var retrieveColumnLayout$1 = barGrid.retrieveColumnLayout;







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Get axis scale extent before niced.
   * Item of returned array can only be number (including Infinity and NaN).
   */
  function getScaleExtent(scale, model) {
    var scaleType = scale.type;
    var min = model.getMin();
    var max = model.getMax();
    var originalExtent = scale.getExtent();
    var axisDataLen;
    var boundaryGap;
    var span;

    if (scaleType === 'ordinal') {
      axisDataLen = model.getCategories().length;
    } else {
      boundaryGap = model.get('boundaryGap');

      if (!util.isArray(boundaryGap)) {
        boundaryGap = [boundaryGap || 0, boundaryGap || 0];
      }

      if (typeof boundaryGap[0] === 'boolean') {
        boundaryGap = [0, 0];
      }

      boundaryGap[0] = number.parsePercent(boundaryGap[0], 1);
      boundaryGap[1] = number.parsePercent(boundaryGap[1], 1);
      span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);
    } // Notice: When min/max is not set (that is, when there are null/undefined,
    // which is the most common case), these cases should be ensured:
    // (1) For 'ordinal', show all axis.data.
    // (2) For others:
    //      + `boundaryGap` is applied (if min/max set, boundaryGap is
    //      disabled).
    //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should
    //      be the result that originalExtent enlarged by boundaryGap.
    // (3) If no data, it should be ensured that `scale.setBlank` is set.
    // FIXME
    // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?
    // (2) When `needCrossZero` and all data is positive/negative, should it be ensured
    // that the results processed by boundaryGap are positive/negative?


    if (min === 'dataMin') {
      min = originalExtent[0];
    } else if (typeof min === 'function') {
      min = min({
        min: originalExtent[0],
        max: originalExtent[1]
      });
    }

    if (max === 'dataMax') {
      max = originalExtent[1];
    } else if (typeof max === 'function') {
      max = max({
        min: originalExtent[0],
        max: originalExtent[1]
      });
    }

    var fixMin = min != null;
    var fixMax = max != null;

    if (min == null) {
      min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;
    }

    if (max == null) {
      max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;
    }

    (min == null || !isFinite(min)) && (min = NaN);
    (max == null || !isFinite(max)) && (max = NaN);
    scale.setBlank(util.eqNaN(min) || util.eqNaN(max) || scaleType === 'ordinal' && !scale.getOrdinalMeta().categories.length); // Evaluate if axis needs cross zero

    if (model.getNeedCrossZero()) {
      // Axis is over zero and min is not set
      if (min > 0 && max > 0 && !fixMin) {
        min = 0;
      } // Axis is under zero and max is not set


      if (min < 0 && max < 0 && !fixMax) {
        max = 0;
      }
    } // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis
    // is base axis
    // FIXME
    // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.
    // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?
    //     Should not depend on series type `bar`?
    // (3) Fix that might overlap when using dataZoom.
    // (4) Consider other chart types using `barGrid`?
    // See #6728, #4862, `test/bar-overflow-time-plot.html`


    var ecModel = model.ecModel;

    if (ecModel && scaleType === 'time'
    /*|| scaleType === 'interval' */
    ) {
      var barSeriesModels = prepareLayoutBarSeries$1('bar', ecModel);
      var isBaseAxisAndHasBarSeries;
      util.each(barSeriesModels, function (seriesModel) {
        isBaseAxisAndHasBarSeries |= seriesModel.getBaseAxis() === model.axis;
      });

      if (isBaseAxisAndHasBarSeries) {
        // Calculate placement of bars on axis
        var barWidthAndOffset = makeColumnLayout$1(barSeriesModels); // Adjust axis min and max to account for overflow

        var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);
        min = adjustedScale.min;
        max = adjustedScale.max;
      }
    }

    return {
      extent: [min, max],
      // "fix" means "fixed", the value should not be
      // changed in the subsequent steps.
      fixMin: fixMin,
      fixMax: fixMax
    };
  }

  function adjustScaleForOverflow(min, max, model, barWidthAndOffset) {
    // Get Axis Length
    var axisExtent = model.axis.getExtent();
    var axisLength = axisExtent[1] - axisExtent[0]; // Get bars on current base axis and calculate min and max overflow

    var barsOnCurrentAxis = retrieveColumnLayout$1(barWidthAndOffset, model.axis);

    if (barsOnCurrentAxis === undefined) {
      return {
        min: min,
        max: max
      };
    }

    var minOverflow = Infinity;
    util.each(barsOnCurrentAxis, function (item) {
      minOverflow = Math.min(item.offset, minOverflow);
    });
    var maxOverflow = -Infinity;
    util.each(barsOnCurrentAxis, function (item) {
      maxOverflow = Math.max(item.offset + item.width, maxOverflow);
    });
    minOverflow = Math.abs(minOverflow);
    maxOverflow = Math.abs(maxOverflow);
    var totalOverFlow = minOverflow + maxOverflow; // Calulate required buffer based on old range and overflow

    var oldRange = max - min;
    var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
    var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
    max += overflowBuffer * (maxOverflow / totalOverFlow);
    min -= overflowBuffer * (minOverflow / totalOverFlow);
    return {
      min: min,
      max: max
    };
  }

  function niceScaleExtent(scale, model) {
    var extentInfo = getScaleExtent(scale, model);
    var extent = extentInfo.extent;
    var splitNumber = model.get('splitNumber');

    if (scale.type === 'log') {
      scale.base = model.get('logBase');
    }

    var scaleType = scale.type;
    scale.setExtent(extent[0], extent[1]);
    scale.niceExtent({
      splitNumber: splitNumber,
      fixMin: extentInfo.fixMin,
      fixMax: extentInfo.fixMax,
      minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,
      maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null
    }); // If some one specified the min, max. And the default calculated interval
    // is not good enough. He can specify the interval. It is often appeared
    // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
    // to be 60.
    // FIXME

    var interval = model.get('interval');

    if (interval != null) {
      scale.setInterval && scale.setInterval(interval);
    }
  }
  /**
   * @param {module:echarts/model/Model} model
   * @param {string} [axisType] Default retrieve from model.type
   * @return {module:echarts/scale/*}
   */


  function createScaleByModel(model, axisType) {
    axisType = axisType || model.get('type');

    if (axisType) {
      switch (axisType) {
        // Buildin scale
        case 'category':
          return new Ordinal(model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(), [Infinity, -Infinity]);

        case 'value':
          return new Interval();
        // Extended scale, like time and log

        default:
          return (Scale_1.getClass(axisType) || Interval).create(model);
      }
    }
  }
  /**
   * Check if the axis corss 0
   */


  function ifAxisCrossZero(axis) {
    var dataExtent = axis.scale.getExtent();
    var min = dataExtent[0];
    var max = dataExtent[1];
    return !(min > 0 && max > 0 || min < 0 && max < 0);
  }
  /**
   * @param {module:echarts/coord/Axis} axis
   * @return {Function} Label formatter function.
   *         param: {number} tickValue,
   *         param: {number} idx, the index in all ticks.
   *                         If category axis, this param is not requied.
   *         return: {string} label string.
   */


  function makeLabelFormatter(axis) {
    var labelFormatter = axis.getLabelModel().get('formatter');
    var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;

    if (typeof labelFormatter === 'string') {
      labelFormatter = function (tpl) {
        return function (val) {
          // For category axis, get raw value; for numeric axis,
          // get foramtted label like '1,333,444'.
          val = axis.scale.getLabel(val);
          return tpl.replace('{value}', val != null ? val : '');
        };
      }(labelFormatter); // Consider empty array


      return labelFormatter;
    } else if (typeof labelFormatter === 'function') {
      return function (tickValue, idx) {
        // The original intention of `idx` is "the index of the tick in all ticks".
        // But the previous implementation of category axis do not consider the
        // `axisLabel.interval`, which cause that, for example, the `interval` is
        // `1`, then the ticks "name5", "name7", "name9" are displayed, where the
        // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep
        // the definition here for back compatibility.
        if (categoryTickStart != null) {
          idx = tickValue - categoryTickStart;
        }

        return labelFormatter(getAxisRawValue(axis, tickValue), idx);
      };
    } else {
      return function (tick) {
        return axis.scale.getLabel(tick);
      };
    }
  }

  function getAxisRawValue(axis, value) {
    // In category axis with data zoom, tick is not the original
    // index of axis.data. So tick should not be exposed to user
    // in category axis.
    return axis.type === 'category' ? axis.scale.getLabel(value) : value;
  }
  /**
   * @param {module:echarts/coord/Axis} axis
   * @return {module:zrender/core/BoundingRect} Be null/undefined if no labels.
   */


  function estimateLabelUnionRect(axis) {
    var axisModel = axis.model;
    var scale = axis.scale;

    if (!axisModel.get('axisLabel.show') || scale.isBlank()) {
      return;
    }

    var isCategory = axis.type === 'category';
    var realNumberScaleTicks;
    var tickCount;
    var categoryScaleExtent = scale.getExtent(); // Optimize for large category data, avoid call `getTicks()`.

    if (isCategory) {
      tickCount = scale.count();
    } else {
      realNumberScaleTicks = scale.getTicks();
      tickCount = realNumberScaleTicks.length;
    }

    var axisLabelModel = axis.getLabelModel();
    var labelFormatter = makeLabelFormatter(axis);
    var rect;
    var step = 1; // Simple optimization for large amount of labels

    if (tickCount > 40) {
      step = Math.ceil(tickCount / 40);
    }

    for (var i = 0; i < tickCount; i += step) {
      var tickValue = realNumberScaleTicks ? realNumberScaleTicks[i] : categoryScaleExtent[0] + i;
      var label = labelFormatter(tickValue);
      var unrotatedSingleRect = axisLabelModel.getTextRect(label);
      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);
      rect ? rect.union(singleRect) : rect = singleRect;
    }

    return rect;
  }

  function rotateTextRect(textRect, rotate) {
    var rotateRadians = rotate * Math.PI / 180;
    var boundingBox = textRect.plain();
    var beforeWidth = boundingBox.width;
    var beforeHeight = boundingBox.height;
    var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
    var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
    var rotatedRect = new BoundingRect_1(boundingBox.x, boundingBox.y, afterWidth, afterHeight);
    return rotatedRect;
  }
  /**
   * @param {module:echarts/src/model/Model} model axisLabelModel or axisTickModel
   * @return {number|String} Can be null|'auto'|number|function
   */


  function getOptionCategoryInterval(model) {
    var interval = model.get('interval');
    return interval == null ? 'auto' : interval;
  }
  /**
   * Set `categoryInterval` as 0 implicitly indicates that
   * show all labels reguardless of overlap.
   * @param {Object} axis axisModel.axis
   * @return {boolean}
   */


  function shouldShowAllLabels(axis) {
    return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;
  }

  var getScaleExtent_1 = getScaleExtent;
  var niceScaleExtent_1 = niceScaleExtent;
  var createScaleByModel_1 = createScaleByModel;
  var ifAxisCrossZero_1 = ifAxisCrossZero;
  var makeLabelFormatter_1 = makeLabelFormatter;
  var getAxisRawValue_1 = getAxisRawValue;
  var estimateLabelUnionRect_1 = estimateLabelUnionRect;
  var getOptionCategoryInterval_1 = getOptionCategoryInterval;
  var shouldShowAllLabels_1 = shouldShowAllLabels;

  var axisHelper = {
  	getScaleExtent: getScaleExtent_1,
  	niceScaleExtent: niceScaleExtent_1,
  	createScaleByModel: createScaleByModel_1,
  	ifAxisCrossZero: ifAxisCrossZero_1,
  	makeLabelFormatter: makeLabelFormatter_1,
  	getAxisRawValue: getAxisRawValue_1,
  	estimateLabelUnionRect: estimateLabelUnionRect_1,
  	getOptionCategoryInterval: getOptionCategoryInterval_1,
  	shouldShowAllLabels: shouldShowAllLabels_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // import * as axisHelper from './axisHelper';
  var _default$1s = {
    /**
     * @param {boolean} origin
     * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN
     */
    getMin: function (origin) {
      var option = this.option;
      var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;

      if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !util.eqNaN(min)) {
        min = this.axis.scale.parse(min);
      }

      return min;
    },

    /**
     * @param {boolean} origin
     * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN
     */
    getMax: function (origin) {
      var option = this.option;
      var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;

      if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !util.eqNaN(max)) {
        max = this.axis.scale.parse(max);
      }

      return max;
    },

    /**
     * @return {boolean}
     */
    getNeedCrossZero: function () {
      var option = this.option;
      return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;
    },

    /**
     * Should be implemented by each axis model if necessary.
     * @return {module:echarts/model/Component} coordinate system model
     */
    getCoordSysModel: util.noop,

    /**
     * @param {number} rangeStart Can only be finite number or null/undefined or NaN.
     * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.
     */
    setRange: function (rangeStart, rangeEnd) {
      this.option.rangeStart = rangeStart;
      this.option.rangeEnd = rangeEnd;
    },

    /**
     * Reset range
     */
    resetRange: function () {
      // rangeStart and rangeEnd is readonly.
      this.option.rangeStart = this.option.rangeEnd = null;
    }
  };
  var axisModelCommonMixin = _default$1s;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  var calculateTextPosition$1 = text.calculateTextPosition;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Symbol factory

  /**
   * Triangle shape
   * @inner
   */
  var Triangle = graphic.extendShape({
    type: 'triangle',
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function (path, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path.moveTo(cx, cy - height);
      path.lineTo(cx + width, cy + height);
      path.lineTo(cx - width, cy + height);
      path.closePath();
    }
  });
  /**
   * Diamond shape
   * @inner
   */

  var Diamond = graphic.extendShape({
    type: 'diamond',
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function (path, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path.moveTo(cx, cy - height);
      path.lineTo(cx + width, cy);
      path.lineTo(cx, cy + height);
      path.lineTo(cx - width, cy);
      path.closePath();
    }
  });
  /**
   * Pin shape
   * @inner
   */

  var Pin = graphic.extendShape({
    type: 'pin',
    shape: {
      // x, y on the cusp
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function (path, shape) {
      var x = shape.x;
      var y = shape.y;
      var w = shape.width / 5 * 3; // Height must be larger than width

      var h = Math.max(w, shape.height);
      var r = w / 2; // Dist on y with tangent point and circle center

      var dy = r * r / (h - r);
      var cy = y - h + r + dy;
      var angle = Math.asin(dy / r); // Dist on x with tangent point and circle center

      var dx = Math.cos(angle) * r;
      var tanX = Math.sin(angle);
      var tanY = Math.cos(angle);
      var cpLen = r * 0.6;
      var cpLen2 = r * 0.7;
      path.moveTo(x - dx, cy + dy);
      path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
      path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
      path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
      path.closePath();
    }
  });
  /**
   * Arrow shape
   * @inner
   */

  var Arrow = graphic.extendShape({
    type: 'arrow',
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function (ctx, shape) {
      var height = shape.height;
      var width = shape.width;
      var x = shape.x;
      var y = shape.y;
      var dx = width / 3 * 2;
      ctx.moveTo(x, y);
      ctx.lineTo(x + dx, y + height);
      ctx.lineTo(x, y + height / 4 * 3);
      ctx.lineTo(x - dx, y + height);
      ctx.lineTo(x, y);
      ctx.closePath();
    }
  });
  /**
   * Map of path contructors
   * @type {Object.<string, module:zrender/graphic/Path>}
   */

  var symbolCtors = {
    line: graphic.Line,
    rect: graphic.Rect,
    roundRect: graphic.Rect,
    square: graphic.Rect,
    circle: graphic.Circle,
    diamond: Diamond,
    pin: Pin,
    arrow: Arrow,
    triangle: Triangle
  };
  var symbolShapeMakers = {
    line: function (x, y, w, h, shape) {
      // FIXME
      shape.x1 = x;
      shape.y1 = y + h / 2;
      shape.x2 = x + w;
      shape.y2 = y + h / 2;
    },
    rect: function (x, y, w, h, shape) {
      shape.x = x;
      shape.y = y;
      shape.width = w;
      shape.height = h;
    },
    roundRect: function (x, y, w, h, shape) {
      shape.x = x;
      shape.y = y;
      shape.width = w;
      shape.height = h;
      shape.r = Math.min(w, h) / 4;
    },
    square: function (x, y, w, h, shape) {
      var size = Math.min(w, h);
      shape.x = x;
      shape.y = y;
      shape.width = size;
      shape.height = size;
    },
    circle: function (x, y, w, h, shape) {
      // Put circle in the center of square
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.r = Math.min(w, h) / 2;
    },
    diamond: function (x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    pin: function (x, y, w, h, shape) {
      shape.x = x + w / 2;
      shape.y = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    arrow: function (x, y, w, h, shape) {
      shape.x = x + w / 2;
      shape.y = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    triangle: function (x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.width = w;
      shape.height = h;
    }
  };
  var symbolBuildProxies = {};
  util.each(symbolCtors, function (Ctor, name) {
    symbolBuildProxies[name] = new Ctor();
  });
  var SymbolClz = graphic.extendShape({
    type: 'symbol',
    shape: {
      symbolType: '',
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    calculateTextPosition: function (out, style, rect) {
      var res = calculateTextPosition$1(out, style, rect);
      var shape = this.shape;

      if (shape && shape.symbolType === 'pin' && style.textPosition === 'inside') {
        res.y = rect.y + rect.height * 0.4;
      }

      return res;
    },
    buildPath: function (ctx, shape, inBundle) {
      var symbolType = shape.symbolType;

      if (symbolType !== 'none') {
        var proxySymbol = symbolBuildProxies[symbolType];

        if (!proxySymbol) {
          // Default rect
          symbolType = 'rect';
          proxySymbol = symbolBuildProxies[symbolType];
        }

        symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
        proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
      }
    }
  }); // Provide setColor helper method to avoid determine if set the fill or stroke outside

  function symbolPathSetColor(color, innerColor) {
    if (this.type !== 'image') {
      var symbolStyle = this.style;
      var symbolShape = this.shape;

      if (symbolShape && symbolShape.symbolType === 'line') {
        symbolStyle.stroke = color;
      } else if (this.__isEmptyBrush) {
        symbolStyle.stroke = color;
        symbolStyle.fill = innerColor || '#fff';
      } else {
        // FIXME å¤æ­å¾å½¢é»è®¤æ¯å¡«åè¿æ¯æè¾¹ï¼ä½¿ç¨ onlyStroke ?
        symbolStyle.fill && (symbolStyle.fill = color);
        symbolStyle.stroke && (symbolStyle.stroke = color);
      }

      this.dirty(false);
    }
  }
  /**
   * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
   * @param {string} symbolType
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {string} color
   * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,
   *                            for path and image only.
   */


  function createSymbol(symbolType, x, y, w, h, color, keepAspect) {
    // TODO Support image object, DynamicImage.
    var isEmpty = symbolType.indexOf('empty') === 0;

    if (isEmpty) {
      symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
    }

    var symbolPath;

    if (symbolType.indexOf('image://') === 0) {
      symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect_1(x, y, w, h), keepAspect ? 'center' : 'cover');
    } else if (symbolType.indexOf('path://') === 0) {
      symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect_1(x, y, w, h), keepAspect ? 'center' : 'cover');
    } else {
      symbolPath = new SymbolClz({
        shape: {
          symbolType: symbolType,
          x: x,
          y: y,
          width: w,
          height: h
        }
      });
    }

    symbolPath.__isEmptyBrush = isEmpty;
    symbolPath.setColor = symbolPathSetColor;
    symbolPath.setColor(color);
    return symbolPath;
  }

  var createSymbol_1 = createSymbol;

  var symbol = {
  	createSymbol: createSymbol_1
  };

  var getLayoutRect_1$1 = layout.getLayoutRect;



  var enableDataStack$2 = dataStackHelper.enableDataStack;
  var isDimensionStacked$2 = dataStackHelper.isDimensionStacked;
  var getStackedDimension$1 = dataStackHelper.getStackedDimension;



  var completeDimensions$1 = completeDimensions_1;



  var createDimensions$1 = createDimensions;



  var createSymbol$1 = symbol.createSymbol;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // import createGraphFromNodeEdge from './chart/helper/createGraphFromNodeEdge';

  /**
   * Create a muti dimension List structure from seriesModel.
   * @param  {module:echarts/model/Model} seriesModel
   * @return {module:echarts/data/List} list
   */
  function createList(seriesModel) {
    return createListFromArray_1(seriesModel.getSource(), seriesModel);
  } // export function createGraph(seriesModel) {
  //     var nodes = seriesModel.get('data');
  //     var links = seriesModel.get('links');
  //     return createGraphFromNodeEdge(nodes, links, seriesModel);
  // }


  var dataStack$1 = {
    isDimensionStacked: isDimensionStacked$2,
    enableDataStack: enableDataStack$2,
    getStackedDimension: getStackedDimension$1
  };
  /**
   * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
   * @param {string} symbolDesc
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {string} color
   */

  /**
   * Create scale
   * @param {Array.<number>} dataExtent
   * @param {Object|module:echarts/Model} option
   */
  function createScale(dataExtent, option) {
    var axisModel = option;

    if (!Model_1.isInstance(option)) {
      axisModel = new Model_1(option);
      util.mixin(axisModel, axisModelCommonMixin);
    }

    var scale = axisHelper.createScaleByModel(axisModel);
    scale.setExtent(dataExtent[0], dataExtent[1]);
    axisHelper.niceScaleExtent(scale, axisModel);
    return scale;
  }
  /**
   * Mixin common methods to axis model,
   *
   * Inlcude methods
   * `getFormattedLabels() => Array.<string>`
   * `getCategories() => Array.<string>`
   * `getMin(origin: boolean) => number`
   * `getMax(origin: boolean) => number`
   * `getNeedCrossZero() => boolean`
   * `setRange(start: number, end: number)`
   * `resetRange()`
   */


  function mixinAxisModelCommonMethods(Model) {
    util.mixin(Model, axisModelCommonMixin);
  }

  var createList_1 = createList;
  var dataStack_1 = dataStack$1;
  var createScale_1 = createScale;
  var mixinAxisModelCommonMethods_1 = mixinAxisModelCommonMethods;

  var helper$1 = {
  	getLayoutRect: getLayoutRect_1$1,
  	completeDimensions: completeDimensions$1,
  	createDimensions: createDimensions$1,
  	createSymbol: createSymbol$1,
  	createList: createList_1,
  	dataStack: dataStack_1,
  	createScale: createScale_1,
  	mixinAxisModelCommonMethods: mixinAxisModelCommonMethods_1
  };

  var EPSILON$3 = 1e-8;

  function isAroundEqual$1(a, b) {
    return Math.abs(a - b) < EPSILON$3;
  }

  function contain$1(points, x, y) {
    var w = 0;
    var p = points[0];

    if (!p) {
      return false;
    }

    for (var i = 1; i < points.length; i++) {
      var p2 = points[i];
      w += windingLine_1(p[0], p[1], p2[0], p2[1], x, y);
      p = p2;
    } // Close polygon


    var p0 = points[0];

    if (!isAroundEqual$1(p[0], p0[0]) || !isAroundEqual$1(p[1], p0[1])) {
      w += windingLine_1(p[0], p[1], p0[0], p0[1], x, y);
    }

    return w !== 0;
  }

  var contain_1$1 = contain$1;

  var polygon = {
  	contain: contain_1$1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @module echarts/coord/geo/Region
   */

  /**
   * @param {string|Region} name
   * @param {Array} geometries
   * @param {Array.<number>} cp
   */
  function Region(name, geometries, cp) {
    /**
     * @type {string}
     * @readOnly
     */
    this.name = name;
    /**
     * @type {Array.<Array>}
     * @readOnly
     */

    this.geometries = geometries;

    if (!cp) {
      var rect = this.getBoundingRect();
      cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    } else {
      cp = [cp[0], cp[1]];
    }
    /**
     * @type {Array.<number>}
     */


    this.center = cp;
  }

  Region.prototype = {
    constructor: Region,
    properties: null,

    /**
     * @return {module:zrender/core/BoundingRect}
     */
    getBoundingRect: function () {
      var rect = this._rect;

      if (rect) {
        return rect;
      }

      var MAX_NUMBER = Number.MAX_VALUE;
      var min = [MAX_NUMBER, MAX_NUMBER];
      var max = [-MAX_NUMBER, -MAX_NUMBER];
      var min2 = [];
      var max2 = [];
      var geometries = this.geometries;

      for (var i = 0; i < geometries.length; i++) {
        // Only support polygon
        if (geometries[i].type !== 'polygon') {
          continue;
        } // Doesn't consider hole


        var exterior = geometries[i].exterior;
        bbox.fromPoints(exterior, min2, max2);
        vector.min(min, min, min2);
        vector.max(max, max, max2);
      } // No data


      if (i === 0) {
        min[0] = min[1] = max[0] = max[1] = 0;
      }

      return this._rect = new BoundingRect_1(min[0], min[1], max[0] - min[0], max[1] - min[1]);
    },

    /**
     * @param {<Array.<number>} coord
     * @return {boolean}
     */
    contain: function (coord) {
      var rect = this.getBoundingRect();
      var geometries = this.geometries;

      if (!rect.contain(coord[0], coord[1])) {
        return false;
      }

      loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {
        // Only support polygon.
        if (geometries[i].type !== 'polygon') {
          continue;
        }

        var exterior = geometries[i].exterior;
        var interiors = geometries[i].interiors;

        if (polygon.contain(exterior, coord[0], coord[1])) {
          // Not in the region if point is in the hole.
          for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
            if (polygon.contain(interiors[k])) {
              continue loopGeo;
            }
          }

          return true;
        }
      }

      return false;
    },
    transformTo: function (x, y, width, height) {
      var rect = this.getBoundingRect();
      var aspect = rect.width / rect.height;

      if (!width) {
        width = aspect * height;
      } else if (!height) {
        height = width / aspect;
      }

      var target = new BoundingRect_1(x, y, width, height);
      var transform = rect.calculateTransform(target);
      var geometries = this.geometries;

      for (var i = 0; i < geometries.length; i++) {
        // Only support polygon.
        if (geometries[i].type !== 'polygon') {
          continue;
        }

        var exterior = geometries[i].exterior;
        var interiors = geometries[i].interiors;

        for (var p = 0; p < exterior.length; p++) {
          vector.applyTransform(exterior[p], exterior[p], transform);
        }

        for (var h = 0; h < (interiors ? interiors.length : 0); h++) {
          for (var p = 0; p < interiors[h].length; p++) {
            vector.applyTransform(interiors[h][p], interiors[h][p], transform);
          }
        }
      }

      rect = this._rect;
      rect.copy(target); // Update center

      this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    },
    cloneShallow: function (name) {
      name == null && (name = this.name);
      var newRegion = new Region(name, this.geometries, this.center);
      newRegion._rect = this._rect;
      newRegion.transformTo = null; // Simply avoid to be called.

      return newRegion;
    }
  };
  var _default$1t = Region;
  var Region_1 = _default$1t;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Parse and decode geo json
   * @module echarts/coord/geo/parseGeoJson
   */
  function decode(json) {
    if (!json.UTF8Encoding) {
      return json;
    }

    var encodeScale = json.UTF8Scale;

    if (encodeScale == null) {
      encodeScale = 1024;
    }

    var features = json.features;

    for (var f = 0; f < features.length; f++) {
      var feature = features[f];
      var geometry = feature.geometry;
      var coordinates = geometry.coordinates;
      var encodeOffsets = geometry.encodeOffsets;

      for (var c = 0; c < coordinates.length; c++) {
        var coordinate = coordinates[c];

        if (geometry.type === 'Polygon') {
          coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);
        } else if (geometry.type === 'MultiPolygon') {
          for (var c2 = 0; c2 < coordinate.length; c2++) {
            var polygon = coordinate[c2];
            coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);
          }
        }
      }
    } // Has been decoded


    json.UTF8Encoding = false;
    return json;
  }

  function decodePolygon(coordinate, encodeOffsets, encodeScale) {
    var result = [];
    var prevX = encodeOffsets[0];
    var prevY = encodeOffsets[1];

    for (var i = 0; i < coordinate.length; i += 2) {
      var x = coordinate.charCodeAt(i) - 64;
      var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding

      x = x >> 1 ^ -(x & 1);
      y = y >> 1 ^ -(y & 1); // Delta deocding

      x += prevX;
      y += prevY;
      prevX = x;
      prevY = y; // Dequantize

      result.push([x / encodeScale, y / encodeScale]);
    }

    return result;
  }
  /**
   * @alias module:echarts/coord/geo/parseGeoJson
   * @param {Object} geoJson
   * @param {string} nameProperty
   * @return {module:zrender/container/Group}
   */


  function _default$1u(geoJson, nameProperty) {
    decode(geoJson);
    return util.map(util.filter(geoJson.features, function (featureObj) {
      // Output of mapshaper may have geometry null
      return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
    }), function (featureObj) {
      var properties = featureObj.properties;
      var geo = featureObj.geometry;
      var coordinates = geo.coordinates;
      var geometries = [];

      if (geo.type === 'Polygon') {
        geometries.push({
          type: 'polygon',
          // According to the GeoJSON specification.
          // First must be exterior, and the rest are all interior(holes).
          exterior: coordinates[0],
          interiors: coordinates.slice(1)
        });
      }

      if (geo.type === 'MultiPolygon') {
        util.each(coordinates, function (item) {
          if (item[0]) {
            geometries.push({
              type: 'polygon',
              exterior: item[0],
              interiors: item.slice(1)
            });
          }
        });
      }

      var region = new Region_1(properties[nameProperty || 'name'], geometries, properties.cp);
      region.properties = properties;
      return region;
    });
  }

  var parseGeoJson = _default$1u;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  var makeInner$6 = model.makeInner;



  var makeLabelFormatter$1 = axisHelper.makeLabelFormatter;
  var getOptionCategoryInterval$1 = axisHelper.getOptionCategoryInterval;
  var shouldShowAllLabels$1 = axisHelper.shouldShowAllLabels;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var inner$6 = makeInner$6();
  /**
   * @param {module:echats/coord/Axis} axis
   * @return {Object} {
   *     labels: [{
   *         formattedLabel: string,
   *         rawLabel: string,
   *         tickValue: number
   *     }, ...],
   *     labelCategoryInterval: number
   * }
   */

  function createAxisLabels(axis) {
    // Only ordinal scale support tick interval
    return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
  }
  /**
   * @param {module:echats/coord/Axis} axis
   * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.
   * @return {Object} {
   *     ticks: Array.<number>
   *     tickCategoryInterval: number
   * }
   */


  function createAxisTicks(axis, tickModel) {
    // Only ordinal scale support tick interval
    return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {
      ticks: axis.scale.getTicks()
    };
  }

  function makeCategoryLabels(axis) {
    var labelModel = axis.getLabelModel();
    var result = makeCategoryLabelsActually(axis, labelModel);
    return !labelModel.get('show') || axis.scale.isBlank() ? {
      labels: [],
      labelCategoryInterval: result.labelCategoryInterval
    } : result;
  }

  function makeCategoryLabelsActually(axis, labelModel) {
    var labelsCache = getListCache(axis, 'labels');
    var optionLabelInterval = getOptionCategoryInterval$1(labelModel);
    var result = listCacheGet(labelsCache, optionLabelInterval);

    if (result) {
      return result;
    }

    var labels;
    var numericLabelInterval;

    if (util.isFunction(optionLabelInterval)) {
      labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
    } else {
      numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;
      labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
    } // Cache to avoid calling interval function repeatly.


    return listCacheSet(labelsCache, optionLabelInterval, {
      labels: labels,
      labelCategoryInterval: numericLabelInterval
    });
  }

  function makeCategoryTicks(axis, tickModel) {
    var ticksCache = getListCache(axis, 'ticks');
    var optionTickInterval = getOptionCategoryInterval$1(tickModel);
    var result = listCacheGet(ticksCache, optionTickInterval);

    if (result) {
      return result;
    }

    var ticks;
    var tickCategoryInterval; // Optimize for the case that large category data and no label displayed,
    // we should not return all ticks.

    if (!tickModel.get('show') || axis.scale.isBlank()) {
      ticks = [];
    }

    if (util.isFunction(optionTickInterval)) {
      ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
    } // Always use label interval by default despite label show. Consider this
    // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows
    // labels. `splitLine` and `axisTick` should be consistent in this case.
    else if (optionTickInterval === 'auto') {
        var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
        tickCategoryInterval = labelsResult.labelCategoryInterval;
        ticks = util.map(labelsResult.labels, function (labelItem) {
          return labelItem.tickValue;
        });
      } else {
        tickCategoryInterval = optionTickInterval;
        ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
      } // Cache to avoid calling interval function repeatly.


    return listCacheSet(ticksCache, optionTickInterval, {
      ticks: ticks,
      tickCategoryInterval: tickCategoryInterval
    });
  }

  function makeRealNumberLabels(axis) {
    var ticks = axis.scale.getTicks();
    var labelFormatter = makeLabelFormatter$1(axis);
    return {
      labels: util.map(ticks, function (tickValue, idx) {
        return {
          formattedLabel: labelFormatter(tickValue, idx),
          rawLabel: axis.scale.getLabel(tickValue),
          tickValue: tickValue
        };
      })
    };
  } // Large category data calculation is performence sensitive, and ticks and label
  // probably be fetched by multiple times. So we cache the result.
  // axis is created each time during a ec process, so we do not need to clear cache.


  function getListCache(axis, prop) {
    // Because key can be funciton, and cache size always be small, we use array cache.
    return inner$6(axis)[prop] || (inner$6(axis)[prop] = []);
  }

  function listCacheGet(cache, key) {
    for (var i = 0; i < cache.length; i++) {
      if (cache[i].key === key) {
        return cache[i].value;
      }
    }
  }

  function listCacheSet(cache, key, value) {
    cache.push({
      key: key,
      value: value
    });
    return value;
  }

  function makeAutoCategoryInterval(axis) {
    var result = inner$6(axis).autoInterval;
    return result != null ? result : inner$6(axis).autoInterval = axis.calculateCategoryInterval();
  }
  /**
   * Calculate interval for category axis ticks and labels.
   * To get precise result, at least one of `getRotate` and `isHorizontal`
   * should be implemented in axis.
   */


  function calculateCategoryInterval(axis) {
    var params = fetchAutoCategoryIntervalCalculationParams(axis);
    var labelFormatter = makeLabelFormatter$1(axis);
    var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:
    // avoid generating a long array by `getTicks`
    // in large category data case.

    var tickCount = ordinalScale.count();

    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }

    var step = 1; // Simple optimization. Empirical value: tick count should less than 40.

    if (tickCount > 40) {
      step = Math.max(1, Math.floor(tickCount / 40));
    }

    var tickValue = ordinalExtent[0];
    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
    var unitW = Math.abs(unitSpan * Math.cos(rotation));
    var unitH = Math.abs(unitSpan * Math.sin(rotation));
    var maxW = 0;
    var maxH = 0; // Caution: Performance sensitive for large category data.
    // Consider dataZoom, we should make appropriate step to avoid O(n) loop.

    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      var width = 0;
      var height = 0; // Not precise, do not consider align and vertical align
      // and each distance from axis line yet.

      var rect = text.getBoundingRect(labelFormatter(tickValue), params.font, 'center', 'top'); // Magic number

      width = rect.width * 1.3;
      height = rect.height * 1.3; // Min size, void long loop.

      maxW = Math.max(maxW, width, 7);
      maxH = Math.max(maxH, height, 7);
    }

    var dw = maxW / unitW;
    var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.

    isNaN(dw) && (dw = Infinity);
    isNaN(dh) && (dh = Infinity);
    var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
    var cache = inner$6(axis.model);
    var axisExtent = axis.getExtent();
    var lastAutoInterval = cache.lastAutoInterval;
    var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,
    // otherwise the calculated interval might jitter when the zoom
    // window size is close to the interval-changing size.
    // For example, if all of the axis labels are `a, b, c, d, e, f, g`.
    // The jitter will cause that sometimes the displayed labels are
    // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).

    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical
    // point is not the same when zooming in or zooming out.
    && lastAutoInterval > interval // If the axis change is caused by chart resize, the cache should not
    // be used. Otherwise some hiden labels might not be shown again.
    && cache.axisExtend0 === axisExtent[0] && cache.axisExtend1 === axisExtent[1]) {
      interval = lastAutoInterval;
    } // Only update cache if cache not used, otherwise the
    // changing of interval is too insensitive.
    else {
        cache.lastTickCount = tickCount;
        cache.lastAutoInterval = interval;
        cache.axisExtend0 = axisExtent[0];
        cache.axisExtend1 = axisExtent[1];
      }

    return interval;
  }

  function fetchAutoCategoryIntervalCalculationParams(axis) {
    var labelModel = axis.getLabelModel();
    return {
      axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
      labelRotate: labelModel.get('rotate') || 0,
      font: labelModel.getFont()
    };
  }

  function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
    var labelFormatter = makeLabelFormatter$1(axis);
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var labelModel = axis.getLabelModel();
    var result = []; // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...

    var step = Math.max((categoryInterval || 0) + 1, 1);
    var startTick = ordinalExtent[0];
    var tickCount = ordinalScale.count(); // Calculate start tick based on zero if possible to keep label consistent
    // while zooming and moving while interval > 0. Otherwise the selection
    // of displayable ticks and symbols probably keep changing.
    // 3 is empirical value.

    if (startTick !== 0 && step > 1 && tickCount / step > 2) {
      startTick = Math.round(Math.ceil(startTick / step) * step);
    } // (1) Only add min max label here but leave overlap checking
    // to render stage, which also ensure the returned list
    // suitable for splitLine and splitArea rendering.
    // (2) Scales except category always contain min max label so
    // do not need to perform this process.


    var showAllLabel = shouldShowAllLabels$1(axis);
    var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;
    var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;

    if (includeMinLabel && startTick !== ordinalExtent[0]) {
      addItem(ordinalExtent[0]);
    } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.


    var tickValue = startTick;

    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      addItem(tickValue);
    }

    if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
      addItem(ordinalExtent[1]);
    }

    function addItem(tVal) {
      result.push(onlyTick ? tVal : {
        formattedLabel: labelFormatter(tVal),
        rawLabel: ordinalScale.getLabel(tVal),
        tickValue: tVal
      });
    }

    return result;
  } // When interval is function, the result `false` means ignore the tick.
  // It is time consuming for large category data.


  function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
    var ordinalScale = axis.scale;
    var labelFormatter = makeLabelFormatter$1(axis);
    var result = [];
    util.each(ordinalScale.getTicks(), function (tickValue) {
      var rawLabel = ordinalScale.getLabel(tickValue);

      if (categoryInterval(tickValue, rawLabel)) {
        result.push(onlyTick ? tickValue : {
          formattedLabel: labelFormatter(tickValue),
          rawLabel: rawLabel,
          tickValue: tickValue
        });
      }
    });
    return result;
  }

  var createAxisLabels_1 = createAxisLabels;
  var createAxisTicks_1 = createAxisTicks;
  var calculateCategoryInterval_1 = calculateCategoryInterval;

  var axisTickLabelBuilder = {
  	createAxisLabels: createAxisLabels_1,
  	createAxisTicks: createAxisTicks_1,
  	calculateCategoryInterval: calculateCategoryInterval_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var each$j = util.each;
  var map$6 = util.map;



  var linearMap$1 = number.linearMap;
  var getPixelPrecision$1 = number.getPixelPrecision;
  var round$2 = number.round;



  var createAxisTicks$1 = axisTickLabelBuilder.createAxisTicks;
  var createAxisLabels$1 = axisTickLabelBuilder.createAxisLabels;
  var calculateCategoryInterval$1 = axisTickLabelBuilder.calculateCategoryInterval;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var NORMALIZED_EXTENT = [0, 1];
  /**
   * Base class of Axis.
   * @constructor
   */

  var Axis = function (dim, scale, extent) {
    /**
     * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'.
     * @type {string}
     */
    this.dim = dim;
    /**
     * Axis scale
     * @type {module:echarts/coord/scale/*}
     */

    this.scale = scale;
    /**
     * @type {Array.<number>}
     * @private
     */

    this._extent = extent || [0, 0];
    /**
     * @type {boolean}
     */

    this.inverse = false;
    /**
     * Usually true when axis has a ordinal scale
     * @type {boolean}
     */

    this.onBand = false;
  };

  Axis.prototype = {
    constructor: Axis,

    /**
     * If axis extent contain given coord
     * @param {number} coord
     * @return {boolean}
     */
    contain: function (coord) {
      var extent = this._extent;
      var min = Math.min(extent[0], extent[1]);
      var max = Math.max(extent[0], extent[1]);
      return coord >= min && coord <= max;
    },

    /**
     * If axis extent contain given data
     * @param {number} data
     * @return {boolean}
     */
    containData: function (data) {
      return this.scale.contain(data);
    },

    /**
     * Get coord extent.
     * @return {Array.<number>}
     */
    getExtent: function () {
      return this._extent.slice();
    },

    /**
     * Get precision used for formatting
     * @param {Array.<number>} [dataExtent]
     * @return {number}
     */
    getPixelPrecision: function (dataExtent) {
      return getPixelPrecision$1(dataExtent || this.scale.getExtent(), this._extent);
    },

    /**
     * Set coord extent
     * @param {number} start
     * @param {number} end
     */
    setExtent: function (start, end) {
      var extent = this._extent;
      extent[0] = start;
      extent[1] = end;
    },

    /**
     * Convert data to coord. Data is the rank if it has an ordinal scale
     * @param {number} data
     * @param  {boolean} clamp
     * @return {number}
     */
    dataToCoord: function (data, clamp) {
      var extent = this._extent;
      var scale = this.scale;
      data = scale.normalize(data);

      if (this.onBand && scale.type === 'ordinal') {
        extent = extent.slice();
        fixExtentWithBands(extent, scale.count());
      }

      return linearMap$1(data, NORMALIZED_EXTENT, extent, clamp);
    },

    /**
     * Convert coord to data. Data is the rank if it has an ordinal scale
     * @param {number} coord
     * @param  {boolean} clamp
     * @return {number}
     */
    coordToData: function (coord, clamp) {
      var extent = this._extent;
      var scale = this.scale;

      if (this.onBand && scale.type === 'ordinal') {
        extent = extent.slice();
        fixExtentWithBands(extent, scale.count());
      }

      var t = linearMap$1(coord, extent, NORMALIZED_EXTENT, clamp);
      return this.scale.scale(t);
    },

    /**
     * Convert pixel point to data in axis
     * @param {Array.<number>} point
     * @param  {boolean} clamp
     * @return {number} data
     */
    pointToData: function (point, clamp) {// Should be implemented in derived class if necessary.
    },

    /**
     * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
     * `axis.getTicksCoords` considers `onBand`, which is used by
     * `boundaryGap:true` of category axis and splitLine and splitArea.
     * @param {Object} [opt]
     * @param {Model} [opt.tickModel=axis.model.getModel('axisTick')]
     * @param {boolean} [opt.clamp] If `true`, the first and the last
     *        tick must be at the axis end points. Otherwise, clip ticks
     *        that outside the axis extent.
     * @return {Array.<Object>} [{
     *     coord: ...,
     *     tickValue: ...
     * }, ...]
     */
    getTicksCoords: function (opt) {
      opt = opt || {};
      var tickModel = opt.tickModel || this.getTickModel();
      var result = createAxisTicks$1(this, tickModel);
      var ticks = result.ticks;
      var ticksCoords = map$6(ticks, function (tickValue) {
        return {
          coord: this.dataToCoord(tickValue),
          tickValue: tickValue
        };
      }, this);
      var alignWithLabel = tickModel.get('alignWithLabel');
      fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
      return ticksCoords;
    },

    /**
     * @return {Array.<Array.<Object>>} [{ coord: ..., tickValue: ...}]
     */
    getMinorTicksCoords: function () {
      if (this.scale.type === 'ordinal') {
        // Category axis doesn't support minor ticks
        return [];
      }

      var minorTickModel = this.model.getModel('minorTick');
      var splitNumber = minorTickModel.get('splitNumber'); // Protection.

      if (!(splitNumber > 0 && splitNumber < 100)) {
        splitNumber = 5;
      }

      var minorTicks = this.scale.getMinorTicks(splitNumber);
      var minorTicksCoords = map$6(minorTicks, function (minorTicksGroup) {
        return map$6(minorTicksGroup, function (minorTick) {
          return {
            coord: this.dataToCoord(minorTick),
            tickValue: minorTick
          };
        }, this);
      }, this);
      return minorTicksCoords;
    },

    /**
     * @return {Array.<Object>} [{
     *     formattedLabel: string,
     *     rawLabel: axis.scale.getLabel(tickValue)
     *     tickValue: number
     * }, ...]
     */
    getViewLabels: function () {
      return createAxisLabels$1(this).labels;
    },

    /**
     * @return {module:echarts/coord/model/Model}
     */
    getLabelModel: function () {
      return this.model.getModel('axisLabel');
    },

    /**
     * Notice here we only get the default tick model. For splitLine
     * or splitArea, we should pass the splitLineModel or splitAreaModel
     * manually when calling `getTicksCoords`.
     * In GL, this method may be overrided to:
     * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
     * @return {module:echarts/coord/model/Model}
     */
    getTickModel: function () {
      return this.model.getModel('axisTick');
    },

    /**
     * Get width of band
     * @return {number}
     */
    getBandWidth: function () {
      var axisExtent = this._extent;
      var dataExtent = this.scale.getExtent();
      var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.

      len === 0 && (len = 1);
      var size = Math.abs(axisExtent[1] - axisExtent[0]);
      return Math.abs(size) / len;
    },

    /**
     * @abstract
     * @return {boolean} Is horizontal
     */
    isHorizontal: null,

    /**
     * @abstract
     * @return {number} Get axis rotate, by degree.
     */
    getRotate: null,

    /**
     * Only be called in category axis.
     * Can be overrided, consider other axes like in 3D.
     * @return {number} Auto interval for cateogry axis tick and label
     */
    calculateCategoryInterval: function () {
      return calculateCategoryInterval$1(this);
    }
  };

  function fixExtentWithBands(extent, nTick) {
    var size = extent[1] - extent[0];
    var len = nTick;
    var margin = size / len / 2;
    extent[0] += margin;
    extent[1] -= margin;
  } // If axis has labels [1, 2, 3, 4]. Bands on the axis are
  // |---1---|---2---|---3---|---4---|.
  // So the displayed ticks and splitLine/splitArea should between
  // each data item, otherwise cause misleading (e.g., split tow bars
  // of a single data item when there are two bar series).
  // Also consider if tickCategoryInterval > 0 and onBand, ticks and
  // splitLine/spliteArea should layout appropriately corresponding
  // to displayed labels. (So we should not use `getBandWidth` in this
  // case).


  function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {
    var ticksLen = ticksCoords.length;

    if (!axis.onBand || alignWithLabel || !ticksLen) {
      return;
    }

    var axisExtent = axis.getExtent();
    var last;
    var diffSize;

    if (ticksLen === 1) {
      ticksCoords[0].coord = axisExtent[0];
      last = ticksCoords[1] = {
        coord: axisExtent[0]
      };
    } else {
      var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
      var shift = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
      each$j(ticksCoords, function (ticksItem) {
        ticksItem.coord -= shift / 2;
      });
      var dataExtent = axis.scale.getExtent();
      diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
      last = {
        coord: ticksCoords[ticksLen - 1].coord + shift * diffSize
      };
      ticksCoords.push(last);
    }

    var inverse = axisExtent[0] > axisExtent[1]; // Handling clamp.

    if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
      clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
    }

    if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {
      ticksCoords.unshift({
        coord: axisExtent[0]
      });
    }

    if (littleThan(axisExtent[1], last.coord)) {
      clamp ? last.coord = axisExtent[1] : ticksCoords.pop();
    }

    if (clamp && littleThan(last.coord, axisExtent[1])) {
      ticksCoords.push({
        coord: axisExtent[1]
      });
    }

    function littleThan(a, b) {
      // Avoid rounding error cause calculated tick coord different with extent.
      // It may cause an extra unecessary tick added.
      a = round$2(a);
      b = round$2(b);
      return inverse ? a > b : a < b;
    }
  }

  var _default$1v = Axis;
  var Axis_1 = _default$1v;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var zrender_1 = zrender;



  var matrix_1 = matrix;



  var vector_1 = vector;





  var color$1 = color;





  var number$1 = number;



  var format$2 = format$1;
  var throttle_1$1 = throttle_1.throttle;



  var helper$2 = helper$1;



  var parseGeoJSON_1 = parseGeoJson;



  var List$1 = List_1;



  var Model$1 = Model_1;



  var Axis$1 = Axis_1;



  var env$1 = env_1;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Do not mount those modules on 'src/echarts' for better tree shaking.
   */
  var parseGeoJson$1 = parseGeoJson;
  var ecUtil = {};
  util.each(['map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults', 'clone', 'merge'], function (name) {
    ecUtil[name] = util[name];
  });
  var graphic$1 = {};
  util.each(['extendShape', 'extendPath', 'makePath', 'makeImage', 'mergePath', 'resizePath', 'createIcon', 'setHoverStyle', 'setLabelStyle', 'setTextStyle', 'setText', 'getFont', 'updateProps', 'initProps', 'getTransform', 'clipPointsByRect', 'clipRectByRect', 'registerShape', 'getShapeClass', 'Group', 'Image', 'Text', 'Circle', 'Sector', 'Ring', 'Polygon', 'Polyline', 'Rect', 'Line', 'BezierCurve', 'Arc', 'IncrementalDisplayable', 'CompoundPath', 'LinearGradient', 'RadialGradient', 'BoundingRect'], function (name) {
    graphic$1[name] = graphic[name];
  });
  var parseGeoJson_1 = parseGeoJson$1;
  var util$2 = ecUtil;
  var graphic_1 = graphic$1;

  var _export$1 = {
  	zrender: zrender_1,
  	matrix: matrix_1,
  	vector: vector_1,
  	color: color$1,
  	number: number$1,
  	format: format$2,
  	throttle: throttle_1$1,
  	helper: helper$2,
  	parseGeoJSON: parseGeoJSON_1,
  	List: List$1,
  	Model: Model$1,
  	Axis: Axis$1,
  	env: env$1,
  	parseGeoJson: parseGeoJson_1,
  	util: util$2,
  	graphic: graphic_1
  };

  var echarts = createCommonjsModule(function (module, exports) {







































  var throttle = throttle_1.throttle;

















  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var assert = util.assert;
  var each = util.each;
  var isFunction = util.isFunction;
  var isObject = util.isObject;
  var parseClassType = Component.parseClassType;
  var version = '4.9.0';
  var dependencies = {
    zrender: '4.3.2'
  };
  var TEST_FRAME_REMAIN_TIME = 1;
  var PRIORITY_PROCESSOR_FILTER = 1000;
  var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
  var PRIORITY_PROCESSOR_DATASTACK = 900;
  var PRIORITY_PROCESSOR_STATISTIC = 5000;
  var PRIORITY_VISUAL_LAYOUT = 1000;
  var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
  var PRIORITY_VISUAL_GLOBAL = 2000;
  var PRIORITY_VISUAL_CHART = 3000;
  var PRIORITY_VISUAL_POST_CHART_LAYOUT = 3500;
  var PRIORITY_VISUAL_COMPONENT = 4000; // FIXME
  // necessary?

  var PRIORITY_VISUAL_BRUSH = 5000;
  var PRIORITY = {
    PROCESSOR: {
      FILTER: PRIORITY_PROCESSOR_FILTER,
      SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
      STATISTIC: PRIORITY_PROCESSOR_STATISTIC
    },
    VISUAL: {
      LAYOUT: PRIORITY_VISUAL_LAYOUT,
      PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
      GLOBAL: PRIORITY_VISUAL_GLOBAL,
      CHART: PRIORITY_VISUAL_CHART,
      POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
      COMPONENT: PRIORITY_VISUAL_COMPONENT,
      BRUSH: PRIORITY_VISUAL_BRUSH
    }
  }; // Main process have three entries: `setOption`, `dispatchAction` and `resize`,
  // where they must not be invoked nestedly, except the only case: invoke
  // dispatchAction with updateMethod "none" in main process.
  // This flag is used to carry out this rule.
  // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).

  var IN_MAIN_PROCESS = '__flagInMainProcess';
  var OPTION_UPDATED = '__optionUpdated';
  var ACTION_REG = /^[a-zA-Z0-9_]+$/;

  function createRegisterEventWithLowercaseName(method, ignoreDisposed) {
    return function (eventName, handler, context) {
      if (!ignoreDisposed && this._disposed) {
        disposedWarning(this.id);
        return;
      } // Event name is all lowercase


      eventName = eventName && eventName.toLowerCase();
      Eventful_1.prototype[method].call(this, eventName, handler, context);
    };
  }
  /**
   * @module echarts~MessageCenter
   */


  function MessageCenter() {
    Eventful_1.call(this);
  }

  MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on', true);
  MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off', true);
  MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one', true);
  util.mixin(MessageCenter, Eventful_1);
  /**
   * @module echarts~ECharts
   */

  function ECharts(dom, theme, opts) {
    opts = opts || {}; // Get theme by name

    if (typeof theme === 'string') {
      theme = themeStorage[theme];
    }
    /**
     * @type {string}
     */


    this.id;
    /**
     * Group id
     * @type {string}
     */

    this.group;
    /**
     * @type {HTMLElement}
     * @private
     */

    this._dom = dom;
    var defaultRenderer = 'canvas';

    /**
     * @type {module:zrender/ZRender}
     * @private
     */
    var zr = this._zr = zrender.init(dom, {
      renderer: opts.renderer || defaultRenderer,
      devicePixelRatio: opts.devicePixelRatio,
      width: opts.width,
      height: opts.height
    });
    /**
     * Expect 60 fps.
     * @type {Function}
     * @private
     */

    this._throttledZrFlush = throttle(util.bind(zr.flush, zr), 17);
    var theme = util.clone(theme);
    theme && backwardCompat(theme, true);
    /**
     * @type {Object}
     * @private
     */

    this._theme = theme;
    /**
     * @type {Array.<module:echarts/view/Chart>}
     * @private
     */

    this._chartsViews = [];
    /**
     * @type {Object.<string, module:echarts/view/Chart>}
     * @private
     */

    this._chartsMap = {};
    /**
     * @type {Array.<module:echarts/view/Component>}
     * @private
     */

    this._componentsViews = [];
    /**
     * @type {Object.<string, module:echarts/view/Component>}
     * @private
     */

    this._componentsMap = {};
    /**
     * @type {module:echarts/CoordinateSystem}
     * @private
     */

    this._coordSysMgr = new CoordinateSystem();
    /**
     * @type {module:echarts/ExtensionAPI}
     * @private
     */

    var api = this._api = createExtensionAPI(this); // Sort on demand

    function prioritySortFunc(a, b) {
      return a.__prio - b.__prio;
    }

    timsort(visualFuncs, prioritySortFunc);
    timsort(dataProcessorFuncs, prioritySortFunc);
    /**
     * @type {module:echarts/stream/Scheduler}
     */

    this._scheduler = new Scheduler_1(this, api, dataProcessorFuncs, visualFuncs);
    Eventful_1.call(this, this._ecEventProcessor = new EventProcessor());
    /**
     * @type {module:echarts~MessageCenter}
     * @private
     */

    this._messageCenter = new MessageCenter(); // Init mouse events

    this._initEvents(); // In case some people write `window.onresize = chart.resize`


    this.resize = util.bind(this.resize, this); // Can't dispatch action during rendering procedure

    this._pendingActions = [];
    zr.animation.on('frame', this._onframe, this);
    bindRenderedEvent(zr, this); // ECharts instance can be used as value.

    util.setAsPrimitive(this);
  }

  var echartsProto = ECharts.prototype;

  echartsProto._onframe = function () {
    if (this._disposed) {
      return;
    }

    var scheduler = this._scheduler; // Lazy update

    if (this[OPTION_UPDATED]) {
      var silent = this[OPTION_UPDATED].silent;
      this[IN_MAIN_PROCESS] = true;
      prepare(this);
      updateMethods.update.call(this);
      this[IN_MAIN_PROCESS] = false;
      this[OPTION_UPDATED] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    } // Avoid do both lazy update and progress in one frame.
    else if (scheduler.unfinished) {
        // Stream progress.
        var remainTime = TEST_FRAME_REMAIN_TIME;
        var ecModel = this._model;
        var api = this._api;
        scheduler.unfinished = false;

        do {
          var startTime = +new Date();
          scheduler.performSeriesTasks(ecModel); // Currently dataProcessorFuncs do not check threshold.

          scheduler.performDataProcessorTasks(ecModel);
          updateStreamModes(this, ecModel); // Do not update coordinate system here. Because that coord system update in
          // each frame is not a good user experience. So we follow the rule that
          // the extent of the coordinate system is determin in the first frame (the
          // frame is executed immedietely after task reset.
          // this._coordSysMgr.update(ecModel, api);
          // console.log('--- ec frame visual ---', remainTime);

          scheduler.performVisualTasks(ecModel);
          renderSeries(this, this._model, api, 'remain');
          remainTime -= +new Date() - startTime;
        } while (remainTime > 0 && scheduler.unfinished); // Call flush explicitly for trigger finished event.


        if (!scheduler.unfinished) {
          this._zr.flush();
        } // Else, zr flushing be ensue within the same frame,
        // because zr flushing is after onframe event.

      }
  };
  /**
   * @return {HTMLElement}
   */


  echartsProto.getDom = function () {
    return this._dom;
  };
  /**
   * @return {module:zrender~ZRender}
   */


  echartsProto.getZr = function () {
    return this._zr;
  };
  /**
   * Usage:
   * chart.setOption(option, notMerge, lazyUpdate);
   * chart.setOption(option, {
   *     notMerge: ...,
   *     lazyUpdate: ...,
   *     silent: ...
   * });
   *
   * @param {Object} option
   * @param {Object|boolean} [opts] opts or notMerge.
   * @param {boolean} [opts.notMerge=false]
   * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.
   */


  echartsProto.setOption = function (option, notMerge, lazyUpdate) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    var silent;

    if (isObject(notMerge)) {
      lazyUpdate = notMerge.lazyUpdate;
      silent = notMerge.silent;
      notMerge = notMerge.notMerge;
    }

    this[IN_MAIN_PROCESS] = true;

    if (!this._model || notMerge) {
      var optionManager = new OptionManager_1(this._api);
      var theme = this._theme;
      var ecModel = this._model = new Global();
      ecModel.scheduler = this._scheduler;
      ecModel.init(null, null, theme, optionManager);
    }

    this._model.setOption(option, optionPreprocessorFuncs);

    if (lazyUpdate) {
      this[OPTION_UPDATED] = {
        silent: silent
      };
      this[IN_MAIN_PROCESS] = false;
    } else {
      prepare(this);
      updateMethods.update.call(this); // Ensure zr refresh sychronously, and then pixel in canvas can be
      // fetched after `setOption`.

      this._zr.flush();

      this[OPTION_UPDATED] = false;
      this[IN_MAIN_PROCESS] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    }
  };
  /**
   * @DEPRECATED
   */


  echartsProto.setTheme = function () {
    console.error('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
  };
  /**
   * @return {module:echarts/model/Global}
   */


  echartsProto.getModel = function () {
    return this._model;
  };
  /**
   * @return {Object}
   */


  echartsProto.getOption = function () {
    return this._model && this._model.getOption();
  };
  /**
   * @return {number}
   */


  echartsProto.getWidth = function () {
    return this._zr.getWidth();
  };
  /**
   * @return {number}
   */


  echartsProto.getHeight = function () {
    return this._zr.getHeight();
  };
  /**
   * @return {number}
   */


  echartsProto.getDevicePixelRatio = function () {
    return this._zr.painter.dpr || window.devicePixelRatio || 1;
  };
  /**
   * Get canvas which has all thing rendered
   * @param {Object} opts
   * @param {string} [opts.backgroundColor]
   * @return {string}
   */


  echartsProto.getRenderedCanvas = function (opts) {
    if (!env_1.canvasSupported) {
      return;
    }

    opts = opts || {};
    opts.pixelRatio = opts.pixelRatio || 1;
    opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');
    var zr = this._zr; // var list = zr.storage.getDisplayList();
    // Stop animations
    // Never works before in init animation, so remove it.
    // zrUtil.each(list, function (el) {
    //     el.stopAnimation(true);
    // });

    return zr.painter.getRenderedCanvas(opts);
  };
  /**
   * Get svg data url
   * @return {string}
   */


  echartsProto.getSvgDataURL = function () {
    if (!env_1.svgSupported) {
      return;
    }

    var zr = this._zr;
    var list = zr.storage.getDisplayList(); // Stop animations

    util.each(list, function (el) {
      el.stopAnimation(true);
    });
    return zr.painter.toDataURL();
  };
  /**
   * @return {string}
   * @param {Object} opts
   * @param {string} [opts.type='png']
   * @param {string} [opts.pixelRatio=1]
   * @param {string} [opts.backgroundColor]
   * @param {string} [opts.excludeComponents]
   */


  echartsProto.getDataURL = function (opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    opts = opts || {};
    var excludeComponents = opts.excludeComponents;
    var ecModel = this._model;
    var excludesComponentViews = [];
    var self = this;
    each(excludeComponents, function (componentType) {
      ecModel.eachComponent({
        mainType: componentType
      }, function (component) {
        var view = self._componentsMap[component.__viewId];

        if (!view.group.ignore) {
          excludesComponentViews.push(view);
          view.group.ignore = true;
        }
      });
    });
    var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataURL() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));
    each(excludesComponentViews, function (view) {
      view.group.ignore = false;
    });
    return url;
  };
  /**
   * @return {string}
   * @param {Object} opts
   * @param {string} [opts.type='png']
   * @param {string} [opts.pixelRatio=1]
   * @param {string} [opts.backgroundColor]
   */


  echartsProto.getConnectedDataURL = function (opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    if (!env_1.canvasSupported) {
      return;
    }

    var isSvg = opts.type === 'svg';
    var groupId = this.group;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var MAX_NUMBER = Infinity;

    if (connectedGroups[groupId]) {
      var left = MAX_NUMBER;
      var top = MAX_NUMBER;
      var right = -MAX_NUMBER;
      var bottom = -MAX_NUMBER;
      var canvasList = [];
      var dpr = opts && opts.pixelRatio || 1;
      util.each(instances, function (chart, id) {
        if (chart.group === groupId) {
          var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.getRenderedCanvas(util.clone(opts));
          var boundingRect = chart.getDom().getBoundingClientRect();
          left = mathMin(boundingRect.left, left);
          top = mathMin(boundingRect.top, top);
          right = mathMax(boundingRect.right, right);
          bottom = mathMax(boundingRect.bottom, bottom);
          canvasList.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      });
      left *= dpr;
      top *= dpr;
      right *= dpr;
      bottom *= dpr;
      var width = right - left;
      var height = bottom - top;
      var targetCanvas = util.createCanvas();
      var zr = zrender.init(targetCanvas, {
        renderer: isSvg ? 'svg' : 'canvas'
      });
      zr.resize({
        width: width,
        height: height
      });

      if (isSvg) {
        var content = '';
        each(canvasList, function (item) {
          var x = item.left - left;
          var y = item.top - top;
          content += '<g transform="translate(' + x + ',' + y + ')">' + item.dom + '</g>';
        });
        zr.painter.getSvgRoot().innerHTML = content;

        if (opts.connectedBackgroundColor) {
          zr.painter.setBackgroundColor(opts.connectedBackgroundColor);
        }

        zr.refreshImmediately();
        return zr.painter.toDataURL();
      } else {
        // Background between the charts
        if (opts.connectedBackgroundColor) {
          zr.add(new graphic.Rect({
            shape: {
              x: 0,
              y: 0,
              width: width,
              height: height
            },
            style: {
              fill: opts.connectedBackgroundColor
            }
          }));
        }

        each(canvasList, function (item) {
          var img = new graphic.Image({
            style: {
              x: item.left * dpr - left,
              y: item.top * dpr - top,
              image: item.dom
            }
          });
          zr.add(img);
        });
        zr.refreshImmediately();
        return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
      }
    } else {
      return this.getDataURL(opts);
    }
  };
  /**
   * Convert from logical coordinate system to pixel coordinate system.
   * See CoordinateSystem#convertToPixel.
   * @param {string|Object} finder
   *        If string, e.g., 'geo', means {geoIndex: 0}.
   *        If Object, could contain some of these properties below:
   *        {
   *            seriesIndex / seriesId / seriesName,
   *            geoIndex / geoId, geoName,
   *            bmapIndex / bmapId / bmapName,
   *            xAxisIndex / xAxisId / xAxisName,
   *            yAxisIndex / yAxisId / yAxisName,
   *            gridIndex / gridId / gridName,
   *            ... (can be extended)
   *        }
   * @param {Array|number} value
   * @return {Array|number} result
   */


  echartsProto.convertToPixel = util.curry(doConvertPixel, 'convertToPixel');
  /**
   * Convert from pixel coordinate system to logical coordinate system.
   * See CoordinateSystem#convertFromPixel.
   * @param {string|Object} finder
   *        If string, e.g., 'geo', means {geoIndex: 0}.
   *        If Object, could contain some of these properties below:
   *        {
   *            seriesIndex / seriesId / seriesName,
   *            geoIndex / geoId / geoName,
   *            bmapIndex / bmapId / bmapName,
   *            xAxisIndex / xAxisId / xAxisName,
   *            yAxisIndex / yAxisId / yAxisName
   *            gridIndex / gridId / gridName,
   *            ... (can be extended)
   *        }
   * @param {Array|number} value
   * @return {Array|number} result
   */

  echartsProto.convertFromPixel = util.curry(doConvertPixel, 'convertFromPixel');

  function doConvertPixel(methodName, finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    var ecModel = this._model;

    var coordSysList = this._coordSysMgr.getCoordinateSystems();

    var result;
    finder = model.parseFinder(ecModel, finder);

    for (var i = 0; i < coordSysList.length; i++) {
      var coordSys = coordSysList[i];

      if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {
        return result;
      }
    }
  }
  /**
   * Is the specified coordinate systems or components contain the given pixel point.
   * @param {string|Object} finder
   *        If string, e.g., 'geo', means {geoIndex: 0}.
   *        If Object, could contain some of these properties below:
   *        {
   *            seriesIndex / seriesId / seriesName,
   *            geoIndex / geoId / geoName,
   *            bmapIndex / bmapId / bmapName,
   *            xAxisIndex / xAxisId / xAxisName,
   *            yAxisIndex / yAxisId / yAxisName,
   *            gridIndex / gridId / gridName,
   *            ... (can be extended)
   *        }
   * @param {Array|number} value
   * @return {boolean} result
   */


  echartsProto.containPixel = function (finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    var ecModel = this._model;
    var result;
    finder = model.parseFinder(ecModel, finder);
    util.each(finder, function (models, key) {
      key.indexOf('Models') >= 0 && util.each(models, function (model) {
        var coordSys = model.coordinateSystem;

        if (coordSys && coordSys.containPoint) {
          result |= !!coordSys.containPoint(value);
        } else if (key === 'seriesModels') {
          var view = this._chartsMap[model.__viewId];

          if (view && view.containPoint) {
            result |= view.containPoint(value, model);
          }
        } else ;
      }, this);
    }, this);
    return !!result;
  };
  /**
   * Get visual from series or data.
   * @param {string|Object} finder
   *        If string, e.g., 'series', means {seriesIndex: 0}.
   *        If Object, could contain some of these properties below:
   *        {
   *            seriesIndex / seriesId / seriesName,
   *            dataIndex / dataIndexInside
   *        }
   *        If dataIndex is not specified, series visual will be fetched,
   *        but not data item visual.
   *        If all of seriesIndex, seriesId, seriesName are not specified,
   *        visual will be fetched from first series.
   * @param {string} visualType 'color', 'symbol', 'symbolSize'
   */


  echartsProto.getVisual = function (finder, visualType) {
    var ecModel = this._model;
    finder = model.parseFinder(ecModel, finder, {
      defaultMainType: 'series'
    });
    var seriesModel = finder.seriesModel;
    var data = seriesModel.getData();
    var dataIndexInside = finder.hasOwnProperty('dataIndexInside') ? finder.dataIndexInside : finder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(finder.dataIndex) : null;
    return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);
  };
  /**
   * Get view of corresponding component model
   * @param  {module:echarts/model/Component} componentModel
   * @return {module:echarts/view/Component}
   */


  echartsProto.getViewOfComponentModel = function (componentModel) {
    return this._componentsMap[componentModel.__viewId];
  };
  /**
   * Get view of corresponding series model
   * @param  {module:echarts/model/Series} seriesModel
   * @return {module:echarts/view/Chart}
   */


  echartsProto.getViewOfSeriesModel = function (seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
  };

  var updateMethods = {
    prepareAndUpdate: function (payload) {
      prepare(this);
      updateMethods.update.call(this, payload);
    },

    /**
     * @param {Object} payload
     * @private
     */
    update: function (payload) {
      // console.profile && console.profile('update');
      var ecModel = this._model;
      var api = this._api;
      var zr = this._zr;
      var coordSysMgr = this._coordSysMgr;
      var scheduler = this._scheduler; // update before setOption

      if (!ecModel) {
        return;
      }

      scheduler.restoreData(ecModel, payload);
      scheduler.performSeriesTasks(ecModel); // TODO
      // Save total ecModel here for undo/redo (after restoring data and before processing data).
      // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
      // Create new coordinate system each update
      // In LineView may save the old coordinate system and use it to get the orignal point

      coordSysMgr.create(ecModel, api);
      scheduler.performDataProcessorTasks(ecModel, payload); // Current stream render is not supported in data process. So we can update
      // stream modes after data processing, where the filtered data is used to
      // deteming whether use progressive rendering.

      updateStreamModes(this, ecModel); // We update stream modes before coordinate system updated, then the modes info
      // can be fetched when coord sys updating (consider the barGrid extent fix). But
      // the drawback is the full coord info can not be fetched. Fortunately this full
      // coord is not requied in stream mode updater currently.

      coordSysMgr.update(ecModel, api);
      clearColorPalette(ecModel);
      scheduler.performVisualTasks(ecModel, payload);
      render(this, ecModel, api, payload); // Set background

      var backgroundColor = ecModel.get('backgroundColor') || 'transparent'; // In IE8

      if (!env_1.canvasSupported) {
        var colorArr = color.parse(backgroundColor);
        backgroundColor = color.stringify(colorArr, 'rgb');

        if (colorArr[3] === 0) {
          backgroundColor = 'transparent';
        }
      } else {
        zr.setBackgroundColor(backgroundColor);
      }

      performPostUpdateFuncs(ecModel, api); // console.profile && console.profileEnd('update');
    },

    /**
     * @param {Object} payload
     * @private
     */
    updateTransform: function (payload) {
      var ecModel = this._model;
      var ecIns = this;
      var api = this._api; // update before setOption

      if (!ecModel) {
        return;
      } // ChartView.markUpdateMethod(payload, 'updateTransform');


      var componentDirtyList = [];
      ecModel.eachComponent(function (componentType, componentModel) {
        var componentView = ecIns.getViewOfComponentModel(componentModel);

        if (componentView && componentView.__alive) {
          if (componentView.updateTransform) {
            var result = componentView.updateTransform(componentModel, ecModel, api, payload);
            result && result.update && componentDirtyList.push(componentView);
          } else {
            componentDirtyList.push(componentView);
          }
        }
      });
      var seriesDirtyMap = util.createHashMap();
      ecModel.eachSeries(function (seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];

        if (chartView.updateTransform) {
          var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
          result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
        } else {
          seriesDirtyMap.set(seriesModel.uid, 1);
        }
      });
      clearColorPalette(ecModel); // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
      // this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);

      this._scheduler.performVisualTasks(ecModel, payload, {
        setDirty: true,
        dirtyMap: seriesDirtyMap
      }); // Currently, not call render of components. Geo render cost a lot.
      // renderComponents(ecIns, ecModel, api, payload, componentDirtyList);


      renderSeries(ecIns, ecModel, api, payload, seriesDirtyMap);
      performPostUpdateFuncs(ecModel, this._api);
    },

    /**
     * @param {Object} payload
     * @private
     */
    updateView: function (payload) {
      var ecModel = this._model; // update before setOption

      if (!ecModel) {
        return;
      }

      Chart_1.markUpdateMethod(payload, 'updateView');
      clearColorPalette(ecModel); // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.

      this._scheduler.performVisualTasks(ecModel, payload, {
        setDirty: true
      });

      render(this, this._model, this._api, payload);
      performPostUpdateFuncs(ecModel, this._api);
    },

    /**
     * @param {Object} payload
     * @private
     */
    updateVisual: function (payload) {
      updateMethods.update.call(this, payload); // var ecModel = this._model;
      // // update before setOption
      // if (!ecModel) {
      //     return;
      // }
      // ChartView.markUpdateMethod(payload, 'updateVisual');
      // clearColorPalette(ecModel);
      // // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
      // this._scheduler.performVisualTasks(ecModel, payload, {visualType: 'visual', setDirty: true});
      // render(this, this._model, this._api, payload);
      // performPostUpdateFuncs(ecModel, this._api);
    },

    /**
     * @param {Object} payload
     * @private
     */
    updateLayout: function (payload) {
      updateMethods.update.call(this, payload); // var ecModel = this._model;
      // // update before setOption
      // if (!ecModel) {
      //     return;
      // }
      // ChartView.markUpdateMethod(payload, 'updateLayout');
      // // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
      // // this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);
      // this._scheduler.performVisualTasks(ecModel, payload, {setDirty: true});
      // render(this, this._model, this._api, payload);
      // performPostUpdateFuncs(ecModel, this._api);
    }
  };

  function prepare(ecIns) {
    var ecModel = ecIns._model;
    var scheduler = ecIns._scheduler;
    scheduler.restorePipelines(ecModel);
    scheduler.prepareStageTasks();
    prepareView(ecIns, 'component', ecModel, scheduler);
    prepareView(ecIns, 'chart', ecModel, scheduler);
    scheduler.plan();
  }
  /**
   * @private
   */


  function updateDirectly(ecIns, method, payload, mainType, subType) {
    var ecModel = ecIns._model; // broadcast

    if (!mainType) {
      // FIXME
      // Chart will not be update directly here, except set dirty.
      // But there is no such scenario now.
      each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);
      return;
    }

    var query = {};
    query[mainType + 'Id'] = payload[mainType + 'Id'];
    query[mainType + 'Index'] = payload[mainType + 'Index'];
    query[mainType + 'Name'] = payload[mainType + 'Name'];
    var condition = {
      mainType: mainType,
      query: query
    };
    subType && (condition.subType = subType); // subType may be '' by parseClassType;

    var excludeSeriesId = payload.excludeSeriesId;

    if (excludeSeriesId != null) {
      excludeSeriesId = util.createHashMap(model.normalizeToArray(excludeSeriesId));
    } // If dispatchAction before setOption, do nothing.


    ecModel && ecModel.eachComponent(condition, function (model) {
      if (!excludeSeriesId || excludeSeriesId.get(model.id) == null) {
        callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);
      }
    }, ecIns);

    function callView(view) {
      view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
    }
  }
  /**
   * Resize the chart
   * @param {Object} opts
   * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
   * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
   * @param {boolean} [opts.silent=false]
   */


  echartsProto.resize = function (opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    this._zr.resize(opts);

    var ecModel = this._model; // Resize loading effect

    this._loadingFX && this._loadingFX.resize();

    if (!ecModel) {
      return;
    }

    var optionChanged = ecModel.resetOption('media');
    var silent = opts && opts.silent;
    this[IN_MAIN_PROCESS] = true;
    optionChanged && prepare(this);
    updateMethods.update.call(this);
    this[IN_MAIN_PROCESS] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };

  function updateStreamModes(ecIns, ecModel) {
    var chartsMap = ecIns._chartsMap;
    var scheduler = ecIns._scheduler;
    ecModel.eachSeries(function (seriesModel) {
      scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
    });
  }
  /**
   * Show loading effect
   * @param  {string} [name='default']
   * @param  {Object} [cfg]
   */


  echartsProto.showLoading = function (name, cfg) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    if (isObject(name)) {
      cfg = name;
      name = '';
    }

    name = name || 'default';
    this.hideLoading();

    if (!loadingEffects[name]) {
      return;
    }

    var el = loadingEffects[name](this._api, cfg);
    var zr = this._zr;
    this._loadingFX = el;
    zr.add(el);
  };
  /**
   * Hide loading effect
   */


  echartsProto.hideLoading = function () {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  };
  /**
   * @param {Object} eventObj
   * @return {Object}
   */


  echartsProto.makeActionFromEvent = function (eventObj) {
    var payload = util.extend({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
  };
  /**
   * @pubilc
   * @param {Object} payload
   * @param {string} [payload.type] Action type
   * @param {Object|boolean} [opt] If pass boolean, means opt.silent
   * @param {boolean} [opt.silent=false] Whether trigger events.
   * @param {boolean} [opt.flush=undefined]
   *                  true: Flush immediately, and then pixel in canvas can be fetched
   *                      immediately. Caution: it might affect performance.
   *                  false: Not flush.
   *                  undefined: Auto decide whether perform flush.
   */


  echartsProto.dispatchAction = function (payload, opt) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    if (!isObject(opt)) {
      opt = {
        silent: !!opt
      };
    }

    if (!actions[payload.type]) {
      return;
    } // Avoid dispatch action before setOption. Especially in `connect`.


    if (!this._model) {
      return;
    } // May dispatchAction in rendering procedure


    if (this[IN_MAIN_PROCESS]) {
      this._pendingActions.push(payload);

      return;
    }

    doDispatchAction.call(this, payload, opt.silent);

    if (opt.flush) {
      this._zr.flush(true);
    } else if (opt.flush !== false && env_1.browser.weChat) {
      // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`
      // hang when sliding page (on touch event), which cause that zr does not
      // refresh util user interaction finished, which is not expected.
      // But `dispatchAction` may be called too frequently when pan on touch
      // screen, which impacts performance if do not throttle them.
      this._throttledZrFlush();
    }

    flushPendingActions.call(this, opt.silent);
    triggerUpdatedEvent.call(this, opt.silent);
  };

  function doDispatchAction(payload, silent) {
    var payloadType = payload.type;
    var escapeConnect = payload.escapeConnect;
    var actionWrap = actions[payloadType];
    var actionInfo = actionWrap.actionInfo;
    var cptType = (actionInfo.update || 'update').split(':');
    var updateMethod = cptType.pop();
    cptType = cptType[0] != null && parseClassType(cptType[0]);
    this[IN_MAIN_PROCESS] = true;
    var payloads = [payload];
    var batched = false; // Batch action

    if (payload.batch) {
      batched = true;
      payloads = util.map(payload.batch, function (item) {
        item = util.defaults(util.extend({}, item), payload);
        item.batch = null;
        return item;
      });
    }

    var eventObjBatch = [];
    var eventObj;
    var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';
    each(payloads, function (batchItem) {
      // Action can specify the event by return it.
      eventObj = actionWrap.action(batchItem, this._model, this._api); // Emit event outside

      eventObj = eventObj || util.extend({}, batchItem); // Convert type to eventType

      eventObj.type = actionInfo.event || eventObj.type;
      eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual.

      if (isHighDown) {
        // method, payload, mainType, subType
        updateDirectly(this, updateMethod, batchItem, 'series');
      } else if (cptType) {
        updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
      }
    }, this);

    if (updateMethod !== 'none' && !isHighDown && !cptType) {
      // Still dirty
      if (this[OPTION_UPDATED]) {
        // FIXME Pass payload ?
        prepare(this);
        updateMethods.update.call(this, payload);
        this[OPTION_UPDATED] = false;
      } else {
        updateMethods[updateMethod].call(this, payload);
      }
    } // Follow the rule of action batch


    if (batched) {
      eventObj = {
        type: actionInfo.event || payloadType,
        escapeConnect: escapeConnect,
        batch: eventObjBatch
      };
    } else {
      eventObj = eventObjBatch[0];
    }

    this[IN_MAIN_PROCESS] = false;
    !silent && this._messageCenter.trigger(eventObj.type, eventObj);
  }

  function flushPendingActions(silent) {
    var pendingActions = this._pendingActions;

    while (pendingActions.length) {
      var payload = pendingActions.shift();
      doDispatchAction.call(this, payload, silent);
    }
  }

  function triggerUpdatedEvent(silent) {
    !silent && this.trigger('updated');
  }
  /**
   * Event `rendered` is triggered when zr
   * rendered. It is useful for realtime
   * snapshot (reflect animation).
   *
   * Event `finished` is triggered when:
   * (1) zrender rendering finished.
   * (2) initial animation finished.
   * (3) progressive rendering finished.
   * (4) no pending action.
   * (5) no delayed setOption needs to be processed.
   */


  function bindRenderedEvent(zr, ecIns) {
    zr.on('rendered', function () {
      ecIns.trigger('rendered'); // The `finished` event should not be triggered repeatly,
      // so it should only be triggered when rendering indeed happend
      // in zrender. (Consider the case that dipatchAction is keep
      // triggering when mouse move).

      if ( // Although zr is dirty if initial animation is not finished
      // and this checking is called on frame, we also check
      // animation finished for robustness.
      zr.animation.isFinished() && !ecIns[OPTION_UPDATED] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
        ecIns.trigger('finished');
      }
    });
  }
  /**
   * @param {Object} params
   * @param {number} params.seriesIndex
   * @param {Array|TypedArray} params.data
   */


  echartsProto.appendData = function (params) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    var seriesIndex = params.seriesIndex;
    var ecModel = this.getModel();
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    seriesModel.appendData(params); // Note: `appendData` does not support that update extent of coordinate
    // system, util some scenario require that. In the expected usage of
    // `appendData`, the initial extent of coordinate system should better
    // be fixed by axis `min`/`max` setting or initial data, otherwise if
    // the extent changed while `appendData`, the location of the painted
    // graphic elements have to be changed, which make the usage of
    // `appendData` meaningless.

    this._scheduler.unfinished = true;
  };
  /**
   * Register event
   * @method
   */


  echartsProto.on = createRegisterEventWithLowercaseName('on', false);
  echartsProto.off = createRegisterEventWithLowercaseName('off', false);
  echartsProto.one = createRegisterEventWithLowercaseName('one', false);
  /**
   * Prepare view instances of charts and components
   * @param  {module:echarts/model/Global} ecModel
   * @private
   */

  function prepareView(ecIns, type, ecModel, scheduler) {
    var isComponent = type === 'component';
    var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
    var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
    var zr = ecIns._zr;
    var api = ecIns._api;

    for (var i = 0; i < viewList.length; i++) {
      viewList[i].__alive = false;
    }

    isComponent ? ecModel.eachComponent(function (componentType, model) {
      componentType !== 'series' && doPrepare(model);
    }) : ecModel.eachSeries(doPrepare);

    function doPrepare(model) {
      // Consider: id same and type changed.
      var viewId = '_ec_' + model.id + '_' + model.type;
      var view = viewMap[viewId];

      if (!view) {
        var classType = parseClassType(model.type);
        var Clazz = isComponent ? Component_1.getClass(classType.main, classType.sub) : Chart_1.getClass(classType.sub);
        view = new Clazz();
        view.init(ecModel, api);
        viewMap[viewId] = view;
        viewList.push(view);
        zr.add(view.group);
      }

      model.__viewId = view.__id = viewId;
      view.__alive = true;
      view.__model = model;
      view.group.__ecComponentInfo = {
        mainType: model.mainType,
        index: model.componentIndex
      };
      !isComponent && scheduler.prepareView(view, model, ecModel, api);
    }

    for (var i = 0; i < viewList.length;) {
      var view = viewList[i];

      if (!view.__alive) {
        !isComponent && view.renderTask.dispose();
        zr.remove(view.group);
        view.dispose(ecModel, api);
        viewList.splice(i, 1);
        delete viewMap[view.__id];
        view.__id = view.group.__ecComponentInfo = null;
      } else {
        i++;
      }
    }
  } // /**
  //  * Encode visual infomation from data after data processing
  //  *
  //  * @param {module:echarts/model/Global} ecModel
  //  * @param {object} layout
  //  * @param {boolean} [layoutFilter] `true`: only layout,
  //  *                                 `false`: only not layout,
  //  *                                 `null`/`undefined`: all.
  //  * @param {string} taskBaseTag
  //  * @private
  //  */
  // function startVisualEncoding(ecIns, ecModel, api, payload, layoutFilter) {
  //     each(visualFuncs, function (visual, index) {
  //         var isLayout = visual.isLayout;
  //         if (layoutFilter == null
  //             || (layoutFilter === false && !isLayout)
  //             || (layoutFilter === true && isLayout)
  //         ) {
  //             visual.func(ecModel, api, payload);
  //         }
  //     });
  // }


  function clearColorPalette(ecModel) {
    ecModel.clearColorPalette();
    ecModel.eachSeries(function (seriesModel) {
      seriesModel.clearColorPalette();
    });
  }

  function render(ecIns, ecModel, api, payload) {
    renderComponents(ecIns, ecModel, api, payload);
    each(ecIns._chartsViews, function (chart) {
      chart.__alive = false;
    });
    renderSeries(ecIns, ecModel, api, payload); // Remove groups of unrendered charts

    each(ecIns._chartsViews, function (chart) {
      if (!chart.__alive) {
        chart.remove(ecModel, api);
      }
    });
  }

  function renderComponents(ecIns, ecModel, api, payload, dirtyList) {
    each(dirtyList || ecIns._componentsViews, function (componentView) {
      var componentModel = componentView.__model;
      componentView.render(componentModel, ecModel, api, payload);
      updateZ(componentModel, componentView);
    });
  }
  /**
   * Render each chart and component
   * @private
   */


  function renderSeries(ecIns, ecModel, api, payload, dirtyMap) {
    // Render all charts
    var scheduler = ecIns._scheduler;
    var unfinished;
    ecModel.eachSeries(function (seriesModel) {
      var chartView = ecIns._chartsMap[seriesModel.__viewId];
      chartView.__alive = true;
      var renderTask = chartView.renderTask;
      scheduler.updatePayload(renderTask, payload);

      if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
        renderTask.dirty();
      }

      unfinished |= renderTask.perform(scheduler.getPerformArgs(renderTask));
      chartView.group.silent = !!seriesModel.get('silent');
      updateZ(seriesModel, chartView);
      updateBlend(seriesModel, chartView);
    });
    scheduler.unfinished |= unfinished; // If use hover layer

    updateHoverLayerStatus(ecIns, ecModel); // Add aria

    aria(ecIns._zr.dom, ecModel);
  }

  function performPostUpdateFuncs(ecModel, api) {
    each(postUpdateFuncs, function (func) {
      func(ecModel, api);
    });
  }

  var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];
  /**
   * @private
   */

  echartsProto._initEvents = function () {
    each(MOUSE_EVENT_NAMES, function (eveName) {
      var handler = function (e) {
        var ecModel = this.getModel();
        var el = e.target;
        var params;
        var isGlobalOut = eveName === 'globalout'; // no e.target when 'globalout'.

        if (isGlobalOut) {
          params = {};
        } else if (el && el.dataIndex != null) {
          var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
          params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType, el) || {};
        } // If element has custom eventData of components
        else if (el && el.eventData) {
            params = util.extend({}, el.eventData);
          } // Contract: if params prepared in mouse event,
        // these properties must be specified:
        // {
        //    componentType: string (component main type)
        //    componentIndex: number
        // }
        // Otherwise event query can not work.


        if (params) {
          var componentType = params.componentType;
          var componentIndex = params.componentIndex; // Special handling for historic reason: when trigger by
          // markLine/markPoint/markArea, the componentType is
          // 'markLine'/'markPoint'/'markArea', but we should better
          // enable them to be queried by seriesIndex, since their
          // option is set in each series.

          if (componentType === 'markLine' || componentType === 'markPoint' || componentType === 'markArea') {
            componentType = 'series';
            componentIndex = params.seriesIndex;
          }

          var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
          var view = model && this[model.mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId];
          params.event = e;
          params.type = eveName;
          this._ecEventProcessor.eventInfo = {
            targetEl: el,
            packedEvent: params,
            model: model,
            view: view
          };
          this.trigger(eveName, params);
        }
      }; // Consider that some component (like tooltip, brush, ...)
      // register zr event handler, but user event handler might
      // do anything, such as call `setOption` or `dispatchAction`,
      // which probably update any of the content and probably
      // cause problem if it is called previous other inner handlers.


      handler.zrEventfulCallAtLast = true;

      this._zr.on(eveName, handler, this);
    }, this);
    each(eventActionMap, function (actionType, eventType) {
      this._messageCenter.on(eventType, function (event) {
        this.trigger(eventType, event);
      }, this);
    }, this);
  };
  /**
   * @return {boolean}
   */


  echartsProto.isDisposed = function () {
    return this._disposed;
  };
  /**
   * Clear
   */


  echartsProto.clear = function () {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    this.setOption({
      series: []
    }, true);
  };
  /**
   * Dispose instance
   */


  echartsProto.dispose = function () {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    this._disposed = true;
    model.setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, '');
    var api = this._api;
    var ecModel = this._model;
    each(this._componentsViews, function (component) {
      component.dispose(ecModel, api);
    });
    each(this._chartsViews, function (chart) {
      chart.dispose(ecModel, api);
    }); // Dispose after all views disposed

    this._zr.dispose();

    delete instances[this.id];
  };

  util.mixin(ECharts, Eventful_1);

  function disposedWarning(id) {}

  function updateHoverLayerStatus(ecIns, ecModel) {
    var zr = ecIns._zr;
    var storage = zr.storage;
    var elCount = 0;
    storage.traverse(function (el) {
      elCount++;
    });

    if (elCount > ecModel.get('hoverLayerThreshold') && !env_1.node) {
      ecModel.eachSeries(function (seriesModel) {
        if (seriesModel.preventUsingHoverLayer) {
          return;
        }

        var chartView = ecIns._chartsMap[seriesModel.__viewId];

        if (chartView.__alive) {
          chartView.group.traverse(function (el) {
            // Don't switch back.
            el.useHoverLayer = true;
          });
        }
      });
    }
  }
  /**
   * Update chart progressive and blend.
   * @param {module:echarts/model/Series|module:echarts/model/Component} model
   * @param {module:echarts/view/Component|module:echarts/view/Chart} view
   */


  function updateBlend(seriesModel, chartView) {
    var blendMode = seriesModel.get('blendMode') || null;
    chartView.group.traverse(function (el) {
      // FIXME marker and other components
      if (!el.isGroup) {
        // Only set if blendMode is changed. In case element is incremental and don't wan't to rerender.
        if (el.style.blend !== blendMode) {
          el.setStyle('blend', blendMode);
        }
      }

      if (el.eachPendingDisplayable) {
        el.eachPendingDisplayable(function (displayable) {
          displayable.setStyle('blend', blendMode);
        });
      }
    });
  }
  /**
   * @param {module:echarts/model/Series|module:echarts/model/Component} model
   * @param {module:echarts/view/Component|module:echarts/view/Chart} view
   */


  function updateZ(model, view) {
    var z = model.get('z');
    var zlevel = model.get('zlevel'); // Set z and zlevel

    view.group.traverse(function (el) {
      if (el.type !== 'group') {
        z != null && (el.z = z);
        zlevel != null && (el.zlevel = zlevel);
      }
    });
  }

  function createExtensionAPI(ecInstance) {
    var coordSysMgr = ecInstance._coordSysMgr;
    return util.extend(new ExtensionAPI_1(ecInstance), {
      // Inject methods
      getCoordinateSystems: util.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),
      getComponentByElement: function (el) {
        while (el) {
          var modelInfo = el.__ecComponentInfo;

          if (modelInfo != null) {
            return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);
          }

          el = el.parent;
        }
      }
    });
  }
  /**
   * @class
   * Usage of query:
   * `chart.on('click', query, handler);`
   * The `query` can be:
   * + The component type query string, only `mainType` or `mainType.subType`,
   *   like: 'xAxis', 'series', 'xAxis.category' or 'series.line'.
   * + The component query object, like:
   *   `{seriesIndex: 2}`, `{seriesName: 'xx'}`, `{seriesId: 'some'}`,
   *   `{xAxisIndex: 2}`, `{xAxisName: 'xx'}`, `{xAxisId: 'some'}`.
   * + The data query object, like:
   *   `{dataIndex: 123}`, `{dataType: 'link'}`, `{name: 'some'}`.
   * + The other query object (cmponent customized query), like:
   *   `{element: 'some'}` (only available in custom series).
   *
   * Caveat: If a prop in the `query` object is `null/undefined`, it is the
   * same as there is no such prop in the `query` object.
   */


  function EventProcessor() {
    // These info required: targetEl, packedEvent, model, view
    this.eventInfo;
  }

  EventProcessor.prototype = {
    constructor: EventProcessor,
    normalizeQuery: function (query) {
      var cptQuery = {};
      var dataQuery = {};
      var otherQuery = {}; // `query` is `mainType` or `mainType.subType` of component.

      if (util.isString(query)) {
        var condCptType = parseClassType(query); // `.main` and `.sub` may be ''.

        cptQuery.mainType = condCptType.main || null;
        cptQuery.subType = condCptType.sub || null;
      } // `query` is an object, convert to {mainType, index, name, id}.
      else {
          // `xxxIndex`, `xxxName`, `xxxId`, `name`, `dataIndex`, `dataType` is reserved,
          // can not be used in `compomentModel.filterForExposedEvent`.
          var suffixes = ['Index', 'Name', 'Id'];
          var dataKeys = {
            name: 1,
            dataIndex: 1,
            dataType: 1
          };
          util.each(query, function (val, key) {
            var reserved = false;

            for (var i = 0; i < suffixes.length; i++) {
              var propSuffix = suffixes[i];
              var suffixPos = key.lastIndexOf(propSuffix);

              if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
                var mainType = key.slice(0, suffixPos); // Consider `dataIndex`.

                if (mainType !== 'data') {
                  cptQuery.mainType = mainType;
                  cptQuery[propSuffix.toLowerCase()] = val;
                  reserved = true;
                }
              }
            }

            if (dataKeys.hasOwnProperty(key)) {
              dataQuery[key] = val;
              reserved = true;
            }

            if (!reserved) {
              otherQuery[key] = val;
            }
          });
        }

      return {
        cptQuery: cptQuery,
        dataQuery: dataQuery,
        otherQuery: otherQuery
      };
    },
    filter: function (eventType, query, args) {
      // They should be assigned before each trigger call.
      var eventInfo = this.eventInfo;

      if (!eventInfo) {
        return true;
      }

      var targetEl = eventInfo.targetEl;
      var packedEvent = eventInfo.packedEvent;
      var model = eventInfo.model;
      var view = eventInfo.view; // For event like 'globalout'.

      if (!model || !view) {
        return true;
      }

      var cptQuery = query.cptQuery;
      var dataQuery = query.dataQuery;
      return check(cptQuery, model, 'mainType') && check(cptQuery, model, 'subType') && check(cptQuery, model, 'index', 'componentIndex') && check(cptQuery, model, 'name') && check(cptQuery, model, 'id') && check(dataQuery, packedEvent, 'name') && check(dataQuery, packedEvent, 'dataIndex') && check(dataQuery, packedEvent, 'dataType') && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));

      function check(query, host, prop, propOnHost) {
        return query[prop] == null || host[propOnHost || prop] === query[prop];
      }
    },
    afterTrigger: function () {
      // Make sure the eventInfo wont be used in next trigger.
      this.eventInfo = null;
    }
  };
  /**
   * @type {Object} key: actionType.
   * @inner
   */

  var actions = {};
  /**
   * Map eventType to actionType
   * @type {Object}
   */

  var eventActionMap = {};
  /**
   * Data processor functions of each stage
   * @type {Array.<Object.<string, Function>>}
   * @inner
   */

  var dataProcessorFuncs = [];
  /**
   * @type {Array.<Function>}
   * @inner
   */

  var optionPreprocessorFuncs = [];
  /**
   * @type {Array.<Function>}
   * @inner
   */

  var postUpdateFuncs = [];
  /**
   * Visual encoding functions of each stage
   * @type {Array.<Object.<string, Function>>}
   */

  var visualFuncs = [];
  /**
   * Theme storage
   * @type {Object.<key, Object>}
   */

  var themeStorage = {};
  /**
   * Loading effects
   */

  var loadingEffects = {};
  var instances = {};
  var connectedGroups = {};
  var idBase = new Date() - 0;
  var groupIdBase = new Date() - 0;
  var DOM_ATTRIBUTE_KEY = '_echarts_instance_';

  function enableConnect(chart) {
    var STATUS_PENDING = 0;
    var STATUS_UPDATING = 1;
    var STATUS_UPDATED = 2;
    var STATUS_KEY = '__connectUpdateStatus';

    function updateConnectedChartsStatus(charts, status) {
      for (var i = 0; i < charts.length; i++) {
        var otherChart = charts[i];
        otherChart[STATUS_KEY] = status;
      }
    }

    each(eventActionMap, function (actionType, eventType) {
      chart._messageCenter.on(eventType, function (event) {
        if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
          if (event && event.escapeConnect) {
            return;
          }

          var action = chart.makeActionFromEvent(event);
          var otherCharts = [];
          each(instances, function (otherChart) {
            if (otherChart !== chart && otherChart.group === chart.group) {
              otherCharts.push(otherChart);
            }
          });
          updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
          each(otherCharts, function (otherChart) {
            if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
              otherChart.dispatchAction(action);
            }
          });
          updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
        }
      });
    });
  }
  /**
   * @param {HTMLElement} dom
   * @param {Object} [theme]
   * @param {Object} opts
   * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default
   * @param {string} [opts.renderer] Can choose 'canvas' or 'svg' to render the chart.
   * @param {number} [opts.width] Use clientWidth of the input `dom` by default.
   *                              Can be 'auto' (the same as null/undefined)
   * @param {number} [opts.height] Use clientHeight of the input `dom` by default.
   *                               Can be 'auto' (the same as null/undefined)
   */


  function init(dom, theme, opts) {
    var existInstance = getInstanceByDom(dom);

    if (existInstance) {
      return existInstance;
    }

    var chart = new ECharts(dom, theme, opts);
    chart.id = 'ec_' + idBase++;
    instances[chart.id] = chart;
    model.setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
    enableConnect(chart);
    return chart;
  }
  /**
   * @return {string|Array.<module:echarts~ECharts>} groupId
   */


  function connect(groupId) {
    // Is array of charts
    if (util.isArray(groupId)) {
      var charts = groupId;
      groupId = null; // If any chart has group

      each(charts, function (chart) {
        if (chart.group != null) {
          groupId = chart.group;
        }
      });
      groupId = groupId || 'g_' + groupIdBase++;
      each(charts, function (chart) {
        chart.group = groupId;
      });
    }

    connectedGroups[groupId] = true;
    return groupId;
  }
  /**
   * @DEPRECATED
   * @return {string} groupId
   */


  function disConnect(groupId) {
    connectedGroups[groupId] = false;
  }
  /**
   * @return {string} groupId
   */


  var disconnect = disConnect;
  /**
   * Dispose a chart instance
   * @param  {module:echarts~ECharts|HTMLDomElement|string} chart
   */

  function dispose(chart) {
    if (typeof chart === 'string') {
      chart = instances[chart];
    } else if (!(chart instanceof ECharts)) {
      // Try to treat as dom
      chart = getInstanceByDom(chart);
    }

    if (chart instanceof ECharts && !chart.isDisposed()) {
      chart.dispose();
    }
  }
  /**
   * @param  {HTMLElement} dom
   * @return {echarts~ECharts}
   */


  function getInstanceByDom(dom) {
    return instances[model.getAttribute(dom, DOM_ATTRIBUTE_KEY)];
  }
  /**
   * @param {string} key
   * @return {echarts~ECharts}
   */


  function getInstanceById(key) {
    return instances[key];
  }
  /**
   * Register theme
   */


  function registerTheme(name, theme) {
    themeStorage[name] = theme;
  }
  /**
   * Register option preprocessor
   * @param {Function} preprocessorFunc
   */


  function registerPreprocessor(preprocessorFunc) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  }
  /**
   * @param {number} [priority=1000]
   * @param {Object|Function} processor
   */


  function registerProcessor(priority, processor) {
    normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_FILTER);
  }
  /**
   * Register postUpdater
   * @param {Function} postUpdateFunc
   */


  function registerPostUpdate(postUpdateFunc) {
    postUpdateFuncs.push(postUpdateFunc);
  }
  /**
   * Usage:
   * registerAction('someAction', 'someEvent', function () { ... });
   * registerAction('someAction', function () { ... });
   * registerAction(
   *     {type: 'someAction', event: 'someEvent', update: 'updateView'},
   *     function () { ... }
   * );
   *
   * @param {(string|Object)} actionInfo
   * @param {string} actionInfo.type
   * @param {string} [actionInfo.event]
   * @param {string} [actionInfo.update]
   * @param {string} [eventName]
   * @param {Function} action
   */


  function registerAction(actionInfo, eventName, action) {
    if (typeof eventName === 'function') {
      action = eventName;
      eventName = '';
    }

    var actionType = isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
      event: eventName
    }][0]; // Event name is all lowercase

    actionInfo.event = (actionInfo.event || actionType).toLowerCase();
    eventName = actionInfo.event; // Validate action type and event name.

    assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));

    if (!actions[actionType]) {
      actions[actionType] = {
        action: action,
        actionInfo: actionInfo
      };
    }

    eventActionMap[eventName] = actionType;
  }
  /**
   * @param {string} type
   * @param {*} CoordinateSystem
   */


  function registerCoordinateSystem(type, CoordinateSystem$1) {
    CoordinateSystem.register(type, CoordinateSystem$1);
  }
  /**
   * Get dimensions of specified coordinate system.
   * @param {string} type
   * @return {Array.<string|Object>}
   */


  function getCoordinateSystemDimensions(type) {
    var coordSysCreator = CoordinateSystem.get(type);

    if (coordSysCreator) {
      return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
    }
  }
  /**
   * Layout is a special stage of visual encoding
   * Most visual encoding like color are common for different chart
   * But each chart has it's own layout algorithm
   *
   * @param {number} [priority=1000]
   * @param {Function} layoutTask
   */


  function registerLayout(priority, layoutTask) {
    normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, 'layout');
  }
  /**
   * @param {number} [priority=3000]
   * @param {module:echarts/stream/Task} visualTask
   */


  function registerVisual(priority, visualTask) {
    normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, 'visual');
  }
  /**
   * @param {Object|Function} fn: {seriesType, createOnAllSeries, performRawSeries, reset}
   */


  function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
    if (isFunction(priority) || isObject(priority)) {
      fn = priority;
      priority = defaultPriority;
    }

    var stageHandler = Scheduler_1.wrapStageHandler(fn, visualType);
    stageHandler.__prio = priority;
    stageHandler.__raw = fn;
    targetList.push(stageHandler);
    return stageHandler;
  }
  /**
   * @param {string} name
   */


  function registerLoading(name, loadingFx) {
    loadingEffects[name] = loadingFx;
  }
  /**
   * @param {Object} opts
   * @param {string} [superClass]
   */


  function extendComponentModel(opts
  /*, superClass*/
  ) {
    // var Clazz = ComponentModel;
    // if (superClass) {
    //     var classType = parseClassType(superClass);
    //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
    // }
    return Component.extend(opts);
  }
  /**
   * @param {Object} opts
   * @param {string} [superClass]
   */


  function extendComponentView(opts
  /*, superClass*/
  ) {
    // var Clazz = ComponentView;
    // if (superClass) {
    //     var classType = parseClassType(superClass);
    //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);
    // }
    return Component_1.extend(opts);
  }
  /**
   * @param {Object} opts
   * @param {string} [superClass]
   */


  function extendSeriesModel(opts
  /*, superClass*/
  ) {
    // var Clazz = SeriesModel;
    // if (superClass) {
    //     superClass = 'series.' + superClass.replace('series.', '');
    //     var classType = parseClassType(superClass);
    //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
    // }
    return Series.extend(opts);
  }
  /**
   * @param {Object} opts
   * @param {string} [superClass]
   */


  function extendChartView(opts
  /*, superClass*/
  ) {
    // var Clazz = ChartView;
    // if (superClass) {
    //     superClass = superClass.replace('series.', '');
    //     var classType = parseClassType(superClass);
    //     Clazz = ChartView.getClass(classType.main, true);
    // }
    return Chart_1.extend(opts);
  }
  /**
   * ZRender need a canvas context to do measureText.
   * But in node environment canvas may be created by node-canvas.
   * So we need to specify how to create a canvas instead of using document.createElement('canvas')
   *
   * Be careful of using it in the browser.
   *
   * @param {Function} creator
   * @example
   *     var Canvas = require('canvas');
   *     var echarts = require('echarts');
   *     echarts.setCanvasCreator(function () {
   *         // Small size is enough.
   *         return new Canvas(32, 32);
   *     });
   */


  function setCanvasCreator(creator) {
    util.$override('createCanvas', creator);
  }
  /**
   * @param {string} mapName
   * @param {Array.<Object>|Object|string} geoJson
   * @param {Object} [specialAreas]
   *
   * @example GeoJSON
   *     $.get('USA.json', function (geoJson) {
   *         echarts.registerMap('USA', geoJson);
   *         // Or
   *         echarts.registerMap('USA', {
   *             geoJson: geoJson,
   *             specialAreas: {}
   *         })
   *     });
   *
   *     $.get('airport.svg', function (svg) {
   *         echarts.registerMap('airport', {
   *             svg: svg
   *         }
   *     });
   *
   *     echarts.registerMap('eu', [
   *         {svg: eu-topographic.svg},
   *         {geoJSON: eu.json}
   *     ])
   */


  function registerMap(mapName, geoJson, specialAreas) {
    mapDataStorage.registerMap(mapName, geoJson, specialAreas);
  }
  /**
   * @param {string} mapName
   * @return {Object}
   */


  function getMap(mapName) {
    // For backward compatibility, only return the first one.
    var records = mapDataStorage.retrieveMap(mapName);
    return records && records[0] && {
      geoJson: records[0].geoJSON,
      specialAreas: records[0].specialAreas
    };
  }

  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);
  registerPreprocessor(backwardCompat);
  registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
  registerLoading('default', _default_1); // Default actions

  registerAction({
    type: 'highlight',
    event: 'highlight',
    update: 'highlight'
  }, util.noop);
  registerAction({
    type: 'downplay',
    event: 'downplay',
    update: 'downplay'
  }, util.noop); // Default theme

  registerTheme('light', light);
  registerTheme('dark', dark); // For backward compatibility, where the namespace `dataTool` will
  // be mounted on `echarts` is the extension `dataTool` is imported.

  var dataTool = {};
  exports.version = version;
  exports.dependencies = dependencies;
  exports.PRIORITY = PRIORITY;
  exports.init = init;
  exports.connect = connect;
  exports.disConnect = disConnect;
  exports.disconnect = disconnect;
  exports.dispose = dispose;
  exports.getInstanceByDom = getInstanceByDom;
  exports.getInstanceById = getInstanceById;
  exports.registerTheme = registerTheme;
  exports.registerPreprocessor = registerPreprocessor;
  exports.registerProcessor = registerProcessor;
  exports.registerPostUpdate = registerPostUpdate;
  exports.registerAction = registerAction;
  exports.registerCoordinateSystem = registerCoordinateSystem;
  exports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;
  exports.registerLayout = registerLayout;
  exports.registerVisual = registerVisual;
  exports.registerLoading = registerLoading;
  exports.extendComponentModel = extendComponentModel;
  exports.extendComponentView = extendComponentView;
  exports.extendSeriesModel = extendSeriesModel;
  exports.extendChartView = extendChartView;
  exports.setCanvasCreator = setCanvasCreator;
  exports.registerMap = registerMap;
  exports.getMap = getMap;
  exports.dataTool = dataTool;

  (function () {
      for (var key in _export$1) {
          if (_export$1.hasOwnProperty(key)) {
              exports[key] = _export$1[key];
          }
      }
  })();
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var _default$1w = Series.extend({
    type: 'series.line',
    dependencies: ['grid', 'polar'],
    getInitialData: function (option, ecModel) {
      return createListFromArray_1(this.getSource(), this, {
        useEncodeDefaulter: true
      });
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: true,
      hoverAnimation: true,
      // stack: null
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // If clip the overflow value
      clip: true,
      // cursor: null,
      label: {
        position: 'top'
      },
      // itemStyle: {
      // },
      lineStyle: {
        width: 2,
        type: 'solid'
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: false,
      // Disabled if step is true
      smooth: false,
      smoothMonotone: null,
      symbol: 'emptyCircle',
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: true,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: 'auto',
      // Whether to connect break point.
      connectNulls: false,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.
      sampling: 'none',
      animationEasing: 'linear',
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: Infinity
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var retrieveRawValue$4 = dataProvider.retrieveRawValue;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @param {module:echarts/data/List} data
   * @param {number} dataIndex
   * @return {string} label string. Not null/undefined
   */
  function getDefaultLabel(data, dataIndex) {
    var labelDims = data.mapDimension('defaultedLabel', true);
    var len = labelDims.length; // Simple optimization (in lots of cases, label dims length is 1)

    if (len === 1) {
      return retrieveRawValue$4(data, dataIndex, labelDims[0]);
    } else if (len) {
      var vals = [];

      for (var i = 0; i < labelDims.length; i++) {
        var val = retrieveRawValue$4(data, dataIndex, labelDims[i]);
        vals.push(val);
      }

      return vals.join(' ');
    }
  }

  var getDefaultLabel_1 = getDefaultLabel;

  var labelHelper = {
  	getDefaultLabel: getDefaultLabel_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  var createSymbol$2 = symbol.createSymbol;





  var parsePercent$4 = number.parsePercent;



  var getDefaultLabel$1 = labelHelper.getDefaultLabel;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @module echarts/chart/helper/Symbol
   */

  /**
   * @constructor
   * @alias {module:echarts/chart/helper/Symbol}
   * @param {module:echarts/data/List} data
   * @param {number} idx
   * @extends {module:zrender/graphic/Group}
   */
  function SymbolClz$1(data, idx, seriesScope) {
    graphic.Group.call(this);
    this.updateData(data, idx, seriesScope);
  }

  var symbolProto = SymbolClz$1.prototype;
  /**
   * @public
   * @static
   * @param {module:echarts/data/List} data
   * @param {number} dataIndex
   * @return {Array.<number>} [width, height]
   */

  var getSymbolSize = SymbolClz$1.getSymbolSize = function (data, idx) {
    var symbolSize = data.getItemVisual(idx, 'symbolSize');
    return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
  };

  function getScale(symbolSize) {
    return [symbolSize[0] / 2, symbolSize[1] / 2];
  }

  function driftSymbol(dx, dy) {
    this.parent.drift(dx, dy);
  }

  symbolProto._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {
    // Remove paths created before
    this.removeAll();
    var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(
    //     symbolType, -0.5, -0.5, 1, 1, color
    // );
    // If width/height are set too small (e.g., set to 1) on ios10
    // and macOS Sierra, a circle stroke become a rect, no matter what
    // the scale is set. So we set width/height as 2. See #4150.

    var symbolPath = createSymbol$2(symbolType, -1, -1, 2, 2, color, keepAspect);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scale: getScale(symbolSize)
    }); // Rewrite drift method

    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  };
  /**
   * Stop animation
   * @param {boolean} toLastFrame
   */


  symbolProto.stopSymbolAnimation = function (toLastFrame) {
    this.childAt(0).stopAnimation(toLastFrame);
  };
  /**
   * FIXME:
   * Caution: This method breaks the encapsulation of this module,
   * but it indeed brings convenience. So do not use the method
   * unless you detailedly know all the implements of `Symbol`,
   * especially animation.
   *
   * Get symbol path element.
   */


  symbolProto.getSymbolPath = function () {
    return this.childAt(0);
  };
  /**
   * Get scale(aka, current symbol size).
   * Including the change caused by animation
   */


  symbolProto.getScale = function () {
    return this.childAt(0).scale;
  };
  /**
   * Highlight symbol
   */


  symbolProto.highlight = function () {
    this.childAt(0).trigger('emphasis');
  };
  /**
   * Downplay symbol
   */


  symbolProto.downplay = function () {
    this.childAt(0).trigger('normal');
  };
  /**
   * @param {number} zlevel
   * @param {number} z
   */


  symbolProto.setZ = function (zlevel, z) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
  };

  symbolProto.setDraggable = function (draggable) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = draggable ? 'move' : symbolPath.cursor;
  };
  /**
   * Update symbol properties
   * @param {module:echarts/data/List} data
   * @param {number} idx
   * @param {Object} [seriesScope]
   * @param {Object} [seriesScope.itemStyle]
   * @param {Object} [seriesScope.hoverItemStyle]
   * @param {Object} [seriesScope.symbolRotate]
   * @param {Object} [seriesScope.symbolOffset]
   * @param {module:echarts/model/Model} [seriesScope.labelModel]
   * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]
   * @param {boolean} [seriesScope.hoverAnimation]
   * @param {Object} [seriesScope.cursorStyle]
   * @param {module:echarts/model/Model} [seriesScope.itemModel]
   * @param {string} [seriesScope.symbolInnerColor]
   * @param {Object} [seriesScope.fadeIn=false]
   */


  symbolProto.updateData = function (data, idx, seriesScope) {
    this.silent = false;
    var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
    var seriesModel = data.hostModel;
    var symbolSize = getSymbolSize(data, idx);
    var isInit = symbolType !== this._symbolType;

    if (isInit) {
      var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');

      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
    } else {
      var symbolPath = this.childAt(0);
      symbolPath.silent = false;
      graphic.updateProps(symbolPath, {
        scale: getScale(symbolSize)
      }, seriesModel, idx);
    }

    this._updateCommon(data, idx, symbolSize, seriesScope);

    if (isInit) {
      var symbolPath = this.childAt(0);
      var fadeIn = seriesScope && seriesScope.fadeIn;
      var target = {
        scale: symbolPath.scale.slice()
      };
      fadeIn && (target.style = {
        opacity: symbolPath.style.opacity
      });
      symbolPath.scale = [0, 0];
      fadeIn && (symbolPath.style.opacity = 0);
      graphic.initProps(symbolPath, target, seriesModel, idx);
    }

    this._seriesModel = seriesModel;
  }; // Update common properties


  var normalStyleAccessPath = ['itemStyle'];
  var emphasisStyleAccessPath = ['emphasis', 'itemStyle'];
  var normalLabelAccessPath = ['label'];
  var emphasisLabelAccessPath = ['emphasis', 'label'];
  /**
   * @param {module:echarts/data/List} data
   * @param {number} idx
   * @param {Array.<number>} symbolSize
   * @param {Object} [seriesScope]
   */

  symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {
    var symbolPath = this.childAt(0);
    var seriesModel = data.hostModel;
    var color = data.getItemVisual(idx, 'color'); // Reset style

    if (symbolPath.type !== 'image') {
      symbolPath.useStyle({
        strokeNoScale: true
      });
    } else {
      symbolPath.setStyle({
        opacity: 1,
        shadowBlur: null,
        shadowOffsetX: null,
        shadowOffsetY: null,
        shadowColor: null
      });
    }

    var itemStyle = seriesScope && seriesScope.itemStyle;
    var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
    var symbolOffset = seriesScope && seriesScope.symbolOffset;
    var labelModel = seriesScope && seriesScope.labelModel;
    var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
    var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
    var cursorStyle = seriesScope && seriesScope.cursorStyle;

    if (!seriesScope || data.hasItemOption) {
      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.
      // Because symbol provide setColor individually to set fill and stroke

      itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);
      hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
      symbolOffset = itemModel.getShallow('symbolOffset');
      labelModel = itemModel.getModel(normalLabelAccessPath);
      hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
      hoverAnimation = itemModel.getShallow('hoverAnimation');
      cursorStyle = itemModel.getShallow('cursor');
    } else {
      hoverItemStyle = util.extend({}, hoverItemStyle);
    }

    var elStyle = symbolPath.style;
    var symbolRotate = data.getItemVisual(idx, 'symbolRotate');
    symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);

    if (symbolOffset) {
      symbolPath.attr('position', [parsePercent$4(symbolOffset[0], symbolSize[0]), parsePercent$4(symbolOffset[1], symbolSize[1])]);
    }

    cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!

    symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);
    symbolPath.setStyle(itemStyle);
    var opacity = data.getItemVisual(idx, 'opacity');

    if (opacity != null) {
      elStyle.opacity = opacity;
    }

    var liftZ = data.getItemVisual(idx, 'liftZ');
    var z2Origin = symbolPath.__z2Origin;

    if (liftZ != null) {
      if (z2Origin == null) {
        symbolPath.__z2Origin = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      symbolPath.__z2Origin = null;
    }

    var useNameLabel = seriesScope && seriesScope.useNameLabel;
    graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      isRectText: true,
      autoColor: color
    }); // Do not execute util needed.

    function getLabelDefaultText(idx, opt) {
      return useNameLabel ? data.getName(idx) : getDefaultLabel$1(data, idx);
    }

    symbolPath.__symbolOriginalScale = getScale(symbolSize);
    symbolPath.hoverStyle = hoverItemStyle;
    symbolPath.highDownOnUpdate = hoverAnimation && seriesModel.isAnimationEnabled() ? highDownOnUpdate : null;
    graphic.setHoverStyle(symbolPath);
  };

  function highDownOnUpdate(fromState, toState) {
    // Do not support this hover animation util some scenario required.
    // Animation can only be supported in hover layer when using `el.incremetal`.
    if (this.incremental || this.useHoverLayer) {
      return;
    }

    if (toState === 'emphasis') {
      var scale = this.__symbolOriginalScale;
      var ratio = scale[1] / scale[0];
      var emphasisOpt = {
        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]
      }; // FIXME
      // modify it after support stop specified animation.
      // toState === fromState
      //     ? (this.stopAnimation(), this.attr(emphasisOpt))

      this.animateTo(emphasisOpt, 400, 'elasticOut');
    } else if (toState === 'normal') {
      this.animateTo({
        scale: this.__symbolOriginalScale
      }, 400, 'elasticOut');
    }
  }
  /**
   * @param {Function} cb
   * @param {Object} [opt]
   * @param {Object} [opt.keepLabel=true]
   */


  symbolProto.fadeOut = function (cb, opt) {
    var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out

    this.silent = symbolPath.silent = true; // Not show text when animating

    !(opt && opt.keepLabel) && (symbolPath.style.text = null);
    graphic.updateProps(symbolPath, {
      style: {
        opacity: 0
      },
      scale: [0, 0]
    }, this._seriesModel, this.dataIndex, cb);
  };

  util.inherits(SymbolClz$1, graphic.Group);
  var _default$1x = SymbolClz$1;
  var _Symbol = _default$1x;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  var isObject$e = util.isObject;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @module echarts/chart/helper/SymbolDraw
   */

  /**
   * @constructor
   * @alias module:echarts/chart/helper/SymbolDraw
   * @param {module:zrender/graphic/Group} [symbolCtor]
   */
  function SymbolDraw(symbolCtor) {
    this.group = new graphic.Group();
    this._symbolCtor = symbolCtor || _Symbol;
  }

  var symbolDrawProto = SymbolDraw.prototype;

  function symbolNeedsDraw(data, point, idx, opt) {
    return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of
    // the symbol element shape. We use the same clip shape here as
    // the line clip.
    && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';
  }
  /**
   * Update symbols draw by new data
   * @param {module:echarts/data/List} data
   * @param {Object} [opt] Or isIgnore
   * @param {Function} [opt.isIgnore]
   * @param {Object} [opt.clipShape]
   */


  symbolDrawProto.updateData = function (data, opt) {
    opt = normalizeUpdateOpt(opt);
    var group = this.group;
    var seriesModel = data.hostModel;
    var oldData = this._data;
    var SymbolCtor = this._symbolCtor;
    var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from
    // stream mode to normal mode, where previous elements should be removed.

    if (!oldData) {
      group.removeAll();
    }

    data.diff(oldData).add(function (newIdx) {
      var point = data.getItemLayout(newIdx);

      if (symbolNeedsDraw(data, point, newIdx, opt)) {
        var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
        symbolEl.attr('position', point);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function (newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      var point = data.getItemLayout(newIdx);

      if (!symbolNeedsDraw(data, point, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }

      if (!symbolEl) {
        symbolEl = new SymbolCtor(data, newIdx);
        symbolEl.attr('position', point);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope);
        graphic.updateProps(symbolEl, {
          position: point
        }, seriesModel);
      } // Add back


      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function (oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function () {
        group.remove(el);
      });
    }).execute();
    this._data = data;
  };

  symbolDrawProto.isPersistent = function () {
    return true;
  };

  symbolDrawProto.updateLayout = function () {
    var data = this._data;

    if (data) {
      // Not use animation
      data.eachItemGraphicEl(function (el, idx) {
        var point = data.getItemLayout(idx);
        el.attr('position', point);
      });
    }
  };

  symbolDrawProto.incrementalPrepareUpdate = function (data) {
    this._seriesScope = makeSeriesScope(data);
    this._data = null;
    this.group.removeAll();
  };
  /**
   * Update symbols draw by new data
   * @param {module:echarts/data/List} data
   * @param {Object} [opt] Or isIgnore
   * @param {Function} [opt.isIgnore]
   * @param {Object} [opt.clipShape]
   */


  symbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {
    opt = normalizeUpdateOpt(opt);

    function updateIncrementalAndHover(el) {
      if (!el.isGroup) {
        el.incremental = el.useHoverLayer = true;
      }
    }

    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var point = data.getItemLayout(idx);

      if (symbolNeedsDraw(data, point, idx, opt)) {
        var el = new this._symbolCtor(data, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        el.attr('position', point);
        this.group.add(el);
        data.setItemGraphicEl(idx, el);
      }
    }
  };

  function normalizeUpdateOpt(opt) {
    if (opt != null && !isObject$e(opt)) {
      opt = {
        isIgnore: opt
      };
    }

    return opt || {};
  }

  symbolDrawProto.remove = function (enableAnimation) {
    var group = this.group;
    var data = this._data; // Incremental model do not have this._data.

    if (data && enableAnimation) {
      data.eachItemGraphicEl(function (el) {
        el.fadeOut(function () {
          group.remove(el);
        });
      });
    } else {
      group.removeAll();
    }
  };

  function makeSeriesScope(data) {
    var seriesModel = data.hostModel;
    return {
      itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),
      hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),
      symbolRotate: seriesModel.get('symbolRotate'),
      symbolOffset: seriesModel.get('symbolOffset'),
      hoverAnimation: seriesModel.get('hoverAnimation'),
      labelModel: seriesModel.getModel('label'),
      hoverLabelModel: seriesModel.getModel('emphasis.label'),
      cursorStyle: seriesModel.get('cursor')
    };
  }

  var _default$1y = SymbolDraw;
  var SymbolDraw_1 = _default$1y;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var isDimensionStacked$3 = dataStackHelper.isDimensionStacked;



  var map$7 = util.map;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @param {Object} coordSys
   * @param {module:echarts/data/List} data
   * @param {string} valueOrigin lineSeries.option.areaStyle.origin
   */
  function prepareDataCoordInfo(coordSys, data, valueOrigin) {
    var baseAxis = coordSys.getBaseAxis();
    var valueAxis = coordSys.getOtherAxis(baseAxis);
    var valueStart = getValueStart(valueAxis, valueOrigin);
    var baseAxisDim = baseAxis.dim;
    var valueAxisDim = valueAxis.dim;
    var valueDim = data.mapDimension(valueAxisDim);
    var baseDim = data.mapDimension(baseAxisDim);
    var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;
    var dims = map$7(coordSys.dimensions, function (coordDim) {
      return data.mapDimension(coordDim);
    });
    var stacked;
    var stackResultDim = data.getCalculationInfo('stackResultDimension');

    if (stacked |= isDimensionStacked$3(data, dims[0]
    /*, dims[1]*/
    )) {
      // jshint ignore:line
      dims[0] = stackResultDim;
    }

    if (stacked |= isDimensionStacked$3(data, dims[1]
    /*, dims[0]*/
    )) {
      // jshint ignore:line
      dims[1] = stackResultDim;
    }

    return {
      dataDimsForPoint: dims,
      valueStart: valueStart,
      valueAxisDim: valueAxisDim,
      baseAxisDim: baseAxisDim,
      stacked: !!stacked,
      valueDim: valueDim,
      baseDim: baseDim,
      baseDataOffset: baseDataOffset,
      stackedOverDimension: data.getCalculationInfo('stackedOverDimension')
    };
  }

  function getValueStart(valueAxis, valueOrigin) {
    var valueStart = 0;
    var extent = valueAxis.scale.getExtent();

    if (valueOrigin === 'start') {
      valueStart = extent[0];
    } else if (valueOrigin === 'end') {
      valueStart = extent[1];
    } // auto
    else {
        // Both positive
        if (extent[0] > 0) {
          valueStart = extent[0];
        } // Both negative
        else if (extent[1] < 0) {
            valueStart = extent[1];
          } // If is one positive, and one negative, onZero shall be true

      }

    return valueStart;
  }

  function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
    var value = NaN;

    if (dataCoordInfo.stacked) {
      value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);
    }

    if (isNaN(value)) {
      value = dataCoordInfo.valueStart;
    }

    var baseDataOffset = dataCoordInfo.baseDataOffset;
    var stackedData = [];
    stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
    stackedData[1 - baseDataOffset] = value;
    return coordSys.dataToPoint(stackedData);
  }

  var prepareDataCoordInfo_1 = prepareDataCoordInfo;
  var getStackedOnPoint_1 = getStackedOnPoint;

  var helper$3 = {
  	prepareDataCoordInfo: prepareDataCoordInfo_1,
  	getStackedOnPoint: getStackedOnPoint_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var prepareDataCoordInfo$1 = helper$3.prepareDataCoordInfo;
  var getStackedOnPoint$1 = helper$3.getStackedOnPoint;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // var arrayDiff = require('zrender/src/core/arrayDiff');
  // 'zrender/src/core/arrayDiff' has been used before, but it did
  // not do well in performance when roam with fixed dataZoom window.
  // function convertToIntId(newIdList, oldIdList) {
  //     // Generate int id instead of string id.
  //     // Compare string maybe slow in score function of arrDiff
  //     // Assume id in idList are all unique
  //     var idIndicesMap = {};
  //     var idx = 0;
  //     for (var i = 0; i < newIdList.length; i++) {
  //         idIndicesMap[newIdList[i]] = idx;
  //         newIdList[i] = idx++;
  //     }
  //     for (var i = 0; i < oldIdList.length; i++) {
  //         var oldId = oldIdList[i];
  //         // Same with newIdList
  //         if (idIndicesMap[oldId]) {
  //             oldIdList[i] = idIndicesMap[oldId];
  //         }
  //         else {
  //             oldIdList[i] = idx++;
  //         }
  //     }
  // }
  function diffData(oldData, newData) {
    var diffResult = [];
    newData.diff(oldData).add(function (idx) {
      diffResult.push({
        cmd: '+',
        idx: idx
      });
    }).update(function (newIdx, oldIdx) {
      diffResult.push({
        cmd: '=',
        idx: oldIdx,
        idx1: newIdx
      });
    }).remove(function (idx) {
      diffResult.push({
        cmd: '-',
        idx: idx
      });
    }).execute();
    return diffResult;
  }

  function _default$1z(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
    var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);
    // var oldIdList = oldData.mapArray(oldData.getId);
    // convertToIntId(newIdList, oldIdList);
    // // FIXME One data ?
    // diff = arrayDiff(oldIdList, newIdList);

    var currPoints = [];
    var nextPoints = []; // Points for stacking base line

    var currStackedPoints = [];
    var nextStackedPoints = [];
    var status = [];
    var sortedIndices = [];
    var rawIndices = [];
    var newDataOldCoordInfo = prepareDataCoordInfo$1(oldCoordSys, newData, oldValueOrigin);
    var oldDataNewCoordInfo = prepareDataCoordInfo$1(newCoordSys, oldData, newValueOrigin);

    for (var i = 0; i < diff.length; i++) {
      var diffItem = diff[i];
      var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast
      // Which is in case remvoing or add more than one data in the tail or head

      switch (diffItem.cmd) {
        case '=':
          var currentPt = oldData.getItemLayout(diffItem.idx);
          var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly

          if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
            currentPt = nextPt.slice();
          }

          currPoints.push(currentPt);
          nextPoints.push(nextPt);
          currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
          nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
          rawIndices.push(newData.getRawIndex(diffItem.idx1));
          break;

        case '+':
          var idx = diffItem.idx;
          currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));
          nextPoints.push(newData.getItemLayout(idx).slice());
          currStackedPoints.push(getStackedOnPoint$1(newDataOldCoordInfo, oldCoordSys, newData, idx));
          nextStackedPoints.push(newStackedOnPoints[idx]);
          rawIndices.push(newData.getRawIndex(idx));
          break;

        case '-':
          var idx = diffItem.idx;
          var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue
          // FIXME FIXME FIXME

          if (rawIndex !== idx) {
            currPoints.push(oldData.getItemLayout(idx));
            nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));
            currStackedPoints.push(oldStackedOnPoints[idx]);
            nextStackedPoints.push(getStackedOnPoint$1(oldDataNewCoordInfo, newCoordSys, oldData, idx));
            rawIndices.push(rawIndex);
          } else {
            pointAdded = false;
          }

      } // Original indices


      if (pointAdded) {
        status.push(diffItem);
        sortedIndices.push(sortedIndices.length);
      }
    } // Diff result may be crossed if all items are changed
    // Sort by data index


    sortedIndices.sort(function (a, b) {
      return rawIndices[a] - rawIndices[b];
    });
    var sortedCurrPoints = [];
    var sortedNextPoints = [];
    var sortedCurrStackedPoints = [];
    var sortedNextStackedPoints = [];
    var sortedStatus = [];

    for (var i = 0; i < sortedIndices.length; i++) {
      var idx = sortedIndices[i];
      sortedCurrPoints[i] = currPoints[idx];
      sortedNextPoints[i] = nextPoints[idx];
      sortedCurrStackedPoints[i] = currStackedPoints[idx];
      sortedNextStackedPoints[i] = nextStackedPoints[idx];
      sortedStatus[i] = status[idx];
    }

    return {
      current: sortedCurrPoints,
      next: sortedNextPoints,
      stackedOnCurrent: sortedCurrStackedPoints,
      stackedOnNext: sortedNextStackedPoints,
      status: sortedStatus
    };
  }

  var lineAnimationDiff = _default$1z;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Poly path support NaN point
  var vec2Min = vector.min;
  var vec2Max = vector.max;
  var scaleAndAdd$1 = vector.scaleAndAdd;
  var v2Copy = vector.copy; // Temporary variable

  var v = [];
  var cp0 = [];
  var cp1 = [];

  function isPointNull(p) {
    return isNaN(p[0]) || isNaN(p[1]);
  }

  function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
    // if (smoothMonotone == null) {
    //     if (isMono(points, 'x')) {
    //         return drawMono(ctx, points, start, segLen, allLen,
    //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);
    //     }
    //     else if (isMono(points, 'y')) {
    //         return drawMono(ctx, points, start, segLen, allLen,
    //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);
    //     }
    //     else {
    //         return drawNonMono.apply(this, arguments);
    //     }
    // }
    // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {
    //     return drawMono.apply(this, arguments);
    // }
    // else {
    //     return drawNonMono.apply(this, arguments);
    // }
    if (smoothMonotone === 'none' || !smoothMonotone) {
      return drawNonMono.apply(this, arguments);
    } else {
      return drawMono.apply(this, arguments);
    }
  }
  /**
   * Check if points is in monotone.
   *
   * @param {number[][]} points         Array of points which is in [x, y] form
   * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which
   *                                    dimension that is checking.
   *                                    If is 'none', `drawNonMono` should be
   *                                    called.
   *                                    If is undefined, either being monotone
   *                                    in 'x' or 'y' will call `drawMono`.
   */
  // function isMono(points, smoothMonotone) {
  //     if (points.length <= 1) {
  //         return true;
  //     }
  //     var dim = smoothMonotone === 'x' ? 0 : 1;
  //     var last = points[0][dim];
  //     var lastDiff = 0;
  //     for (var i = 1; i < points.length; ++i) {
  //         var diff = points[i][dim] - last;
  //         if (!isNaN(diff) && !isNaN(lastDiff)
  //             && diff !== 0 && lastDiff !== 0
  //             && ((diff >= 0) !== (lastDiff >= 0))
  //         ) {
  //             return false;
  //         }
  //         if (!isNaN(diff) && diff !== 0) {
  //             lastDiff = diff;
  //             last = points[i][dim];
  //         }
  //     }
  //     return true;
  // }

  /**
   * Draw smoothed line in monotone, in which only vertical or horizontal bezier
   * control points will be used. This should be used when points are monotone
   * either in x or y dimension.
   */


  function drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
    var prevIdx = 0;
    var idx = start;

    for (var k = 0; k < segLen; k++) {
      var p = points[idx];

      if (idx >= allLen || idx < 0) {
        break;
      }

      if (isPointNull(p)) {
        if (connectNulls) {
          idx += dir;
          continue;
        }

        break;
      }

      if (idx === start) {
        ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
      } else {
        if (smooth > 0) {
          var prevP = points[prevIdx];
          var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both

          var ctrlLen = (p[dim] - prevP[dim]) * smooth;
          v2Copy(cp0, prevP);
          cp0[dim] = prevP[dim] + ctrlLen;
          v2Copy(cp1, p);
          cp1[dim] = p[dim] - ctrlLen;
          ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
        } else {
          ctx.lineTo(p[0], p[1]);
        }
      }

      prevIdx = idx;
      idx += dir;
    }

    return k;
  }
  /**
   * Draw smoothed line in non-monotone, in may cause undesired curve in extreme
   * situations. This should be used when points are non-monotone neither in x or
   * y dimension.
   */


  function drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
    var prevIdx = 0;
    var idx = start;

    for (var k = 0; k < segLen; k++) {
      var p = points[idx];

      if (idx >= allLen || idx < 0) {
        break;
      }

      if (isPointNull(p)) {
        if (connectNulls) {
          idx += dir;
          continue;
        }

        break;
      }

      if (idx === start) {
        ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
        v2Copy(cp0, p);
      } else {
        if (smooth > 0) {
          var nextIdx = idx + dir;
          var nextP = points[nextIdx];

          if (connectNulls) {
            // Find next point not null
            while (nextP && isPointNull(points[nextIdx])) {
              nextIdx += dir;
              nextP = points[nextIdx];
            }
          }

          var ratioNextSeg = 0.5;
          var prevP = points[prevIdx];
          var nextP = points[nextIdx]; // Last point

          if (!nextP || isPointNull(nextP)) {
            v2Copy(cp1, p);
          } else {
            // If next data is null in not connect case
            if (isPointNull(nextP) && !connectNulls) {
              nextP = p;
            }

            vector.sub(v, nextP, prevP);
            var lenPrevSeg;
            var lenNextSeg;

            if (smoothMonotone === 'x' || smoothMonotone === 'y') {
              var dim = smoothMonotone === 'x' ? 0 : 1;
              lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
              lenNextSeg = Math.abs(p[dim] - nextP[dim]);
            } else {
              lenPrevSeg = vector.dist(p, prevP);
              lenNextSeg = vector.dist(p, nextP);
            } // Use ratio of seg length


            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            scaleAndAdd$1(cp1, p, v, -smooth * (1 - ratioNextSeg));
          } // Smooth constraint


          vec2Min(cp0, cp0, smoothMax);
          vec2Max(cp0, cp0, smoothMin);
          vec2Min(cp1, cp1, smoothMax);
          vec2Max(cp1, cp1, smoothMin);
          ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment

          scaleAndAdd$1(cp0, p, v, smooth * ratioNextSeg);
        } else {
          ctx.lineTo(p[0], p[1]);
        }
      }

      prevIdx = idx;
      idx += dir;
    }

    return k;
  }

  function getBoundingBox(points, smoothConstraint) {
    var ptMin = [Infinity, Infinity];
    var ptMax = [-Infinity, -Infinity];

    if (smoothConstraint) {
      for (var i = 0; i < points.length; i++) {
        var pt = points[i];

        if (pt[0] < ptMin[0]) {
          ptMin[0] = pt[0];
        }

        if (pt[1] < ptMin[1]) {
          ptMin[1] = pt[1];
        }

        if (pt[0] > ptMax[0]) {
          ptMax[0] = pt[0];
        }

        if (pt[1] > ptMax[1]) {
          ptMax[1] = pt[1];
        }
      }
    }

    return {
      min: smoothConstraint ? ptMin : ptMax,
      max: smoothConstraint ? ptMax : ptMin
    };
  }

  var Polyline$1 = Path_1.extend({
    type: 'ec-polyline',
    shape: {
      points: [],
      smooth: 0,
      smoothConstraint: true,
      smoothMonotone: null,
      connectNulls: false
    },
    style: {
      fill: null,
      stroke: '#000'
    },
    brush: fixClipWithShadow(Path_1.prototype.brush),
    buildPath: function (ctx, shape) {
      var points = shape.points;
      var i = 0;
      var len = points.length;
      var result = getBoundingBox(points, shape.smoothConstraint);

      if (shape.connectNulls) {
        // Must remove first and last null values avoid draw error in polygon
        for (; len > 0; len--) {
          if (!isPointNull(points[len - 1])) {
            break;
          }
        }

        for (; i < len; i++) {
          if (!isPointNull(points[i])) {
            break;
          }
        }
      }

      while (i < len) {
        i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
      }
    }
  });
  var Polygon$1 = Path_1.extend({
    type: 'ec-polygon',
    shape: {
      points: [],
      // Offset between stacked base points and points
      stackedOnPoints: [],
      smooth: 0,
      stackedOnSmooth: 0,
      smoothConstraint: true,
      smoothMonotone: null,
      connectNulls: false
    },
    brush: fixClipWithShadow(Path_1.prototype.brush),
    buildPath: function (ctx, shape) {
      var points = shape.points;
      var stackedOnPoints = shape.stackedOnPoints;
      var i = 0;
      var len = points.length;
      var smoothMonotone = shape.smoothMonotone;
      var bbox = getBoundingBox(points, shape.smoothConstraint);
      var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);

      if (shape.connectNulls) {
        // Must remove first and last null values avoid draw error in polygon
        for (; len > 0; len--) {
          if (!isPointNull(points[len - 1])) {
            break;
          }
        }

        for (; i < len; i++) {
          if (!isPointNull(points[i])) {
            break;
          }
        }
      }

      while (i < len) {
        var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
        drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
        i += k + 1;
        ctx.closePath();
      }
    }
  });
  var Polyline_1$1 = Polyline$1;
  var Polygon_1$1 = Polygon$1;

  var poly$1 = {
  	Polyline: Polyline_1$1,
  	Polygon: Polygon_1$1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  var round$3 = number.round;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function createGridClipPath(cartesian, hasAnimation, seriesModel) {
    var rect = cartesian.getArea();
    var isHorizontal = cartesian.getBaseAxis().isHorizontal();
    var x = rect.x;
    var y = rect.y;
    var width = rect.width;
    var height = rect.height;
    var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand the clip path a bit to avoid the border is clipped and looks thinner

    x -= lineWidth / 2;
    y -= lineWidth / 2;
    width += lineWidth;
    height += lineWidth; // fix: https://github.com/apache/incubator-echarts/issues/11369

    x = Math.floor(x);
    width = Math.round(width);
    var clipPath = new graphic.Rect({
      shape: {
        x: x,
        y: y,
        width: width,
        height: height
      }
    });

    if (hasAnimation) {
      clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;
      graphic.initProps(clipPath, {
        shape: {
          width: width,
          height: height
        }
      }, seriesModel);
    }

    return clipPath;
  }

  function createPolarClipPath(polar, hasAnimation, seriesModel) {
    var sectorArea = polar.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.

    var clipPath = new graphic.Sector({
      shape: {
        cx: round$3(polar.cx, 1),
        cy: round$3(polar.cy, 1),
        r0: round$3(sectorArea.r0, 1),
        r: round$3(sectorArea.r, 1),
        startAngle: sectorArea.startAngle,
        endAngle: sectorArea.endAngle,
        clockwise: sectorArea.clockwise
      }
    });

    if (hasAnimation) {
      clipPath.shape.endAngle = sectorArea.startAngle;
      graphic.initProps(clipPath, {
        shape: {
          endAngle: sectorArea.endAngle
        }
      }, seriesModel);
    }

    return clipPath;
  }

  function createClipPath(coordSys, hasAnimation, seriesModel) {
    if (!coordSys) {
      return null;
    } else if (coordSys.type === 'polar') {
      return createPolarClipPath(coordSys, hasAnimation, seriesModel);
    } else if (coordSys.type === 'cartesian2d') {
      return createGridClipPath(coordSys, hasAnimation, seriesModel);
    }

    return null;
  }

  var createGridClipPath_1 = createGridClipPath;
  var createPolarClipPath_1 = createPolarClipPath;
  var createClipPath_1 = createClipPath;

  var createClipPathFromCoordSys = {
  	createGridClipPath: createGridClipPath_1,
  	createPolarClipPath: createPolarClipPath_1,
  	createClipPath: createClipPath_1
  };

  var fromPoints$1 = bbox.fromPoints;













  var Polyline$2 = poly$1.Polyline;
  var Polygon$2 = poly$1.Polygon;





  var prepareDataCoordInfo$2 = helper$3.prepareDataCoordInfo;
  var getStackedOnPoint$2 = helper$3.getStackedOnPoint;



  var createGridClipPath$1 = createClipPathFromCoordSys.createGridClipPath;
  var createPolarClipPath$1 = createClipPathFromCoordSys.createPolarClipPath;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // FIXME step not support polar
  function isPointsSame(points1, points2) {
    if (points1.length !== points2.length) {
      return;
    }

    for (var i = 0; i < points1.length; i++) {
      var p1 = points1[i];
      var p2 = points2[i];

      if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
        return;
      }
    }

    return true;
  }

  function getBoundingDiff(points1, points2) {
    var min1 = [];
    var max1 = [];
    var min2 = [];
    var max2 = [];
    fromPoints$1(points1, min1, max1);
    fromPoints$1(points2, min2, max2); // Get a max value from each corner of two boundings.

    return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));
  }

  function getSmooth(smooth) {
    return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;
  }
  /**
   * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys
   * @param {module:echarts/data/List} data
   * @param {Object} dataCoordInfo
   * @param {Array.<Array.<number>>} points
   */


  function getStackedOnPoints(coordSys, data, dataCoordInfo) {
    if (!dataCoordInfo.valueDim) {
      return [];
    }

    var points = [];

    for (var idx = 0, len = data.count(); idx < len; idx++) {
      points.push(getStackedOnPoint$2(dataCoordInfo, coordSys, data, idx));
    }

    return points;
  }

  function turnPointsIntoStep(points, coordSys, stepTurnAt) {
    var baseAxis = coordSys.getBaseAxis();
    var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
    var stepPoints = [];

    for (var i = 0; i < points.length - 1; i++) {
      var nextPt = points[i + 1];
      var pt = points[i];
      stepPoints.push(pt);
      var stepPt = [];

      switch (stepTurnAt) {
        case 'end':
          stepPt[baseIndex] = nextPt[baseIndex];
          stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start

          stepPoints.push(stepPt);
          break;

        case 'middle':
          // default is start
          var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
          var stepPt2 = [];
          stepPt[baseIndex] = stepPt2[baseIndex] = middle;
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt);
          stepPoints.push(stepPt2);
          break;

        default:
          stepPt[baseIndex] = pt[baseIndex];
          stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start

          stepPoints.push(stepPt);
      }
    } // Last points


    points[i] && stepPoints.push(points[i]);
    return stepPoints;
  }

  function getVisualGradient(data, coordSys) {
    var visualMetaList = data.getVisual('visualMeta');

    if (!visualMetaList || !visualMetaList.length || !data.count()) {
      // When data.count() is 0, gradient range can not be calculated.
      return;
    }

    if (coordSys.type !== 'cartesian2d') {
      return;
    }

    var coordDim;
    var visualMeta;

    for (var i = visualMetaList.length - 1; i >= 0; i--) {
      var dimIndex = visualMetaList[i].dimension;
      var dimName = data.dimensions[dimIndex];
      var dimInfo = data.getDimensionInfo(dimName);
      coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y

      if (coordDim === 'x' || coordDim === 'y') {
        visualMeta = visualMetaList[i];
        break;
      }
    }

    if (!visualMeta) {
      return;
    } // If the area to be rendered is bigger than area defined by LinearGradient,
    // the canvas spec prescribes that the color of the first stop and the last
    // stop should be used. But if two stops are added at offset 0, in effect
    // browsers use the color of the second stop to render area outside
    // LinearGradient. So we can only infinitesimally extend area defined in
    // LinearGradient to render `outerColors`.


    var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.

    var colorStops = util.map(visualMeta.stops, function (stop) {
      return {
        coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
        color: stop.color
      };
    });
    var stopLen = colorStops.length;
    var outerColors = visualMeta.outerColors.slice();

    if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
      colorStops.reverse();
      outerColors.reverse();
    }

    var tinyExtent = 10; // Arbitrary value: 10px

    var minCoord = colorStops[0].coord - tinyExtent;
    var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
    var coordSpan = maxCoord - minCoord;

    if (coordSpan < 1e-3) {
      return 'transparent';
    }

    util.each(colorStops, function (stop) {
      stop.offset = (stop.coord - minCoord) / coordSpan;
    });
    colorStops.push({
      offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
      color: outerColors[1] || 'transparent'
    });
    colorStops.unshift({
      // notice colorStops.length have been changed.
      offset: stopLen ? colorStops[0].offset : 0.5,
      color: outerColors[0] || 'transparent'
    }); // zrUtil.each(colorStops, function (colorStop) {
    //     // Make sure each offset has rounded px to avoid not sharp edge
    //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);
    // });

    var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
    gradient[coordDim] = minCoord;
    gradient[coordDim + '2'] = maxCoord;
    return gradient;
  }

  function getIsIgnoreFunc(seriesModel, data, coordSys) {
    var showAllSymbol = seriesModel.get('showAllSymbol');
    var isAuto = showAllSymbol === 'auto';

    if (showAllSymbol && !isAuto) {
      return;
    }

    var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

    if (!categoryAxis) {
      return;
    } // Note that category label interval strategy might bring some weird effect
    // in some scenario: users may wonder why some of the symbols are not
    // displayed. So we show all symbols as possible as we can.


    if (isAuto // Simplify the logic, do not determine label overlap here.
    && canShowAllSymbolForCategory(categoryAxis, data)) {
      return;
    } // Otherwise follow the label interval strategy on category axis.


    var categoryDataDim = data.mapDimension(categoryAxis.dim);
    var labelMap = {};
    util.each(categoryAxis.getViewLabels(), function (labelItem) {
      labelMap[labelItem.tickValue] = 1;
    });
    return function (dataIndex) {
      return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
    };
  }

  function canShowAllSymbolForCategory(categoryAxis, data) {
    // In mose cases, line is monotonous on category axis, and the label size
    // is close with each other. So we check the symbol size and some of the
    // label size alone with the category axis to estimate whether all symbol
    // can be shown without overlap.
    var axisExtent = categoryAxis.getExtent();
    var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
    isNaN(availSize) && (availSize = 0); // 0/0 is NaN.
    // Sampling some points, max 5.

    var dataLen = data.count();
    var step = Math.max(1, Math.round(dataLen / 5));

    for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
      if (_Symbol.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.
      )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number
      * 1.5 > availSize) {
        return false;
      }
    }

    return true;
  }

  function createLineClipPath(coordSys, hasAnimation, seriesModel) {
    if (coordSys.type === 'cartesian2d') {
      var isHorizontal = coordSys.getBaseAxis().isHorizontal();
      var clipPath = createGridClipPath$1(coordSys, hasAnimation, seriesModel); // Expand clip shape to avoid clipping when line value exceeds axis

      if (!seriesModel.get('clip', true)) {
        var rectShape = clipPath.shape;
        var expandSize = Math.max(rectShape.width, rectShape.height);

        if (isHorizontal) {
          rectShape.y -= expandSize;
          rectShape.height += expandSize * 2;
        } else {
          rectShape.x -= expandSize;
          rectShape.width += expandSize * 2;
        }
      }

      return clipPath;
    } else {
      return createPolarClipPath$1(coordSys, hasAnimation, seriesModel);
    }
  }

  var _default$1A = Chart_1.extend({
    type: 'line',
    init: function () {
      var lineGroup = new graphic.Group();
      var symbolDraw = new SymbolDraw_1();
      this.group.add(symbolDraw.group);
      this._symbolDraw = symbolDraw;
      this._lineGroup = lineGroup;
    },
    render: function (seriesModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var group = this.group;
      var data = seriesModel.getData();
      var lineStyleModel = seriesModel.getModel('lineStyle');
      var areaStyleModel = seriesModel.getModel('areaStyle');
      var points = data.mapArray(data.getItemLayout);
      var isCoordSysPolar = coordSys.type === 'polar';
      var prevCoordSys = this._coordSys;
      var symbolDraw = this._symbolDraw;
      var polyline = this._polyline;
      var polygon = this._polygon;
      var lineGroup = this._lineGroup;
      var hasAnimation = seriesModel.get('animation');
      var isAreaChart = !areaStyleModel.isEmpty();
      var valueOrigin = areaStyleModel.get('origin');
      var dataCoordInfo = prepareDataCoordInfo$2(coordSys, data, valueOrigin);
      var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);
      var showSymbol = seriesModel.get('showSymbol');
      var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols

      var oldData = this._data;
      oldData && oldData.eachItemGraphicEl(function (el, idx) {
        if (el.__temp) {
          group.remove(el);
          oldData.setItemGraphicEl(idx, null);
        }
      }); // Remove previous created symbols if showSymbol changed to false

      if (!showSymbol) {
        symbolDraw.remove();
      }

      group.add(lineGroup); // FIXME step not support polar

      var step = !isCoordSysPolar && seriesModel.get('step');
      var clipShapeForSymbol;

      if (coordSys && coordSys.getArea && seriesModel.get('clip', true)) {
        clipShapeForSymbol = coordSys.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.
        // See #7913 and `test/dataZoom-clip.html`.

        if (clipShapeForSymbol.width != null) {
          clipShapeForSymbol.x -= 0.1;
          clipShapeForSymbol.y -= 0.1;
          clipShapeForSymbol.width += 0.2;
          clipShapeForSymbol.height += 0.2;
        } else if (clipShapeForSymbol.r0) {
          clipShapeForSymbol.r0 -= 0.5;
          clipShapeForSymbol.r1 += 0.5;
        }
      }

      this._clipShapeForSymbol = clipShapeForSymbol; // Initialization animation or coordinate system changed

      if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
        showSymbol && symbolDraw.updateData(data, {
          isIgnore: isIgnoreFunc,
          clipShape: clipShapeForSymbol
        });

        if (step) {
          // TODO If stacked series is not step
          points = turnPointsIntoStep(points, coordSys, step);
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
        }

        polyline = this._newPolyline(points, coordSys, hasAnimation);

        if (isAreaChart) {
          polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
        }

        lineGroup.setClipPath(createLineClipPath(coordSys, true, seriesModel));
      } else {
        if (isAreaChart && !polygon) {
          // If areaStyle is added
          polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
        } else if (polygon && !isAreaChart) {
          // If areaStyle is removed
          lineGroup.remove(polygon);
          polygon = this._polygon = null;
        } // Update clipPath


        lineGroup.setClipPath(createLineClipPath(coordSys, false, seriesModel)); // Always update, or it is wrong in the case turning on legend
        // because points are not changed

        showSymbol && symbolDraw.updateData(data, {
          isIgnore: isIgnoreFunc,
          clipShape: clipShapeForSymbol
        }); // Stop symbol animation and sync with line points
        // FIXME performance?

        data.eachItemGraphicEl(function (el) {
          el.stopAnimation(true);
        }); // In the case data zoom triggerred refreshing frequently
        // Data may not change if line has a category axis. So it should animate nothing

        if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
          if (hasAnimation) {
            this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);
          } else {
            // Not do it in update with animation
            if (step) {
              // TODO If stacked series is not step
              points = turnPointsIntoStep(points, coordSys, step);
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
            }

            polyline.setShape({
              points: points
            });
            polygon && polygon.setShape({
              points: points,
              stackedOnPoints: stackedOnPoints
            });
          }
        }
      }

      var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');
      polyline.useStyle(util.defaults( // Use color in lineStyle first
      lineStyleModel.getLineStyle(), {
        fill: 'none',
        stroke: visualColor,
        lineJoin: 'bevel'
      }));
      var smooth = seriesModel.get('smooth');
      smooth = getSmooth(seriesModel.get('smooth'));
      polyline.setShape({
        smooth: smooth,
        smoothMonotone: seriesModel.get('smoothMonotone'),
        connectNulls: seriesModel.get('connectNulls')
      });

      if (polygon) {
        var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
        var stackedOnSmooth = 0;
        polygon.useStyle(util.defaults(areaStyleModel.getAreaStyle(), {
          fill: visualColor,
          opacity: 0.7,
          lineJoin: 'bevel'
        }));

        if (stackedOnSeries) {
          stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
        }

        polygon.setShape({
          smooth: smooth,
          stackedOnSmooth: stackedOnSmooth,
          smoothMonotone: seriesModel.get('smoothMonotone'),
          connectNulls: seriesModel.get('connectNulls')
        });
      }

      this._data = data; // Save the coordinate system for transition animation when data changed

      this._coordSys = coordSys;
      this._stackedOnPoints = stackedOnPoints;
      this._points = points;
      this._step = step;
      this._valueOrigin = valueOrigin;
    },
    dispose: function () {},
    highlight: function (seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var dataIndex = model.queryDataIndex(data, payload);

      if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
        var symbol = data.getItemGraphicEl(dataIndex);

        if (!symbol) {
          // Create a temporary symbol if it is not exists
          var pt = data.getItemLayout(dataIndex);

          if (!pt) {
            // Null data
            return;
          } // fix #11360: should't draw symbol outside clipShapeForSymbol


          if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(pt[0], pt[1])) {
            return;
          }

          symbol = new _Symbol(data, dataIndex);
          symbol.position = pt;
          symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
          symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
          symbol.__temp = true;
          data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation

          symbol.stopSymbolAnimation(true);
          this.group.add(symbol);
        }

        symbol.highlight();
      } else {
        // Highlight whole series
        Chart_1.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
      }
    },
    downplay: function (seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var dataIndex = model.queryDataIndex(data, payload);

      if (dataIndex != null && dataIndex >= 0) {
        var symbol = data.getItemGraphicEl(dataIndex);

        if (symbol) {
          if (symbol.__temp) {
            data.setItemGraphicEl(dataIndex, null);
            this.group.remove(symbol);
          } else {
            symbol.downplay();
          }
        }
      } else {
        // FIXME
        // can not downplay completely.
        // Downplay whole series
        Chart_1.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
      }
    },

    /**
     * @param {module:zrender/container/Group} group
     * @param {Array.<Array.<number>>} points
     * @private
     */
    _newPolyline: function (points) {
      var polyline = this._polyline; // Remove previous created polyline

      if (polyline) {
        this._lineGroup.remove(polyline);
      }

      polyline = new Polyline$2({
        shape: {
          points: points
        },
        silent: true,
        z2: 10
      });

      this._lineGroup.add(polyline);

      this._polyline = polyline;
      return polyline;
    },

    /**
     * @param {module:zrender/container/Group} group
     * @param {Array.<Array.<number>>} stackedOnPoints
     * @param {Array.<Array.<number>>} points
     * @private
     */
    _newPolygon: function (points, stackedOnPoints) {
      var polygon = this._polygon; // Remove previous created polygon

      if (polygon) {
        this._lineGroup.remove(polygon);
      }

      polygon = new Polygon$2({
        shape: {
          points: points,
          stackedOnPoints: stackedOnPoints
        },
        silent: true
      });

      this._lineGroup.add(polygon);

      this._polygon = polygon;
      return polygon;
    },

    /**
     * @private
     */
    // FIXME Two value axis
    _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {
      var polyline = this._polyline;
      var polygon = this._polygon;
      var seriesModel = data.hostModel;
      var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
      var current = diff.current;
      var stackedOnCurrent = diff.stackedOnCurrent;
      var next = diff.next;
      var stackedOnNext = diff.stackedOnNext;

      if (step) {
        // TODO If stacked series is not step
        current = turnPointsIntoStep(diff.current, coordSys, step);
        stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
        next = turnPointsIntoStep(diff.next, coordSys, step);
        stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
      } // Don't apply animation if diff is large.
      // For better result and avoid memory explosion problems like
      // https://github.com/apache/incubator-echarts/issues/12229


      if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {
        polyline.setShape({
          points: next
        });

        if (polygon) {
          polygon.setShape({
            points: next,
            stackedOnPoints: stackedOnNext
          });
        }

        return;
      } // `diff.current` is subset of `current` (which should be ensured by
      // turnPointsIntoStep), so points in `__points` can be updated when
      // points in `current` are update during animation.


      polyline.shape.__points = diff.current;
      polyline.shape.points = current;
      graphic.updateProps(polyline, {
        shape: {
          points: next
        }
      }, seriesModel);

      if (polygon) {
        polygon.setShape({
          points: current,
          stackedOnPoints: stackedOnCurrent
        });
        graphic.updateProps(polygon, {
          shape: {
            points: next,
            stackedOnPoints: stackedOnNext
          }
        }, seriesModel);
      }

      var updatedDataInfo = [];
      var diffStatus = diff.status;

      for (var i = 0; i < diffStatus.length; i++) {
        var cmd = diffStatus[i].cmd;

        if (cmd === '=') {
          var el = data.getItemGraphicEl(diffStatus[i].idx1);

          if (el) {
            updatedDataInfo.push({
              el: el,
              ptIdx: i // Index of points

            });
          }
        }
      }

      if (polyline.animators && polyline.animators.length) {
        polyline.animators[0].during(function () {
          for (var i = 0; i < updatedDataInfo.length; i++) {
            var el = updatedDataInfo[i].el;
            el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);
          }
        });
      }
    },
    remove: function (ecModel) {
      var group = this.group;
      var oldData = this._data;

      this._lineGroup.removeAll();

      this._symbolDraw.remove(true); // Remove temporary created elements when highlighting


      oldData && oldData.eachItemGraphicEl(function (el, idx) {
        if (el.__temp) {
          group.remove(el);
          oldData.setItemGraphicEl(idx, null);
        }
      });
      this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var isFunction$5 = util.isFunction;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function _default$1B(seriesType, defaultSymbolType, legendSymbol) {
    // Encoding visual for all series include which is filtered for legend drawing
    return {
      seriesType: seriesType,
      // For legend.
      performRawSeries: true,
      reset: function (seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var symbolType = seriesModel.get('symbol');
        var symbolSize = seriesModel.get('symbolSize');
        var keepAspect = seriesModel.get('symbolKeepAspect');
        var symbolRotate = seriesModel.get('symbolRotate');
        var hasSymbolTypeCallback = isFunction$5(symbolType);
        var hasSymbolSizeCallback = isFunction$5(symbolSize);
        var hasSymbolRotateCallback = isFunction$5(symbolRotate);
        var hasCallback = hasSymbolTypeCallback || hasSymbolSizeCallback || hasSymbolRotateCallback;
        var seriesSymbol = !hasSymbolTypeCallback && symbolType ? symbolType : defaultSymbolType;
        var seriesSymbolSize = !hasSymbolSizeCallback ? symbolSize : null;
        data.setVisual({
          legendSymbol: legendSymbol || seriesSymbol,
          // If seting callback functions on `symbol` or `symbolSize`, for simplicity and avoiding
          // to bring trouble, we do not pick a reuslt from one of its calling on data item here,
          // but just use the default value. Callback on `symbol` or `symbolSize` is convenient in
          // some cases but generally it is not recommanded.
          symbol: seriesSymbol,
          symbolSize: seriesSymbolSize,
          symbolKeepAspect: keepAspect,
          symbolRotate: symbolRotate
        }); // Only visible series has each data be visual encoded

        if (ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }

        function dataEach(data, idx) {
          if (hasCallback) {
            var rawValue = seriesModel.getRawValue(idx);
            var params = seriesModel.getDataParams(idx);
            hasSymbolTypeCallback && data.setItemVisual(idx, 'symbol', symbolType(rawValue, params));
            hasSymbolSizeCallback && data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
            hasSymbolRotateCallback && data.setItemVisual(idx, 'symbolRotate', symbolRotate(rawValue, params));
          }

          if (data.hasItemOption) {
            var itemModel = data.getItemModel(idx);
            var itemSymbolType = itemModel.getShallow('symbol', true);
            var itemSymbolSize = itemModel.getShallow('symbolSize', true);
            var itemSymbolRotate = itemModel.getShallow('symbolRotate', true);
            var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol

            if (itemSymbolType != null) {
              data.setItemVisual(idx, 'symbol', itemSymbolType);
            }

            if (itemSymbolSize != null) {
              // PENDING Transform symbolSize ?
              data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
            }

            if (itemSymbolRotate != null) {
              data.setItemVisual(idx, 'symbolRotate', itemSymbolRotate);
            }

            if (itemSymbolKeepAspect != null) {
              data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);
            }
          }
        }

        return {
          dataEach: data.hasItemOption || hasCallback ? dataEach : null
        };
      }
    };
  }

  var symbol$1 = _default$1B;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var map$8 = util.map;





  var isDimensionStacked$4 = dataStackHelper.isDimensionStacked;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /* global Float32Array */
  function _default$1C(seriesType) {
    return {
      seriesType: seriesType,
      plan: createRenderPlanner(),
      reset: function (seriesModel) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem;
        var pipelineContext = seriesModel.pipelineContext;
        var isLargeRender = pipelineContext.large;

        if (!coordSys) {
          return;
        }

        var dims = map$8(coordSys.dimensions, function (dim) {
          return data.mapDimension(dim);
        }).slice(0, 2);
        var dimLen = dims.length;
        var stackResultDim = data.getCalculationInfo('stackResultDimension');

        if (isDimensionStacked$4(data, dims[0]
        /*, dims[1]*/
        )) {
          dims[0] = stackResultDim;
        }

        if (isDimensionStacked$4(data, dims[1]
        /*, dims[0]*/
        )) {
          dims[1] = stackResultDim;
        }

        function progress(params, data) {
          var segCount = params.end - params.start;
          var points = isLargeRender && new Float32Array(segCount * dimLen);

          for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {
            var point;

            if (dimLen === 1) {
              var x = data.get(dims[0], i);
              point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);
            } else {
              var x = tmpIn[0] = data.get(dims[0], i);
              var y = tmpIn[1] = data.get(dims[1], i); // Also {Array.<number>}, not undefined to avoid if...else... statement

              point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);
            }

            if (isLargeRender) {
              points[offset++] = point ? point[0] : NaN;
              points[offset++] = point ? point[1] : NaN;
            } else {
              data.setItemLayout(i, point && point.slice() || [NaN, NaN]);
            }
          }

          isLargeRender && data.setLayout('symbolPoints', points);
        }

        return dimLen && {
          progress: progress
        };
      }
    };
  }

  var points$1 = _default$1C;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var samplers = {
    average: function (frame) {
      var sum = 0;
      var count = 0;

      for (var i = 0; i < frame.length; i++) {
        if (!isNaN(frame[i])) {
          sum += frame[i];
          count++;
        }
      } // Return NaN if count is 0


      return count === 0 ? NaN : sum / count;
    },
    sum: function (frame) {
      var sum = 0;

      for (var i = 0; i < frame.length; i++) {
        // Ignore NaN
        sum += frame[i] || 0;
      }

      return sum;
    },
    max: function (frame) {
      var max = -Infinity;

      for (var i = 0; i < frame.length; i++) {
        frame[i] > max && (max = frame[i]);
      } // NaN will cause illegal axis extent.


      return isFinite(max) ? max : NaN;
    },
    min: function (frame) {
      var min = Infinity;

      for (var i = 0; i < frame.length; i++) {
        frame[i] < min && (min = frame[i]);
      } // NaN will cause illegal axis extent.


      return isFinite(min) ? min : NaN;
    },
    // TODO
    // Median
    nearest: function (frame) {
      return frame[0];
    }
  };

  var indexSampler = function (frame, value) {
    return Math.round(frame.length / 2);
  };

  function _default$1D(seriesType) {
    return {
      seriesType: seriesType,
      modifyOutputEnd: true,
      reset: function (seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var sampling = seriesModel.get('sampling');
        var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling

        if (coordSys.type === 'cartesian2d' && sampling) {
          var baseAxis = coordSys.getBaseAxis();
          var valueAxis = coordSys.getOtherAxis(baseAxis);
          var extent = baseAxis.getExtent(); // Coordinste system has been resized

          var size = Math.abs(extent[1] - extent[0]);
          var rate = Math.round(data.count() / size);

          if (rate > 1) {
            var sampler;

            if (typeof sampling === 'string') {
              sampler = samplers[sampling];
            } else if (typeof sampling === 'function') {
              sampler = sampling;
            }

            if (sampler) {
              // Only support sample the first dim mapped from value axis.
              seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
            }
          }
        }
      }
    };
  }

  var dataSample = _default$1D;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Cartesian coordinate system
   * @module  echarts/coord/Cartesian
   *
   */
  function dimAxisMapper(dim) {
    return this._axes[dim];
  }
  /**
   * @alias module:echarts/coord/Cartesian
   * @constructor
   */


  var Cartesian = function (name) {
    this._axes = {};
    this._dimList = [];
    /**
     * @type {string}
     */

    this.name = name || '';
  };

  Cartesian.prototype = {
    constructor: Cartesian,
    type: 'cartesian',

    /**
     * Get axis
     * @param  {number|string} dim
     * @return {module:echarts/coord/Cartesian~Axis}
     */
    getAxis: function (dim) {
      return this._axes[dim];
    },

    /**
     * Get axes list
     * @return {Array.<module:echarts/coord/Cartesian~Axis>}
     */
    getAxes: function () {
      return util.map(this._dimList, dimAxisMapper, this);
    },

    /**
     * Get axes list by given scale type
     */
    getAxesByScale: function (scaleType) {
      scaleType = scaleType.toLowerCase();
      return util.filter(this.getAxes(), function (axis) {
        return axis.scale.type === scaleType;
      });
    },

    /**
     * Add axis
     * @param {module:echarts/coord/Cartesian.Axis}
     */
    addAxis: function (axis) {
      var dim = axis.dim;
      this._axes[dim] = axis;

      this._dimList.push(dim);
    },

    /**
     * Convert data to coord in nd space
     * @param {Array.<number>|Object.<string, number>} val
     * @return {Array.<number>|Object.<string, number>}
     */
    dataToCoord: function (val) {
      return this._dataCoordConvert(val, 'dataToCoord');
    },

    /**
     * Convert coord in nd space to data
     * @param  {Array.<number>|Object.<string, number>} val
     * @return {Array.<number>|Object.<string, number>}
     */
    coordToData: function (val) {
      return this._dataCoordConvert(val, 'coordToData');
    },
    _dataCoordConvert: function (input, method) {
      var dimList = this._dimList;
      var output = input instanceof Array ? [] : {};

      for (var i = 0; i < dimList.length; i++) {
        var dim = dimList[i];
        var axis = this._axes[dim];
        output[dim] = axis[method](input[dim]);
      }

      return output;
    }
  };
  var _default$1E = Cartesian;
  var Cartesian_1 = _default$1E;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function Cartesian2D(name) {
    Cartesian_1.call(this, name);
  }

  Cartesian2D.prototype = {
    constructor: Cartesian2D,
    type: 'cartesian2d',

    /**
     * @type {Array.<string>}
     * @readOnly
     */
    dimensions: ['x', 'y'],

    /**
     * Base axis will be used on stacking.
     *
     * @return {module:echarts/coord/cartesian/Axis2D}
     */
    getBaseAxis: function () {
      return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
    },

    /**
     * If contain point
     * @param {Array.<number>} point
     * @return {boolean}
     */
    containPoint: function (point) {
      var axisX = this.getAxis('x');
      var axisY = this.getAxis('y');
      return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
    },

    /**
     * If contain data
     * @param {Array.<number>} data
     * @return {boolean}
     */
    containData: function (data) {
      return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
    },

    /**
     * @param {Array.<number>} data
     * @param {Array.<number>} out
     * @return {Array.<number>}
     */
    dataToPoint: function (data, reserved, out) {
      var xAxis = this.getAxis('x');
      var yAxis = this.getAxis('y');
      out = out || [];
      out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));
      out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));
      return out;
    },

    /**
     * @param {Array.<number>} data
     * @param {Array.<number>} out
     * @return {Array.<number>}
     */
    clampData: function (data, out) {
      var xScale = this.getAxis('x').scale;
      var yScale = this.getAxis('y').scale;
      var xAxisExtent = xScale.getExtent();
      var yAxisExtent = yScale.getExtent();
      var x = xScale.parse(data[0]);
      var y = yScale.parse(data[1]);
      out = out || [];
      out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
      out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
      return out;
    },

    /**
     * @param {Array.<number>} point
     * @param {Array.<number>} out
     * @return {Array.<number>}
     */
    pointToData: function (point, out) {
      var xAxis = this.getAxis('x');
      var yAxis = this.getAxis('y');
      out = out || [];
      out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));
      out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));
      return out;
    },

    /**
     * Get other axis
     * @param {module:echarts/coord/cartesian/Axis2D} axis
     */
    getOtherAxis: function (axis) {
      return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
    },

    /**
     * Get rect area of cartesian.
     * Area will have a contain function to determine if a point is in the coordinate system.
     * @return {BoundingRect}
     */
    getArea: function () {
      var xExtent = this.getAxis('x').getGlobalExtent();
      var yExtent = this.getAxis('y').getGlobalExtent();
      var x = Math.min(xExtent[0], xExtent[1]);
      var y = Math.min(yExtent[0], yExtent[1]);
      var width = Math.max(xExtent[0], xExtent[1]) - x;
      var height = Math.max(yExtent[0], yExtent[1]) - y;
      var rect = new BoundingRect_1(x, y, width, height);
      return rect;
    }
  };
  util.inherits(Cartesian2D, Cartesian_1);
  var _default$1F = Cartesian2D;
  var Cartesian2D_1 = _default$1F;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Extend axis 2d
   * @constructor module:echarts/coord/cartesian/Axis2D
   * @extends {module:echarts/coord/cartesian/Axis}
   * @param {string} dim
   * @param {*} scale
   * @param {Array.<number>} coordExtent
   * @param {string} axisType
   * @param {string} position
   */
  var Axis2D = function (dim, scale, coordExtent, axisType, position) {
    Axis_1.call(this, dim, scale, coordExtent);
    /**
     * Axis type
     *  - 'category'
     *  - 'value'
     *  - 'time'
     *  - 'log'
     * @type {string}
     */

    this.type = axisType || 'value';
    /**
     * Axis position
     *  - 'top'
     *  - 'bottom'
     *  - 'left'
     *  - 'right'
     */

    this.position = position || 'bottom';
  };

  Axis2D.prototype = {
    constructor: Axis2D,

    /**
     * Index of axis, can be used as key
     */
    index: 0,

    /**
     * Implemented in <module:echarts/coord/cartesian/Grid>.
     * @return {Array.<module:echarts/coord/cartesian/Axis2D>}
     *         If not on zero of other axis, return null/undefined.
     *         If no axes, return an empty array.
     */
    getAxesOnZeroOf: null,

    /**
     * Axis model
     * @param {module:echarts/coord/cartesian/AxisModel}
     */
    model: null,
    isHorizontal: function () {
      var position = this.position;
      return position === 'top' || position === 'bottom';
    },

    /**
     * Each item cooresponds to this.getExtent(), which
     * means globalExtent[0] may greater than globalExtent[1],
     * unless `asc` is input.
     *
     * @param {boolean} [asc]
     * @return {Array.<number>}
     */
    getGlobalExtent: function (asc) {
      var ret = this.getExtent();
      ret[0] = this.toGlobalCoord(ret[0]);
      ret[1] = this.toGlobalCoord(ret[1]);
      asc && ret[0] > ret[1] && ret.reverse();
      return ret;
    },
    getOtherAxis: function () {
      this.grid.getOtherAxis();
    },

    /**
     * @override
     */
    pointToData: function (point, clamp) {
      return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);
    },

    /**
     * Transform global coord to local coord,
     * i.e. var localCoord = axis.toLocalCoord(80);
     * designate by module:echarts/coord/cartesian/Grid.
     * @type {Function}
     */
    toLocalCoord: null,

    /**
     * Transform global coord to local coord,
     * i.e. var globalCoord = axis.toLocalCoord(40);
     * designate by module:echarts/coord/cartesian/Grid.
     * @type {Function}
     */
    toGlobalCoord: null
  };
  util.inherits(Axis2D, Axis_1);
  var _default$1G = Axis2D;
  var Axis2D_1 = _default$1G;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var defaultOption = {
    show: true,
    zlevel: 0,
    z: 0,
    // Inverse the axis.
    inverse: false,
    // Axis name displayed.
    name: '',
    // 'start' | 'middle' | 'end'
    nameLocation: 'end',
    // By degree. By default auto rotate by nameLocation.
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: '...',
      placeholder: '.'
    },
    // Use global text style by default.
    nameTextStyle: {},
    // The gap between axisName and axisLine.
    nameGap: 15,
    // Default `false` to support tooltip.
    silent: false,
    // Default `false` to avoid legacy user event listener fail.
    triggerEvent: false,
    tooltip: {
      show: false
    },
    axisPointer: {},
    axisLine: {
      show: true,
      onZero: true,
      onZeroAxisIndex: null,
      lineStyle: {
        color: '#333',
        width: 1,
        type: 'solid'
      },
      // The arrow at both ends the the axis.
      symbol: ['none', 'none'],
      symbolSize: [10, 15]
    },
    axisTick: {
      show: true,
      // Whether axisTick is inside the grid or outside the grid.
      inside: false,
      // The length of axisTick.
      length: 5,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      // Whether axisLabel is inside the grid or outside the grid.
      inside: false,
      rotate: 0,
      // true | false | null/undefined (auto)
      showMinLabel: null,
      // true | false | null/undefined (auto)
      showMaxLabel: null,
      margin: 8,
      // formatter: null,
      fontSize: 12
    },
    splitLine: {
      show: true,
      lineStyle: {
        color: ['#ccc'],
        width: 1,
        type: 'solid'
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']
      }
    }
  };
  var axisDefault = {};
  axisDefault.categoryAxis = util.merge({
    // The gap at both ends of the axis. For categoryAxis, boolean.
    boundaryGap: true,
    // Set false to faster category collection.
    // Only usefull in the case like: category is
    // ['2012-01-01', '2012-01-02', ...], where the input
    // data has been ensured not duplicate and is large data.
    // null means "auto":
    // if axis.data provided, do not deduplication,
    // else do deduplication.
    deduplication: null,
    // splitArea: {
    // show: false
    // },
    splitLine: {
      show: false
    },
    axisTick: {
      // If tick is align with label when boundaryGap is true
      alignWithLabel: false,
      interval: 'auto'
    },
    axisLabel: {
      interval: 'auto'
    }
  }, defaultOption);
  axisDefault.valueAxis = util.merge({
    // The gap at both ends of the axis. For value axis, [GAP, GAP], where
    // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)
    boundaryGap: [0, 0],
    // TODO
    // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
    // Min value of the axis. can be:
    // + a number
    // + 'dataMin': use the min value in data.
    // + null/undefined: auto decide min value (consider pretty look and boundaryGap).
    // min: null,
    // Max value of the axis. can be:
    // + a number
    // + 'dataMax': use the max value in data.
    // + null/undefined: auto decide max value (consider pretty look and boundaryGap).
    // max: null,
    // Readonly prop, specifies start value of the range when using data zoom.
    // rangeStart: null
    // Readonly prop, specifies end value of the range when using data zoom.
    // rangeEnd: null
    // Optional value can be:
    // + `false`: always include value 0.
    // + `true`: the extent do not consider value 0.
    // scale: false,
    // AxisTick and axisLabel and splitLine are caculated based on splitNumber.
    splitNumber: 5,
    // Interval specifies the span of the ticks is mandatorily.
    // interval: null
    // Specify min interval when auto calculate tick interval.
    // minInterval: null
    // Specify max interval when auto calculate tick interval.
    // maxInterval: null
    minorTick: {
      // Minor tick, not available for cateogry axis.
      show: false,
      // Split number of minor ticks. The value should be in range of (0, 100)
      splitNumber: 5,
      // Lenght of minor tick
      length: 3,
      // Same inside with axisTick
      // Line style
      lineStyle: {// Default to be same with axisTick
      }
    },
    minorSplitLine: {
      show: false,
      lineStyle: {
        color: '#eee',
        width: 1
      }
    }
  }, defaultOption);
  axisDefault.timeAxis = util.defaults({
    scale: true,
    min: 'dataMin',
    max: 'dataMax'
  }, axisDefault.valueAxis);
  axisDefault.logAxis = util.defaults({
    scale: true,
    logBase: 10
  }, axisDefault.valueAxis);
  var _default$1H = axisDefault;
  var axisDefault_1 = _default$1H;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  var getLayoutParams$2 = layout.getLayoutParams;
  var mergeLayoutParam$2 = layout.mergeLayoutParam;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // FIXME axisType is fixed ?
  var AXIS_TYPES = ['value', 'category', 'time', 'log'];
  /**
   * Generate sub axis model class
   * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
   * @param {module:echarts/model/Component} BaseAxisModelClass
   * @param {Function} axisTypeDefaulter
   * @param {Object} [extraDefaultOption]
   */

  function _default$1I(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
    util.each(AXIS_TYPES, function (axisType) {
      BaseAxisModelClass.extend({
        /**
         * @readOnly
         */
        type: axisName + 'Axis.' + axisType,
        mergeDefaultAndTheme: function (option, ecModel) {
          var layoutMode = this.layoutMode;
          var inputPositionParams = layoutMode ? getLayoutParams$2(option) : {};
          var themeModel = ecModel.getTheme();
          util.merge(option, themeModel.get(axisType + 'Axis'));
          util.merge(option, this.getDefaultOption());
          option.type = axisTypeDefaulter(axisName, option);

          if (layoutMode) {
            mergeLayoutParam$2(option, inputPositionParams, layoutMode);
          }
        },

        /**
         * @override
         */
        optionUpdated: function () {
          var thisOption = this.option;

          if (thisOption.type === 'category') {
            this.__ordinalMeta = OrdinalMeta_1.createByAxisModel(this);
          }
        },

        /**
         * Should not be called before all of 'getInitailData' finished.
         * Because categories are collected during initializing data.
         */
        getCategories: function (rawData) {
          var option = this.option; // FIXME
          // warning if called before all of 'getInitailData' finished.

          if (option.type === 'category') {
            if (rawData) {
              return option.data;
            }

            return this.__ordinalMeta.categories;
          }
        },
        getOrdinalMeta: function () {
          return this.__ordinalMeta;
        },
        defaultOption: util.mergeAll([{}, axisDefault_1[axisType + 'Axis'], extraDefaultOption], true)
      });
    });
    Component.registerSubTypeDefaulter(axisName + 'Axis', util.curry(axisTypeDefaulter, axisName));
  }

  var axisModelCreator = _default$1I;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var AxisModel = Component.extend({
    type: 'cartesian2dAxis',

    /**
     * @type {module:echarts/coord/cartesian/Axis2D}
     */
    axis: null,

    /**
     * @override
     */
    init: function () {
      AxisModel.superApply(this, 'init', arguments);
      this.resetRange();
    },

    /**
     * @override
     */
    mergeOption: function () {
      AxisModel.superApply(this, 'mergeOption', arguments);
      this.resetRange();
    },

    /**
     * @override
     */
    restoreData: function () {
      AxisModel.superApply(this, 'restoreData', arguments);
      this.resetRange();
    },

    /**
     * @override
     * @return {module:echarts/model/Component}
     */
    getCoordSysModel: function () {
      return this.ecModel.queryComponents({
        mainType: 'grid',
        index: this.option.gridIndex,
        id: this.option.gridId
      })[0];
    }
  });

  function getAxisType(axisDim, option) {
    // Default axis with data is category axis
    return option.type || (option.data ? 'category' : 'value');
  }

  util.merge(AxisModel.prototype, axisModelCommonMixin);
  var extraOption = {
    // gridIndex: 0,
    // gridId: '',
    // Offset is for multiple axis on the same position
    offset: 0
  };
  axisModelCreator('x', AxisModel, getAxisType, extraOption);
  axisModelCreator('y', AxisModel, getAxisType, extraOption);

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Grid æ¯å¨æç´è§åæ ç³»çæ¶åå¿é¡»è¦å­å¨ç
  // æä»¥è¿éä¹è¦è¢« Cartesian2D ä¾èµ
  var _default$1J = Component.extend({
    type: 'grid',
    dependencies: ['xAxis', 'yAxis'],
    layoutMode: 'box',

    /**
     * @type {module:echarts/coord/cartesian/Grid}
     */
    coordinateSystem: null,
    defaultOption: {
      show: false,
      zlevel: 0,
      z: 0,
      left: '10%',
      top: 60,
      right: '10%',
      bottom: 60,
      // If grid size contain label
      containLabel: false,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: 'rgba(0,0,0,0)',
      borderWidth: 1,
      borderColor: '#ccc'
    }
  });

  var isObject$f = util.isObject;
  var each$k = util.each;
  var map$9 = util.map;
  var indexOf$4 = util.indexOf;



  var getLayoutRect$1 = layout.getLayoutRect;



  var createScaleByModel$1 = axisHelper.createScaleByModel;
  var ifAxisCrossZero$1 = axisHelper.ifAxisCrossZero;
  var niceScaleExtent$1 = axisHelper.niceScaleExtent;
  var estimateLabelUnionRect$1 = axisHelper.estimateLabelUnionRect;









  var getStackedDimension$2 = dataStackHelper.getStackedDimension;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Grid is a region which contains at most 4 cartesian systems
   *
   * TODO Default cartesian
   */
  // Depends on GridModel, AxisModel, which performs preprocess.

  /**
   * Check if the axis is used in the specified grid
   * @inner
   */
  function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
    return axisModel.getCoordSysModel() === gridModel;
  }

  function Grid(gridModel, ecModel, api) {
    /**
     * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
     * @private
     */
    this._coordsMap = {};
    /**
     * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
     * @private
     */

    this._coordsList = [];
    /**
     * @type {Object.<string, Array.<module:echarts/coord/cartesian/Axis2D>>}
     * @private
     */

    this._axesMap = {};
    /**
     * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
     * @private
     */

    this._axesList = [];

    this._initCartesian(gridModel, ecModel, api);

    this.model = gridModel;
  }

  var gridProto = Grid.prototype;
  gridProto.type = 'grid';
  gridProto.axisPointerEnabled = true;

  gridProto.getRect = function () {
    return this._rect;
  };

  gridProto.update = function (ecModel, api) {
    var axesMap = this._axesMap;

    this._updateScale(ecModel, this.model);

    each$k(axesMap.x, function (xAxis) {
      niceScaleExtent$1(xAxis.scale, xAxis.model);
    });
    each$k(axesMap.y, function (yAxis) {
      niceScaleExtent$1(yAxis.scale, yAxis.model);
    }); // Key: axisDim_axisIndex, value: boolean, whether onZero target.

    var onZeroRecords = {};
    each$k(axesMap.x, function (xAxis) {
      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);
    });
    each$k(axesMap.y, function (yAxis) {
      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);
    }); // Resize again if containLabel is enabled
    // FIXME It may cause getting wrong grid size in data processing stage

    this.resize(this.model, api);
  };

  function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
    axis.getAxesOnZeroOf = function () {
      // TODO: onZero of multiple axes.
      return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
    }; // onZero can not be enabled in these two situations:
    // 1. When any other axis is a category axis.
    // 2. When no axis is cross 0 point.


    var otherAxes = axesMap[otherAxisDim];
    var otherAxisOnZeroOf;
    var axisModel = axis.model;
    var onZero = axisModel.get('axisLine.onZero');
    var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');

    if (!onZero) {
      return;
    } // If target axis is specified.


    if (onZeroAxisIndex != null) {
      if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
        otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
      }
    } else {
      // Find the first available other axis.
      for (var idx in otherAxes) {
        if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,
        // if both onZero, the two Y axes overlap.
        && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
          otherAxisOnZeroOf = otherAxes[idx];
          break;
        }
      }
    }

    if (otherAxisOnZeroOf) {
      onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
    }

    function getOnZeroRecordKey(axis) {
      return axis.dim + '_' + axis.index;
    }
  }

  function canOnZeroToAxis(axis) {
    return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero$1(axis);
  }
  /**
   * Resize the grid
   * @param {module:echarts/coord/cartesian/GridModel} gridModel
   * @param {module:echarts/ExtensionAPI} api
   */


  gridProto.resize = function (gridModel, api, ignoreContainLabel) {
    var gridRect = getLayoutRect$1(gridModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes(); // Minus label size

    if (!ignoreContainLabel && gridModel.get('containLabel')) {
      each$k(axesList, function (axis) {
        if (!axis.model.get('axisLabel.inside')) {
          var labelUnionRect = estimateLabelUnionRect$1(axis);

          if (labelUnionRect) {
            var dim = axis.isHorizontal() ? 'height' : 'width';
            var margin = axis.model.get('axisLabel.margin');
            gridRect[dim] -= labelUnionRect[dim] + margin;

            if (axis.position === 'top') {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === 'left') {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }

    function adjustAxes() {
      each$k(axesList, function (axis) {
        var isHorizontal = axis.isHorizontal();
        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent[idx], extent[1 - idx]);
        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  };
  /**
   * @param {string} axisType
   * @param {number} [axisIndex]
   */


  gridProto.getAxis = function (axisType, axisIndex) {
    var axesMapOnDim = this._axesMap[axisType];

    if (axesMapOnDim != null) {
      if (axisIndex == null) {
        // Find first axis
        for (var name in axesMapOnDim) {
          if (axesMapOnDim.hasOwnProperty(name)) {
            return axesMapOnDim[name];
          }
        }
      }

      return axesMapOnDim[axisIndex];
    }
  };
  /**
   * @return {Array.<module:echarts/coord/Axis>}
   */


  gridProto.getAxes = function () {
    return this._axesList.slice();
  };
  /**
   * Usage:
   *      grid.getCartesian(xAxisIndex, yAxisIndex);
   *      grid.getCartesian(xAxisIndex);
   *      grid.getCartesian(null, yAxisIndex);
   *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});
   *
   * @param {number|Object} [xAxisIndex]
   * @param {number} [yAxisIndex]
   */


  gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
      return this._coordsMap[key];
    }

    if (isObject$f(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    } // When only xAxisIndex or yAxisIndex given, find its first cartesian.


    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
        return coordList[i];
      }
    }
  };

  gridProto.getCartesians = function () {
    return this._coordsList.slice();
  };
  /**
   * @implements
   * see {module:echarts/CoodinateSystem}
   */


  gridProto.convertToPixel = function (ecModel, finder, value) {
    var target = this._findConvertTarget(ecModel, finder);

    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  };
  /**
   * @implements
   * see {module:echarts/CoodinateSystem}
   */


  gridProto.convertFromPixel = function (ecModel, finder, value) {
    var target = this._findConvertTarget(ecModel, finder);

    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  };
  /**
   * @inner
   */


  gridProto._findConvertTarget = function (ecModel, finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian;
    var axis;

    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      indexOf$4(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis('x', xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis('y', yAxisModel.componentIndex);
    } // Lowest priority.
    else if (gridModel) {
        var grid = gridModel.coordinateSystem;

        if (grid === this) {
          cartesian = this._coordsList[0];
        }
      }

    return {
      cartesian: cartesian,
      axis: axis
    };
  };
  /**
   * @implements
   * see {module:echarts/CoodinateSystem}
   */


  gridProto.containPoint = function (point) {
    var coord = this._coordsList[0];

    if (coord) {
      return coord.containPoint(point);
    }
  };
  /**
   * Initialize cartesian coordinate systems
   * @private
   */


  gridProto._initCartesian = function (gridModel, ecModel, api) {
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    }; /// Create axis

    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);

    if (!axesCount.x || !axesCount.y) {
      // Roll back when there no either x or y axis
      this._axesMap = {};
      this._axesList = [];
      return;
    }

    this._axesMap = axesMap; /// Create cartesian2d

    each$k(axesMap.x, function (xAxis, xAxisIndex) {
      each$k(axesMap.y, function (yAxis, yAxisIndex) {
        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
        var cartesian = new Cartesian2D_1(key);
        cartesian.grid = this;
        cartesian.model = gridModel;
        this._coordsMap[key] = cartesian;

        this._coordsList.push(cartesian);

        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      }, this);
    }, this);

    function createAxisCreator(axisType) {
      return function (axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }

        var axisPosition = axisModel.get('position');

        if (axisType === 'x') {
          // Fix position
          if (axisPosition !== 'top' && axisPosition !== 'bottom') {
            // Default bottom of X
            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';
          }
        } else {
          // Fix position
          if (axisPosition !== 'left' && axisPosition !== 'right') {
            // Default left of Y
            axisPosition = axisPositionUsed.left ? 'right' : 'left';
          }
        }

        axisPositionUsed[axisPosition] = true;
        var axis = new Axis2D_1(axisType, createScaleByModel$1(axisModel), [0, 0], axisModel.get('type'), axisPosition);
        var isCategory = axis.type === 'category';
        axis.onBand = isCategory && axisModel.get('boundaryGap');
        axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel

        axisModel.axis = axis; // Inject axisModel into axis

        axis.model = axisModel; // Inject grid info axis

        axis.grid = this; // Index of axis, can be used as key

        axis.index = idx;

        this._axesList.push(axis);

        axesMap[axisType][idx] = axis;
        axesCount[axisType]++;
      };
    }
  };
  /**
   * Update cartesian properties from series
   * @param  {module:echarts/model/Option} option
   * @private
   */


  gridProto._updateScale = function (ecModel, gridModel) {
    // Reset scale
    each$k(this._axesList, function (axis) {
      axis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeries(function (seriesModel) {
      if (isCartesian2D(seriesModel)) {
        var axesModels = findAxesModels(seriesModel);
        var xAxisModel = axesModels[0];
        var yAxisModel = axesModels[1];

        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }

        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        var data = seriesModel.getData();
        var xAxis = cartesian.getAxis('x');
        var yAxis = cartesian.getAxis('y');

        if (data.type === 'list') {
          unionExtent(data, xAxis);
          unionExtent(data, yAxis);
        }
      }
    }, this);

    function unionExtent(data, axis, seriesModel) {
      each$k(data.mapDimension(axis.dim, true), function (dim) {
        axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension
        // is [0.1, 0.5], the extent of the `stackResultDimension`
        // is [7, 9], the final extent should not include [0.1, 0.5].
        data, getStackedDimension$2(data, dim));
      });
    }
  };
  /**
   * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined
   * @return {Object} {baseAxes: [], otherAxes: []}
   */


  gridProto.getTooltipAxes = function (dim) {
    var baseAxes = [];
    var otherAxes = [];
    each$k(this.getCartesians(), function (cartesian) {
      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      var otherAxis = cartesian.getOtherAxis(baseAxis);
      indexOf$4(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf$4(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {
      baseAxes: baseAxes,
      otherAxes: otherAxes
    };
  };
  /**
   * @inner
   */


  function updateAxisTransform(axis, coordBase) {
    var axisExtent = axis.getExtent();
    var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform

    axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
      return coord + coordBase;
    } : function (coord) {
      return axisExtentSum - coord + coordBase;
    };
    axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
      return coord - coordBase;
    } : function (coord) {
      return axisExtentSum - coord + coordBase;
    };
  }

  var axesTypes = ['xAxis', 'yAxis'];
  /**
   * @inner
   */

  function findAxesModels(seriesModel, ecModel) {
    return map$9(axesTypes, function (axisType) {
      var axisModel = seriesModel.getReferringComponents(axisType)[0];
      return axisModel;
    });
  }
  /**
   * @inner
   */


  function isCartesian2D(seriesModel) {
    return seriesModel.get('coordinateSystem') === 'cartesian2d';
  }

  Grid.create = function (ecModel, api) {
    var grids = [];
    ecModel.eachComponent('grid', function (gridModel, idx) {
      var grid = new Grid(gridModel, ecModel, api);
      grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize
      // should be performed in create stage.

      grid.resize(gridModel, api, true);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    }); // Inject the coordinateSystems into seriesModel

    ecModel.eachSeries(function (seriesModel) {
      if (!isCartesian2D(seriesModel)) {
        return;
      }

      var axesModels = findAxesModels(seriesModel);
      var xAxisModel = axesModels[0];
      var yAxisModel = axesModels[1];
      var gridModel = xAxisModel.getCoordSysModel();
      var grid = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  }; // For deciding which dimensions to use when creating list data


  Grid.dimensions = Grid.prototype.dimensions = Cartesian2D_1.prototype.dimensions;
  CoordinateSystem.register('cartesian2d', Grid);

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var retrieve$1 = util.retrieve;
  var defaults$3 = util.defaults;
  var extend$9 = util.extend;
  var each$l = util.each;









  var isRadianAroundZero$1 = number.isRadianAroundZero;
  var remRadian$1 = number.remRadian;



  var createSymbol$3 = symbol.createSymbol;





  var v2ApplyTransform$2 = vector.applyTransform;



  var shouldShowAllLabels$2 = axisHelper.shouldShowAllLabels;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var PI$2 = Math.PI;
  /**
   * A final axis is translated and rotated from a "standard axis".
   * So opt.position and opt.rotation is required.
   *
   * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
   * for example: (0, 0) ------------> (0, 50)
   *
   * nameDirection or tickDirection or labelDirection is 1 means tick
   * or label is below the standard axis, whereas is -1 means above
   * the standard axis. labelOffset means offset between label and axis,
   * which is useful when 'onZero', where axisLabel is in the grid and
   * label in outside grid.
   *
   * Tips: like always,
   * positive rotation represents anticlockwise, and negative rotation
   * represents clockwise.
   * The direction of position coordinate is the same as the direction
   * of screen coordinate.
   *
   * Do not need to consider axis 'inverse', which is auto processed by
   * axis extent.
   *
   * @param {module:zrender/container/Group} group
   * @param {Object} axisModel
   * @param {Object} opt Standard axis parameters.
   * @param {Array.<number>} opt.position [x, y]
   * @param {number} opt.rotation by radian
   * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.
   * @param {number} [opt.tickDirection=1] 1 or -1
   * @param {number} [opt.labelDirection=1] 1 or -1
   * @param {number} [opt.labelOffset=0] Usefull when onZero.
   * @param {string} [opt.axisLabelShow] default get from axisModel.
   * @param {string} [opt.axisName] default get from axisModel.
   * @param {number} [opt.axisNameAvailableWidth]
   * @param {number} [opt.labelRotate] by degree, default get from axisModel.
   * @param {number} [opt.strokeContainThreshold] Default label interval when label
   * @param {number} [opt.nameTruncateMaxWidth]
   */

  var AxisBuilder = function (axisModel, opt) {
    /**
     * @readOnly
     */
    this.opt = opt;
    /**
     * @readOnly
     */

    this.axisModel = axisModel; // Default value

    defaults$3(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true
    });
    /**
     * @readOnly
     */

    this.group = new graphic.Group(); // FIXME Not use a seperate text group?

    var dumbGroup = new graphic.Group({
      position: opt.position.slice(),
      rotation: opt.rotation
    }); // this.group.add(dumbGroup);
    // this._dumbGroup = dumbGroup;

    dumbGroup.updateTransform();
    this._transform = dumbGroup.transform;
    this._dumbGroup = dumbGroup;
  };

  AxisBuilder.prototype = {
    constructor: AxisBuilder,
    hasBuilder: function (name) {
      return !!builders[name];
    },
    add: function (name) {
      builders[name].call(this);
    },
    getGroup: function () {
      return this.group;
    }
  };
  var builders = {
    /**
     * @private
     */
    axisLine: function () {
      var opt = this.opt;
      var axisModel = this.axisModel;

      if (!axisModel.get('axisLine.show')) {
        return;
      }

      var extent = this.axisModel.axis.getExtent();
      var matrix = this._transform;
      var pt1 = [extent[0], 0];
      var pt2 = [extent[1], 0];

      if (matrix) {
        v2ApplyTransform$2(pt1, pt1, matrix);
        v2ApplyTransform$2(pt2, pt2, matrix);
      }

      var lineStyle = extend$9({
        lineCap: 'round'
      }, axisModel.getModel('axisLine.lineStyle').getLineStyle());
      this.group.add(new graphic.Line({
        // Id for animation
        anid: 'line',
        subPixelOptimize: true,
        shape: {
          x1: pt1[0],
          y1: pt1[1],
          x2: pt2[0],
          y2: pt2[1]
        },
        style: lineStyle,
        strokeContainThreshold: opt.strokeContainThreshold || 5,
        silent: true,
        z2: 1
      }));
      var arrows = axisModel.get('axisLine.symbol');
      var arrowSize = axisModel.get('axisLine.symbolSize');
      var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;

      if (typeof arrowOffset === 'number') {
        arrowOffset = [arrowOffset, arrowOffset];
      }

      if (arrows != null) {
        if (typeof arrows === 'string') {
          // Use the same arrow for start and end point
          arrows = [arrows, arrows];
        }

        if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {
          // Use the same size for width and height
          arrowSize = [arrowSize, arrowSize];
        }

        var symbolWidth = arrowSize[0];
        var symbolHeight = arrowSize[1];
        each$l([{
          rotate: opt.rotation + Math.PI / 2,
          offset: arrowOffset[0],
          r: 0
        }, {
          rotate: opt.rotation - Math.PI / 2,
          offset: arrowOffset[1],
          r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
        }], function (point, index) {
          if (arrows[index] !== 'none' && arrows[index] != null) {
            var symbol = createSymbol$3(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset

            var r = point.r + point.offset;
            var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];
            symbol.attr({
              rotation: point.rotate,
              position: pos,
              silent: true,
              z2: 11
            });
            this.group.add(symbol);
          }
        }, this);
      }
    },

    /**
     * @private
     */
    axisTickLabel: function () {
      var axisModel = this.axisModel;
      var opt = this.opt;
      var ticksEls = buildAxisMajorTicks(this, axisModel, opt);
      var labelEls = buildAxisLabel(this, axisModel, opt);
      fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
      buildAxisMinorTicks(this, axisModel, opt);
    },

    /**
     * @private
     */
    axisName: function () {
      var opt = this.opt;
      var axisModel = this.axisModel;
      var name = retrieve$1(opt.axisName, axisModel.get('name'));

      if (!name) {
        return;
      }

      var nameLocation = axisModel.get('nameLocation');
      var nameDirection = opt.nameDirection;
      var textStyleModel = axisModel.getModel('nameTextStyle');
      var gap = axisModel.get('nameGap') || 0;
      var extent = this.axisModel.axis.getExtent();
      var gapSignal = extent[0] > extent[1] ? -1 : 1;
      var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'
      // Reuse labelOffset.
      isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];
      var labelLayout;
      var nameRotation = axisModel.get('nameRotate');

      if (nameRotation != null) {
        nameRotation = nameRotation * PI$2 / 180; // To radian.
      }

      var axisNameAvailableWidth;

      if (isNameLocationCenter(nameLocation)) {
        labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
        nameDirection);
      } else {
        labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);
        axisNameAvailableWidth = opt.axisNameAvailableWidth;

        if (axisNameAvailableWidth != null) {
          axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
          !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
        }
      }

      var textFont = textStyleModel.getFont();
      var truncateOpt = axisModel.get('nameTruncate', true) || {};
      var ellipsis = truncateOpt.ellipsis;
      var maxWidth = retrieve$1(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME
      // truncate rich text? (consider performance)

      var truncatedText = ellipsis != null && maxWidth != null ? format$1.truncateText(name, maxWidth, textFont, ellipsis, {
        minChar: 2,
        placeholder: truncateOpt.placeholder
      }) : name;
      var tooltipOpt = axisModel.get('tooltip', true);
      var mainType = axisModel.mainType;
      var formatterParams = {
        componentType: mainType,
        name: name,
        $vars: ['name']
      };
      formatterParams[mainType + 'Index'] = axisModel.componentIndex;
      var textEl = new graphic.Text({
        // Id for animation
        anid: 'name',
        __fullText: name,
        __truncatedText: truncatedText,
        position: pos,
        rotation: labelLayout.rotation,
        silent: isLabelSilent(axisModel),
        z2: 1,
        tooltip: tooltipOpt && tooltipOpt.show ? extend$9({
          content: name,
          formatter: function () {
            return name;
          },
          formatterParams: formatterParams
        }, tooltipOpt) : null
      });
      graphic.setTextStyle(textEl.style, textStyleModel, {
        text: truncatedText,
        textFont: textFont,
        textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),
        textAlign: textStyleModel.get('align') || labelLayout.textAlign,
        textVerticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign
      });

      if (axisModel.get('triggerEvent')) {
        textEl.eventData = makeAxisEventDataBase(axisModel);
        textEl.eventData.targetType = 'axisName';
        textEl.eventData.name = name;
      } // FIXME


      this._dumbGroup.add(textEl);

      textEl.updateTransform();
      this.group.add(textEl);
      textEl.decomposeTransform();
    }
  };

  var makeAxisEventDataBase = AxisBuilder.makeAxisEventDataBase = function (axisModel) {
    var eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
    return eventData;
  };
  /**
   * @public
   * @static
   * @param {Object} opt
   * @param {number} axisRotation in radian
   * @param {number} textRotation in radian
   * @param {number} direction
   * @return {Object} {
   *  rotation, // according to axis
   *  textAlign,
   *  textVerticalAlign
   * }
   */


  var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
    var rotationDiff = remRadian$1(textRotation - axisRotation);
    var textAlign;
    var textVerticalAlign;

    if (isRadianAroundZero$1(rotationDiff)) {
      // Label is parallel with axis line.
      textVerticalAlign = direction > 0 ? 'top' : 'bottom';
      textAlign = 'center';
    } else if (isRadianAroundZero$1(rotationDiff - PI$2)) {
      // Label is inverse parallel with axis line.
      textVerticalAlign = direction > 0 ? 'bottom' : 'top';
      textAlign = 'center';
    } else {
      textVerticalAlign = 'middle';

      if (rotationDiff > 0 && rotationDiff < PI$2) {
        textAlign = direction > 0 ? 'right' : 'left';
      } else {
        textAlign = direction > 0 ? 'left' : 'right';
      }
    }

    return {
      rotation: rotationDiff,
      textAlign: textAlign,
      textVerticalAlign: textVerticalAlign
    };
  };

  function endTextLayout(opt, textPosition, textRotate, extent) {
    var rotationDiff = remRadian$1(textRotate - opt.rotation);
    var textAlign;
    var textVerticalAlign;
    var inverse = extent[0] > extent[1];
    var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;

    if (isRadianAroundZero$1(rotationDiff - PI$2 / 2)) {
      textVerticalAlign = onLeft ? 'bottom' : 'top';
      textAlign = 'center';
    } else if (isRadianAroundZero$1(rotationDiff - PI$2 * 1.5)) {
      textVerticalAlign = onLeft ? 'top' : 'bottom';
      textAlign = 'center';
    } else {
      textVerticalAlign = 'middle';

      if (rotationDiff < PI$2 * 1.5 && rotationDiff > PI$2 / 2) {
        textAlign = onLeft ? 'left' : 'right';
      } else {
        textAlign = onLeft ? 'right' : 'left';
      }
    }

    return {
      rotation: rotationDiff,
      textAlign: textAlign,
      textVerticalAlign: textVerticalAlign
    };
  }

  var isLabelSilent = AxisBuilder.isLabelSilent = function (axisModel) {
    var tooltipOpt = axisModel.get('tooltip');
    return axisModel.get('silent') // Consider mouse cursor, add these restrictions.
    || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);
  };

  function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
    if (shouldShowAllLabels$2(axisModel.axis)) {
      return;
    } // If min or max are user set, we need to check
    // If the tick on min(max) are overlap on their neighbour tick
    // If they are overlapped, we need to hide the min(max) tick label


    var showMinLabel = axisModel.get('axisLabel.showMinLabel');
    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME
    // Have not consider onBand yet, where tick els is more than label els.

    labelEls = labelEls || [];
    tickEls = tickEls || [];
    var firstLabel = labelEls[0];
    var nextLabel = labelEls[1];
    var lastLabel = labelEls[labelEls.length - 1];
    var prevLabel = labelEls[labelEls.length - 2];
    var firstTick = tickEls[0];
    var nextTick = tickEls[1];
    var lastTick = tickEls[tickEls.length - 1];
    var prevTick = tickEls[tickEls.length - 2];

    if (showMinLabel === false) {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
      if (showMinLabel) {
        ignoreEl(nextLabel);
        ignoreEl(nextTick);
      } else {
        ignoreEl(firstLabel);
        ignoreEl(firstTick);
      }
    }

    if (showMaxLabel === false) {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
      if (showMaxLabel) {
        ignoreEl(prevLabel);
        ignoreEl(prevTick);
      } else {
        ignoreEl(lastLabel);
        ignoreEl(lastTick);
      }
    }
  }

  function ignoreEl(el) {
    el && (el.ignore = true);
  }

  function isTwoLabelOverlapped(current, next, labelLayout) {
    // current and next has the same rotation.
    var firstRect = current && current.getBoundingRect().clone();
    var nextRect = next && next.getBoundingRect().clone();

    if (!firstRect || !nextRect) {
      return;
    } // When checking intersect of two rotated labels, we use mRotationBack
    // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.


    var mRotationBack = matrix.identity([]);
    matrix.rotate(mRotationBack, mRotationBack, -current.rotation);
    firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));
    nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));
    return firstRect.intersect(nextRect);
  }

  function isNameLocationCenter(nameLocation) {
    return nameLocation === 'middle' || nameLocation === 'center';
  }

  function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, aniid) {
    var tickEls = [];
    var pt1 = [];
    var pt2 = [];

    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = ticksCoords[i].coord;
      pt1[0] = tickCoord;
      pt1[1] = 0;
      pt2[0] = tickCoord;
      pt2[1] = tickEndCoord;

      if (tickTransform) {
        v2ApplyTransform$2(pt1, pt1, tickTransform);
        v2ApplyTransform$2(pt2, pt2, tickTransform);
      } // Tick line, Not use group transform to have better line draw


      var tickEl = new graphic.Line({
        // Id for animation
        anid: aniid + '_' + ticksCoords[i].tickValue,
        subPixelOptimize: true,
        shape: {
          x1: pt1[0],
          y1: pt1[1],
          x2: pt2[0],
          y2: pt2[1]
        },
        style: tickLineStyle,
        z2: 2,
        silent: true
      });
      tickEls.push(tickEl);
    }

    return tickEls;
  }

  function buildAxisMajorTicks(axisBuilder, axisModel, opt) {
    var axis = axisModel.axis;
    var tickModel = axisModel.getModel('axisTick');

    if (!tickModel.get('show') || axis.scale.isBlank()) {
      return;
    }

    var lineStyleModel = tickModel.getModel('lineStyle');
    var tickEndCoord = opt.tickDirection * tickModel.get('length');
    var ticksCoords = axis.getTicksCoords();
    var ticksEls = createTicks(ticksCoords, axisBuilder._transform, tickEndCoord, defaults$3(lineStyleModel.getLineStyle(), {
      stroke: axisModel.get('axisLine.lineStyle.color')
    }), 'ticks');

    for (var i = 0; i < ticksEls.length; i++) {
      axisBuilder.group.add(ticksEls[i]);
    }

    return ticksEls;
  }

  function buildAxisMinorTicks(axisBuilder, axisModel, opt) {
    var axis = axisModel.axis;
    var minorTickModel = axisModel.getModel('minorTick');

    if (!minorTickModel.get('show') || axis.scale.isBlank()) {
      return;
    }

    var minorTicksCoords = axis.getMinorTicksCoords();

    if (!minorTicksCoords.length) {
      return;
    }

    var lineStyleModel = minorTickModel.getModel('lineStyle');
    var tickEndCoord = opt.tickDirection * minorTickModel.get('length');
    var minorTickLineStyle = defaults$3(lineStyleModel.getLineStyle(), defaults$3(axisModel.getModel('axisTick').getLineStyle(), {
      stroke: axisModel.get('axisLine.lineStyle.color')
    }));

    for (var i = 0; i < minorTicksCoords.length; i++) {
      var minorTicksEls = createTicks(minorTicksCoords[i], axisBuilder._transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);

      for (var k = 0; k < minorTicksEls.length; k++) {
        axisBuilder.group.add(minorTicksEls[k]);
      }
    }
  }

  function buildAxisLabel(axisBuilder, axisModel, opt) {
    var axis = axisModel.axis;
    var show = retrieve$1(opt.axisLabelShow, axisModel.get('axisLabel.show'));

    if (!show || axis.scale.isBlank()) {
      return;
    }

    var labelModel = axisModel.getModel('axisLabel');
    var labelMargin = labelModel.get('margin');
    var labels = axis.getViewLabels(); // Special label rotate.

    var labelRotation = (retrieve$1(opt.labelRotate, labelModel.get('rotate')) || 0) * PI$2 / 180;
    var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
    var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
    var labelEls = [];
    var silent = isLabelSilent(axisModel);
    var triggerEvent = axisModel.get('triggerEvent');
    each$l(labels, function (labelItem, index) {
      var tickValue = labelItem.tickValue;
      var formattedLabel = labelItem.formattedLabel;
      var rawLabel = labelItem.rawLabel;
      var itemLabelModel = labelModel;

      if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
        itemLabelModel = new Model_1(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);
      }

      var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');
      var tickCoord = axis.dataToCoord(tickValue);
      var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
      var textEl = new graphic.Text({
        // Id for animation
        anid: 'label_' + tickValue,
        position: pos,
        rotation: labelLayout.rotation,
        silent: silent,
        z2: 10
      });
      graphic.setTextStyle(textEl.style, itemLabelModel, {
        text: formattedLabel,
        textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
        textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
        textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original
        // index of axis.data. So tick should not be exposed to user
        // in category axis.
        // (2) Compatible with previous version, which always use formatted label as
        // input. But in interval scale the formatted label is like '223,445', which
        // maked user repalce ','. So we modify it to return original val but remain
        // it as 'string' to avoid error in replacing.
        axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor
      }); // Pack data for mouse event

      if (triggerEvent) {
        textEl.eventData = makeAxisEventDataBase(axisModel);
        textEl.eventData.targetType = 'axisLabel';
        textEl.eventData.value = rawLabel;
      } // FIXME


      axisBuilder._dumbGroup.add(textEl);

      textEl.updateTransform();
      labelEls.push(textEl);
      axisBuilder.group.add(textEl);
      textEl.decomposeTransform();
    });
    return labelEls;
  }

  var _default$1K = AxisBuilder;
  var AxisBuilder_1 = _default$1K;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var each$m = util.each;
  var curry$1 = util.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
  // allAxesInfo should be updated when setOption performed.

  function collect(ecModel, api) {
    var result = {
      /**
       * key: makeKey(axis.model)
       * value: {
       *      axis,
       *      coordSys,
       *      axisPointerModel,
       *      triggerTooltip,
       *      involveSeries,
       *      snap,
       *      seriesModels,
       *      seriesDataCount
       * }
       */
      axesInfo: {},
      seriesInvolved: false,

      /**
       * key: makeKey(coordSys.model)
       * value: Object: key makeKey(axis.model), value: axisInfo
       */
      coordSysAxesInfo: {},
      coordSysMap: {}
    };
    collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.

    result.seriesInvolved && collectSeriesInfo(result, ecModel);
    return result;
  }

  function collectAxesInfo(result, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent('tooltip');
    var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.

    var linksOption = globalAxisPointerModel.get('link', true) || [];
    var linkGroups = []; // Collect axes info.

    each$m(api.getCoordinateSystems(), function (coordSys) {
      // Some coordinate system do not support axes, like geo.
      if (!coordSys.axisPointerEnabled) {
        return;
      }

      var coordSysKey = makeKey(coordSys.model);
      var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
      result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer
      // for user. So we enable seting tooltip on coordSys model.

      var coordSysModel = coordSys.model;
      var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);
      each$m(coordSys.getAxes(), curry$1(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.
      // Notice this case: coordSys is `grid` but not `cartesian2D` here.

      if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not
      // show but axisPointer will show as normal.
      && baseTooltipModel.get('show')) {
        // Compatible with previous logic. But series.tooltip.trigger: 'axis'
        // or series.data[n].tooltip.trigger: 'axis' are not support any more.
        var triggerAxis = baseTooltipModel.get('trigger') === 'axis';
        var cross = baseTooltipModel.get('axisPointer.type') === 'cross';
        var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));

        if (triggerAxis || cross) {
          each$m(tooltipAxes.baseAxes, curry$1(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));
        }

        if (cross) {
          each$m(tooltipAxes.otherAxes, curry$1(saveTooltipAxisInfo, 'cross', false));
        }
      } // fromTooltip: true | false | 'cross'
      // triggerTooltip: true | false | null


      function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
        var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);
        var axisPointerShow = axisPointerModel.get('show');

        if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
          return;
        }

        if (triggerTooltip == null) {
          triggerTooltip = axisPointerModel.get('triggerTooltip');
        }

        axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
        var snap = axisPointerModel.get('snap');
        var key = makeKey(axis.model);
        var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).

        var axisInfo = result.axesInfo[key] = {
          key: key,
          axis: axis,
          coordSys: coordSys,
          axisPointerModel: axisPointerModel,
          triggerTooltip: triggerTooltip,
          involveSeries: involveSeries,
          snap: snap,
          useHandle: isHandleTrigger(axisPointerModel),
          seriesModels: []
        };
        axesInfoInCoordSys[key] = axisInfo;
        result.seriesInvolved |= involveSeries;
        var groupIndex = getLinkGroupIndex(linksOption, axis);

        if (groupIndex != null) {
          var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
            axesInfo: {}
          });
          linkGroup.axesInfo[key] = axisInfo;
          linkGroup.mapper = linksOption[groupIndex].mapper;
          axisInfo.linkGroup = linkGroup;
        }
      }
    });
  }

  function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
    var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');
    var volatileOption = {};
    each$m(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {
      volatileOption[field] = util.clone(tooltipAxisPointerModel.get(field));
    }); // category axis do not auto snap, otherwise some tick that do not
    // has value can not be hovered. value/time/log axis default snap if
    // triggered from tooltip and trigger tooltip.

    volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.
    // Only these properties can be overrided from tooltip to axisPointer.

    if (tooltipAxisPointerModel.get('type') === 'cross') {
      volatileOption.type = 'line';
    }

    var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.

    labelOption.show == null && (labelOption.show = false);

    if (fromTooltip === 'cross') {
      // When 'cross', both axes show labels.
      var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get('label.show');
      labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true; // If triggerTooltip, this is a base axis, which should better not use cross style
      // (cross style is dashed by default)

      if (!triggerTooltip) {
        var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');
        crossStyle && util.defaults(labelOption, crossStyle.textStyle);
      }
    }

    return axis.model.getModel('axisPointer', new Model_1(volatileOption, globalAxisPointerModel, ecModel));
  }

  function collectSeriesInfo(result, ecModel) {
    // Prepare data for axis trigger
    ecModel.eachSeries(function (seriesModel) {
      // Notice this case: this coordSys is `cartesian2D` but not `grid`.
      var coordSys = seriesModel.coordinateSystem;
      var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);
      var seriesTooltipShow = seriesModel.get('tooltip.show', true);

      if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {
        return;
      }

      each$m(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
        var axis = axisInfo.axis;

        if (coordSys.getAxis(axis.dim) === axis) {
          axisInfo.seriesModels.push(seriesModel);
          axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
          axisInfo.seriesDataCount += seriesModel.getData().count();
        }
      });
    }, this);
  }
  /**
   * For example:
   * {
   *     axisPointer: {
   *         links: [{
   *             xAxisIndex: [2, 4],
   *             yAxisIndex: 'all'
   *         }, {
   *             xAxisId: ['a5', 'a7'],
   *             xAxisName: 'xxx'
   *         }]
   *     }
   * }
   */


  function getLinkGroupIndex(linksOption, axis) {
    var axisModel = axis.model;
    var dim = axis.dim;

    for (var i = 0; i < linksOption.length; i++) {
      var linkOption = linksOption[i] || {};

      if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
        return i;
      }
    }
  }

  function checkPropInLink(linkPropValue, axisPropValue) {
    return linkPropValue === 'all' || util.isArray(linkPropValue) && util.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
  }

  function fixValue(axisModel) {
    var axisInfo = getAxisInfo(axisModel);

    if (!axisInfo) {
      return;
    }

    var axisPointerModel = axisInfo.axisPointerModel;
    var scale = axisInfo.axis.scale;
    var option = axisPointerModel.option;
    var status = axisPointerModel.get('status');
    var value = axisPointerModel.get('value'); // Parse init value for category and time axis.

    if (value != null) {
      value = scale.parse(value);
    }

    var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value
    // and status should be initialized.

    if (status == null) {
      option.status = useHandle ? 'show' : 'hide';
    }

    var extent = scale.getExtent().slice();
    extent[0] > extent[1] && extent.reverse();

    if ( // Pick a value on axis when initializing.
    value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,
    // where we should re-pick a value to keep `handle` displaying normally.
    || value > extent[1]) {
      // Make handle displayed on the end of the axis when init, which looks better.
      value = extent[1];
    }

    if (value < extent[0]) {
      value = extent[0];
    }

    option.value = value;

    if (useHandle) {
      option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';
    }
  }

  function getAxisInfo(axisModel) {
    var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;
    return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
  }

  function getAxisPointerModel(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    return axisInfo && axisInfo.axisPointerModel;
  }

  function isHandleTrigger(axisPointerModel) {
    return !!axisPointerModel.get('handle.show');
  }
  /**
   * @param {module:echarts/model/Model} model
   * @return {string} unique key
   */


  function makeKey(model) {
    return model.type + '||' + model.id;
  }

  var collect_1 = collect;
  var fixValue_1 = fixValue;
  var getAxisInfo_1 = getAxisInfo;
  var getAxisPointerModel_1 = getAxisPointerModel;
  var makeKey_1 = makeKey;

  var modelHelper = {
  	collect: collect_1,
  	fixValue: fixValue_1,
  	getAxisInfo: getAxisInfo_1,
  	getAxisPointerModel: getAxisPointerModel_1,
  	makeKey: makeKey_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Base class of AxisView.
   */
  var AxisView = echarts.extendComponentView({
    type: 'axis',

    /**
     * @private
     */
    _axisPointer: null,

    /**
     * @protected
     * @type {string}
     */
    axisPointerClass: null,

    /**
     * @override
     */
    render: function (axisModel, ecModel, api, payload) {
      // FIXME
      // This process should proformed after coordinate systems updated
      // (axis scale updated), and should be performed each time update.
      // So put it here temporarily, although it is not appropriate to
      // put a model-writing procedure in `view`.
      this.axisPointerClass && modelHelper.fixValue(axisModel);
      AxisView.superApply(this, 'render', arguments);
      updateAxisPointer(this, axisModel, ecModel, api, payload, true);
    },

    /**
     * Action handler.
     * @public
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/model/Global} ecModel
     * @param {module:echarts/ExtensionAPI} api
     * @param {Object} payload
     */
    updateAxisPointer: function (axisModel, ecModel, api, payload, force) {
      updateAxisPointer(this, axisModel, ecModel, api, payload, false);
    },

    /**
     * @override
     */
    remove: function (ecModel, api) {
      var axisPointer = this._axisPointer;
      axisPointer && axisPointer.remove(api);
      AxisView.superApply(this, 'remove', arguments);
    },

    /**
     * @override
     */
    dispose: function (ecModel, api) {
      disposeAxisPointer(this, api);
      AxisView.superApply(this, 'dispose', arguments);
    }
  });

  function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
    var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);

    if (!Clazz) {
      return;
    }

    var axisPointerModel = modelHelper.getAxisPointerModel(axisModel);
    axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
  }

  function disposeAxisPointer(axisView, ecModel, api) {
    var axisPointer = axisView._axisPointer;
    axisPointer && axisPointer.dispose(ecModel, api);
    axisView._axisPointer = null;
  }

  var axisPointerClazz = [];

  AxisView.registerAxisPointerClass = function (type, clazz) {
    axisPointerClazz[type] = clazz;
  };

  AxisView.getAxisPointerClass = function (type) {
    return type && axisPointerClazz[type];
  };

  var _default$1L = AxisView;
  var AxisView_1 = _default$1L;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Can only be called after coordinate system creation stage.
   * (Can be called before coordinate system update stage).
   *
   * @param {Object} opt {labelInside}
   * @return {Object} {
   *  position, rotation, labelDirection, labelOffset,
   *  tickDirection, labelRotate, z2
   * }
   */
  function layout$2(gridModel, axisModel, opt) {
    opt = opt || {};
    var grid = gridModel.coordinateSystem;
    var axis = axisModel.axis;
    var layout = {};
    var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
    var rawAxisPosition = axis.position;
    var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;
    var axisDim = axis.dim;
    var rect = grid.getRect();
    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
    var idx = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2
    };
    var axisOffset = axisModel.get('offset') || 0;
    var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];

    if (otherAxisOnZeroOf) {
      var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
      posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
    } // Axis position


    layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation

    layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim

    var dirMap = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    };
    layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
    layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;

    if (axisModel.get('axisTick.inside')) {
      layout.tickDirection = -layout.tickDirection;
    }

    if (util.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {
      layout.labelDirection = -layout.labelDirection;
    } // Special label rotation


    var labelRotate = axisModel.get('axisLabel.rotate');
    layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // Over splitLine and splitArea

    layout.z2 = 1;
    return layout;
  }

  var layout_1$1 = layout$2;

  var cartesianAxisHelper = {
  	layout: layout_1$1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;

    if (axis.scale.isBlank()) {
      return;
    }

    var splitAreaModel = axisModel.getModel('splitArea');
    var areaStyleModel = splitAreaModel.getModel('areaStyle');
    var areaColors = areaStyleModel.get('color');
    var gridRect = gridModel.coordinateSystem.getRect();
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitAreaModel,
      clamp: true
    });

    if (!ticksCoords.length) {
      return;
    } // For Making appropriate splitArea animation, the color and anid
    // should be corresponding to previous one if possible.


    var areaColorsLen = areaColors.length;
    var lastSplitAreaColors = axisView.__splitAreaColors;
    var newSplitAreaColors = util.createHashMap();
    var colorIndex = 0;

    if (lastSplitAreaColors) {
      for (var i = 0; i < ticksCoords.length; i++) {
        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);

        if (cIndex != null) {
          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
          break;
        }
      }
    }

    var prev = axis.toGlobalCoord(ticksCoords[0].coord);
    var areaStyle = areaStyleModel.getAreaStyle();
    areaColors = util.isArray(areaColors) ? areaColors : [areaColors];

    for (var i = 1; i < ticksCoords.length; i++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      var x;
      var y;
      var width;
      var height;

      if (axis.isHorizontal()) {
        x = prev;
        y = gridRect.y;
        width = tickCoord - x;
        height = gridRect.height;
        prev = x + width;
      } else {
        x = gridRect.x;
        y = prev;
        width = gridRect.width;
        height = tickCoord - y;
        prev = y + height;
      }

      var tickValue = ticksCoords[i - 1].tickValue;
      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
      axisGroup.add(new graphic.Rect({
        anid: tickValue != null ? 'area_' + tickValue : null,
        shape: {
          x: x,
          y: y,
          width: width,
          height: height
        },
        style: util.defaults({
          fill: areaColors[colorIndex]
        }, areaStyle),
        silent: true
      }));
      colorIndex = (colorIndex + 1) % areaColorsLen;
    }

    axisView.__splitAreaColors = newSplitAreaColors;
  }

  function rectCoordAxisHandleRemove(axisView) {
    axisView.__splitAreaColors = null;
  }

  var rectCoordAxisBuildSplitArea_1 = rectCoordAxisBuildSplitArea;
  var rectCoordAxisHandleRemove_1 = rectCoordAxisHandleRemove;

  var axisSplitHelper = {
  	rectCoordAxisBuildSplitArea: rectCoordAxisBuildSplitArea_1,
  	rectCoordAxisHandleRemove: rectCoordAxisHandleRemove_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */













  var rectCoordAxisBuildSplitArea$1 = axisSplitHelper.rectCoordAxisBuildSplitArea;
  var rectCoordAxisHandleRemove$1 = axisSplitHelper.rectCoordAxisHandleRemove;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
  var selfBuilderAttrs = ['splitArea', 'splitLine', 'minorSplitLine'];
  var CartesianAxisView = AxisView_1.extend({
    type: 'cartesianAxis',
    axisPointerClass: 'CartesianAxisPointer',

    /**
     * @override
     */
    render: function (axisModel, ecModel, api, payload) {
      this.group.removeAll();
      var oldAxisGroup = this._axisGroup;
      this._axisGroup = new graphic.Group();
      this.group.add(this._axisGroup);

      if (!axisModel.get('show')) {
        return;
      }

      var gridModel = axisModel.getCoordSysModel();
      var layout = cartesianAxisHelper.layout(gridModel, axisModel);
      var axisBuilder = new AxisBuilder_1(axisModel, layout);
      util.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);

      this._axisGroup.add(axisBuilder.getGroup());

      util.each(selfBuilderAttrs, function (name) {
        if (axisModel.get(name + '.show')) {
          this['_' + name](axisModel, gridModel);
        }
      }, this);
      graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
      CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);
    },
    remove: function () {
      rectCoordAxisHandleRemove$1(this);
    },

    /**
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/coord/cartesian/GridModel} gridModel
     * @private
     */
    _splitLine: function (axisModel, gridModel) {
      var axis = axisModel.axis;

      if (axis.scale.isBlank()) {
        return;
      }

      var splitLineModel = axisModel.getModel('splitLine');
      var lineStyleModel = splitLineModel.getModel('lineStyle');
      var lineColors = lineStyleModel.get('color');
      lineColors = util.isArray(lineColors) ? lineColors : [lineColors];
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var lineCount = 0;
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitLineModel
      });
      var p1 = [];
      var p2 = [];
      var lineStyle = lineStyleModel.getLineStyle();

      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);

        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }

        var colorIndex = lineCount++ % lineColors.length;
        var tickValue = ticksCoords[i].tickValue;

        this._axisGroup.add(new graphic.Line({
          anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,
          subPixelOptimize: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: util.defaults({
            stroke: lineColors[colorIndex]
          }, lineStyle),
          silent: true
        }));
      }
    },

    /**
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/coord/cartesian/GridModel} gridModel
     * @private
     */
    _minorSplitLine: function (axisModel, gridModel) {
      var axis = axisModel.axis;
      var minorSplitLineModel = axisModel.getModel('minorSplitLine');
      var lineStyleModel = minorSplitLineModel.getModel('lineStyle');
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var minorTicksCoords = axis.getMinorTicksCoords();

      if (!minorTicksCoords.length) {
        return;
      }

      var p1 = [];
      var p2 = [];
      var lineStyle = lineStyleModel.getLineStyle();

      for (var i = 0; i < minorTicksCoords.length; i++) {
        for (var k = 0; k < minorTicksCoords[i].length; k++) {
          var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);

          if (isHorizontal) {
            p1[0] = tickCoord;
            p1[1] = gridRect.y;
            p2[0] = tickCoord;
            p2[1] = gridRect.y + gridRect.height;
          } else {
            p1[0] = gridRect.x;
            p1[1] = tickCoord;
            p2[0] = gridRect.x + gridRect.width;
            p2[1] = tickCoord;
          }

          this._axisGroup.add(new graphic.Line({
            anid: 'minor_line_' + minorTicksCoords[i][k].tickValue,
            subPixelOptimize: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: lineStyle,
            silent: true
          }));
        }
      }
    },

    /**
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/coord/cartesian/GridModel} gridModel
     * @private
     */
    _splitArea: function (axisModel, gridModel) {
      rectCoordAxisBuildSplitArea$1(this, this._axisGroup, axisModel, gridModel);
    }
  });
  CartesianAxisView.extend({
    type: 'xAxis'
  });
  CartesianAxisView.extend({
    type: 'yAxis'
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */











  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Grid view
  echarts.extendComponentView({
    type: 'grid',
    render: function (gridModel, ecModel) {
      this.group.removeAll();

      if (gridModel.get('show')) {
        this.group.add(new graphic.Rect({
          shape: gridModel.coordinateSystem.getRect(),
          style: util.defaults({
            fill: gridModel.get('backgroundColor')
          }, gridModel.getItemStyle()),
          silent: true,
          z2: -1
        }));
      }
    }
  });
  echarts.registerPreprocessor(function (option) {
    // Only create grid when need
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */















  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // In case developer forget to include grid component
  echarts.registerVisual(symbol$1('line', 'circle', 'line'));
  echarts.registerLayout(points$1('line')); // Down sample after filter

  echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}
   * @param {module:echarts/model/Global} ecModel
   * @return {Object} {point: [x, y], el: ...} point Will not be null.
   */
  function _default$1M(finder, ecModel) {
    var point = [];
    var seriesIndex = finder.seriesIndex;
    var seriesModel;

    if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
      return {
        point: []
      };
    }

    var data = seriesModel.getData();
    var dataIndex = model.queryDataIndex(data, finder);

    if (dataIndex == null || dataIndex < 0 || util.isArray(dataIndex)) {
      return {
        point: []
      };
    }

    var el = data.getItemGraphicEl(dataIndex);
    var coordSys = seriesModel.coordinateSystem;

    if (seriesModel.getTooltipPosition) {
      point = seriesModel.getTooltipPosition(dataIndex) || [];
    } else if (coordSys && coordSys.dataToPoint) {
      point = coordSys.dataToPoint(data.getValues(util.map(coordSys.dimensions, function (dim) {
        return data.mapDimension(dim);
      }), dataIndex, true)) || [];
    } else if (el) {
      // Use graphic bounding rect
      var rect = el.getBoundingRect().clone();
      rect.applyTransform(el.transform);
      point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    }

    return {
      point: point,
      el: el
    };
  }

  var findPointFromSeries = _default$1M;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  var makeInner$7 = model.makeInner;





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var each$n = util.each;
  var curry$2 = util.curry;
  var inner$7 = makeInner$7();
  /**
   * Basic logic: check all axis, if they do not demand show/highlight,
   * then hide/downplay them.
   *
   * @param {Object} coordSysAxesInfo
   * @param {Object} payload
   * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'
   * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to
   *              trigger axisPointer and tooltip.
   * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to
   *              trigger axisPointer and tooltip.
   * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.
   * @param {Object} [payload.dataIndex] finder, restrict target axes.
   * @param {Object} [payload.axesInfo] finder, restrict target axes.
   *        [{
   *          axisDim: 'x'|'y'|'angle'|...,
   *          axisIndex: ...,
   *          value: ...
   *        }, ...]
   * @param {Function} [payload.dispatchAction]
   * @param {Object} [payload.tooltipOption]
   * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,
   *        which can be specified in dispatchAction
   * @param {module:echarts/model/Global} ecModel
   * @param {module:echarts/ExtensionAPI} api
   * @return {Object} content of event obj for echarts.connect.
   */

  function _default$1N(payload, ecModel, api) {
    var currTrigger = payload.currTrigger;
    var point = [payload.x, payload.y];
    var finder = payload;
    var dispatchAction = payload.dispatchAction || util.bind(api.dispatchAction, api);
    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending
    // See #6121. But we are not able to reproduce it yet.

    if (!coordSysAxesInfo) {
      return;
    }

    if (illegalPoint(point)) {
      // Used in the default behavior of `connection`: use the sample seriesIndex
      // and dataIndex. And also used in the tooltipView trigger.
      point = findPointFromSeries({
        seriesIndex: finder.seriesIndex,
        // Do not use dataIndexInside from other ec instance.
        // FIXME: auto detect it?
        dataIndex: finder.dataIndex
      }, ecModel).point;
    }

    var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
    // Notice: In this case, it is difficult to get the `point` (which is necessary to show
    // tooltip, so if point is not given, we just use the point found by sample seriesIndex
    // and dataIndex.

    var inputAxesInfo = finder.axesInfo;
    var axesInfo = coordSysAxesInfo.axesInfo;
    var shouldHide = currTrigger === 'leave' || illegalPoint(point);
    var outputFinder = {};
    var showValueMap = {};
    var dataByCoordSys = {
      list: [],
      map: {}
    };
    var updaters = {
      showPointer: curry$2(showPointer, showValueMap),
      showTooltip: curry$2(showTooltip, dataByCoordSys)
    }; // Process for triggered axes.

    each$n(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
      // If a point given, it must be contained by the coordinate system.
      var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
      each$n(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
        var axis = axisInfo.axis;
        var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.

        if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
          var val = inputAxisInfo && inputAxisInfo.value;

          if (val == null && !isIllegalPoint) {
            val = axis.pointToData(point);
          }

          val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);
        }
      });
    }); // Process for linked axes.

    var linkTriggers = {};
    each$n(axesInfo, function (tarAxisInfo, tarKey) {
      var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.

      if (linkGroup && !showValueMap[tarKey]) {
        each$n(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
          var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.

          if (srcAxisInfo !== tarAxisInfo && srcValItem) {
            var val = srcValItem.value;
            linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
            linkTriggers[tarAxisInfo.key] = val;
          }
        });
      }
    });
    each$n(linkTriggers, function (val, tarKey) {
      processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);
    });
    updateModelActually(showValueMap, axesInfo, outputFinder);
    dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
    dispatchHighDownActually(axesInfo, dispatchAction, api);
    return outputFinder;
  }

  function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
    var axis = axisInfo.axis;

    if (axis.scale.isBlank() || !axis.containData(newValue)) {
      return;
    }

    if (!axisInfo.involveSeries) {
      updaters.showPointer(axisInfo, newValue);
      return;
    } // Heavy calculation. So put it after axis.containData checking.


    var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
    var payloadBatch = payloadInfo.payloadBatch;
    var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.
    // By default use the first involved series data as a sample to connect.

    if (payloadBatch[0] && outputFinder.seriesIndex == null) {
      util.extend(outputFinder, payloadBatch[0]);
    } // If no linkSource input, this process is for collecting link
    // target, where snap should not be accepted.


    if (!dontSnap && axisInfo.snap) {
      if (axis.containData(snapToValue) && snapToValue != null) {
        newValue = snapToValue;
      }
    }

    updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be
    // incorrect "axis value ~ series value" mapping displayed in tooltip.

    updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
  }

  function buildPayloadsBySeries(value, axisInfo) {
    var axis = axisInfo.axis;
    var dim = axis.dim;
    var snapToValue = value;
    var payloadBatch = [];
    var minDist = Number.MAX_VALUE;
    var minDiff = -1;
    each$n(axisInfo.seriesModels, function (series, idx) {
      var dataDim = series.getData().mapDimension(dim, true);
      var seriesNestestValue;
      var dataIndices;

      if (series.getAxisTooltipData) {
        var result = series.getAxisTooltipData(dataDim, value, axis);
        dataIndices = result.dataIndices;
        seriesNestestValue = result.nestestValue;
      } else {
        dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        axis.type === 'category' ? 0.5 : null);

        if (!dataIndices.length) {
          return;
        }

        seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
      }

      if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
        return;
      }

      var diff = value - seriesNestestValue;
      var dist = Math.abs(diff); // Consider category case

      if (dist <= minDist) {
        if (dist < minDist || diff >= 0 && minDiff < 0) {
          minDist = dist;
          minDiff = diff;
          snapToValue = seriesNestestValue;
          payloadBatch.length = 0;
        }

        each$n(dataIndices, function (dataIndex) {
          payloadBatch.push({
            seriesIndex: series.seriesIndex,
            dataIndexInside: dataIndex,
            dataIndex: series.getData().getRawIndex(dataIndex)
          });
        });
      }
    });
    return {
      payloadBatch: payloadBatch,
      snapToValue: snapToValue
    };
  }

  function showPointer(showValueMap, axisInfo, value, payloadBatch) {
    showValueMap[axisInfo.key] = {
      value: value,
      payloadBatch: payloadBatch
    };
  }

  function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
    var payloadBatch = payloadInfo.payloadBatch;
    var axis = axisInfo.axis;
    var axisModel = axis.model;
    var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,
    // whose length will be used to judge whether dispatch action.

    if (!axisInfo.triggerTooltip || !payloadBatch.length) {
      return;
    }

    var coordSysModel = axisInfo.coordSys.model;
    var coordSysKey = modelHelper.makeKey(coordSysModel);
    var coordSysItem = dataByCoordSys.map[coordSysKey];

    if (!coordSysItem) {
      coordSysItem = dataByCoordSys.map[coordSysKey] = {
        coordSysId: coordSysModel.id,
        coordSysIndex: coordSysModel.componentIndex,
        coordSysType: coordSysModel.type,
        coordSysMainType: coordSysModel.mainType,
        dataByAxis: []
      };
      dataByCoordSys.list.push(coordSysItem);
    }

    coordSysItem.dataByAxis.push({
      axisDim: axis.dim,
      axisIndex: axisModel.componentIndex,
      axisType: axisModel.type,
      axisId: axisModel.id,
      value: value,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: axisPointerModel.get('label.precision'),
        formatter: axisPointerModel.get('label.formatter')
      },
      seriesDataIndices: payloadBatch.slice()
    });
  }

  function updateModelActually(showValueMap, axesInfo, outputFinder) {
    var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.

    each$n(axesInfo, function (axisInfo, key) {
      var option = axisInfo.axisPointerModel.option;
      var valItem = showValueMap[key];

      if (valItem) {
        !axisInfo.useHandle && (option.status = 'show');
        option.value = valItem.value; // For label formatter param and highlight.

        option.seriesDataIndices = (valItem.payloadBatch || []).slice();
      } // When always show (e.g., handle used), remain
      // original value and status.
      else {
          // If hide, value still need to be set, consider
          // click legend to toggle axis blank.
          !axisInfo.useHandle && (option.status = 'hide');
        } // If status is 'hide', should be no info in payload.


      option.status === 'show' && outputAxesInfo.push({
        axisDim: axisInfo.axis.dim,
        axisIndex: axisInfo.axis.model.componentIndex,
        value: option.value
      });
    });
  }

  function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
    // Basic logic: If no showTip required, hideTip will be dispatched.
    if (illegalPoint(point) || !dataByCoordSys.list.length) {
      dispatchAction({
        type: 'hideTip'
      });
      return;
    } // In most case only one axis (or event one series is used). It is
    // convinient to fetch payload.seriesIndex and payload.dataIndex
    // dirtectly. So put the first seriesIndex and dataIndex of the first
    // axis on the payload.


    var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
    dispatchAction({
      type: 'showTip',
      escapeConnect: true,
      x: point[0],
      y: point[1],
      tooltipOption: payload.tooltipOption,
      position: payload.position,
      dataIndexInside: sampleItem.dataIndexInside,
      dataIndex: sampleItem.dataIndex,
      seriesIndex: sampleItem.seriesIndex,
      dataByCoordSys: dataByCoordSys.list
    });
  }

  function dispatchHighDownActually(axesInfo, dispatchAction, api) {
    // FIXME
    // highlight status modification shoule be a stage of main process?
    // (Consider confilct (e.g., legend and axisPointer) and setOption)
    var zr = api.getZr();
    var highDownKey = 'axisPointerLastHighlights';
    var lastHighlights = inner$7(zr)[highDownKey] || {};
    var newHighlights = inner$7(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.
    // Build hash map and remove duplicate incidentally.

    each$n(axesInfo, function (axisInfo, key) {
      var option = axisInfo.axisPointerModel.option;
      option.status === 'show' && each$n(option.seriesDataIndices, function (batchItem) {
        var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;
        newHighlights[key] = batchItem;
      });
    }); // Diff.

    var toHighlight = [];
    var toDownplay = [];
    util.each(lastHighlights, function (batchItem, key) {
      !newHighlights[key] && toDownplay.push(batchItem);
    });
    util.each(newHighlights, function (batchItem, key) {
      !lastHighlights[key] && toHighlight.push(batchItem);
    });
    toDownplay.length && api.dispatchAction({
      type: 'downplay',
      escapeConnect: true,
      batch: toDownplay
    });
    toHighlight.length && api.dispatchAction({
      type: 'highlight',
      escapeConnect: true,
      batch: toHighlight
    });
  }

  function findInputAxisInfo(inputAxesInfo, axisInfo) {
    for (var i = 0; i < (inputAxesInfo || []).length; i++) {
      var inputAxisInfo = inputAxesInfo[i];

      if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
        return inputAxisInfo;
      }
    }
  }

  function makeMapperParam(axisInfo) {
    var axisModel = axisInfo.axis.model;
    var item = {};
    var dim = item.axisDim = axisInfo.axis.dim;
    item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;
    item.axisName = item[dim + 'AxisName'] = axisModel.name;
    item.axisId = item[dim + 'AxisId'] = axisModel.id;
    return item;
  }

  function illegalPoint(point) {
    return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
  }

  var axisTrigger = _default$1N;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var AxisPointerModel = echarts.extendComponentModel({
    type: 'axisPointer',
    coordSysAxesInfo: null,
    defaultOption: {
      // 'auto' means that show when triggered by tooltip or handle.
      show: 'auto',
      // 'click' | 'mousemove' | 'none'
      triggerOn: null,
      // set default in AxisPonterView.js
      zlevel: 0,
      z: 50,
      type: 'line',
      // 'line' 'shadow' 'cross' 'none'.
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: false,
      triggerTooltip: true,
      value: null,
      status: null,
      // Init value depends on whether handle is used.
      // [group0, group1, ...]
      // Each group can be: {
      //      mapper: function () {},
      //      singleTooltip: 'multiple',  // 'multiple' or 'single'
      //      xAxisId: ...,
      //      yAxisName: ...,
      //      angleAxisIndex: ...
      // }
      // mapper: can be ignored.
      //      input: {axisInfo, value}
      //      output: {axisInfo, value}
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: '#aaa',
        width: 1,
        type: 'solid'
      },
      shadowStyle: {
        color: 'rgba(150,150,150,0.3)'
      },
      label: {
        show: true,
        formatter: null,
        // string | Function
        precision: 'auto',
        // Or a number like 0, 1, 2 ...
        margin: 3,
        color: '#fff',
        padding: [5, 7, 5, 7],
        backgroundColor: 'auto',
        // default: axis line color
        borderColor: null,
        borderWidth: 0,
        shadowBlur: 3,
        shadowColor: '#aaa' // Considering applicability, common style should
        // better not have shadowOffset.
        // shadowOffsetX: 0,
        // shadowOffsetY: 2

      },
      handle: {
        show: false,

        /* eslint-disable */
        icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
        // jshint ignore:line

        /* eslint-enable */
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: '#333',
        shadowBlur: 3,
        shadowColor: '#aaa',
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  var makeInner$8 = model.makeInner;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var inner$8 = makeInner$8();
  var each$o = util.each;
  /**
   * @param {string} key
   * @param {module:echarts/ExtensionAPI} api
   * @param {Function} handler
   *      param: {string} currTrigger
   *      param: {Array.<number>} point
   */

  function register(key, api, handler) {
    if (env_1.node) {
      return;
    }

    var zr = api.getZr();
    inner$8(zr).records || (inner$8(zr).records = {});
    initGlobalListeners(zr, api);
    var record = inner$8(zr).records[key] || (inner$8(zr).records[key] = {});
    record.handler = handler;
  }

  function initGlobalListeners(zr, api) {
    if (inner$8(zr).initialized) {
      return;
    }

    inner$8(zr).initialized = true;
    useHandler('click', util.curry(doEnter, 'click'));
    useHandler('mousemove', util.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);

    useHandler('globalout', onLeave);

    function useHandler(eventType, cb) {
      zr.on(eventType, function (e) {
        var dis = makeDispatchAction(api);
        each$o(inner$8(zr).records, function (record) {
          record && cb(record, e, dis.dispatchAction);
        });
        dispatchTooltipFinally(dis.pendings, api);
      });
    }
  }

  function dispatchTooltipFinally(pendings, api) {
    var showLen = pendings.showTip.length;
    var hideLen = pendings.hideTip.length;
    var actuallyPayload;

    if (showLen) {
      actuallyPayload = pendings.showTip[showLen - 1];
    } else if (hideLen) {
      actuallyPayload = pendings.hideTip[hideLen - 1];
    }

    if (actuallyPayload) {
      actuallyPayload.dispatchAction = null;
      api.dispatchAction(actuallyPayload);
    }
  }

  function onLeave(record, e, dispatchAction) {
    record.handler('leave', null, dispatchAction);
  }

  function doEnter(currTrigger, record, e, dispatchAction) {
    record.handler(currTrigger, e, dispatchAction);
  }

  function makeDispatchAction(api) {
    var pendings = {
      showTip: [],
      hideTip: []
    }; // FIXME
    // better approach?
    // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
    // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
    // So we have to add "final stage" to merge those dispatched actions.

    var dispatchAction = function (payload) {
      var pendingList = pendings[payload.type];

      if (pendingList) {
        pendingList.push(payload);
      } else {
        payload.dispatchAction = dispatchAction;
        api.dispatchAction(payload);
      }
    };

    return {
      dispatchAction: dispatchAction,
      pendings: pendings
    };
  }
  /**
   * @param {string} key
   * @param {module:echarts/ExtensionAPI} api
   */


  function unregister(key, api) {
    if (env_1.node) {
      return;
    }

    var zr = api.getZr();
    var record = (inner$8(zr).records || {})[key];

    if (record) {
      inner$8(zr).records[key] = null;
    }
  }

  var register_1 = register;
  var unregister_1 = unregister;

  var globalListener = {
  	register: register_1,
  	unregister: unregister_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var AxisPointerView = echarts.extendComponentView({
    type: 'axisPointer',
    render: function (globalAxisPointerModel, ecModel, api) {
      var globalTooltipModel = ecModel.getComponent('tooltip');
      var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable
      // AxisPointerView to be independent to Tooltip.

      globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {
        // If 'none', it is not controlled by mouse totally.
        if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
          dispatchAction({
            type: 'updateAxisPointer',
            currTrigger: currTrigger,
            x: e && e.offsetX,
            y: e && e.offsetY
          });
        }
      });
    },

    /**
     * @override
     */
    remove: function (ecModel, api) {
      globalListener.unregister(api.getZr(), 'axisPointer');
      AxisPointerView.superApply(this._model, 'remove', arguments);
    },

    /**
     * @override
     */
    dispose: function (ecModel, api) {
      globalListener.unregister('axisPointer', api);
      AxisPointerView.superApply(this._model, 'dispose', arguments);
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */















  var makeInner$9 = model.makeInner;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var inner$9 = makeInner$9();
  var clone$7 = util.clone;
  var bind$2 = util.bind;
  /**
   * Base axis pointer class in 2D.
   * Implemenents {module:echarts/component/axis/IAxisPointer}.
   */

  function BaseAxisPointer() {}

  BaseAxisPointer.prototype = {
    /**
     * @private
     */
    _group: null,

    /**
     * @private
     */
    _lastGraphicKey: null,

    /**
     * @private
     */
    _handle: null,

    /**
     * @private
     */
    _dragging: false,

    /**
     * @private
     */
    _lastValue: null,

    /**
     * @private
     */
    _lastStatus: null,

    /**
     * @private
     */
    _payloadInfo: null,

    /**
     * In px, arbitrary value. Do not set too small,
     * no animation is ok for most cases.
     * @protected
     */
    animationThreshold: 15,

    /**
     * @implement
     */
    render: function (axisModel, axisPointerModel, api, forceRender) {
      var value = axisPointerModel.get('value');
      var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not
      // be replaced when user calling setOption in not merge mode.

      this._axisModel = axisModel;
      this._axisPointerModel = axisPointerModel;
      this._api = api; // Optimize: `render` will be called repeatly during mouse move.
      // So it is power consuming if performing `render` each time,
      // especially on mobile device.

      if (!forceRender && this._lastValue === value && this._lastStatus === status) {
        return;
      }

      this._lastValue = value;
      this._lastStatus = status;
      var group = this._group;
      var handle = this._handle;

      if (!status || status === 'hide') {
        // Do not clear here, for animation better.
        group && group.hide();
        handle && handle.hide();
        return;
      }

      group && group.show();
      handle && handle.show(); // Otherwise status is 'show'

      var elOption = {};
      this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.

      var graphicKey = elOption.graphicKey;

      if (graphicKey !== this._lastGraphicKey) {
        this.clear(api);
      }

      this._lastGraphicKey = graphicKey;
      var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);

      if (!group) {
        group = this._group = new graphic.Group();
        this.createPointerEl(group, elOption, axisModel, axisPointerModel);
        this.createLabelEl(group, elOption, axisModel, axisPointerModel);
        api.getZr().add(group);
      } else {
        var doUpdateProps = util.curry(updateProps$1, axisPointerModel, moveAnimation);
        this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);
        this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
      }

      updateMandatoryProps(group, axisPointerModel, true);

      this._renderHandle(value);
    },

    /**
     * @implement
     */
    remove: function (api) {
      this.clear(api);
    },

    /**
     * @implement
     */
    dispose: function (api) {
      this.clear(api);
    },

    /**
     * @protected
     */
    determineAnimation: function (axisModel, axisPointerModel) {
      var animation = axisPointerModel.get('animation');
      var axis = axisModel.axis;
      var isCategoryAxis = axis.type === 'category';
      var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.

      if (!useSnap && !isCategoryAxis) {
        return false;
      }

      if (animation === 'auto' || animation == null) {
        var animationThreshold = this.animationThreshold;

        if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
          return true;
        } // It is important to auto animation when snap used. Consider if there is
        // a dataZoom, animation will be disabled when too many points exist, while
        // it will be enabled for better visual effect when little points exist.


        if (useSnap) {
          var seriesDataCount = modelHelper.getAxisInfo(axisModel).seriesDataCount;
          var axisExtent = axis.getExtent(); // Approximate band width

          return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
        }

        return false;
      }

      return animation === true;
    },

    /**
     * add {pointer, label, graphicKey} to elOption
     * @protected
     */
    makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.
    },

    /**
     * @protected
     */
    createPointerEl: function (group, elOption, axisModel, axisPointerModel) {
      var pointerOption = elOption.pointer;

      if (pointerOption) {
        var pointerEl = inner$9(group).pointerEl = new graphic[pointerOption.type](clone$7(elOption.pointer));
        group.add(pointerEl);
      }
    },

    /**
     * @protected
     */
    createLabelEl: function (group, elOption, axisModel, axisPointerModel) {
      if (elOption.label) {
        var labelEl = inner$9(group).labelEl = new graphic.Rect(clone$7(elOption.label));
        group.add(labelEl);
        updateLabelShowHide(labelEl, axisPointerModel);
      }
    },

    /**
     * @protected
     */
    updatePointerEl: function (group, elOption, updateProps) {
      var pointerEl = inner$9(group).pointerEl;

      if (pointerEl && elOption.pointer) {
        pointerEl.setStyle(elOption.pointer.style);
        updateProps(pointerEl, {
          shape: elOption.pointer.shape
        });
      }
    },

    /**
     * @protected
     */
    updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {
      var labelEl = inner$9(group).labelEl;

      if (labelEl) {
        labelEl.setStyle(elOption.label.style);
        updateProps(labelEl, {
          // Consider text length change in vertical axis, animation should
          // be used on shape, otherwise the effect will be weird.
          shape: elOption.label.shape,
          position: elOption.label.position
        });
        updateLabelShowHide(labelEl, axisPointerModel);
      }
    },

    /**
     * @private
     */
    _renderHandle: function (value) {
      if (this._dragging || !this.updateHandleTransform) {
        return;
      }

      var axisPointerModel = this._axisPointerModel;

      var zr = this._api.getZr();

      var handle = this._handle;
      var handleModel = axisPointerModel.getModel('handle');
      var status = axisPointerModel.get('status');

      if (!handleModel.get('show') || !status || status === 'hide') {
        handle && zr.remove(handle);
        this._handle = null;
        return;
      }

      var isInit;

      if (!this._handle) {
        isInit = true;
        handle = this._handle = graphic.createIcon(handleModel.get('icon'), {
          cursor: 'move',
          draggable: true,
          onmousemove: function (e) {
            // Fot mobile devicem, prevent screen slider on the button.
            event.stop(e.event);
          },
          onmousedown: bind$2(this._onHandleDragMove, this, 0, 0),
          drift: bind$2(this._onHandleDragMove, this),
          ondragend: bind$2(this._onHandleDragEnd, this)
        });
        zr.add(handle);
      }

      updateMandatoryProps(handle, axisPointerModel, false); // update style

      var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];
      handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position

      var handleSize = handleModel.get('size');

      if (!util.isArray(handleSize)) {
        handleSize = [handleSize, handleSize];
      }

      handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);
      throttle_1.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');

      this._moveHandleToValue(value, isInit);
    },

    /**
     * @private
     */
    _moveHandleToValue: function (value, isInit) {
      updateProps$1(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
    },

    /**
     * @private
     */
    _onHandleDragMove: function (dx, dy) {
      var handle = this._handle;

      if (!handle) {
        return;
      }

      this._dragging = true; // Persistent for throttle.

      var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
      this._payloadInfo = trans;
      handle.stopAnimation();
      handle.attr(getHandleTransProps(trans));
      inner$9(handle).lastProp = null;

      this._doDispatchAxisPointer();
    },

    /**
     * Throttled method.
     * @private
     */
    _doDispatchAxisPointer: function () {
      var handle = this._handle;

      if (!handle) {
        return;
      }

      var payloadInfo = this._payloadInfo;
      var axisModel = this._axisModel;

      this._api.dispatchAction({
        type: 'updateAxisPointer',
        x: payloadInfo.cursorPoint[0],
        y: payloadInfo.cursorPoint[1],
        tooltipOption: payloadInfo.tooltipOption,
        axesInfo: [{
          axisDim: axisModel.axis.dim,
          axisIndex: axisModel.componentIndex
        }]
      });
    },

    /**
     * @private
     */
    _onHandleDragEnd: function (moveAnimation) {
      this._dragging = false;
      var handle = this._handle;

      if (!handle) {
        return;
      }

      var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with
      // axisPointer. So move handle to align the exact value position when
      // drag ended.


      this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle
      // button, and will be hidden after finger left handle button.


      this._api.dispatchAction({
        type: 'hideTip'
      });
    },

    /**
     * Should be implemenented by sub-class if support `handle`.
     * @protected
     * @param {number} value
     * @param {module:echarts/model/Model} axisModel
     * @param {module:echarts/model/Model} axisPointerModel
     * @return {Object} {position: [x, y], rotation: 0}
     */
    getHandleTransform: null,

    /**
     * * Should be implemenented by sub-class if support `handle`.
     * @protected
     * @param {Object} transform {position, rotation}
     * @param {Array.<number>} delta [dx, dy]
     * @param {module:echarts/model/Model} axisModel
     * @param {module:echarts/model/Model} axisPointerModel
     * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}
     */
    updateHandleTransform: null,

    /**
     * @private
     */
    clear: function (api) {
      this._lastValue = null;
      this._lastStatus = null;
      var zr = api.getZr();
      var group = this._group;
      var handle = this._handle;

      if (zr && group) {
        this._lastGraphicKey = null;
        group && zr.remove(group);
        handle && zr.remove(handle);
        this._group = null;
        this._handle = null;
        this._payloadInfo = null;
      }
    },

    /**
     * @protected
     */
    doClear: function () {// Implemented by sub-class if necessary.
    },

    /**
     * @protected
     * @param {Array.<number>} xy
     * @param {Array.<number>} wh
     * @param {number} [xDimIndex=0] or 1
     */
    buildLabel: function (xy, wh, xDimIndex) {
      xDimIndex = xDimIndex || 0;
      return {
        x: xy[xDimIndex],
        y: xy[1 - xDimIndex],
        width: wh[xDimIndex],
        height: wh[1 - xDimIndex]
      };
    }
  };
  BaseAxisPointer.prototype.constructor = BaseAxisPointer;

  function updateProps$1(animationModel, moveAnimation, el, props) {
    // Animation optimize.
    if (!propsEqual(inner$9(el).lastProp, props)) {
      inner$9(el).lastProp = props;
      moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
    }
  }

  function propsEqual(lastProps, newProps) {
    if (util.isObject(lastProps) && util.isObject(newProps)) {
      var equals = true;
      util.each(newProps, function (item, key) {
        equals = equals && propsEqual(lastProps[key], item);
      });
      return !!equals;
    } else {
      return lastProps === newProps;
    }
  }

  function updateLabelShowHide(labelEl, axisPointerModel) {
    labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();
  }

  function getHandleTransProps(trans) {
    return {
      position: trans.position.slice(),
      rotation: trans.rotation || 0
    };
  }

  function updateMandatoryProps(group, axisPointerModel, silent) {
    var z = axisPointerModel.get('z');
    var zlevel = axisPointerModel.get('zlevel');
    group && group.traverse(function (el) {
      if (el.type !== 'group') {
        z != null && (el.z = z);
        zlevel != null && (el.zlevel = zlevel);
        el.silent = silent;
      }
    });
  }

  clazz.enableClassExtend(BaseAxisPointer);
  var _default$1O = BaseAxisPointer;
  var BaseAxisPointer_1 = _default$1O;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */















  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @param {module:echarts/model/Model} axisPointerModel
   */
  function buildElStyle(axisPointerModel) {
    var axisPointerType = axisPointerModel.get('type');
    var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');
    var style;

    if (axisPointerType === 'line') {
      style = styleModel.getLineStyle();
      style.fill = null;
    } else if (axisPointerType === 'shadow') {
      style = styleModel.getAreaStyle();
      style.stroke = null;
    }

    return style;
  }
  /**
   * @param {Function} labelPos {align, verticalAlign, position}
   */


  function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
    var value = axisPointerModel.get('value');
    var text$1 = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
      precision: axisPointerModel.get('label.precision'),
      formatter: axisPointerModel.get('label.formatter')
    });
    var labelModel = axisPointerModel.getModel('label');
    var paddings = format$1.normalizeCssArray(labelModel.get('padding') || 0);
    var font = labelModel.getFont();
    var textRect = text.getBoundingRect(text$1, font);
    var position = labelPos.position;
    var width = textRect.width + paddings[1] + paddings[3];
    var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.

    var align = labelPos.align;
    align === 'right' && (position[0] -= width);
    align === 'center' && (position[0] -= width / 2);
    var verticalAlign = labelPos.verticalAlign;
    verticalAlign === 'bottom' && (position[1] -= height);
    verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container

    confineInContainer(position, width, height, api);
    var bgColor = labelModel.get('backgroundColor');

    if (!bgColor || bgColor === 'auto') {
      bgColor = axisModel.get('axisLine.lineStyle.color');
    }

    elOption.label = {
      shape: {
        x: 0,
        y: 0,
        width: width,
        height: height,
        r: labelModel.get('borderRadius')
      },
      position: position.slice(),
      // TODO: rich
      style: {
        text: text$1,
        textFont: font,
        textFill: labelModel.getTextColor(),
        textPosition: 'inside',
        textPadding: paddings,
        fill: bgColor,
        stroke: labelModel.get('borderColor') || 'transparent',
        lineWidth: labelModel.get('borderWidth') || 0,
        shadowBlur: labelModel.get('shadowBlur'),
        shadowColor: labelModel.get('shadowColor'),
        shadowOffsetX: labelModel.get('shadowOffsetX'),
        shadowOffsetY: labelModel.get('shadowOffsetY')
      },
      // Lable should be over axisPointer.
      z2: 10
    };
  } // Do not overflow ec container


  function confineInContainer(position, width, height, api) {
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    position[0] = Math.min(position[0] + width, viewWidth) - width;
    position[1] = Math.min(position[1] + height, viewHeight) - height;
    position[0] = Math.max(position[0], 0);
    position[1] = Math.max(position[1], 0);
  }
  /**
   * @param {number} value
   * @param {module:echarts/coord/Axis} axis
   * @param {module:echarts/model/Global} ecModel
   * @param {Object} opt
   * @param {Array.<Object>} seriesDataIndices
   * @param {number|string} opt.precision 'auto' or a number
   * @param {string|Function} opt.formatter label formatter
   */


  function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
    value = axis.scale.parse(value);
    var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    value, {
      precision: opt.precision
    });
    var formatter = opt.formatter;

    if (formatter) {
      var params = {
        value: axisHelper.getAxisRawValue(axis, value),
        axisDimension: axis.dim,
        axisIndex: axis.index,
        seriesData: []
      };
      util.each(seriesDataIndices, function (idxItem) {
        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
        var dataIndex = idxItem.dataIndexInside;
        var dataParams = series && series.getDataParams(dataIndex);
        dataParams && params.seriesData.push(dataParams);
      });

      if (util.isString(formatter)) {
        text = formatter.replace('{value}', text);
      } else if (util.isFunction(formatter)) {
        text = formatter(params);
      }
    }

    return text;
  }
  /**
   * @param {module:echarts/coord/Axis} axis
   * @param {number} value
   * @param {Object} layoutInfo {
   *  rotation, position, labelOffset, labelDirection, labelMargin
   * }
   */


  function getTransformedPosition(axis, value, layoutInfo) {
    var transform = matrix.create();
    matrix.rotate(transform, transform, layoutInfo.rotation);
    matrix.translate(transform, transform, layoutInfo.position);
    return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
  }

  function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
    var textLayout = AxisBuilder_1.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
    layoutInfo.labelMargin = axisPointerModel.get('label.margin');
    buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
      position: getTransformedPosition(axisModel.axis, value, layoutInfo),
      align: textLayout.textAlign,
      verticalAlign: textLayout.textVerticalAlign
    });
  }
  /**
   * @param {Array.<number>} p1
   * @param {Array.<number>} p2
   * @param {number} [xDimIndex=0] or 1
   */


  function makeLineShape(p1, p2, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x1: p1[xDimIndex],
      y1: p1[1 - xDimIndex],
      x2: p2[xDimIndex],
      y2: p2[1 - xDimIndex]
    };
  }
  /**
   * @param {Array.<number>} xy
   * @param {Array.<number>} wh
   * @param {number} [xDimIndex=0] or 1
   */


  function makeRectShape(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  }

  function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
    return {
      cx: cx,
      cy: cy,
      r0: r0,
      r: r,
      startAngle: startAngle,
      endAngle: endAngle,
      clockwise: true
    };
  }

  var buildElStyle_1 = buildElStyle;
  var buildLabelElOption_1 = buildLabelElOption;
  var getValueLabel_1 = getValueLabel;
  var getTransformedPosition_1 = getTransformedPosition;
  var buildCartesianSingleLabelElOption_1 = buildCartesianSingleLabelElOption;
  var makeLineShape_1 = makeLineShape;
  var makeRectShape_1 = makeRectShape;
  var makeSectorShape_1 = makeSectorShape;

  var viewHelper = {
  	buildElStyle: buildElStyle_1,
  	buildLabelElOption: buildLabelElOption_1,
  	getValueLabel: getValueLabel_1,
  	getTransformedPosition: getTransformedPosition_1,
  	buildCartesianSingleLabelElOption: buildCartesianSingleLabelElOption_1,
  	makeLineShape: makeLineShape_1,
  	makeRectShape: makeRectShape_1,
  	makeSectorShape: makeSectorShape_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var CartesianAxisPointer = BaseAxisPointer_1.extend({
    /**
     * @override
     */
    makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {
      var axis = axisModel.axis;
      var grid = axis.grid;
      var axisPointerType = axisPointerModel.get('type');
      var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
      var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));

      if (axisPointerType && axisPointerType !== 'none') {
        var elStyle = viewHelper.buildElStyle(axisPointerModel);
        var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
        pointerOption.style = elStyle;
        elOption.graphicKey = pointerOption.type;
        elOption.pointer = pointerOption;
      }

      var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);
      viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
    },

    /**
     * @override
     */
    getHandleTransform: function (value, axisModel, axisPointerModel) {
      var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {
        labelInside: false
      });
      layoutInfo.labelMargin = axisPointerModel.get('handle.margin');
      return {
        position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
        rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
      };
    },

    /**
     * @override
     */
    updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {
      var axis = axisModel.axis;
      var grid = axis.grid;
      var axisExtent = axis.getGlobalExtent(true);
      var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
      var dimIndex = axis.dim === 'x' ? 0 : 1;
      var currPosition = transform.position;
      currPosition[dimIndex] += delta[dimIndex];
      currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
      currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
      var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
      var cursorPoint = [cursorOtherValue, cursorOtherValue];
      cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.

      var tooltipOptions = [{
        verticalAlign: 'middle'
      }, {
        align: 'center'
      }];
      return {
        position: currPosition,
        rotation: transform.rotation,
        cursorPoint: cursorPoint,
        tooltipOption: tooltipOptions[dimIndex]
      };
    }
  });

  function getCartesian(grid, axis) {
    var opt = {};
    opt[axis.dim + 'AxisIndex'] = axis.index;
    return grid.getCartesian(opt);
  }

  var pointerShapeBuilder = {
    line: function (axis, pixelValue, otherExtent) {
      var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
      return {
        type: 'Line',
        subPixelOptimize: true,
        shape: targetShape
      };
    },
    shadow: function (axis, pixelValue, otherExtent) {
      var bandWidth = Math.max(1, axis.getBandWidth());
      var span = otherExtent[1] - otherExtent[0];
      return {
        type: 'Rect',
        shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
      };
    }
  };

  function getAxisDimIndex(axis) {
    return axis.dim === 'x' ? 0 : 1;
  }

  AxisView_1.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */















  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // CartesianAxisPointer is not supposed to be required here. But consider
  // echarts.simple.js and online build tooltip, which only require gridSimple,
  // CartesianAxisPointer should be able to required somewhere.
  echarts.registerPreprocessor(function (option) {
    // Always has a global axisPointerModel for default setting.
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link
      // is not set, remain null/undefined, otherwise it will
      // override existent link setting.

      if (link && !util.isArray(link)) {
        option.axisPointer.link = [link];
      }
    }
  }); // This process should proformed after coordinate systems created
  // and series data processed. So put it on statistic processing stage.

  echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
    // allAxesInfo should be updated when setOption performed.
    ecModel.getComponent('axisPointer').coordSysAxesInfo = modelHelper.collect(ecModel, api);
  }); // Broadcast to all views.

  echarts.registerAction({
    type: 'updateAxisPointer',
    event: 'updateAxisPointer',
    update: ':updateAxisPointer'
  }, axisTrigger);

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var _default$1P = echarts.extendComponentModel({
    type: 'tooltip',
    dependencies: ['axisPointer'],
    defaultOption: {
      zlevel: 0,
      z: 60,
      show: true,
      // tooltipä¸»ä½åå®¹
      showContent: true,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: 'item',
      // 'click' | 'mousemove' | 'none'
      triggerOn: 'mousemove|click',
      alwaysShowContent: false,
      displayMode: 'single',
      // 'single' | 'multipleByCoordSys'
      renderMode: 'auto',
      // 'auto' | 'html' | 'richText'
      // 'auto': use html by default, and use non-html if `document` is not defined
      // 'html': use html for tooltip
      // 'richText': use canvas, svg, and etc. for tooltip
      // ä½ç½® {Array} | {Function}
      // position: null
      // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
      // align: null,
      // verticalAlign: null,
      // æ¯å¦çº¦æ content å¨ viewRect ä¸­ãé»è®¤ false æ¯ä¸ºäºå¼å®¹ä»¥åçæ¬ã
      confine: false,
      // åå®¹æ ¼å¼å¨ï¼{string}ï¼Templateï¼ Â¦ {Function}
      // formatter: null
      showDelay: 0,
      // éèå»¶è¿ï¼åä½ms
      hideDelay: 100,
      // å¨ç»åæ¢æ¶é´ï¼åä½s
      transitionDuration: 0.4,
      enterable: false,
      // æç¤ºèæ¯é¢è²ï¼é»è®¤ä¸ºéæåº¦ä¸º0.7çé»è²
      backgroundColor: 'rgba(50,50,50,0.7)',
      // æç¤ºè¾¹æ¡é¢è²
      borderColor: '#333',
      // æç¤ºè¾¹æ¡åè§ï¼åä½pxï¼é»è®¤ä¸º4
      borderRadius: 4,
      // æç¤ºè¾¹æ¡çº¿å®½ï¼åä½pxï¼é»è®¤ä¸º0ï¼æ è¾¹æ¡ï¼
      borderWidth: 0,
      // æç¤ºåè¾¹è·ï¼åä½pxï¼é»è®¤åæ¹ååè¾¹è·ä¸º5ï¼
      // æ¥åæ°ç»åå«è®¾å®ä¸å³ä¸å·¦è¾¹è·ï¼åcss
      padding: 5,
      // Extra css text
      extraCssText: '',
      // åæ è½´æç¤ºå¨ï¼åæ è½´è§¦åææ
      axisPointer: {
        // é»è®¤ä¸ºç´çº¿
        // å¯éä¸ºï¼'line' | 'shadow' | 'cross'
        type: 'line',
        // type ä¸º line çæ¶åææï¼æå® tooltip line æå¨çè½´ï¼å¯é
        // å¯é 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // é»è®¤ 'auto'ï¼ä¼éæ©ç±»åä¸º category çè½´ï¼å¯¹äºåæ°å¼è½´ï¼ç¬å¡å°åæ ç³»ä¼é»è®¤éæ© x è½´
        // æåæ ç³»ä¼é»è®¤éæ© angle è½´
        axis: 'auto',
        animation: 'auto',
        animationDurationUpdate: 200,
        animationEasingUpdate: 'exponentialOut',
        crossStyle: {
          color: '#999',
          width: 1,
          type: 'dashed',
          // TODO formatter
          textStyle: {} // lineStyle and shadowStyle should not be specified here,
          // otherwise it will always override those styles on option.axisPointer.

        }
      },
      textStyle: {
        color: '#fff',
        fontSize: 14
      }
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */













  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var each$p = util.each;
  var toCamelCase$1 = format$1.toCamelCase;
  var vendors = ['', '-webkit-', '-moz-', '-o-'];
  var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';
  /**
   * @param {number} duration
   * @return {string}
   * @inner
   */

  function assembleTransition(duration) {
    var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
    var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;
    return util.map(vendors, function (vendorPrefix) {
      return vendorPrefix + 'transition:' + transitionText;
    }).join(';');
  }
  /**
   * @param {Object} textStyle
   * @return {string}
   * @inner
   */


  function assembleFont(textStyleModel) {
    var cssText = [];
    var fontSize = textStyleModel.get('fontSize');
    var color = textStyleModel.getTextColor();
    color && cssText.push('color:' + color);
    cssText.push('font:' + textStyleModel.getFont());
    var lineHeight = textStyleModel.get('lineHeight');

    if (lineHeight == null) {
      lineHeight = Math.round(fontSize * 3 / 2);
    }

    fontSize && cssText.push('line-height:' + lineHeight + 'px');
    var shadowColor = textStyleModel.get('textShadowColor');
    var shadowBlur = textStyleModel.get('textShadowBlur') || 0;
    var shadowOffsetX = textStyleModel.get('textShadowOffsetX') || 0;
    var shadowOffsetY = textStyleModel.get('textShadowOffsetY') || 0;
    shadowBlur && cssText.push('text-shadow:' + shadowOffsetX + 'px ' + shadowOffsetY + 'px ' + shadowBlur + 'px ' + shadowColor);
    each$p(['decoration', 'align'], function (name) {
      var val = textStyleModel.get(name);
      val && cssText.push('text-' + name + ':' + val);
    });
    return cssText.join(';');
  }
  /**
   * @param {Object} tooltipModel
   * @return {string}
   * @inner
   */


  function assembleCssText(tooltipModel) {
    var cssText = [];
    var transitionDuration = tooltipModel.get('transitionDuration');
    var backgroundColor = tooltipModel.get('backgroundColor');
    var textStyleModel = tooltipModel.getModel('textStyle');
    var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.

    transitionDuration && cssText.push(assembleTransition(transitionDuration));

    if (backgroundColor) {
      if (env_1.canvasSupported) {
        cssText.push('background-Color:' + backgroundColor);
      } else {
        // for ie
        cssText.push('background-Color:#' + color.toHex(backgroundColor));
        cssText.push('filter:alpha(opacity=70)');
      }
    } // Border style


    each$p(['width', 'color', 'radius'], function (name) {
      var borderName = 'border-' + name;
      var camelCase = toCamelCase$1(borderName);
      var val = tooltipModel.get(camelCase);
      val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
    }); // Text style

    cssText.push(assembleFont(textStyleModel)); // Padding

    if (padding != null) {
      cssText.push('padding:' + format$1.normalizeCssArray(padding).join('px ') + 'px');
    }

    return cssText.join(';') + ';';
  } // If not able to make, do not modify the input `out`.


  function makeStyleCoord(out, zr, appendToBody, zrX, zrY) {
    var zrPainter = zr && zr.painter;

    if (appendToBody) {
      var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();

      if (zrViewportRoot) {
        // Some APPs might use scale on body, so we support CSS transform here.
        dom.transformLocalCoord(out, zrViewportRoot, document.body, zrX, zrY);
      }
    } else {
      out[0] = zrX;
      out[1] = zrY; // xy should be based on canvas root. But tooltipContent is
      // the sibling of canvas root. So padding of ec container
      // should be considered here.

      var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();

      if (viewportRootOffset) {
        out[0] += viewportRootOffset.offsetLeft;
        out[1] += viewportRootOffset.offsetTop;
      }
    }

    out[2] = out[0] / zr.getWidth(); // The ratio of left to width

    out[3] = out[1] / zr.getHeight(); // The ratio of top to height
  }
  /**
   * @alias module:echarts/component/tooltip/TooltipContent
   * @param {HTMLElement} container
   * @param {ExtensionAPI} api
   * @param {Object} [opt]
   * @param {boolean} [opt.appendToBody]
   *        `false`: the DOM element will be inside the container. Default value.
   *        `true`: the DOM element will be appended to HTML body, which avoid
   *                some overflow clip but intrude outside of the container.
   * @constructor
   */


  function TooltipContent(container, api, opt) {
    if (env_1.wxa) {
      return null;
    }

    var el = document.createElement('div');
    el.domBelongToZr = true;
    this.el = el;
    var zr = this._zr = api.getZr();
    var appendToBody = this._appendToBody = opt && opt.appendToBody;
    this._styleCoord = [0, 0, 0, 0]; // [left, top, left/width, top/height]

    makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);

    if (appendToBody) {
      document.body.appendChild(el);
    } else {
      container.appendChild(el);
    }

    this._container = container;
    this._show = false;
    /**
     * @private
     */

    this._hideTimeout; // FIXME
    // Is it needed to trigger zr event manually if
    // the browser do not support `pointer-events: none`.

    var self = this;

    el.onmouseenter = function () {
      // clear the timeout in hideLater and keep showing tooltip
      if (self._enterable) {
        clearTimeout(self._hideTimeout);
        self._show = true;
      }

      self._inContent = true;
    };

    el.onmousemove = function (e) {
      e = e || window.event;

      if (!self._enterable) {
        // `pointer-events: none` is set to tooltip content div
        // if `enterable` is set as `false`, and `el.onmousemove`
        // can not be triggered. But in browser that do not
        // support `pointer-events`, we need to do this:
        // Try trigger zrender event to avoid mouse
        // in and out shape too frequently
        var handler = zr.handler;
        var zrViewportRoot = zr.painter.getViewportRoot();
        event.normalizeEvent(zrViewportRoot, e, true);
        handler.dispatch('mousemove', e);
      }
    };

    el.onmouseleave = function () {
      if (self._enterable) {
        if (self._show) {
          self.hideLater(self._hideDelay);
        }
      }

      self._inContent = false;
    };
  }

  TooltipContent.prototype = {
    constructor: TooltipContent,

    /**
     * @private
     * @type {boolean}
     */
    _enterable: true,

    /**
     * Update when tooltip is rendered
     */
    update: function (tooltipModel) {
      // FIXME
      // Move this logic to ec main?
      var container = this._container;
      var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
      var domStyle = container.style;

      if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
        domStyle.position = 'relative';
      }

      var alwaysShowContent = tooltipModel.get('alwaysShowContent');
      alwaysShowContent && this._moveTooltipIfResized(); // Hide the tooltip
      // PENDING
      // this.hide();
    },

    /**
     * when `alwaysShowContent` is true,
     * we should move the tooltip after chart resized
     */
    _moveTooltipIfResized: function () {
      var ratioX = this._styleCoord[2]; // The ratio of left to width

      var ratioY = this._styleCoord[3]; // The ratio of top to height

      var realX = ratioX * this._zr.getWidth();

      var realY = ratioY * this._zr.getHeight();

      this.moveTo(realX, realY);
    },
    show: function (tooltipModel) {
      clearTimeout(this._hideTimeout);
      var el = this.el;
      var styleCoord = this._styleCoord;
      el.style.cssText = gCssText + assembleCssText(tooltipModel) // Because of the reason described in:
      // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
      // we should set initial value to `left` and `top`.
      + ';left:' + styleCoord[0] + 'px;top:' + styleCoord[1] + 'px;' + (tooltipModel.get('extraCssText') || '');
      el.style.display = el.innerHTML ? 'block' : 'none'; // If mouse occasionally move over the tooltip, a mouseout event will be
      // triggered by canvas, and cause some unexpectable result like dragging
      // stop, "unfocusAdjacency". Here `pointer-events: none` is used to solve
      // it. Although it is not supported by IE8~IE10, fortunately it is a rare
      // scenario.

      el.style.pointerEvents = this._enterable ? 'auto' : 'none';
      this._show = true;
    },
    setContent: function (content) {
      this.el.innerHTML = content == null ? '' : content;
    },
    setEnterable: function (enterable) {
      this._enterable = enterable;
    },
    getSize: function () {
      var el = this.el;
      return [el.clientWidth, el.clientHeight];
    },
    moveTo: function (zrX, zrY) {
      var styleCoord = this._styleCoord;
      makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY);
      var style = this.el.style;
      style.left = styleCoord[0] + 'px';
      style.top = styleCoord[1] + 'px';
    },
    hide: function () {
      this.el.style.display = 'none';
      this._show = false;
    },
    hideLater: function (time) {
      if (this._show && !(this._inContent && this._enterable)) {
        if (time) {
          this._hideDelay = time; // Set show false to avoid invoke hideLater multiple times

          this._show = false;
          this._hideTimeout = setTimeout(util.bind(this.hide, this), time);
        } else {
          this.hide();
        }
      }
    },
    isShow: function () {
      return this._show;
    },
    dispose: function () {
      this.el.parentNode.removeChild(this.el);
    },
    getOuterSize: function () {
      var width = this.el.clientWidth;
      var height = this.el.clientHeight; // Consider browser compatibility.
      // IE8 does not support getComputedStyle.

      if (document.defaultView && document.defaultView.getComputedStyle) {
        var stl = document.defaultView.getComputedStyle(this.el);

        if (stl) {
          width += parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
          height += parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
        }
      }

      return {
        width: width,
        height: height
      };
    }
  };
  var _default$1Q = TooltipContent;
  var TooltipContent_1 = _default$1Q;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // import Group from 'zrender/src/container/Group';
  function makeStyleCoord$1(out, zr, zrX, zrY) {
    out[0] = zrX;
    out[1] = zrY;
    out[2] = out[0] / zr.getWidth(); // The ratio of left to width

    out[3] = out[1] / zr.getHeight(); // The ratio of top to height
  }
  /**
   * @alias module:echarts/component/tooltip/TooltipRichContent
   * @constructor
   */


  function TooltipRichContent(api) {
    var zr = this._zr = api.getZr();
    this._styleCoord = [0, 0, 0, 0]; // [left, top, left/width, top/height]

    makeStyleCoord$1(this._styleCoord, zr, api.getWidth() / 2, api.getHeight() / 2);
    this._show = false;
    /**
     * @private
     */

    this._hideTimeout;
  }

  TooltipRichContent.prototype = {
    constructor: TooltipRichContent,

    /**
     * @private
     * @type {boolean}
     */
    _enterable: true,

    /**
     * Update when tooltip is rendered
     */
    update: function (tooltipModel) {
      var alwaysShowContent = tooltipModel.get('alwaysShowContent');
      alwaysShowContent && this._moveTooltipIfResized();
    },

    /**
     * when `alwaysShowContent` is true,
     * we should move the tooltip after chart resized
     */
    _moveTooltipIfResized: function () {
      var ratioX = this._styleCoord[2]; // The ratio of left to width

      var ratioY = this._styleCoord[3]; // The ratio of top to height

      var realX = ratioX * this._zr.getWidth();

      var realY = ratioY * this._zr.getHeight();

      this.moveTo(realX, realY);
    },
    show: function (tooltipModel) {
      if (this._hideTimeout) {
        clearTimeout(this._hideTimeout);
      }

      this.el.attr('show', true);
      this._show = true;
    },

    /**
     * Set tooltip content
     *
     * @param {string} content rich text string of content
     * @param {Object} markerRich rich text style
     * @param {Object} tooltipModel tooltip model
     */
    setContent: function (content, markerRich, tooltipModel) {
      if (this.el) {
        this._zr.remove(this.el);
      }

      var markers = {};
      var text = content;
      var prefix = '{marker';
      var suffix = '|}';
      var startId = text.indexOf(prefix);

      while (startId >= 0) {
        var endId = text.indexOf(suffix);
        var name = text.substr(startId + prefix.length, endId - startId - prefix.length);

        if (name.indexOf('sub') > -1) {
          markers['marker' + name] = {
            textWidth: 4,
            textHeight: 4,
            textBorderRadius: 2,
            textBackgroundColor: markerRich[name],
            // TODO: textOffset is not implemented for rich text
            textOffset: [3, 0]
          };
        } else {
          markers['marker' + name] = {
            textWidth: 10,
            textHeight: 10,
            textBorderRadius: 5,
            textBackgroundColor: markerRich[name]
          };
        }

        text = text.substr(endId + 1);
        startId = text.indexOf('{marker');
      }

      var textStyleModel = tooltipModel.getModel('textStyle');
      var fontSize = textStyleModel.get('fontSize');
      var lineHeight = tooltipModel.get('textLineHeight');

      if (lineHeight == null) {
        lineHeight = Math.round(fontSize * 3 / 2);
      }

      this.el = new Text_1({
        style: graphic.setTextStyle({}, textStyleModel, {
          rich: markers,
          text: content,
          textBackgroundColor: tooltipModel.get('backgroundColor'),
          textBorderRadius: tooltipModel.get('borderRadius'),
          textFill: tooltipModel.get('textStyle.color'),
          textPadding: tooltipModel.get('padding'),
          textLineHeight: lineHeight
        }),
        z: tooltipModel.get('z')
      });

      this._zr.add(this.el);

      var self = this;
      this.el.on('mouseover', function () {
        // clear the timeout in hideLater and keep showing tooltip
        if (self._enterable) {
          clearTimeout(self._hideTimeout);
          self._show = true;
        }

        self._inContent = true;
      });
      this.el.on('mouseout', function () {
        if (self._enterable) {
          if (self._show) {
            self.hideLater(self._hideDelay);
          }
        }

        self._inContent = false;
      });
    },
    setEnterable: function (enterable) {
      this._enterable = enterable;
    },
    getSize: function () {
      var bounding = this.el.getBoundingRect();
      return [bounding.width, bounding.height];
    },
    moveTo: function (x, y) {
      if (this.el) {
        var styleCoord = this._styleCoord;
        makeStyleCoord$1(styleCoord, this._zr, x, y);
        this.el.attr('position', [styleCoord[0], styleCoord[1]]);
      }
    },
    hide: function () {
      if (this.el) {
        this.el.hide();
      }

      this._show = false;
    },
    hideLater: function (time) {
      if (this._show && !(this._inContent && this._enterable)) {
        if (time) {
          this._hideDelay = time; // Set show false to avoid invoke hideLater multiple times

          this._show = false;
          this._hideTimeout = setTimeout(util.bind(this.hide, this), time);
        } else {
          this.hide();
        }
      }
    },
    isShow: function () {
      return this._show;
    },
    dispose: function () {
      clearTimeout(this._hideTimeout);

      if (this.el) {
        this._zr.remove(this.el);
      }
    },
    getOuterSize: function () {
      var size = this.getSize();
      return {
        width: size[0],
        height: size[1]
      };
    }
  };
  var _default$1R = TooltipRichContent;
  var TooltipRichContent_1 = _default$1R;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */































  var getTooltipRenderMode$2 = model.getTooltipRenderMode;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var bind$3 = util.bind;
  var each$q = util.each;
  var parsePercent$5 = number.parsePercent;
  var proxyRect = new graphic.Rect({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }
  });

  var _default$1S = echarts.extendComponentView({
    type: 'tooltip',
    init: function (ecModel, api) {
      if (env_1.node) {
        return;
      }

      var tooltipModel = ecModel.getComponent('tooltip');
      var renderMode = tooltipModel.get('renderMode');
      this._renderMode = getTooltipRenderMode$2(renderMode);
      var tooltipContent;

      if (this._renderMode === 'html') {
        tooltipContent = new TooltipContent_1(api.getDom(), api, {
          appendToBody: tooltipModel.get('appendToBody', true)
        });
        this._newLine = '<br/>';
      } else {
        tooltipContent = new TooltipRichContent_1(api);
        this._newLine = '\n';
      }

      this._tooltipContent = tooltipContent;
    },
    render: function (tooltipModel, ecModel, api) {
      if (env_1.node) {
        return;
      } // Reset


      this.group.removeAll();
      /**
       * @private
       * @type {module:echarts/component/tooltip/TooltipModel}
       */

      this._tooltipModel = tooltipModel;
      /**
       * @private
       * @type {module:echarts/model/Global}
       */

      this._ecModel = ecModel;
      /**
       * @private
       * @type {module:echarts/ExtensionAPI}
       */

      this._api = api;
      /**
       * Should be cleaned when render.
       * @private
       * @type {Array.<Array.<Object>>}
       */

      this._lastDataByCoordSys = null;
      /**
       * @private
       * @type {boolean}
       */

      this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
      var tooltipContent = this._tooltipContent;
      tooltipContent.update(tooltipModel);
      tooltipContent.setEnterable(tooltipModel.get('enterable'));

      this._initGlobalListener();

      this._keepShow();
    },
    _initGlobalListener: function () {
      var tooltipModel = this._tooltipModel;
      var triggerOn = tooltipModel.get('triggerOn');
      globalListener.register('itemTooltip', this._api, bind$3(function (currTrigger, e, dispatchAction) {
        // If 'none', it is not controlled by mouse totally.
        if (triggerOn !== 'none') {
          if (triggerOn.indexOf(currTrigger) >= 0) {
            this._tryShow(e, dispatchAction);
          } else if (currTrigger === 'leave') {
            this._hide(dispatchAction);
          }
        }
      }, this));
    },
    _keepShow: function () {
      var tooltipModel = this._tooltipModel;
      var ecModel = this._ecModel;
      var api = this._api; // Try to keep the tooltip show when refreshing

      if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,
      // self.manuallyShowTip({x, y}) might cause tooltip hide,
      // which is not expected.
      && tooltipModel.get('triggerOn') !== 'none') {
        var self = this;
        clearTimeout(this._refreshUpdateTimeout);
        this._refreshUpdateTimeout = setTimeout(function () {
          // Show tip next tick after other charts are rendered
          // In case highlight action has wrong result
          // FIXME
          !api.isDisposed() && self.manuallyShowTip(tooltipModel, ecModel, api, {
            x: self._lastX,
            y: self._lastY
          });
        });
      }
    },

    /**
     * Show tip manually by
     * dispatchAction({
     *     type: 'showTip',
     *     x: 10,
     *     y: 10
     * });
     * Or
     * dispatchAction({
     *      type: 'showTip',
     *      seriesIndex: 0,
     *      dataIndex or dataIndexInside or name
     * });
     *
     *  TODO Batch
     */
    manuallyShowTip: function (tooltipModel, ecModel, api, payload) {
      if (payload.from === this.uid || env_1.node) {
        return;
      }

      var dispatchAction = makeDispatchAction$1(payload, api); // Reset ticket

      this._ticket = ''; // When triggered from axisPointer.

      var dataByCoordSys = payload.dataByCoordSys;

      if (payload.tooltip && payload.x != null && payload.y != null) {
        var el = proxyRect;
        el.position = [payload.x, payload.y];
        el.update();
        el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.

        this._tryShow({
          offsetX: payload.x,
          offsetY: payload.y,
          target: el
        }, dispatchAction);
      } else if (dataByCoordSys) {
        this._tryShow({
          offsetX: payload.x,
          offsetY: payload.y,
          position: payload.position,
          dataByCoordSys: payload.dataByCoordSys,
          tooltipOption: payload.tooltipOption
        }, dispatchAction);
      } else if (payload.seriesIndex != null) {
        if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
          return;
        }

        var pointInfo = findPointFromSeries(payload, ecModel);
        var cx = pointInfo.point[0];
        var cy = pointInfo.point[1];

        if (cx != null && cy != null) {
          this._tryShow({
            offsetX: cx,
            offsetY: cy,
            position: payload.position,
            target: pointInfo.el
          }, dispatchAction);
        }
      } else if (payload.x != null && payload.y != null) {
        // FIXME
        // should wrap dispatchAction like `axisPointer/globalListener` ?
        api.dispatchAction({
          type: 'updateAxisPointer',
          x: payload.x,
          y: payload.y
        });

        this._tryShow({
          offsetX: payload.x,
          offsetY: payload.y,
          position: payload.position,
          target: api.getZr().findHover(payload.x, payload.y).target
        }, dispatchAction);
      }
    },
    manuallyHideTip: function (tooltipModel, ecModel, api, payload) {
      var tooltipContent = this._tooltipContent;

      if (!this._alwaysShowContent && this._tooltipModel) {
        tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
      }

      this._lastX = this._lastY = null;

      if (payload.from !== this.uid) {
        this._hide(makeDispatchAction$1(payload, api));
      }
    },
    // Be compatible with previous design, that is, when tooltip.type is 'axis' and
    // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
    // and tooltip.
    _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {
      var seriesIndex = payload.seriesIndex;
      var dataIndex = payload.dataIndex;
      var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;

      if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
        return;
      }

      var seriesModel = ecModel.getSeriesByIndex(seriesIndex);

      if (!seriesModel) {
        return;
      }

      var data = seriesModel.getData();
      var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);

      if (tooltipModel.get('trigger') !== 'axis') {
        return;
      }

      api.dispatchAction({
        type: 'updateAxisPointer',
        seriesIndex: seriesIndex,
        dataIndex: dataIndex,
        position: payload.position
      });
      return true;
    },
    _tryShow: function (e, dispatchAction) {
      var el = e.target;
      var tooltipModel = this._tooltipModel;

      if (!tooltipModel) {
        return;
      } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed


      this._lastX = e.offsetX;
      this._lastY = e.offsetY;
      var dataByCoordSys = e.dataByCoordSys;

      if (dataByCoordSys && dataByCoordSys.length) {
        this._showAxisTooltip(dataByCoordSys, e);
      } // Always show item tooltip if mouse is on the element with dataIndex
      else if (el && el.dataIndex != null) {
          this._lastDataByCoordSys = null;

          this._showSeriesItemTooltip(e, el, dispatchAction);
        } // Tooltip provided directly. Like legend.
        else if (el && el.tooltip) {
            this._lastDataByCoordSys = null;

            this._showComponentItemTooltip(e, el, dispatchAction);
          } else {
            this._lastDataByCoordSys = null;

            this._hide(dispatchAction);
          }
    },
    _showOrMove: function (tooltipModel, cb) {
      // showDelay is used in this case: tooltip.enterable is set
      // as true. User intent to move mouse into tooltip and click
      // something. `showDelay` makes it easier to enter the content
      // but tooltip do not move immediately.
      var delay = tooltipModel.get('showDelay');
      cb = util.bind(cb, this);
      clearTimeout(this._showTimout);
      delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
    },
    _showAxisTooltip: function (dataByCoordSys, e) {
      var ecModel = this._ecModel;
      var globalTooltipModel = this._tooltipModel;
      var point = [e.offsetX, e.offsetY];
      var singleDefaultHTML = [];
      var singleParamsList = [];
      var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);
      var renderMode = this._renderMode;
      var newLine = this._newLine;
      var markers = {};
      each$q(dataByCoordSys, function (itemCoordSys) {
        // var coordParamList = [];
        // var coordDefaultHTML = [];
        // var coordTooltipModel = buildTooltipModel([
        //     e.tooltipOption,
        //     itemCoordSys.tooltipOption,
        //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),
        //     globalTooltipModel
        // ]);
        // var displayMode = coordTooltipModel.get('displayMode');
        // var paramsList = displayMode === 'single' ? singleParamsList : [];
        each$q(itemCoordSys.dataByAxis, function (item) {
          var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);
          var axisValue = item.value;
          var seriesDefaultHTML = [];

          if (!axisModel || axisValue == null) {
            return;
          }

          var valueLabel = viewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);
          util.each(item.seriesDataIndices, function (idxItem) {
            var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
            var dataIndex = idxItem.dataIndexInside;
            var dataParams = series && series.getDataParams(dataIndex);
            dataParams.axisDim = item.axisDim;
            dataParams.axisIndex = item.axisIndex;
            dataParams.axisType = item.axisType;
            dataParams.axisId = item.axisId;
            dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);
            dataParams.axisValueLabel = valueLabel;

            if (dataParams) {
              singleParamsList.push(dataParams);
              var seriesTooltip = series.formatTooltip(dataIndex, true, null, renderMode);
              var html;

              if (util.isObject(seriesTooltip)) {
                html = seriesTooltip.html;
                var newMarkers = seriesTooltip.markers;
                util.merge(markers, newMarkers);
              } else {
                html = seriesTooltip;
              }

              seriesDefaultHTML.push(html);
            }
          }); // Default tooltip content
          // FIXME
          // (1) should be the first data which has name?
          // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.

          var firstLine = valueLabel;

          if (renderMode !== 'html') {
            singleDefaultHTML.push(seriesDefaultHTML.join(newLine));
          } else {
            singleDefaultHTML.push((firstLine ? format$1.encodeHTML(firstLine) + newLine : '') + seriesDefaultHTML.join(newLine));
          }
        });
      }, this); // In most case, the second axis is shown upper than the first one.

      singleDefaultHTML.reverse();
      singleDefaultHTML = singleDefaultHTML.join(this._newLine + this._newLine);
      var positionExpr = e.position;

      this._showOrMove(singleTooltipModel, function () {
        if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
          this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);
        } else {
          this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr, undefined, markers);
        }
      }); // Do not trigger events here, because this branch only be entered
      // from dispatchAction.

    },
    _showSeriesItemTooltip: function (e, el, dispatchAction) {
      var ecModel = this._ecModel; // Use dataModel in element if possible
      // Used when mouseover on a element like markPoint or edge
      // In which case, the data is not main data in series.

      var seriesIndex = el.seriesIndex;
      var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.

      var dataModel = el.dataModel || seriesModel;
      var dataIndex = el.dataIndex;
      var dataType = el.dataType;
      var data = dataModel.getData(dataType);
      var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
      var tooltipTrigger = tooltipModel.get('trigger');

      if (tooltipTrigger != null && tooltipTrigger !== 'item') {
        return;
      }

      var params = dataModel.getDataParams(dataIndex, dataType);
      var seriesTooltip = dataModel.formatTooltip(dataIndex, false, dataType, this._renderMode);
      var defaultHtml;
      var markers;

      if (util.isObject(seriesTooltip)) {
        defaultHtml = seriesTooltip.html;
        markers = seriesTooltip.markers;
      } else {
        defaultHtml = seriesTooltip;
        markers = null;
      }

      var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;

      this._showOrMove(tooltipModel, function () {
        this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markers);
      }); // FIXME
      // duplicated showtip if manuallyShowTip is called from dispatchAction.


      dispatchAction({
        type: 'showTip',
        dataIndexInside: dataIndex,
        dataIndex: data.getRawIndex(dataIndex),
        seriesIndex: seriesIndex,
        from: this.uid
      });
    },
    _showComponentItemTooltip: function (e, el, dispatchAction) {
      var tooltipOpt = el.tooltip;

      if (typeof tooltipOpt === 'string') {
        var content = tooltipOpt;
        tooltipOpt = {
          content: content,
          // Fixed formatter
          formatter: content
        };
      }

      var subTooltipModel = new Model_1(tooltipOpt, this._tooltipModel, this._ecModel);
      var defaultHtml = subTooltipModel.get('content');
      var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`
      // only works on coordinate system. In fact, we have not found case
      // that requires setting `trigger` nothing on component yet.

      this._showOrMove(subTooltipModel, function () {
        this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);
      }); // If not dispatch showTip, tip may be hide triggered by axis.


      dispatchAction({
        type: 'showTip',
        from: this.uid
      });
    },
    _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markers) {
      // Reset ticket
      this._ticket = '';

      if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
        return;
      }

      var tooltipContent = this._tooltipContent;
      var formatter = tooltipModel.get('formatter');
      positionExpr = positionExpr || tooltipModel.get('position');
      var html = defaultHtml;

      if (formatter && typeof formatter === 'string') {
        html = format$1.formatTpl(formatter, params, true);
      } else if (typeof formatter === 'function') {
        var callback = bind$3(function (cbTicket, html) {
          if (cbTicket === this._ticket) {
            tooltipContent.setContent(html, markers, tooltipModel);

            this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
          }
        }, this);
        this._ticket = asyncTicket;
        html = formatter(params, asyncTicket, callback);
      }

      tooltipContent.setContent(html, markers, tooltipModel);
      tooltipContent.show(tooltipModel);

      this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
    },

    /**
     * @param  {string|Function|Array.<number>|Object} positionExpr
     * @param  {number} x Mouse x
     * @param  {number} y Mouse y
     * @param  {boolean} confine Whether confine tooltip content in view rect.
     * @param  {Object|<Array.<Object>} params
     * @param  {module:zrender/Element} el target element
     * @param  {module:echarts/ExtensionAPI} api
     * @return {Array.<number>}
     */
    _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {
      var viewWidth = this._api.getWidth();

      var viewHeight = this._api.getHeight();

      positionExpr = positionExpr || tooltipModel.get('position');
      var contentSize = content.getSize();
      var align = tooltipModel.get('align');
      var vAlign = tooltipModel.get('verticalAlign');
      var rect = el && el.getBoundingRect().clone();
      el && rect.applyTransform(el.transform);

      if (typeof positionExpr === 'function') {
        // Callback of position can be an array or a string specify the position
        positionExpr = positionExpr([x, y], params, content.el, rect, {
          viewSize: [viewWidth, viewHeight],
          contentSize: contentSize.slice()
        });
      }

      if (util.isArray(positionExpr)) {
        x = parsePercent$5(positionExpr[0], viewWidth);
        y = parsePercent$5(positionExpr[1], viewHeight);
      } else if (util.isObject(positionExpr)) {
        positionExpr.width = contentSize[0];
        positionExpr.height = contentSize[1];
        var layoutRect = layout.getLayoutRect(positionExpr, {
          width: viewWidth,
          height: viewHeight
        });
        x = layoutRect.x;
        y = layoutRect.y;
        align = null; // When positionExpr is left/top/right/bottom,
        // align and verticalAlign will not work.

        vAlign = null;
      } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
      else if (typeof positionExpr === 'string' && el) {
          var pos = calcTooltipPosition(positionExpr, rect, contentSize);
          x = pos[0];
          y = pos[1];
        } else {
          var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
          x = pos[0];
          y = pos[1];
        }

      align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
      vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);

      if (tooltipModel.get('confine')) {
        var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
        x = pos[0];
        y = pos[1];
      }

      content.moveTo(x, y);
    },
    // FIXME
    // Should we remove this but leave this to user?
    _updateContentNotChangedOnAxis: function (dataByCoordSys) {
      var lastCoordSys = this._lastDataByCoordSys;
      var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
      contentNotChanged && each$q(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
        var lastDataByAxis = lastItemCoordSys.dataByAxis || {};
        var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
        var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
        contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;
        contentNotChanged && each$q(lastDataByAxis, function (lastItem, indexAxis) {
          var thisItem = thisDataByAxis[indexAxis] || {};
          var lastIndices = lastItem.seriesDataIndices || [];
          var newIndices = thisItem.seriesDataIndices || [];
          contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
          contentNotChanged && each$q(lastIndices, function (lastIdxItem, j) {
            var newIdxItem = newIndices[j];
            contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
          });
        });
      });
      this._lastDataByCoordSys = dataByCoordSys;
      return !!contentNotChanged;
    },
    _hide: function (dispatchAction) {
      // Do not directly hideLater here, because this behavior may be prevented
      // in dispatchAction when showTip is dispatched.
      // FIXME
      // duplicated hideTip if manuallyHideTip is called from dispatchAction.
      this._lastDataByCoordSys = null;
      dispatchAction({
        type: 'hideTip',
        from: this.uid
      });
    },
    dispose: function (ecModel, api) {
      if (env_1.node) {
        return;
      }

      this._tooltipContent.dispose();

      globalListener.unregister('itemTooltip', api);
    }
  });
  /**
   * @param {Array.<Object|module:echarts/model/Model>} modelCascade
   * From top to bottom. (the last one should be globalTooltipModel);
   */


  function buildTooltipModel(modelCascade) {
    var resultModel = modelCascade.pop();

    while (modelCascade.length) {
      var tooltipOpt = modelCascade.pop();

      if (tooltipOpt) {
        if (Model_1.isInstance(tooltipOpt)) {
          tooltipOpt = tooltipOpt.get('tooltip', true);
        } // In each data item tooltip can be simply write:
        // {
        //  value: 10,
        //  tooltip: 'Something you need to know'
        // }


        if (typeof tooltipOpt === 'string') {
          tooltipOpt = {
            formatter: tooltipOpt
          };
        }

        resultModel = new Model_1(tooltipOpt, resultModel, resultModel.ecModel);
      }
    }

    return resultModel;
  }

  function makeDispatchAction$1(payload, api) {
    return payload.dispatchAction || util.bind(api.dispatchAction, api);
  }

  function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
    var size = content.getOuterSize();
    var width = size.width;
    var height = size.height;

    if (gapH != null) {
      if (x + width + gapH > viewWidth) {
        x -= width + gapH;
      } else {
        x += gapH;
      }
    }

    if (gapV != null) {
      if (y + height + gapV > viewHeight) {
        y -= height + gapV;
      } else {
        y += gapV;
      }
    }

    return [x, y];
  }

  function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
    var size = content.getOuterSize();
    var width = size.width;
    var height = size.height;
    x = Math.min(x + width, viewWidth) - width;
    y = Math.min(y + height, viewHeight) - height;
    x = Math.max(x, 0);
    y = Math.max(y, 0);
    return [x, y];
  }

  function calcTooltipPosition(position, rect, contentSize) {
    var domWidth = contentSize[0];
    var domHeight = contentSize[1];
    var gap = 5;
    var x = 0;
    var y = 0;
    var rectWidth = rect.width;
    var rectHeight = rect.height;

    switch (position) {
      case 'inside':
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y + rectHeight / 2 - domHeight / 2;
        break;

      case 'top':
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y - domHeight - gap;
        break;

      case 'bottom':
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y + rectHeight + gap;
        break;

      case 'left':
        x = rect.x - domWidth - gap;
        y = rect.y + rectHeight / 2 - domHeight / 2;
        break;

      case 'right':
        x = rect.x + rectWidth + gap;
        y = rect.y + rectHeight / 2 - domHeight / 2;
    }

    return [x, y];
  }

  function isCenterAlign(align) {
    return align === 'center' || align === 'middle';
  }

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // FIXME Better way to pack data in graphic element

  /**
   * @action
   * @property {string} type
   * @property {number} seriesIndex
   * @property {number} dataIndex
   * @property {number} [x]
   * @property {number} [y]
   */
  echarts.registerAction({
    type: 'showTip',
    event: 'showTip',
    update: 'tooltip:manuallyShowTip'
  }, // noop
  function () {});
  echarts.registerAction({
    type: 'hideTip',
    event: 'hideTip',
    update: 'tooltip:manuallyHideTip'
  }, // noop
  function () {});

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  var isNameSpecified$1 = model.isNameSpecified;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var langSelector = lang.legend.selector;
  var defaultSelectorOption = {
    all: {
      type: 'all',
      title: util.clone(langSelector.all)
    },
    inverse: {
      type: 'inverse',
      title: util.clone(langSelector.inverse)
    }
  };
  var LegendModel = echarts.extendComponentModel({
    type: 'legend.plain',
    dependencies: ['series'],
    layoutMode: {
      type: 'box',
      // legend.width/height are maxWidth/maxHeight actually,
      // whereas realy width/height is calculated by its content.
      // (Setting {left: 10, right: 10} does not make sense).
      // So consider the case:
      // `setOption({legend: {left: 10});`
      // then `setOption({legend: {right: 10});`
      // The previous `left` should be cleared by setting `ignoreSize`.
      ignoreSize: true
    },
    init: function (option, parentModel, ecModel) {
      this.mergeDefaultAndTheme(option, ecModel);
      option.selected = option.selected || {};

      this._updateSelector(option);
    },
    mergeOption: function (option) {
      LegendModel.superCall(this, 'mergeOption', option);

      this._updateSelector(option);
    },
    _updateSelector: function (option) {
      var selector = option.selector;

      if (selector === true) {
        selector = option.selector = ['all', 'inverse'];
      }

      if (util.isArray(selector)) {
        util.each(selector, function (item, index) {
          util.isString(item) && (item = {
            type: item
          });
          selector[index] = util.merge(item, defaultSelectorOption[item.type]);
        });
      }
    },
    optionUpdated: function () {
      this._updateData(this.ecModel);

      var legendData = this._data; // If selectedMode is single, try to select one

      if (legendData[0] && this.get('selectedMode') === 'single') {
        var hasSelected = false; // If has any selected in option.selected

        for (var i = 0; i < legendData.length; i++) {
          var name = legendData[i].get('name');

          if (this.isSelected(name)) {
            // Force to unselect others
            this.select(name);
            hasSelected = true;
            break;
          }
        } // Try select the first if selectedMode is single


        !hasSelected && this.select(legendData[0].get('name'));
      }
    },
    _updateData: function (ecModel) {
      var potentialData = [];
      var availableNames = [];
      ecModel.eachRawSeries(function (seriesModel) {
        var seriesName = seriesModel.name;
        availableNames.push(seriesName);
        var isPotential;

        if (seriesModel.legendVisualProvider) {
          var provider = seriesModel.legendVisualProvider;
          var names = provider.getAllNames();

          if (!ecModel.isSeriesFiltered(seriesModel)) {
            availableNames = availableNames.concat(names);
          }

          if (names.length) {
            potentialData = potentialData.concat(names);
          } else {
            isPotential = true;
          }
        } else {
          isPotential = true;
        }

        if (isPotential && isNameSpecified$1(seriesModel)) {
          potentialData.push(seriesModel.name);
        }
      });
      /**
       * @type {Array.<string>}
       * @private
       */

      this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,
      // which is convinient for user preparing option.

      var rawData = this.get('data') || potentialData;
      var legendData = util.map(rawData, function (dataItem) {
        // Can be string or number
        if (typeof dataItem === 'string' || typeof dataItem === 'number') {
          dataItem = {
            name: dataItem
          };
        }

        return new Model_1(dataItem, this, this.ecModel);
      }, this);
      /**
       * @type {Array.<module:echarts/model/Model>}
       * @private
       */

      this._data = legendData;
    },

    /**
     * @return {Array.<module:echarts/model/Model>}
     */
    getData: function () {
      return this._data;
    },

    /**
     * @param {string} name
     */
    select: function (name) {
      var selected = this.option.selected;
      var selectedMode = this.get('selectedMode');

      if (selectedMode === 'single') {
        var data = this._data;
        util.each(data, function (dataItem) {
          selected[dataItem.get('name')] = false;
        });
      }

      selected[name] = true;
    },

    /**
     * @param {string} name
     */
    unSelect: function (name) {
      if (this.get('selectedMode') !== 'single') {
        this.option.selected[name] = false;
      }
    },

    /**
     * @param {string} name
     */
    toggleSelected: function (name) {
      var selected = this.option.selected; // Default is true

      if (!selected.hasOwnProperty(name)) {
        selected[name] = true;
      }

      this[selected[name] ? 'unSelect' : 'select'](name);
    },
    allSelect: function () {
      var data = this._data;
      var selected = this.option.selected;
      util.each(data, function (dataItem) {
        selected[dataItem.get('name', true)] = true;
      });
    },
    inverseSelect: function () {
      var data = this._data;
      var selected = this.option.selected;
      util.each(data, function (dataItem) {
        var name = dataItem.get('name', true); // Initially, default value is true

        if (!selected.hasOwnProperty(name)) {
          selected[name] = true;
        }

        selected[name] = !selected[name];
      });
    },

    /**
     * @param {string} name
     */
    isSelected: function (name) {
      var selected = this.option.selected;
      return !(selected.hasOwnProperty(name) && !selected[name]) && util.indexOf(this._availableNames, name) >= 0;
    },
    getOrient: function () {
      return this.get('orient') === 'vertical' ? {
        index: 1,
        name: 'vertical'
      } : {
        index: 0,
        name: 'horizontal'
      };
    },
    defaultOption: {
      // ä¸çº§å±å 
      zlevel: 0,
      // äºçº§å±å 
      z: 4,
      show: true,
      // å¸å±æ¹å¼ï¼é»è®¤ä¸ºæ°´å¹³å¸å±ï¼å¯éä¸ºï¼
      // 'horizontal' | 'vertical'
      orient: 'horizontal',
      left: 'center',
      // right: 'center',
      top: 0,
      // bottom: null,
      // æ°´å¹³å¯¹é½
      // 'auto' | 'left' | 'right'
      // é»è®¤ä¸º 'auto', æ ¹æ® x çä½ç½®å¤æ­æ¯å·¦å¯¹é½è¿æ¯å³å¯¹é½
      align: 'auto',
      backgroundColor: 'rgba(0,0,0,0)',
      // å¾ä¾è¾¹æ¡é¢è²
      borderColor: '#ccc',
      borderRadius: 0,
      // å¾ä¾è¾¹æ¡çº¿å®½ï¼åä½pxï¼é»è®¤ä¸º0ï¼æ è¾¹æ¡ï¼
      borderWidth: 0,
      // å¾ä¾åè¾¹è·ï¼åä½pxï¼é»è®¤åæ¹ååè¾¹è·ä¸º5ï¼
      // æ¥åæ°ç»åå«è®¾å®ä¸å³ä¸å·¦è¾¹è·ï¼åcss
      padding: 5,
      // åä¸ªitemä¹é´çé´éï¼åä½pxï¼é»è®¤ä¸º10ï¼
      // æ¨ªåå¸å±æ¶ä¸ºæ°´å¹³é´éï¼çºµåå¸å±æ¶ä¸ºçºµåé´é
      itemGap: 10,
      // the width of legend symbol
      itemWidth: 25,
      // the height of legend symbol
      itemHeight: 14,
      // the color of unselected legend symbol
      inactiveColor: '#ccc',
      // the borderColor of unselected legend symbol
      inactiveBorderColor: '#ccc',
      itemStyle: {
        // the default borderWidth of legend symbol
        borderWidth: 0
      },
      textStyle: {
        // å¾ä¾æå­é¢è²
        color: '#333'
      },
      // formatter: '',
      // éæ©æ¨¡å¼ï¼é»è®¤å¼å¯å¾ä¾å¼å³
      selectedMode: true,
      // éç½®é»è®¤éä¸­ç¶æï¼å¯éåLEGEND.SELECTEDäºä»¶åå¨ææ°æ®è½½å¥
      // selected: null,
      // å¾ä¾åå®¹ï¼è¯¦è§legend.dataï¼æ°ç»ä¸­æ¯ä¸é¡¹ä»£è¡¨ä¸ä¸ªitem
      // data: [],
      // Usage:
      // selector: [{type: 'all or inverse', title: xxx}]
      // or
      // selector: true
      // or
      // selector: ['all', 'inverse']
      selector: false,
      selectorLabel: {
        show: true,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: ' sans-serif',
        color: '#666',
        borderWidth: 1,
        borderColor: '#666'
      },
      emphasis: {
        selectorLabel: {
          show: true,
          color: '#eee',
          backgroundColor: '#666'
        }
      },
      // Value can be 'start' or 'end'
      selectorPosition: 'auto',
      selectorItemGap: 7,
      selectorButtonGap: 10,
      // Tooltip ç¸å³éç½®
      tooltip: {
        show: false
      }
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function legendSelectActionHandler(methodName, payload, ecModel) {
    var selectedMap = {};
    var isToggleSelect = methodName === 'toggleSelected';
    var isSelected; // Update all legend components

    ecModel.eachComponent('legend', function (legendModel) {
      if (isToggleSelect && isSelected != null) {
        // Force other legend has same selected status
        // Or the first is toggled to true and other are toggled to false
        // In the case one legend has some item unSelected in option. And if other legend
        // doesn't has the item, they will assume it is selected.
        legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
      } else if (methodName === 'allSelect' || methodName === 'inverseSelect') {
        legendModel[methodName]();
      } else {
        legendModel[methodName](payload.name);
        isSelected = legendModel.isSelected(payload.name);
      }

      var legendData = legendModel.getData();
      util.each(legendData, function (model) {
        var name = model.get('name'); // Wrap element

        if (name === '\n' || name === '') {
          return;
        }

        var isItemSelected = legendModel.isSelected(name);

        if (selectedMap.hasOwnProperty(name)) {
          // Unselected if any legend is unselected
          selectedMap[name] = selectedMap[name] && isItemSelected;
        } else {
          selectedMap[name] = isItemSelected;
        }
      });
    }); // Return the event explicitly

    return methodName === 'allSelect' || methodName === 'inverseSelect' ? {
      selected: selectedMap
    } : {
      name: payload.name,
      selected: selectedMap
    };
  }
  /**
   * @event legendToggleSelect
   * @type {Object}
   * @property {string} type 'legendToggleSelect'
   * @property {string} [from]
   * @property {string} name Series name or data item name
   */


  echarts.registerAction('legendToggleSelect', 'legendselectchanged', util.curry(legendSelectActionHandler, 'toggleSelected'));
  echarts.registerAction('legendAllSelect', 'legendselectall', util.curry(legendSelectActionHandler, 'allSelect'));
  echarts.registerAction('legendInverseSelect', 'legendinverseselect', util.curry(legendSelectActionHandler, 'inverseSelect'));
  /**
   * @event legendSelect
   * @type {Object}
   * @property {string} type 'legendSelect'
   * @property {string} name Series name or data item name
   */

  echarts.registerAction('legendSelect', 'legendselected', util.curry(legendSelectActionHandler, 'select'));
  /**
   * @event legendUnSelect
   * @type {Object}
   * @property {string} type 'legendUnSelect'
   * @property {string} name Series name or data item name
   */

  echarts.registerAction('legendUnSelect', 'legendunselected', util.curry(legendSelectActionHandler, 'unSelect'));

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var getLayoutRect$2 = layout.getLayoutRect;
  var layoutBox = layout.box;
  var positionElement$1 = layout.positionElement;





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Layout list like component.
   * It will box layout each items in group of component and then position the whole group in the viewport
   * @param {module:zrender/group/Group} group
   * @param {module:echarts/model/Component} componentModel
   * @param {module:echarts/ExtensionAPI}
   */
  function layout$3(group, componentModel, api) {
    var boxLayoutParams = componentModel.getBoxLayoutParams();
    var padding = componentModel.get('padding');
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var rect = getLayoutRect$2(boxLayoutParams, viewportSize, padding);
    layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);
    positionElement$1(group, boxLayoutParams, viewportSize, padding);
  }

  function makeBackground(rect, componentModel) {
    var padding = format$1.normalizeCssArray(componentModel.get('padding'));
    var style = componentModel.getItemStyle(['color', 'opacity']);
    style.fill = componentModel.get('backgroundColor');
    var rect = new graphic.Rect({
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[1] + padding[3],
        height: rect.height + padding[0] + padding[2],
        r: componentModel.get('borderRadius')
      },
      style: style,
      silent: true,
      z2: -1
    }); // FIXME
    // `subPixelOptimizeRect` may bring some gap between edge of viewpart
    // and background rect when setting like `left: 0`, `top: 0`.
    // graphic.subPixelOptimizeRect(rect);

    return rect;
  }

  var layout_1$2 = layout$3;
  var makeBackground_1 = makeBackground;

  var listComponent = {
  	layout: layout_1$2,
  	makeBackground: makeBackground_1
  };

  var createSymbol$4 = symbol.createSymbol;





  var makeBackground$1 = listComponent.makeBackground;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var curry$3 = util.curry;
  var each$r = util.each;
  var Group$1 = graphic.Group;

  var _default$1T = echarts.extendComponentView({
    type: 'legend.plain',
    newlineDisabled: false,

    /**
     * @override
     */
    init: function () {
      /**
       * @private
       * @type {module:zrender/container/Group}
       */
      this.group.add(this._contentGroup = new Group$1());
      /**
       * @private
       * @type {module:zrender/Element}
       */

      this._backgroundEl;
      /**
       * @private
       * @type {module:zrender/container/Group}
       */

      this.group.add(this._selectorGroup = new Group$1());
      /**
       * If first rendering, `contentGroup.position` is [0, 0], which
       * does not make sense and may cause unexepcted animation if adopted.
       * @private
       * @type {boolean}
       */

      this._isFirstRender = true;
    },

    /**
     * @protected
     */
    getContentGroup: function () {
      return this._contentGroup;
    },

    /**
     * @protected
     */
    getSelectorGroup: function () {
      return this._selectorGroup;
    },

    /**
     * @override
     */
    render: function (legendModel, ecModel, api) {
      var isFirstRender = this._isFirstRender;
      this._isFirstRender = false;
      this.resetInner();

      if (!legendModel.get('show', true)) {
        return;
      }

      var itemAlign = legendModel.get('align');
      var orient = legendModel.get('orient');

      if (!itemAlign || itemAlign === 'auto') {
        itemAlign = legendModel.get('left') === 'right' && orient === 'vertical' ? 'right' : 'left';
      }

      var selector = legendModel.get('selector', true);
      var selectorPosition = legendModel.get('selectorPosition', true);

      if (selector && (!selectorPosition || selectorPosition === 'auto')) {
        selectorPosition = orient === 'horizontal' ? 'end' : 'start';
      }

      this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition); // Perform layout.

      var positionInfo = legendModel.getBoxLayoutParams();
      var viewportSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var padding = legendModel.get('padding');
      var maxSize = layout.getLayoutRect(positionInfo, viewportSize, padding);
      var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition); // Place mainGroup, based on the calculated `mainRect`.

      var layoutRect = layout.getLayoutRect(util.defaults({
        width: mainRect.width,
        height: mainRect.height
      }, positionInfo), viewportSize, padding);
      this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.

      this.group.add(this._backgroundEl = makeBackground$1(mainRect, legendModel));
    },

    /**
     * @protected
     */
    resetInner: function () {
      this.getContentGroup().removeAll();
      this._backgroundEl && this.group.remove(this._backgroundEl);
      this.getSelectorGroup().removeAll();
    },

    /**
     * @protected
     */
    renderInner: function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
      var contentGroup = this.getContentGroup();
      var legendDrawnMap = util.createHashMap();
      var selectMode = legendModel.get('selectedMode');
      var excludeSeriesId = [];
      ecModel.eachRawSeries(function (seriesModel) {
        !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);
      });
      each$r(legendModel.getData(), function (itemModel, dataIndex) {
        var name = itemModel.get('name'); // Use empty string or \n as a newline string

        if (!this.newlineDisabled && (name === '' || name === '\n')) {
          contentGroup.add(new Group$1({
            newline: true
          }));
          return;
        } // Representitive series.


        var seriesModel = ecModel.getSeriesByName(name)[0];

        if (legendDrawnMap.get(name)) {
          // Have been drawed
          return;
        } // Legend to control series.


        if (seriesModel) {
          var data = seriesModel.getData();
          var color = data.getVisual('color');
          var borderColor = data.getVisual('borderColor'); // If color is a callback function

          if (typeof color === 'function') {
            // Use the first data
            color = color(seriesModel.getDataParams(0));
          } // If borderColor is a callback function


          if (typeof borderColor === 'function') {
            // Use the first data
            borderColor = borderColor(seriesModel.getDataParams(0));
          } // Using rect symbol defaultly


          var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';
          var symbolType = data.getVisual('symbol');

          var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, selectMode);

          itemGroup.on('click', curry$3(dispatchSelectAction, name, null, api, excludeSeriesId)).on('mouseover', curry$3(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on('mouseout', curry$3(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
          legendDrawnMap.set(name, true);
        } else {
          // Legend to control data. In pie and funnel.
          ecModel.eachRawSeries(function (seriesModel) {
            // In case multiple series has same data name
            if (legendDrawnMap.get(name)) {
              return;
            }

            if (seriesModel.legendVisualProvider) {
              var provider = seriesModel.legendVisualProvider;

              if (!provider.containName(name)) {
                return;
              }

              var idx = provider.indexOfName(name);
              var color = provider.getItemVisual(idx, 'color');
              var borderColor = provider.getItemVisual(idx, 'borderColor');
              var legendSymbolType = 'roundRect';

              var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, borderColor, selectMode); // FIXME: consider different series has items with the same name.


              itemGroup.on('click', curry$3(dispatchSelectAction, null, name, api, excludeSeriesId)) // Should not specify the series name, consider legend controls
              // more than one pie series.
              .on('mouseover', curry$3(dispatchHighlightAction, null, name, api, excludeSeriesId)).on('mouseout', curry$3(dispatchDownplayAction, null, name, api, excludeSeriesId));
              legendDrawnMap.set(name, true);
            }
          }, this);
        }
      }, this);

      if (selector) {
        this._createSelector(selector, legendModel, api, orient, selectorPosition);
      }
    },
    _createSelector: function (selector, legendModel, api, orient, selectorPosition) {
      var selectorGroup = this.getSelectorGroup();
      each$r(selector, function (selectorItem) {
        createSelectorButton(selectorItem);
      });

      function createSelectorButton(selectorItem) {
        var type = selectorItem.type;
        var labelText = new graphic.Text({
          style: {
            x: 0,
            y: 0,
            align: 'center',
            verticalAlign: 'middle'
          },
          onclick: function () {
            api.dispatchAction({
              type: type === 'all' ? 'legendAllSelect' : 'legendInverseSelect'
            });
          }
        });
        selectorGroup.add(labelText);
        var labelModel = legendModel.getModel('selectorLabel');
        var emphasisLabelModel = legendModel.getModel('emphasis.selectorLabel');
        graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, emphasisLabelModel, {
          defaultText: selectorItem.title,
          isRectText: false
        });
        graphic.setHoverStyle(labelText);
      }
    },
    _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, selectMode) {
      var itemWidth = legendModel.get('itemWidth');
      var itemHeight = legendModel.get('itemHeight');
      var inactiveColor = legendModel.get('inactiveColor');
      var inactiveBorderColor = legendModel.get('inactiveBorderColor');
      var symbolKeepAspect = legendModel.get('symbolKeepAspect');
      var legendModelItemStyle = legendModel.getModel('itemStyle');
      var isSelected = legendModel.isSelected(name);
      var itemGroup = new Group$1();
      var textStyleModel = itemModel.getModel('textStyle');
      var itemIcon = itemModel.get('icon');
      var tooltipModel = itemModel.getModel('tooltip');
      var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first

      legendSymbolType = itemIcon || legendSymbolType;
      var legendSymbol = createSymbol$4(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend
      symbolKeepAspect == null ? true : symbolKeepAspect);
      itemGroup.add(setSymbolStyle(legendSymbol, legendSymbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected)); // Compose symbols
      // PENDING

      if (!itemIcon && symbolType // At least show one symbol, can't be all none
      && (symbolType !== legendSymbolType || symbolType === 'none')) {
        var size = itemHeight * 0.8;

        if (symbolType === 'none') {
          symbolType = 'circle';
        }

        var legendSymbolCenter = createSymbol$4(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend
        symbolKeepAspect == null ? true : symbolKeepAspect); // Put symbol in the center

        itemGroup.add(setSymbolStyle(legendSymbolCenter, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected));
      }

      var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
      var textAlign = itemAlign;
      var formatter = legendModel.get('formatter');
      var content = name;

      if (typeof formatter === 'string' && formatter) {
        content = formatter.replace('{name}', name != null ? name : '');
      } else if (typeof formatter === 'function') {
        content = formatter(name);
      }

      itemGroup.add(new graphic.Text({
        style: graphic.setTextStyle({}, textStyleModel, {
          text: content,
          x: textX,
          y: itemHeight / 2,
          textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
          textAlign: textAlign,
          textVerticalAlign: 'middle'
        })
      })); // Add a invisible rect to increase the area of mouse hover

      var hitRect = new graphic.Rect({
        shape: itemGroup.getBoundingRect(),
        invisible: true,
        tooltip: tooltipModel.get('show') ? util.extend({
          content: name,
          // Defaul formatter
          formatter: legendGlobalTooltipModel.get('formatter', true) || function () {
            return name;
          },
          formatterParams: {
            componentType: 'legend',
            legendIndex: legendModel.componentIndex,
            name: name,
            $vars: ['name']
          }
        }, tooltipModel.option) : null
      });
      itemGroup.add(hitRect);
      itemGroup.eachChild(function (child) {
        child.silent = true;
      });
      hitRect.silent = !selectMode;
      this.getContentGroup().add(itemGroup);
      graphic.setHoverStyle(itemGroup);
      itemGroup.__legendDataIndex = dataIndex;
      return itemGroup;
    },

    /**
     * @protected
     */
    layoutInner: function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
      var contentGroup = this.getContentGroup();
      var selectorGroup = this.getSelectorGroup(); // Place items in contentGroup.

      layout.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);
      var contentRect = contentGroup.getBoundingRect();
      var contentPos = [-contentRect.x, -contentRect.y];

      if (selector) {
        // Place buttons in selectorGroup
        layout.box( // Buttons in selectorGroup always layout horizontally
        'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));
        var selectorRect = selectorGroup.getBoundingRect();
        var selectorPos = [-selectorRect.x, -selectorRect.y];
        var selectorButtonGap = legendModel.get('selectorButtonGap', true);
        var orientIdx = legendModel.getOrient().index;
        var wh = orientIdx === 0 ? 'width' : 'height';
        var hw = orientIdx === 0 ? 'height' : 'width';
        var yx = orientIdx === 0 ? 'y' : 'x';

        if (selectorPosition === 'end') {
          selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
        } else {
          contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
        } //Always align selector to content as 'middle'


        selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
        selectorGroup.attr('position', selectorPos);
        contentGroup.attr('position', contentPos);
        var mainRect = {
          x: 0,
          y: 0
        };
        mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
        mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
        mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
        return mainRect;
      } else {
        contentGroup.attr('position', contentPos);
        return this.group.getBoundingRect();
      }
    },

    /**
     * @protected
     */
    remove: function () {
      this.getContentGroup().removeAll();
      this._isFirstRender = true;
    }
  });

  function setSymbolStyle(symbol, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected) {
    var itemStyle;

    if (symbolType !== 'line' && symbolType.indexOf('empty') < 0) {
      itemStyle = legendModelItemStyle.getItemStyle();
      symbol.style.stroke = borderColor;

      if (!isSelected) {
        itemStyle.stroke = inactiveBorderColor;
      }
    } else {
      itemStyle = legendModelItemStyle.getItemStyle(['borderWidth', 'borderColor']);
    }

    return symbol.setStyle(itemStyle);
  }

  function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
    // downplay before unselect
    dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
    api.dispatchAction({
      type: 'legendToggleSelect',
      name: seriesName != null ? seriesName : dataName
    }); // highlight after select

    dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
  }

  function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
    // If element hover will move to a hoverLayer.
    var el = api.getZr().storage.getDisplayList()[0];

    if (!(el && el.useHoverLayer)) {
      api.dispatchAction({
        type: 'highlight',
        seriesName: seriesName,
        name: dataName,
        excludeSeriesId: excludeSeriesId
      });
    }
  }

  function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
    // If element hover will move to a hoverLayer.
    var el = api.getZr().storage.getDisplayList()[0];

    if (!(el && el.useHoverLayer)) {
      api.dispatchAction({
        type: 'downplay',
        seriesName: seriesName,
        name: dataName,
        excludeSeriesId: excludeSeriesId
      });
    }
  }

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function _default$1U(ecModel) {
    var legendModels = ecModel.findComponents({
      mainType: 'legend'
    });

    if (legendModels && legendModels.length) {
      ecModel.filterSeries(function (series) {
        // If in any legend component the status is not selected.
        // Because in legend series is assumed selected when it is not in the legend data.
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(series.name)) {
            return false;
          }
        }

        return true;
      });
    }
  }

  var legendFilter = _default$1U;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */













  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Do not contain scrollable legend, for sake of file size.
  // Series Filter
  echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
  Component.registerSubTypeDefaulter('legend', function () {
    // Default 'plain' when no type specified.
    return 'plain';
  });

  var constants = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, '__esModule', { value: true });

  var DEFAULT_THEME = {
    categoryAxis: {
      axisLine: { show: false },
      axisTick: { show: false },
      splitLine: { show: false }
    },
    valueAxis: {
      axisLine: { show: false }
    },
    line: {
      smooth: true
    },
    grid: {
      containLabel: true,
      left: 10,
      right: 10
    }
  };

  var DEFAULT_COLORS = ['#19d4ae', '#5ab1ef', '#fa6e86', '#ffb980', '#0067a6', '#c4b4e4', '#d87a80', '#9cbbff', '#d9d0c7', '#87a997', '#d49ea2', '#5b4947', '#7ba3a8'];

  var HEAT_MAP_COLOR = ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffbf', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026'];

  var HEAT_BMAP_COLOR = ['blue', 'blue', 'green', 'yellow', 'red'];

  var itemPoint = function itemPoint(color) {
    return ['<span style="', 'background-color:' + color + ';', 'display: inline-block;', 'width: 10px;', 'height: 10px;', 'border-radius: 50%;', 'margin-right:2px;', '"></span>'].join('');
  };

  var STATIC_PROPS = ['initOptions', 'loading', 'dataEmpty', 'judgeWidth', 'widthChangeDelay'];

  var ECHARTS_SETTINGS = ['grid', 'dataZoom', 'visualMap', 'toolbox', 'title', 'legend', 'xAxis', 'yAxis', 'radar', 'tooltip', 'axisPointer', 'brush', 'geo', 'timeline', 'graphic', 'series', 'backgroundColor', 'textStyle'];

  exports.DEFAULT_THEME = DEFAULT_THEME;
  exports.DEFAULT_COLORS = DEFAULT_COLORS;
  exports.HEAT_MAP_COLOR = HEAT_MAP_COLOR;
  exports.HEAT_BMAP_COLOR = HEAT_BMAP_COLOR;
  exports.itemPoint = itemPoint;
  exports.STATIC_PROPS = STATIC_PROPS;
  exports.ECHARTS_SETTINGS = ECHARTS_SETTINGS;
  });

  function _interopDefault$1 (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }


  var echartsLib = _interopDefault$1(echarts);


  var numerify$1 = _interopDefault$1(require$$3);


  var Loading = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "v-charts-component-loading" }, [_c('div', { staticClass: "loader" }, [_c('div', { staticClass: "loading-spinner" }, [_c('svg', { staticClass: "circular", attrs: { "viewBox": "25 25 50 50" } }, [_c('circle', { staticClass: "path", attrs: { "cx": "50", "cy": "50", "r": "20", "fill": "none" } })])])])]);
    }, staticRenderFns: []
  };

  var DataEmpty = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "v-charts-data-empty" }, [_vm._v(" ææ æ°æ® ")]);
    }, staticRenderFns: []
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function setExtend (options, extend) {
    Object.keys(extend).forEach(function (attr) {
      var value = extend[attr];
      if (~attr.indexOf('.')) {
        // eg: a.b.c a.1.b
        utilsLite.set(options, attr, value);
      } else if (typeof value === 'function') {
        // get callback value
        options[attr] = value(options[attr]);
      } else {
        // mixin extend value
        if (utilsLite.isArray(options[attr]) && utilsLite.isObject(options[attr][0])) {
          // eg: [{ xx: 1 }, { xx: 2 }]
          options[attr].forEach(function (option, index) {
            options[attr][index] = _extends({}, option, value);
          });
        } else if (utilsLite.isObject(options[attr])) {
          // eg: { xx: 1, yy: 2 }
          options[attr] = _extends({}, options[attr], value);
        } else {
          options[attr] = value;
        }
      }
    });
  }

  function setMark (seriesItem, marks) {
    Object.keys(marks).forEach(function (key) {
      if (marks[key]) seriesItem[key] = marks[key];
    });
  }

  function setAnimation (options, animation) {
    Object.keys(animation).forEach(function (key) {
      options[key] = animation[key];
    });
  }

  var core = {
    render: function render(h) {
      return h('div', {
        class: [utilsLite.camelToKebab(this.$options.name || this.$options._componentTag)],
        style: this.canvasStyle
      }, [h('div', {
        style: this.canvasStyle,
        class: { 'v-charts-mask-status': this.dataEmpty || this.loading },
        ref: 'canvas'
      }), h(DataEmpty, {
        style: { display: this.dataEmpty ? '' : 'none' }
      }), h(Loading, {
        style: { display: this.loading ? '' : 'none' }
      }), this.$slots.default]);
    },


    props: {
      data: { type: [Object, Array], default: function _default() {
          return {};
        }
      },
      settings: { type: Object, default: function _default() {
          return {};
        }
      },
      width: { type: String, default: 'auto' },
      height: { type: String, default: '400px' },
      beforeConfig: { type: Function },
      afterConfig: { type: Function },
      afterSetOption: { type: Function },
      afterSetOptionOnce: { type: Function },
      events: { type: Object },
      grid: { type: [Object, Array] },
      colors: { type: Array },
      tooltipVisible: { type: Boolean, default: true },
      legendVisible: { type: Boolean, default: true },
      legendPosition: { type: String },
      markLine: { type: Object },
      markArea: { type: Object },
      markPoint: { type: Object },
      visualMap: { type: [Object, Array] },
      dataZoom: { type: [Object, Array] },
      toolbox: { type: [Object, Array] },
      initOptions: { type: Object, default: function _default() {
          return {};
        }
      },
      title: [Object, Array],
      legend: [Object, Array],
      xAxis: [Object, Array],
      yAxis: [Object, Array],
      radar: Object,
      tooltip: Object,
      axisPointer: [Object, Array],
      brush: [Object, Array],
      geo: [Object, Array],
      timeline: [Object, Array],
      graphic: [Object, Array],
      series: [Object, Array],
      backgroundColor: [Object, String],
      textStyle: [Object, Array],
      animation: Object,
      theme: Object,
      themeName: String,
      loading: Boolean,
      dataEmpty: Boolean,
      extend: Object,
      judgeWidth: { type: Boolean, default: false },
      widthChangeDelay: { type: Number, default: 300 },
      tooltipFormatter: { type: Function },
      resizeable: { type: Boolean, default: true },
      resizeDelay: { type: Number, default: 200 },
      changeDelay: { type: Number, default: 0 },
      setOptionOpts: { type: [Boolean, Object], default: true },
      cancelResizeCheck: Boolean,
      notSetUnchange: Array,
      log: Boolean
    },

    watch: {
      data: {
        deep: true,
        handler: function handler(v) {
          if (v) {
            this.changeHandler();
          }
        }
      },

      settings: {
        deep: true,
        handler: function handler(v) {
          if (v.type && this.chartLib) this.chartHandler = this.chartLib[v.type];
          this.changeHandler();
        }
      },

      width: 'nextTickResize',
      height: 'nextTickResize',

      events: {
        deep: true,
        handler: 'createEventProxy'
      },

      theme: {
        deep: true,
        handler: 'themeChange'
      },

      themeName: 'themeChange',

      resizeable: 'resizeableHandler'
    },

    computed: {
      canvasStyle: function canvasStyle() {
        return {
          width: this.width,
          height: this.height,
          position: 'relative'
        };
      },
      chartColor: function chartColor() {
        return this.colors || this.theme && this.theme.color || constants.DEFAULT_COLORS;
      }
    },

    methods: {
      dataHandler: function dataHandler() {
        if (!this.chartHandler) return;
        var data = this.data;
        var _data = data,
            _data$columns = _data.columns,
            columns = _data$columns === undefined ? [] : _data$columns,
            _data$rows = _data.rows,
            rows = _data$rows === undefined ? [] : _data$rows;

        var extra = {
          tooltipVisible: this.tooltipVisible,
          legendVisible: this.legendVisible,
          echarts: this.echarts,
          color: this.chartColor,
          tooltipFormatter: this.tooltipFormatter,
          _once: this._once
        };
        if (this.beforeConfig) data = this.beforeConfig(data);

        var options = this.chartHandler(columns, rows, this.settings, extra);
        if (options) {
          if (typeof options.then === 'function') {
            options.then(this.optionsHandler);
          } else {
            this.optionsHandler(options);
          }
        }
      },
      nextTickResize: function nextTickResize() {
        this.$nextTick(this.resize);
      },
      resize: function resize() {
        if (!this.cancelResizeCheck) {
          if (this.$el && this.$el.clientWidth && this.$el.clientHeight) {
            this.echartsResize();
          }
        } else {
          this.echartsResize();
        }
      },
      echartsResize: function echartsResize() {
        this.echarts && this.echarts.resize();
      },
      optionsHandler: function optionsHandler(options) {
        var _this = this;

        // legend
        if (this.legendPosition && options.legend) {
          options.legend[this.legendPosition] = 10;
          if (~['left', 'right'].indexOf(this.legendPosition)) {
            options.legend.top = 'middle';
            options.legend.orient = 'vertical';
          }
        }
        // color
        options.color = this.chartColor;
        // echarts self settings
        constants.ECHARTS_SETTINGS.forEach(function (setting) {
          if (_this[setting]) options[setting] = _this[setting];
        });
        // animation
        if (this.animation) setAnimation(options, this.animation);
        // marks
        if (this.markArea || this.markLine || this.markPoint) {
          var marks = {
            markArea: this.markArea,
            markLine: this.markLine,
            markPoint: this.markPoint
          };
          var series = options.series;
          if (utilsLite.isArray(series)) {
            series.forEach(function (item) {
              setMark(item, marks);
            });
          } else if (utilsLite.isObject(series)) {
            setMark(series, marks);
          }
        }
        // change inited echarts settings
        if (this.extend) setExtend(options, this.extend);
        if (this.afterConfig) options = this.afterConfig(options);
        var setOptionOpts = this.setOptionOpts;
        // map chart not merge
        if ((this.settings.bmap || this.settings.amap) && !utilsLite.isObject(setOptionOpts)) {
          setOptionOpts = false;
        }
        // exclude unchange options
        if (this.notSetUnchange && this.notSetUnchange.length) {
          this.notSetUnchange.forEach(function (item) {
            var value = options[item];
            if (value) {
              if (utilsLite.isEqual(value, _this._store[item])) {
                options[item] = undefined;
              } else {
                _this._store[item] = utilsLite.cloneDeep(value);
              }
            }
          });
          if (utilsLite.isObject(setOptionOpts)) {
            setOptionOpts.notMerge = false;
          } else {
            setOptionOpts = false;
          }
        }
        if (this._isDestroyed) return;
        if (this.log) console.log(options);
        this.echarts.setOption(options, setOptionOpts);
        this.$emit('ready', this.echarts, options, echartsLib);
        if (!this._once['ready-once']) {
          this._once['ready-once'] = true;
          this.$emit('ready-once', this.echarts, options, echartsLib);
        }
        if (this.judgeWidth) this.judgeWidthHandler(options);
        if (this.afterSetOption) this.afterSetOption(this.echarts, options, echartsLib);
        if (this.afterSetOptionOnce && !this._once['afterSetOptionOnce']) {
          this._once['afterSetOptionOnce'] = true;
          this.afterSetOptionOnce(this.echarts, options, echartsLib);
        }
      },
      judgeWidthHandler: function judgeWidthHandler(options) {
        var _this2 = this;

        var widthChangeDelay = this.widthChangeDelay,
            resize = this.resize;

        if (this.$el.clientWidth || this.$el.clientHeight) {
          resize();
        } else {
          this.$nextTick(function (_) {
            if (_this2.$el.clientWidth || _this2.$el.clientHeight) {
              resize();
            } else {
              setTimeout(function (_) {
                resize();
                if (!_this2.$el.clientWidth || !_this2.$el.clientHeight) {
                  console.warn(' Can\'t get dom width or height ');
                }
              }, widthChangeDelay);
            }
          });
        }
      },
      resizeableHandler: function resizeableHandler(resizeable) {
        if (resizeable && !this._once.onresize) this.addResizeListener();
        if (!resizeable && this._once.onresize) this.removeResizeListener();
      },
      init: function init() {
        if (this.echarts) return;
        var themeName = this.themeName || this.theme || constants.DEFAULT_THEME;
        this.echarts = echartsLib.init(this.$refs.canvas, themeName, this.initOptions);
        if (this.data) this.changeHandler();
        this.createEventProxy();
        if (this.resizeable) this.addResizeListener();
      },
      addResizeListener: function addResizeListener() {
        window.addEventListener('resize', this.resizeHandler);
        this._once.onresize = true;
      },
      removeResizeListener: function removeResizeListener() {
        window.removeEventListener('resize', this.resizeHandler);
        this._once.onresize = false;
      },
      addWatchToProps: function addWatchToProps() {
        var _this3 = this;

        var watchedVariable = this._watchers.map(function (watcher) {
          return watcher.expression;
        });
        Object.keys(this.$props).forEach(function (prop) {
          if (!~watchedVariable.indexOf(prop) && !~constants.STATIC_PROPS.indexOf(prop)) {
            var opts = {};
            if (~['[object Object]', '[object Array]'].indexOf(utilsLite.getType(_this3.$props[prop]))) {
              opts.deep = true;
            }
            _this3.$watch(prop, function () {
              _this3.changeHandler();
            }, opts);
          }
        });
      },
      createEventProxy: function createEventProxy() {
        var _this4 = this;

        // åªè¦ç¨æ·ä½¿ç¨ on æ¹æ³ç»å®çäºä»¶é½åä¸å±ä»£çï¼
        // æ¯å¦çæ­£æ§è¡ç¸åºçäºä»¶æ¹æ³åå³äºè¯¥æ¹æ³æ¯å¦ä»ç¶å­å¨ events ä¸­
        // å®ç° events çå¨æååº
        var self = this;
        var keys = Object.keys(this.events || {});
        keys.length && keys.forEach(function (ev) {
          if (_this4.registeredEvents.indexOf(ev) === -1) {
            _this4.registeredEvents.push(ev);
            _this4.echarts.on(ev, function (ev) {
              return function () {
                if (ev in self.events) {
                  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }

                  self.events[ev].apply(null, args);
                }
              };
            }(ev));
          }
        });
      },
      themeChange: function themeChange(theme) {
        this.clean();
        this.echarts = null;
        this.init();
      },
      clean: function clean() {
        if (this.resizeable) this.removeResizeListener();
        this.echarts.dispose();
      }
    },

    created: function created() {
      this.echarts = null;
      this.registeredEvents = [];
      this._once = {};
      this._store = {};
      this.resizeHandler = utilsLite.debounce(this.resize, this.resizeDelay);
      this.changeHandler = utilsLite.debounce(this.dataHandler, this.changeDelay);
      this.addWatchToProps();
    },
    mounted: function mounted() {
      this.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.clean();
    },


    _numerify: numerify$1
  };

  var core_1 = core;

  function _interopDefault$2 (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }




  var Core = _interopDefault$2(core_1);

  var _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function getLineXAxis(args) {
    var dimension = args.dimension,
        rows = args.rows,
        xAxisName = args.xAxisName,
        axisVisible = args.axisVisible,
        xAxisType = args.xAxisType;

    return dimension.map(function (item, index) {
      return {
        type: xAxisType,
        nameLocation: 'middle',
        nameGap: 22,
        name: xAxisName[index] || '',
        axisTick: { show: true, lineStyle: { color: '#eee' } },
        data: rows.map(function (row) {
          return row[item];
        }),
        show: axisVisible
      };
    });
  }

  function getLineSeries(args) {
    var rows = args.rows,
        axisSite = args.axisSite,
        metrics = args.metrics,
        area = args.area,
        stack = args.stack,
        nullAddZero = args.nullAddZero,
        labelMap = args.labelMap,
        label = args.label,
        itemStyle = args.itemStyle,
        lineStyle = args.lineStyle,
        areaStyle = args.areaStyle,
        dimension = args.dimension;

    var series = [];
    var dataTemp = {};
    var stackMap = stack && utils.getStackMap(stack);
    metrics.forEach(function (item) {
      dataTemp[item] = [];
    });
    rows.forEach(function (row) {
      metrics.forEach(function (item) {
        var value = null;
        if (row[item] != null) {
          value = row[item];
        } else if (nullAddZero) {
          value = 0;
        }
        dataTemp[item].push([row[dimension[0]], value]);
      });
    });
    metrics.forEach(function (item) {
      var seriesItem = {
        name: labelMap[item] != null ? labelMap[item] : item,
        type: 'line',
        data: dataTemp[item]
      };

      if (area) seriesItem.areaStyle = { normal: {} };
      if (axisSite.right) {
        seriesItem.yAxisIndex = ~axisSite.right.indexOf(item) ? 1 : 0;
      }

      if (stack && stackMap[item]) seriesItem.stack = stackMap[item];

      if (label) seriesItem.label = label;
      if (itemStyle) seriesItem.itemStyle = itemStyle;
      if (lineStyle) seriesItem.lineStyle = lineStyle;
      if (areaStyle) seriesItem.areaStyle = areaStyle;

      series.push(seriesItem);
    });
    return series;
  }

  function getLineYAxis(args) {
    var yAxisName = args.yAxisName,
        yAxisType = args.yAxisType,
        axisVisible = args.axisVisible,
        scale = args.scale,
        min = args.min,
        max = args.max,
        digit = args.digit;

    var yAxisBase = {
      type: 'value',
      axisTick: {
        show: false
      },
      show: axisVisible
    };
    var yAxis = [];

    var _loop = function _loop(i) {
      if (yAxisType[i]) {
        yAxis[i] = _extends$1({}, yAxisBase, {
          axisLabel: {
            formatter: function formatter(val) {
              return utils.getFormated(val, yAxisType[i], digit);
            }
          }
        });
      } else {
        yAxis[i] = _extends$1({}, yAxisBase);
      }
      yAxis[i].name = yAxisName[i] || '';
      yAxis[i].scale = scale[i] || false;
      yAxis[i].min = min[i] || null;
      yAxis[i].max = max[i] || null;
    };

    for (var i = 0; i < 2; i++) {
      _loop(i);
    }
    return yAxis;
  }

  function getLineTooltip(args) {
    var axisSite = args.axisSite,
        yAxisType = args.yAxisType,
        digit = args.digit,
        labelMap = args.labelMap,
        tooltipFormatter = args.tooltipFormatter;

    var rightItems = axisSite.right || [];
    var rightList = labelMap ? rightItems.map(function (item) {
      return labelMap[item] === undefined ? item : labelMap[item];
    }) : rightItems;
    return {
      trigger: 'axis',
      formatter: function formatter(items) {
        if (tooltipFormatter) {
          return tooltipFormatter.apply(null, arguments);
        }
        var tpl = [];
        var _items$ = items[0],
            name = _items$.name,
            axisValueLabel = _items$.axisValueLabel;

        var title = name || axisValueLabel;
        tpl.push(title + '<br>');
        items.forEach(function (_ref) {
          var seriesName = _ref.seriesName,
              data = _ref.data,
              marker = _ref.marker;

          var showData = null;
          var type = ~rightList.indexOf(seriesName) ? yAxisType[1] : yAxisType[0];
          var itemData = utilsLite.isArray(data) ? data[1] : data;
          showData = utils.getFormated(itemData, type, digit);
          tpl.push(marker);
          tpl.push(seriesName + ': ' + showData);
          tpl.push('<br>');
        });
        return tpl.join('');
      }
    };
  }

  function getLegend(args) {
    var metrics = args.metrics,
        legendName = args.legendName,
        labelMap = args.labelMap;

    if (!legendName && !labelMap) return { data: metrics };
    var data = labelMap ? metrics.map(function (item) {
      return labelMap[item] == null ? item : labelMap[item];
    }) : metrics;
    return {
      data: data,
      formatter: function formatter(name) {
        return legendName[name] != null ? legendName[name] : name;
      }
    };
  }

  var line$1 = function line$$1(columns, rows, settings, extra) {
    rows = utilsLite.isArray(rows) ? rows : [];
    columns = utilsLite.isArray(columns) ? columns : [];
    var _settings$axisSite = settings.axisSite,
        axisSite = _settings$axisSite === undefined ? {} : _settings$axisSite,
        _settings$yAxisType = settings.yAxisType,
        yAxisType = _settings$yAxisType === undefined ? ['normal', 'normal'] : _settings$yAxisType,
        _settings$xAxisType = settings.xAxisType,
        xAxisType = _settings$xAxisType === undefined ? 'category' : _settings$xAxisType,
        _settings$yAxisName = settings.yAxisName,
        yAxisName = _settings$yAxisName === undefined ? [] : _settings$yAxisName,
        _settings$dimension = settings.dimension,
        dimension = _settings$dimension === undefined ? [columns[0]] : _settings$dimension,
        _settings$xAxisName = settings.xAxisName,
        xAxisName = _settings$xAxisName === undefined ? [] : _settings$xAxisName,
        _settings$axisVisible = settings.axisVisible,
        axisVisible = _settings$axisVisible === undefined ? true : _settings$axisVisible,
        area = settings.area,
        stack = settings.stack,
        _settings$scale = settings.scale,
        scale = _settings$scale === undefined ? [false, false] : _settings$scale,
        _settings$min = settings.min,
        min = _settings$min === undefined ? [null, null] : _settings$min,
        _settings$max = settings.max,
        max = _settings$max === undefined ? [null, null] : _settings$max,
        _settings$nullAddZero = settings.nullAddZero,
        nullAddZero = _settings$nullAddZero === undefined ? false : _settings$nullAddZero,
        _settings$digit = settings.digit,
        digit = _settings$digit === undefined ? 2 : _settings$digit,
        _settings$legendName = settings.legendName,
        legendName = _settings$legendName === undefined ? {} : _settings$legendName,
        _settings$labelMap = settings.labelMap,
        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,
        label = settings.label,
        itemStyle = settings.itemStyle,
        lineStyle = settings.lineStyle,
        areaStyle = settings.areaStyle;
    var tooltipVisible = extra.tooltipVisible,
        legendVisible = extra.legendVisible,
        tooltipFormatter = extra.tooltipFormatter;

    var metrics = columns.slice();

    if (axisSite.left && axisSite.right) {
      metrics = axisSite.left.concat(axisSite.right);
    } else if (axisSite.left && !axisSite.right) {
      metrics = axisSite.left;
    } else if (settings.metrics) {
      metrics = settings.metrics;
    } else {
      metrics.splice(columns.indexOf(dimension[0]), 1);
    }

    var legend = legendVisible && getLegend({ metrics: metrics, legendName: legendName, labelMap: labelMap });
    var tooltip = tooltipVisible && getLineTooltip({
      axisSite: axisSite,
      yAxisType: yAxisType,
      digit: digit,
      labelMap: labelMap,
      xAxisType: xAxisType,
      tooltipFormatter: tooltipFormatter
    });
    var xAxis = getLineXAxis({
      dimension: dimension,
      rows: rows,
      xAxisName: xAxisName,
      axisVisible: axisVisible,
      xAxisType: xAxisType
    });
    var yAxis = getLineYAxis({
      yAxisName: yAxisName,
      yAxisType: yAxisType,
      axisVisible: axisVisible,
      scale: scale,
      min: min,
      max: max,
      digit: digit
    });
    var series = getLineSeries({
      rows: rows,
      axisSite: axisSite,
      metrics: metrics,
      area: area,
      stack: stack,
      nullAddZero: nullAddZero,
      labelMap: labelMap,
      label: label,
      itemStyle: itemStyle,
      lineStyle: lineStyle,
      areaStyle: areaStyle,
      xAxisType: xAxisType,
      dimension: dimension
    });
    var options = { legend: legend, xAxis: xAxis, series: series, yAxis: yAxis, tooltip: tooltip };
    return options;
  };

  var index = _extends$1({}, Core, {
    name: 'VeLine',
    data: function data() {
      this.chartHandler = line$1;
      return {};
    }
  });

  var line_common = index;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function IndicatorAxis(dim, scale, radiusExtent) {
    Axis_1.call(this, dim, scale, radiusExtent);
    /**
     * Axis type
     *  - 'category'
     *  - 'value'
     *  - 'time'
     *  - 'log'
     * @type {string}
     */

    this.type = 'value';
    this.angle = 0;
    /**
     * Indicator name
     * @type {string}
     */

    this.name = '';
    /**
     * @type {module:echarts/model/Model}
     */

    this.model;
  }

  util.inherits(IndicatorAxis, Axis_1);
  var _default$1V = IndicatorAxis;
  var IndicatorAxis_1 = _default$1V;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */











  var getScaleExtent$1 = axisHelper.getScaleExtent;
  var niceScaleExtent$2 = axisHelper.niceScaleExtent;





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // TODO clockwise
  function Radar(radarModel, ecModel, api) {
    this._model = radarModel;
    /**
     * Radar dimensions
     * @type {Array.<string>}
     */

    this.dimensions = [];
    this._indicatorAxes = util.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {
      var dim = 'indicator_' + idx;
      var indicatorAxis = new IndicatorAxis_1(dim, indicatorModel.get('axisType') === 'log' ? new Log() : new Interval());
      indicatorAxis.name = indicatorModel.get('name'); // Inject model and axis

      indicatorAxis.model = indicatorModel;
      indicatorModel.axis = indicatorAxis;
      this.dimensions.push(dim);
      return indicatorAxis;
    }, this);
    this.resize(radarModel, api);
    /**
     * @type {number}
     * @readOnly
     */

    this.cx;
    /**
     * @type {number}
     * @readOnly
     */

    this.cy;
    /**
     * @type {number}
     * @readOnly
     */

    this.r;
    /**
     * @type {number}
     * @readOnly
     */

    this.r0;
    /**
     * @type {number}
     * @readOnly
     */

    this.startAngle;
  }

  Radar.prototype.getIndicatorAxes = function () {
    return this._indicatorAxes;
  };

  Radar.prototype.dataToPoint = function (value, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
  };

  Radar.prototype.coordToPoint = function (coord, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    var angle = indicatorAxis.angle;
    var x = this.cx + coord * Math.cos(angle);
    var y = this.cy - coord * Math.sin(angle);
    return [x, y];
  };

  Radar.prototype.pointToData = function (pt) {
    var dx = pt[0] - this.cx;
    var dy = pt[1] - this.cy;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx); // Find the closest angle
    // FIXME index can calculated directly

    var minRadianDiff = Infinity;
    var closestAxis;
    var closestAxisIdx = -1;

    for (var i = 0; i < this._indicatorAxes.length; i++) {
      var indicatorAxis = this._indicatorAxes[i];
      var diff = Math.abs(radian - indicatorAxis.angle);

      if (diff < minRadianDiff) {
        closestAxis = indicatorAxis;
        closestAxisIdx = i;
        minRadianDiff = diff;
      }
    }

    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
  };

  Radar.prototype.resize = function (radarModel, api) {
    var center = radarModel.get('center');
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var viewSize = Math.min(viewWidth, viewHeight) / 2;
    this.cx = number.parsePercent(center[0], viewWidth);
    this.cy = number.parsePercent(center[1], viewHeight);
    this.startAngle = radarModel.get('startAngle') * Math.PI / 180; // radius may be single value like `20`, `'80%'`, or array like `[10, '80%']`

    var radius = radarModel.get('radius');

    if (typeof radius === 'string' || typeof radius === 'number') {
      radius = [0, radius];
    }

    this.r0 = number.parsePercent(radius[0], viewSize);
    this.r = number.parsePercent(radius[1], viewSize);
    util.each(this._indicatorAxes, function (indicatorAxis, idx) {
      indicatorAxis.setExtent(this.r0, this.r);
      var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length; // Normalize to [-PI, PI]

      angle = Math.atan2(Math.sin(angle), Math.cos(angle));
      indicatorAxis.angle = angle;
    }, this);
  };

  Radar.prototype.update = function (ecModel, api) {
    var indicatorAxes = this._indicatorAxes;
    var radarModel = this._model;
    util.each(indicatorAxes, function (indicatorAxis) {
      indicatorAxis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeriesByType('radar', function (radarSeries, idx) {
      if (radarSeries.get('coordinateSystem') !== 'radar' || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {
        return;
      }

      var data = radarSeries.getData();
      util.each(indicatorAxes, function (indicatorAxis) {
        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
      });
    }, this);
    var splitNumber = radarModel.get('splitNumber');

    function increaseInterval(interval) {
      var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10)); // Increase interval

      var f = interval / exp10;

      if (f === 2) {
        f = 5;
      } else {
        // f is 2 or 5
        f *= 2;
      }

      return f * exp10;
    } // Force all the axis fixing the maxSplitNumber.


    util.each(indicatorAxes, function (indicatorAxis, idx) {
      var rawExtent = getScaleExtent$1(indicatorAxis.scale, indicatorAxis.model).extent;
      niceScaleExtent$2(indicatorAxis.scale, indicatorAxis.model);
      var axisModel = indicatorAxis.model;
      var scale = indicatorAxis.scale;
      var fixedMin = axisModel.getMin();
      var fixedMax = axisModel.getMax();
      var interval = scale.getInterval();

      if (fixedMin != null && fixedMax != null) {
        // User set min, max, divide to get new interval
        scale.setExtent(+fixedMin, +fixedMax);
        scale.setInterval((fixedMax - fixedMin) / splitNumber);
      } else if (fixedMin != null) {
        var max; // User set min, expand extent on the other side

        do {
          max = fixedMin + interval * splitNumber;
          scale.setExtent(+fixedMin, max); // Interval must been set after extent
          // FIXME

          scale.setInterval(interval);
          interval = increaseInterval(interval);
        } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));
      } else if (fixedMax != null) {
        var min; // User set min, expand extent on the other side

        do {
          min = fixedMax - interval * splitNumber;
          scale.setExtent(min, +fixedMax);
          scale.setInterval(interval);
          interval = increaseInterval(interval);
        } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));
      } else {
        var nicedSplitNumber = scale.getTicks().length - 1;

        if (nicedSplitNumber > splitNumber) {
          interval = increaseInterval(interval);
        } // TODO


        var max = Math.ceil(rawExtent[1] / interval) * interval;
        var min = number.round(max - interval * splitNumber);
        scale.setExtent(min, max);
        scale.setInterval(interval);
      }
    });
  };
  /**
   * Radar dimensions is based on the data
   * @type {Array}
   */


  Radar.dimensions = [];

  Radar.create = function (ecModel, api) {
    var radarList = [];
    ecModel.eachComponent('radar', function (radarModel) {
      var radar = new Radar(radarModel, ecModel, api);
      radarList.push(radar);
      radarModel.coordinateSystem = radar;
    });
    ecModel.eachSeriesByType('radar', function (radarSeries) {
      if (radarSeries.get('coordinateSystem') === 'radar') {
        // Inject coordinate system
        radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];
      }
    });
    return radarList;
  };

  CoordinateSystem.register('radar', Radar);

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */











  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var valueAxisDefault = axisDefault_1.valueAxis;

  function defaultsShow(opt, show) {
    return util.defaults({
      show: show
    }, opt);
  }

  var RadarModel = echarts.extendComponentModel({
    type: 'radar',
    optionUpdated: function () {
      var boundaryGap = this.get('boundaryGap');
      var splitNumber = this.get('splitNumber');
      var scale = this.get('scale');
      var axisLine = this.get('axisLine');
      var axisTick = this.get('axisTick');
      var axisType = this.get('axisType');
      var axisLabel = this.get('axisLabel');
      var nameTextStyle = this.get('name');
      var showName = this.get('name.show');
      var nameFormatter = this.get('name.formatter');
      var nameGap = this.get('nameGap');
      var triggerEvent = this.get('triggerEvent');
      var indicatorModels = util.map(this.get('indicator') || [], function (indicatorOpt) {
        // PENDING
        if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
          indicatorOpt.min = 0;
        } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
          indicatorOpt.max = 0;
        }

        var iNameTextStyle = nameTextStyle;

        if (indicatorOpt.color != null) {
          iNameTextStyle = util.defaults({
            color: indicatorOpt.color
          }, nameTextStyle);
        } // Use same configuration


        indicatorOpt = util.merge(util.clone(indicatorOpt), {
          boundaryGap: boundaryGap,
          splitNumber: splitNumber,
          scale: scale,
          axisLine: axisLine,
          axisTick: axisTick,
          axisType: axisType,
          axisLabel: axisLabel,
          // Compatible with 2 and use text
          name: indicatorOpt.text,
          nameLocation: 'end',
          nameGap: nameGap,
          // min: 0,
          nameTextStyle: iNameTextStyle,
          triggerEvent: triggerEvent
        }, false);

        if (!showName) {
          indicatorOpt.name = '';
        }

        if (typeof nameFormatter === 'string') {
          var indName = indicatorOpt.name;
          indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');
        } else if (typeof nameFormatter === 'function') {
          indicatorOpt.name = nameFormatter(indicatorOpt.name, indicatorOpt);
        }

        var model = util.extend(new Model_1(indicatorOpt, null, this.ecModel), axisModelCommonMixin); // For triggerEvent.

        model.mainType = 'radar';
        model.componentIndex = this.componentIndex;
        return model;
      }, this);

      this.getIndicatorModels = function () {
        return indicatorModels;
      };
    },
    defaultOption: {
      zlevel: 0,
      z: 0,
      center: ['50%', '50%'],
      radius: '75%',
      startAngle: 90,
      name: {
        show: true // formatter: null
        // textStyle: {}

      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      nameGap: 15,
      scale: false,
      // Polygon or circle
      shape: 'polygon',
      axisLine: util.merge({
        lineStyle: {
          color: '#bbb'
        }
      }, valueAxisDefault.axisLine),
      axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
      axisTick: defaultsShow(valueAxisDefault.axisTick, false),
      axisType: 'interval',
      splitLine: defaultsShow(valueAxisDefault.splitLine, true),
      splitArea: defaultsShow(valueAxisDefault.splitArea, true),
      // {text, min, max}
      indicator: []
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var axisBuilderAttrs$1 = ['axisLine', 'axisTickLabel', 'axisName'];

  var _default$1W = echarts.extendComponentView({
    type: 'radar',
    render: function (radarModel, ecModel, api) {
      var group = this.group;
      group.removeAll();

      this._buildAxes(radarModel);

      this._buildSplitLineAndArea(radarModel);
    },
    _buildAxes: function (radarModel) {
      var radar = radarModel.coordinateSystem;
      var indicatorAxes = radar.getIndicatorAxes();
      var axisBuilders = util.map(indicatorAxes, function (indicatorAxis) {
        var axisBuilder = new AxisBuilder_1(indicatorAxis.model, {
          position: [radar.cx, radar.cy],
          rotation: indicatorAxis.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return axisBuilder;
      });
      util.each(axisBuilders, function (axisBuilder) {
        util.each(axisBuilderAttrs$1, axisBuilder.add, axisBuilder);
        this.group.add(axisBuilder.getGroup());
      }, this);
    },
    _buildSplitLineAndArea: function (radarModel) {
      var radar = radarModel.coordinateSystem;
      var indicatorAxes = radar.getIndicatorAxes();

      if (!indicatorAxes.length) {
        return;
      }

      var shape = radarModel.get('shape');
      var splitLineModel = radarModel.getModel('splitLine');
      var splitAreaModel = radarModel.getModel('splitArea');
      var lineStyleModel = splitLineModel.getModel('lineStyle');
      var areaStyleModel = splitAreaModel.getModel('areaStyle');
      var showSplitLine = splitLineModel.get('show');
      var showSplitArea = splitAreaModel.get('show');
      var splitLineColors = lineStyleModel.get('color');
      var splitAreaColors = areaStyleModel.get('color');
      splitLineColors = util.isArray(splitLineColors) ? splitLineColors : [splitLineColors];
      splitAreaColors = util.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
      var splitLines = [];
      var splitAreas = [];

      function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
        var colorIndex = idx % areaOrLineColorList.length;
        areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];
        return colorIndex;
      }

      if (shape === 'circle') {
        var ticksRadius = indicatorAxes[0].getTicksCoords();
        var cx = radar.cx;
        var cy = radar.cy;

        for (var i = 0; i < ticksRadius.length; i++) {
          if (showSplitLine) {
            var colorIndex = getColorIndex(splitLines, splitLineColors, i);
            splitLines[colorIndex].push(new graphic.Circle({
              shape: {
                cx: cx,
                cy: cy,
                r: ticksRadius[i].coord
              }
            }));
          }

          if (showSplitArea && i < ticksRadius.length - 1) {
            var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);
            splitAreas[colorIndex].push(new graphic.Ring({
              shape: {
                cx: cx,
                cy: cy,
                r0: ticksRadius[i].coord,
                r: ticksRadius[i + 1].coord
              }
            }));
          }
        }
      } // Polyyon
      else {
          var realSplitNumber;
          var axesTicksPoints = util.map(indicatorAxes, function (indicatorAxis, idx) {
            var ticksCoords = indicatorAxis.getTicksCoords();
            realSplitNumber = realSplitNumber == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber);
            return util.map(ticksCoords, function (tickCoord) {
              return radar.coordToPoint(tickCoord.coord, idx);
            });
          });
          var prevPoints = [];

          for (var i = 0; i <= realSplitNumber; i++) {
            var points = [];

            for (var j = 0; j < indicatorAxes.length; j++) {
              points.push(axesTicksPoints[j][i]);
            } // Close


            if (points[0]) {
              points.push(points[0].slice());
            }

            if (showSplitLine) {
              var colorIndex = getColorIndex(splitLines, splitLineColors, i);
              splitLines[colorIndex].push(new graphic.Polyline({
                shape: {
                  points: points
                }
              }));
            }

            if (showSplitArea && prevPoints) {
              var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);
              splitAreas[colorIndex].push(new graphic.Polygon({
                shape: {
                  points: points.concat(prevPoints)
                }
              }));
            }

            prevPoints = points.slice().reverse();
          }
        }

      var lineStyle = lineStyleModel.getLineStyle();
      var areaStyle = areaStyleModel.getAreaStyle(); // Add splitArea before splitLine

      util.each(splitAreas, function (splitAreas, idx) {
        this.group.add(graphic.mergePath(splitAreas, {
          style: util.defaults({
            stroke: 'none',
            fill: splitAreaColors[idx % splitAreaColors.length]
          }, areaStyle),
          silent: true
        }));
      }, this);
      util.each(splitLines, function (splitLines, idx) {
        this.group.add(graphic.mergePath(splitLines, {
          style: util.defaults({
            fill: 'none',
            stroke: splitLineColors[idx % splitLineColors.length]
          }, lineStyle),
          silent: true
        }));
      }, this);
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  var extend$a = util.extend;
  var isArray$9 = util.isArray;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * [Usage]:
   * (1)
   * createListSimply(seriesModel, ['value']);
   * (2)
   * createListSimply(seriesModel, {
   *     coordDimensions: ['value'],
   *     dimensionsCount: 5
   * });
   *
   * @param {module:echarts/model/Series} seriesModel
   * @param {Object|Array.<string|Object>} opt opt or coordDimensions
   *        The options in opt, see `echarts/data/helper/createDimensions`
   * @param {Array.<string>} [nameList]
   * @return {module:echarts/data/List}
   */
  function _default$1X(seriesModel, opt, nameList) {
    opt = isArray$9(opt) && {
      coordDimensions: opt
    } || extend$a({}, opt);
    var source = seriesModel.getSource();
    var dimensionsInfo = createDimensions(source, opt);
    var list = new List_1(dimensionsInfo, seriesModel);
    list.initData(source, nameList);
    return list;
  }

  var createListSimply = _default$1X;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * LegendVisualProvider is an bridge that pick encoded color from data and
   * provide to the legend component.
   * @param {Function} getDataWithEncodedVisual Function to get data after filtered. It stores all the encoding info
   * @param {Function} getRawData Function to get raw data before filtered.
   */
  function LegendVisualProvider(getDataWithEncodedVisual, getRawData) {
    this.getAllNames = function () {
      var rawData = getRawData(); // We find the name from the raw data. In case it's filtered by the legend component.
      // Normally, the name can be found in rawData, but can't be found in filtered data will display as gray.

      return rawData.mapArray(rawData.getName);
    };

    this.containName = function (name) {
      var rawData = getRawData();
      return rawData.indexOfName(name) >= 0;
    };

    this.indexOfName = function (name) {
      // Only get data when necessary.
      // Because LegendVisualProvider constructor may be new in the stage that data is not prepared yet.
      // Invoking Series#getData immediately will throw an error.
      var dataWithEncodedVisual = getDataWithEncodedVisual();
      return dataWithEncodedVisual.indexOfName(name);
    };

    this.getItemVisual = function (dataIndex, key) {
      // Get encoded visual properties from final filtered data.
      var dataWithEncodedVisual = getDataWithEncodedVisual();
      return dataWithEncodedVisual.getItemVisual(dataIndex, key);
    };
  }

  var _default$1Y = LegendVisualProvider;
  var LegendVisualProvider_1 = _default$1Y;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  var encodeHTML$2 = format$1.encodeHTML;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var RadarSeries = Series.extend({
    type: 'series.radar',
    dependencies: ['radar'],
    // Overwrite
    init: function (option) {
      RadarSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item
      // Use a function instead of direct access because data reference may changed

      this.legendVisualProvider = new LegendVisualProvider_1(util.bind(this.getData, this), util.bind(this.getRawData, this));
    },
    getInitialData: function (option, ecModel) {
      return createListSimply(this, {
        generateCoord: 'indicator_',
        generateCoordCount: Infinity
      });
    },
    formatTooltip: function (dataIndex, multipleSeries, dataType, renderMode) {
      var data = this.getData();
      var coordSys = this.coordinateSystem;
      var indicatorAxes = coordSys.getIndicatorAxes();
      var name = this.getData().getName(dataIndex);
      var newLine = renderMode === 'html' ? '<br/>' : '\n';
      return encodeHTML$2(name === '' ? this.name : name) + newLine + util.map(indicatorAxes, function (axis, idx) {
        var val = data.get(data.mapDimension(axis.dim), dataIndex);
        return encodeHTML$2(axis.name + ' : ' + val);
      }).join(newLine);
    },

    /**
     * @implement
     */
    getTooltipPosition: function (dataIndex) {
      if (dataIndex != null) {
        var data = this.getData();
        var coordSys = this.coordinateSystem;
        var values = data.getValues(util.map(coordSys.dimensions, function (dim) {
          return data.mapDimension(dim);
        }), dataIndex, true);

        for (var i = 0, len = values.length; i < len; i++) {
          if (!isNaN(values[i])) {
            var indicatorAxes = coordSys.getIndicatorAxes();
            return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
          }
        }
      }
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'radar',
      legendHoverLink: true,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: 'solid'
      },
      label: {
        position: 'top'
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbol: 'emptyCircle',
      symbolSize: 4 // symbolRotate: null

    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function normalizeSymbolSize(symbolSize) {
    if (!util.isArray(symbolSize)) {
      symbolSize = [+symbolSize, +symbolSize];
    }

    return symbolSize;
  }

  var _default$1Z = echarts.extendChartView({
    type: 'radar',
    render: function (seriesModel, ecModel, api) {
      var polar = seriesModel.coordinateSystem;
      var group = this.group;
      var data = seriesModel.getData();
      var oldData = this._data;

      function createSymbol(data, idx) {
        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
        var color = data.getItemVisual(idx, 'color');

        if (symbolType === 'none') {
          return;
        }

        var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
        var symbolPath = symbol.createSymbol(symbolType, -1, -1, 2, 2, color);
        var symbolRotate = data.getItemVisual(idx, 'symbolRotate') || 0;
        symbolPath.attr({
          style: {
            strokeNoScale: true
          },
          z2: 100,
          scale: [symbolSize[0] / 2, symbolSize[1] / 2],
          rotation: symbolRotate * Math.PI / 180 || 0
        });
        return symbolPath;
      }

      function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {
        // Simply rerender all
        symbolGroup.removeAll();

        for (var i = 0; i < newPoints.length - 1; i++) {
          var symbolPath = createSymbol(data, idx);

          if (symbolPath) {
            symbolPath.__dimIdx = i;

            if (oldPoints[i]) {
              symbolPath.attr('position', oldPoints[i]);
              graphic[isInit ? 'initProps' : 'updateProps'](symbolPath, {
                position: newPoints[i]
              }, seriesModel, idx);
            } else {
              symbolPath.attr('position', newPoints[i]);
            }

            symbolGroup.add(symbolPath);
          }
        }
      }

      function getInitialPoints(points) {
        return util.map(points, function (pt) {
          return [polar.cx, polar.cy];
        });
      }

      data.diff(oldData).add(function (idx) {
        var points = data.getItemLayout(idx);

        if (!points) {
          return;
        }

        var polygon = new graphic.Polygon();
        var polyline = new graphic.Polyline();
        var target = {
          shape: {
            points: points
          }
        };
        polygon.shape.points = getInitialPoints(points);
        polyline.shape.points = getInitialPoints(points);
        graphic.initProps(polygon, target, seriesModel, idx);
        graphic.initProps(polyline, target, seriesModel, idx);
        var itemGroup = new graphic.Group();
        var symbolGroup = new graphic.Group();
        itemGroup.add(polyline);
        itemGroup.add(polygon);
        itemGroup.add(symbolGroup);
        updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);
        data.setItemGraphicEl(idx, itemGroup);
      }).update(function (newIdx, oldIdx) {
        var itemGroup = oldData.getItemGraphicEl(oldIdx);
        var polyline = itemGroup.childAt(0);
        var polygon = itemGroup.childAt(1);
        var symbolGroup = itemGroup.childAt(2);
        var target = {
          shape: {
            points: data.getItemLayout(newIdx)
          }
        };

        if (!target.shape.points) {
          return;
        }

        updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
        graphic.updateProps(polyline, target, seriesModel);
        graphic.updateProps(polygon, target, seriesModel);
        data.setItemGraphicEl(newIdx, itemGroup);
      }).remove(function (idx) {
        group.remove(oldData.getItemGraphicEl(idx));
      }).execute();
      data.eachItemGraphicEl(function (itemGroup, idx) {
        var itemModel = data.getItemModel(idx);
        var polyline = itemGroup.childAt(0);
        var polygon = itemGroup.childAt(1);
        var symbolGroup = itemGroup.childAt(2);
        var color = data.getItemVisual(idx, 'color');
        group.add(itemGroup);
        polyline.useStyle(util.defaults(itemModel.getModel('lineStyle').getLineStyle(), {
          fill: 'none',
          stroke: color
        }));
        polyline.hoverStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();
        var areaStyleModel = itemModel.getModel('areaStyle');
        var hoverAreaStyleModel = itemModel.getModel('emphasis.areaStyle');
        var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
        var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();
        hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;
        polygon.ignore = polygonIgnore;
        polygon.useStyle(util.defaults(areaStyleModel.getAreaStyle(), {
          fill: color,
          opacity: 0.7
        }));
        polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();
        var itemStyle = itemModel.getModel('itemStyle').getItemStyle(['color']);
        var itemHoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();
        var labelModel = itemModel.getModel('label');
        var labelHoverModel = itemModel.getModel('emphasis.label');
        symbolGroup.eachChild(function (symbolPath) {
          symbolPath.setStyle(itemStyle);
          symbolPath.hoverStyle = util.clone(itemHoverStyle);
          var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);
          (defaultText == null || isNaN(defaultText)) && (defaultText = '');
          graphic.setLabelStyle(symbolPath.style, symbolPath.hoverStyle, labelModel, labelHoverModel, {
            labelFetcher: data.hostModel,
            labelDataIndex: idx,
            labelDimIndex: symbolPath.__dimIdx,
            defaultText: defaultText,
            autoColor: color,
            isRectText: true
          });
        });

        itemGroup.highDownOnUpdate = function (fromState, toState) {
          polygon.attr('ignore', toState === 'emphasis' ? hoverPolygonIgnore : polygonIgnore);
        };

        graphic.setHoverStyle(itemGroup);
      });
      this._data = data;
    },
    remove: function () {
      this.group.removeAll();
      this._data = null;
    },
    dispose: function () {}
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var createHashMap$b = util.createHashMap;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Pick color from palette for each data item.
  // Applicable for charts that require applying color palette
  // in data level (like pie, funnel, chord).
  function _default$1_(seriesType) {
    return {
      getTargetSeries: function (ecModel) {
        // Pie and funnel may use diferrent scope
        var paletteScope = {};
        var seiresModelMap = createHashMap$b();
        ecModel.eachSeriesByType(seriesType, function (seriesModel) {
          seriesModel.__paletteScope = paletteScope;
          seiresModelMap.set(seriesModel.uid, seriesModel);
        });
        return seiresModelMap;
      },
      reset: function (seriesModel, ecModel) {
        var dataAll = seriesModel.getRawData();
        var idxMap = {};
        var data = seriesModel.getData();
        data.each(function (idx) {
          var rawIdx = data.getRawIndex(idx);
          idxMap[rawIdx] = idx;
        });
        dataAll.each(function (rawIdx) {
          var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded

          var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);
          var singleDataBorderColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'borderColor', true);
          var itemModel;

          if (!singleDataColor || !singleDataBorderColor) {
            // FIXME Performance
            itemModel = dataAll.getItemModel(rawIdx);
          }

          if (!singleDataColor) {
            var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Data is not filtered

            if (filteredIdx != null) {
              data.setItemVisual(filteredIdx, 'color', color);
            }
          }

          if (!singleDataBorderColor) {
            var borderColor = itemModel.get('itemStyle.borderColor'); // Data is not filtered

            if (filteredIdx != null) {
              data.setItemVisual(filteredIdx, 'borderColor', borderColor);
            }
          }
        });
      }
    };
  }

  var dataColor = _default$1_;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function _default$1$(ecModel) {
    ecModel.eachSeriesByType('radar', function (seriesModel) {
      var data = seriesModel.getData();
      var points = [];
      var coordSys = seriesModel.coordinateSystem;

      if (!coordSys) {
        return;
      }

      var axes = coordSys.getIndicatorAxes();
      util.each(axes, function (axis, axisIndex) {
        data.each(data.mapDimension(axes[axisIndex].dim), function (val, dataIndex) {
          points[dataIndex] = points[dataIndex] || [];
          var point = coordSys.dataToPoint(val, axisIndex);
          points[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
        });
      }); // Close polygon

      data.each(function (idx) {
        // TODO
        // Is it appropriate to connect to the next data when some data is missing?
        // Or, should trade it like `connectNull` in line chart?
        var firstPoint = util.find(points[idx], function (point) {
          return isValidPoint(point);
        }) || getValueMissingPoint(coordSys); // Copy the first actual point to the end of the array

        points[idx].push(firstPoint.slice());
        data.setItemLayout(idx, points[idx]);
      });
    });
  }

  function isValidPoint(point) {
    return !isNaN(point[0]) && !isNaN(point[1]);
  }

  function getValueMissingPoint(coordSys) {
    // It is error-prone to input [NaN, NaN] into polygon, polygon.
    // (probably cause problem when refreshing or animating)
    return [coordSys.cx, coordSys.cy];
  }

  var radarLayout = _default$1$;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function _default$20(seriesType) {
    return {
      seriesType: seriesType,
      reset: function (seriesModel, ecModel) {
        var legendModels = ecModel.findComponents({
          mainType: 'legend'
        });

        if (!legendModels || !legendModels.length) {
          return;
        }

        var data = seriesModel.getData();
        data.filterSelf(function (idx) {
          var name = data.getName(idx); // If in any legend component the status is not selected.

          for (var i = 0; i < legendModels.length; i++) {
            if (!legendModels[i].isSelected(name)) {
              return false;
            }
          }

          return true;
        });
      }
    };
  }

  var dataFilter = _default$20;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Backward compat for radar chart in 2
  function _default$21(option) {
    var polarOptArr = option.polar;

    if (polarOptArr) {
      if (!util.isArray(polarOptArr)) {
        polarOptArr = [polarOptArr];
      }

      var polarNotRadar = [];
      util.each(polarOptArr, function (polarOpt, idx) {
        if (polarOpt.indicator) {
          if (polarOpt.type && !polarOpt.shape) {
            polarOpt.shape = polarOpt.type;
          }

          option.radar = option.radar || [];

          if (!util.isArray(option.radar)) {
            option.radar = [option.radar];
          }

          option.radar.push(polarOpt);
        } else {
          polarNotRadar.push(polarOpt);
        }
      });
      option.polar = polarNotRadar;
    }

    util.each(option.series, function (seriesOpt) {
      if (seriesOpt && seriesOpt.type === 'radar' && seriesOpt.polarIndex) {
        seriesOpt.radarIndex = seriesOpt.polarIndex;
      }
    });
  }

  var backwardCompat$1 = _default$21;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



















  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // Must use radar component
  echarts.registerVisual(dataColor('radar'));
  echarts.registerVisual(symbol$1('radar', 'circle'));
  echarts.registerLayout(radarLayout);
  echarts.registerProcessor(dataFilter('radar'));
  echarts.registerPreprocessor(backwardCompat$1);

  function _interopDefault$3 (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }




  var Core$1 = _interopDefault$3(core_1);

  function getRadarLegend(rows, dimension, legendName) {
    var legendData = rows.map(function (row) {
      return row[dimension];
    });

    return {
      data: legendData,
      formatter: function formatter(name) {
        return legendName[name] != null ? legendName[name] : name;
      }
    };
  }

  function getRadarTooltip(dataType, radar$$1, digit) {
    var typeTemp = [];
    var nameTemp = [];
    radar$$1.indicator.map(function (item, index) {
      typeTemp[index] = dataType[item.name];
      nameTemp[index] = item.name;
    });
    return {
      formatter: function formatter(item) {
        var tpl = [];
        tpl.push(constants.itemPoint(item.color));
        tpl.push(item.name + '<br />');
        item.data.value.forEach(function (val, index) {
          tpl.push(nameTemp[index] + ': ');
          tpl.push(utils.getFormated(val, typeTemp[index], digit) + '<br />');
        });
        return tpl.join('');
      }
    };
  }

  function getRadarSetting(rows, metrics, labelMap) {
    var settingBase = {
      indicator: [],
      shape: 'circle',
      splitNumber: 5
    };
    var indicatorTemp = {};
    rows.forEach(function (items) {
      metrics.forEach(function (item) {
        var key = labelMap[item] != null ? labelMap[item] : item;
        if (!indicatorTemp[key]) {
          indicatorTemp[key] = [items[item]];
        } else {
          indicatorTemp[key].push(items[item]);
        }
      });
    });
    settingBase.indicator = Object.keys(indicatorTemp).map(function (key) {
      return {
        name: key,
        max: Math.max.apply(null, indicatorTemp[key])
      };
    });
    return settingBase;
  }

  function getRadarSeries(args) {
    var rows = args.rows,
        dimension = args.dimension,
        metrics = args.metrics,
        radar$$1 = args.radar,
        label = args.label,
        itemStyle = args.itemStyle,
        lineStyle = args.lineStyle,
        labelMap = args.labelMap,
        areaStyle = args.areaStyle;

    var radarIndexObj = {};
    radar$$1.indicator.forEach(function (item, index) {
      var name = item.name;
      radarIndexObj[name] = index;
    });

    var seriesData = rows.map(function (row) {
      var serieData = {
        value: [],
        name: row[dimension]
      };
      Object.keys(row).forEach(function (key) {
        if (~metrics.indexOf(key)) {
          var k = labelMap[key] != null ? radarIndexObj[labelMap[key]] : radarIndexObj[key];
          serieData.value[k] = row[key];
        }
      });
      return serieData;
    });
    var result = {
      name: dimension,
      type: 'radar',
      data: seriesData
    };
    if (label) result.label = label;
    if (itemStyle) result.itemStyle = itemStyle;
    if (lineStyle) result.lineStyle = lineStyle;
    if (areaStyle) result.areaStyle = areaStyle;
    return [result];
  }

  var radar$1 = function radar$$1(columns, rows, settings, extra) {
    var _settings$dataType = settings.dataType,
        dataType = _settings$dataType === undefined ? {} : _settings$dataType,
        _settings$legendName = settings.legendName,
        legendName = _settings$legendName === undefined ? {} : _settings$legendName,
        _settings$labelMap = settings.labelMap,
        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,
        _settings$dimension = settings.dimension,
        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,
        _settings$digit = settings.digit,
        digit = _settings$digit === undefined ? 2 : _settings$digit,
        label = settings.label,
        itemStyle = settings.itemStyle,
        lineStyle = settings.lineStyle,
        areaStyle = settings.areaStyle;
    var tooltipVisible = extra.tooltipVisible,
        legendVisible = extra.legendVisible;

    var metrics = columns.slice();
    if (settings.metrics) {
      metrics = settings.metrics;
    } else {
      metrics.splice(columns.indexOf(dimension), 1);
    }
    var legend = legendVisible && getRadarLegend(rows, dimension, legendName);
    var radar$$1 = getRadarSetting(rows, metrics, labelMap);
    var tooltip = tooltipVisible && getRadarTooltip(dataType, radar$$1, digit);
    var series = getRadarSeries({
      rows: rows,
      dimension: dimension,
      metrics: metrics,
      radar: radar$$1,
      label: label,
      itemStyle: itemStyle,
      lineStyle: lineStyle,
      labelMap: labelMap,
      areaStyle: areaStyle
    });
    var options = { legend: legend, tooltip: tooltip, radar: radar$$1, series: series };
    return options;
  };

  var _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var index$1 = _extends$2({}, Core$1, {
    name: 'VeRadar',
    data: function data() {
      this.chartHandler = radar$1;
      return {};
    }
  });

  var radar_common = index$1;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Data selectable mixin for chart series.
   * To eanble data select, option of series must have `selectedMode`.
   * And each data item will use `selected` to toggle itself selected status
   */
  var _default$22 = {
    /**
     * @param {Array.<Object>} targetList [{name, value, selected}, ...]
     *        If targetList is an array, it should like [{name: ..., value: ...}, ...].
     *        If targetList is a "List", it must have coordDim: 'value' dimension and name.
     */
    updateSelectedMap: function (targetList) {
      this._targetList = util.isArray(targetList) ? targetList.slice() : [];
      this._selectTargetMap = util.reduce(targetList || [], function (targetMap, target) {
        targetMap.set(target.name, target);
        return targetMap;
      }, util.createHashMap());
    },

    /**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */
    // PENGING If selectedMode is null ?
    select: function (name, id) {
      var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);
      var selectedMode = this.get('selectedMode');

      if (selectedMode === 'single') {
        this._selectTargetMap.each(function (target) {
          target.selected = false;
        });
      }

      target && (target.selected = true);
    },

    /**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */
    unSelect: function (name, id) {
      var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');
      // selectedMode !== 'single' && target && (target.selected = false);

      target && (target.selected = false);
    },

    /**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */
    toggleSelected: function (name, id) {
      var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);

      if (target != null) {
        this[target.selected ? 'unSelect' : 'select'](name, id);
        return target.selected;
      }
    },

    /**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */
    isSelected: function (name, id) {
      var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);
      return target && target.selected;
    }
  };
  var selectableMixin = _default$22;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */











  var getPercentWithPrecision$1 = number.getPercentWithPrecision;





  var retrieveRawAttr$1 = dataProvider.retrieveRawAttr;



  var makeSeriesEncodeForNameBased$1 = sourceHelper.makeSeriesEncodeForNameBased;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var PieSeries = echarts.extendSeriesModel({
    type: 'series.pie',
    // Overwrite
    init: function (option) {
      PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item
      // Use a function instead of direct access because data reference may changed

      this.legendVisualProvider = new LegendVisualProvider_1(util.bind(this.getData, this), util.bind(this.getRawData, this));
      this.updateSelectedMap(this._createSelectableList());

      this._defaultLabelLine(option);
    },
    // Overwrite
    mergeOption: function (newOption) {
      PieSeries.superCall(this, 'mergeOption', newOption);
      this.updateSelectedMap(this._createSelectableList());
    },
    getInitialData: function (option, ecModel) {
      return createListSimply(this, {
        coordDimensions: ['value'],
        encodeDefaulter: util.curry(makeSeriesEncodeForNameBased$1, this)
      });
    },
    _createSelectableList: function () {
      var data = this.getRawData();
      var valueDim = data.mapDimension('value');
      var targetList = [];

      for (var i = 0, len = data.count(); i < len; i++) {
        targetList.push({
          name: data.getName(i),
          value: data.get(valueDim, i),
          selected: retrieveRawAttr$1(data, i, 'selected')
        });
      }

      return targetList;
    },
    // Overwrite
    getDataParams: function (dataIndex) {
      var data = this.getData();
      var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?

      var valueList = [];
      data.each(data.mapDimension('value'), function (value) {
        valueList.push(value);
      });
      params.percent = getPercentWithPrecision$1(valueList, dataIndex, data.hostModel.get('percentPrecision'));
      params.$vars.push('percent');
      return params;
    },
    _defaultLabelLine: function (option) {
      // Extend labelLine emphasis
      model.defaultEmphasis(option, 'labelLine', ['show']);
      var labelLineNormalOpt = option.labelLine;
      var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`

      labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
      labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      hoverAnimation: true,
      // é»è®¤å¨å±å±ä¸­
      center: ['50%', '50%'],
      radius: [0, '75%'],
      // é»è®¤é¡ºæ¶é
      clockwise: true,
      startAngle: 90,
      // æå°è§åº¦æ¹ä¸º0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // éä¸­æ¶æåºåç§»é
      selectedOffset: 10,
      // é«äº®æåºåç§»é
      hoverOffset: 10,
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: true,
      // éæ©æ¨¡å¼ï¼é»è®¤å³é­ï¼å¯ésingleï¼multiple
      // selectedMode: false,
      // åä¸æ ¼å°ç«ç°å¾æ¨¡å¼ï¼'radius'ï¼åå¾ï¼ | 'area'ï¼é¢ç§¯ï¼
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: true,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // If rotate around circle
        rotate: false,
        show: true,
        // 'outer', 'inside', 'center'
        position: 'outer',
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: 'none',
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        margin: '25%',
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5 // formatter: æ ç­¾ææ¬æ ¼å¼å¨ï¼åTooltip.formatterï¼ä¸æ¯æå¼æ­¥åè°
        // é»è®¤ä½¿ç¨å¨å±ææ¬æ ·å¼ï¼è¯¦è§TEXTSTYLE
        // distance: å½positionä¸ºinneræ¶ææï¼ä¸ºlabelä½ç½®å°åå¿çè·ç¦»ä¸ååå¾(ç¯ç¶å¾ä¸ºåå¤åå¾å)çæ¯ä¾ç³»æ°

      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: true,
        // å¼å¯¼çº¿ä¸¤æ®µä¸­çç¬¬ä¸æ®µé¿åº¦
        length: 15,
        // å¼å¯¼çº¿ä¸¤æ®µä¸­çç¬¬äºæ®µé¿åº¦
        length2: 15,
        smooth: false,
        lineStyle: {
          // color: åå¼,
          width: 1,
          type: 'solid'
        }
      },
      itemStyle: {
        borderWidth: 1
      },
      // Animation type. Valid values: expansion, scale
      animationType: 'expansion',
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: 'transition',
      animationEasing: 'cubicOut'
    }
  });
  util.mixin(PieSeries, selectableMixin);

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @param {module:echarts/model/Series} seriesModel
   * @param {boolean} hasAnimation
   * @inner
   */
  function updateDataSelected(uid, seriesModel, hasAnimation, api) {
    var data = seriesModel.getData();
    var dataIndex = this.dataIndex;
    var name = data.getName(dataIndex);
    var selectedOffset = seriesModel.get('selectedOffset');
    api.dispatchAction({
      type: 'pieToggleSelect',
      from: uid,
      name: name,
      seriesId: seriesModel.id
    });
    data.each(function (idx) {
      toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);
    });
  }
  /**
   * @param {module:zrender/graphic/Sector} el
   * @param {Object} layout
   * @param {boolean} isSelected
   * @param {number} selectedOffset
   * @param {boolean} hasAnimation
   * @inner
   */


  function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {
    var midAngle = (layout.startAngle + layout.endAngle) / 2;
    var dx = Math.cos(midAngle);
    var dy = Math.sin(midAngle);
    var offset = isSelected ? selectedOffset : 0;
    var position = [dx * offset, dy * offset];
    hasAnimation // animateTo will stop revious animation like update transition
    ? el.animate().when(200, {
      position: position
    }).start('bounceOut') : el.attr('position', position);
  }
  /**
   * Piece of pie including Sector, Label, LabelLine
   * @constructor
   * @extends {module:zrender/graphic/Group}
   */


  function PiePiece(data, idx) {
    graphic.Group.call(this);
    var sector = new graphic.Sector({
      z2: 2
    });
    var polyline = new graphic.Polyline();
    var text = new graphic.Text();
    this.add(sector);
    this.add(polyline);
    this.add(text);
    this.updateData(data, idx, true);
  }

  var piePieceProto = PiePiece.prototype;

  piePieceProto.updateData = function (data, idx, firstCreate) {
    var sector = this.childAt(0);
    var labelLine = this.childAt(1);
    var labelText = this.childAt(2);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout = data.getItemLayout(idx);
    var sectorShape = util.extend({}, layout);
    sectorShape.label = null;
    var animationTypeUpdate = seriesModel.getShallow('animationTypeUpdate');

    if (firstCreate) {
      sector.setShape(sectorShape);
      var animationType = seriesModel.getShallow('animationType');

      if (animationType === 'scale') {
        sector.shape.r = layout.r0;
        graphic.initProps(sector, {
          shape: {
            r: layout.r
          }
        }, seriesModel, idx);
      } // Expansion
      else {
          sector.shape.endAngle = layout.startAngle;
          graphic.updateProps(sector, {
            shape: {
              endAngle: layout.endAngle
            }
          }, seriesModel, idx);
        }
    } else {
      if (animationTypeUpdate === 'expansion') {
        // Sectors are set to be target shape and an overlaying clipPath is used for animation
        sector.setShape(sectorShape);
      } else {
        // Transition animation from the old shape
        graphic.updateProps(sector, {
          shape: sectorShape
        }, seriesModel, idx);
      }
    } // Update common style


    var visualColor = data.getItemVisual(idx, 'color');
    sector.useStyle(util.defaults({
      lineJoin: 'bevel',
      fill: visualColor
    }, itemModel.getModel('itemStyle').getItemStyle()));
    sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();
    var cursorStyle = itemModel.getShallow('cursor');
    cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected

    toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), seriesModel.get('selectedOffset'), seriesModel.get('animation')); // Label and text animation should be applied only for transition type animation when update

    var withAnimation = !firstCreate && animationTypeUpdate === 'transition';

    this._updateLabel(data, idx, withAnimation);

    this.highDownOnUpdate = !seriesModel.get('silent') ? function (fromState, toState) {
      var hasAnimation = seriesModel.isAnimationEnabled() && itemModel.get('hoverAnimation');

      if (toState === 'emphasis') {
        labelLine.ignore = labelLine.hoverIgnore;
        labelText.ignore = labelText.hoverIgnore; // Sector may has animation of updating data. Force to move to the last frame
        // Or it may stopped on the wrong shape

        if (hasAnimation) {
          sector.stopAnimation(true);
          sector.animateTo({
            shape: {
              r: layout.r + seriesModel.get('hoverOffset')
            }
          }, 300, 'elasticOut');
        }
      } else {
        labelLine.ignore = labelLine.normalIgnore;
        labelText.ignore = labelText.normalIgnore;

        if (hasAnimation) {
          sector.stopAnimation(true);
          sector.animateTo({
            shape: {
              r: layout.r
            }
          }, 300, 'elasticOut');
        }
      }
    } : null;
    graphic.setHoverStyle(this);
  };

  piePieceProto._updateLabel = function (data, idx, withAnimation) {
    var labelLine = this.childAt(1);
    var labelText = this.childAt(2);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout = data.getItemLayout(idx);
    var labelLayout = layout.label;
    var visualColor = data.getItemVisual(idx, 'color');

    if (!labelLayout || isNaN(labelLayout.x) || isNaN(labelLayout.y)) {
      labelText.ignore = labelText.normalIgnore = labelText.hoverIgnore = labelLine.ignore = labelLine.normalIgnore = labelLine.hoverIgnore = true;
      return;
    }

    var targetLineShape = {
      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]
    };
    var targetTextStyle = {
      x: labelLayout.x,
      y: labelLayout.y
    };

    if (withAnimation) {
      graphic.updateProps(labelLine, {
        shape: targetLineShape
      }, seriesModel, idx);
      graphic.updateProps(labelText, {
        style: targetTextStyle
      }, seriesModel, idx);
    } else {
      labelLine.attr({
        shape: targetLineShape
      });
      labelText.attr({
        style: targetTextStyle
      });
    }

    labelText.attr({
      rotation: labelLayout.rotation,
      origin: [labelLayout.x, labelLayout.y],
      z2: 10
    });
    var labelModel = itemModel.getModel('label');
    var labelHoverModel = itemModel.getModel('emphasis.label');
    var labelLineModel = itemModel.getModel('labelLine');
    var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');
    var visualColor = data.getItemVisual(idx, 'color');
    graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      defaultText: labelLayout.text,
      autoColor: visualColor,
      useInsideStyle: !!labelLayout.inside
    }, {
      textAlign: labelLayout.textAlign,
      textVerticalAlign: labelLayout.verticalAlign,
      opacity: data.getItemVisual(idx, 'opacity')
    });
    labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
    labelText.hoverIgnore = !labelHoverModel.get('show');
    labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
    labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color

    labelLine.setStyle({
      stroke: visualColor,
      opacity: data.getItemVisual(idx, 'opacity')
    });
    labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());
    labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();
    var smooth = labelLineModel.get('smooth');

    if (smooth && smooth === true) {
      smooth = 0.4;
    }

    labelLine.setShape({
      smooth: smooth
    });
  };

  util.inherits(PiePiece, graphic.Group); // Pie view

  var PieView = Chart_1.extend({
    type: 'pie',
    init: function () {
      var sectorGroup = new graphic.Group();
      this._sectorGroup = sectorGroup;
    },
    render: function (seriesModel, ecModel, api, payload) {
      if (payload && payload.from === this.uid) {
        return;
      }

      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      var hasAnimation = ecModel.get('animation');
      var isFirstRender = !oldData;
      var animationType = seriesModel.get('animationType');
      var animationTypeUpdate = seriesModel.get('animationTypeUpdate');
      var onSectorClick = util.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);
      var selectedMode = seriesModel.get('selectedMode');
      data.diff(oldData).add(function (idx) {
        var piePiece = new PiePiece(data, idx); // Default expansion animation

        if (isFirstRender && animationType !== 'scale') {
          piePiece.eachChild(function (child) {
            child.stopAnimation(true);
          });
        }

        selectedMode && piePiece.on('click', onSectorClick);
        data.setItemGraphicEl(idx, piePiece);
        group.add(piePiece);
      }).update(function (newIdx, oldIdx) {
        var piePiece = oldData.getItemGraphicEl(oldIdx);

        if (!isFirstRender && animationTypeUpdate !== 'transition') {
          piePiece.eachChild(function (child) {
            child.stopAnimation(true);
          });
        }

        piePiece.updateData(data, newIdx);
        piePiece.off('click');
        selectedMode && piePiece.on('click', onSectorClick);
        group.add(piePiece);
        data.setItemGraphicEl(newIdx, piePiece);
      }).remove(function (idx) {
        var piePiece = oldData.getItemGraphicEl(idx);
        group.remove(piePiece);
      }).execute();

      if (hasAnimation && data.count() > 0 && (isFirstRender ? animationType !== 'scale' : animationTypeUpdate !== 'transition')) {
        var shape = data.getItemLayout(0);

        for (var s = 1; isNaN(shape.startAngle) && s < data.count(); ++s) {
          shape = data.getItemLayout(s);
        }

        var r = Math.max(api.getWidth(), api.getHeight()) / 2;
        var removeClipPath = util.bind(group.removeClipPath, group);
        group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel, isFirstRender));
      } else {
        // clipPath is used in first-time animation, so remove it when otherwise. See: #8994
        group.removeClipPath();
      }

      this._data = data;
    },
    dispose: function () {},
    _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel, isFirstRender) {
      var clipPath = new graphic.Sector({
        shape: {
          cx: cx,
          cy: cy,
          r0: 0,
          r: r,
          startAngle: startAngle,
          endAngle: startAngle,
          clockwise: clockwise
        }
      });
      var initOrUpdate = isFirstRender ? graphic.initProps : graphic.updateProps;
      initOrUpdate(clipPath, {
        shape: {
          endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2
        }
      }, seriesModel, cb);
      return clipPath;
    },

    /**
     * @implement
     */
    containPoint: function (point, seriesModel) {
      var data = seriesModel.getData();
      var itemLayout = data.getItemLayout(0);

      if (itemLayout) {
        var dx = point[0] - itemLayout.cx;
        var dy = point[1] - itemLayout.cy;
        var radius = Math.sqrt(dx * dx + dy * dy);
        return radius <= itemLayout.r && radius >= itemLayout.r0;
      }
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function _default$23(seriesType, actionInfos) {
    util.each(actionInfos, function (actionInfo) {
      actionInfo.update = 'updateView';
      /**
       * @payload
       * @property {string} seriesName
       * @property {string} name
       */

      echarts.registerAction(actionInfo, function (payload, ecModel) {
        var selected = {};
        ecModel.eachComponent({
          mainType: 'series',
          subType: seriesType,
          query: payload
        }, function (seriesModel) {
          if (seriesModel[actionInfo.method]) {
            seriesModel[actionInfo.method](payload.name, payload.dataIndex);
          }

          var data = seriesModel.getData(); // Create selected map

          data.each(function (idx) {
            var name = data.getName(idx);
            selected[name] = seriesModel.isSelected(name) || false;
          });
        });
        return {
          name: payload.name,
          selected: selected,
          seriesId: payload.seriesId
        };
      });
    });
  }

  var createDataSelectAction = _default$23;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  var parsePercent$6 = number.parsePercent;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // FIXME emphasis label position is not same with normal label position
  var RADIAN = Math.PI / 180;

  function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
    list.sort(function (a, b) {
      return a.y - b.y;
    });

    function shiftDown(start, end, delta, dir) {
      for (var j = start; j < end; j++) {
        if (list[j].y + delta > viewTop + viewHeight) {
          break;
        }

        list[j].y += delta;

        if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {
          shiftUp(j, delta / 2);
          return;
        }
      }

      shiftUp(end - 1, delta / 2);
    }

    function shiftUp(end, delta) {
      for (var j = end; j >= 0; j--) {
        if (list[j].y - delta < viewTop) {
          break;
        }

        list[j].y -= delta;

        if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {
          break;
        }
      }
    }

    function changeX(list, isDownList, cx, cy, r, dir) {
      var lastDeltaX = dir > 0 ? isDownList // right-side
      ? Number.MAX_VALUE // down
      : 0 // up
      : isDownList // left-side
      ? Number.MAX_VALUE // down
      : 0; // up

      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i].labelAlignTo !== 'none') {
          continue;
        }

        var deltaY = Math.abs(list[i].y - cy);
        var length = list[i].len;
        var length2 = list[i].len2;
        var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);

        if (isDownList && deltaX >= lastDeltaX) {
          // right-down, left-down
          deltaX = lastDeltaX - 10;
        }

        if (!isDownList && deltaX <= lastDeltaX) {
          // right-up, left-up
          deltaX = lastDeltaX + 10;
        }

        list[i].x = cx + deltaX * dir;
        lastDeltaX = deltaX;
      }
    }

    var lastY = 0;
    var delta;
    var len = list.length;
    var upList = [];
    var downList = [];

    for (var i = 0; i < len; i++) {
      if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {
        var dx = list[i].x - farthestX;
        list[i].linePoints[1][0] += dx;
        list[i].x = farthestX;
      }

      delta = list[i].y - lastY;

      if (delta < 0) {
        shiftDown(i, len, -delta);
      }

      lastY = list[i].y + list[i].height;
    }

    if (viewHeight - lastY < 0) {
      shiftUp(len - 1, lastY - viewHeight);
    }

    for (var i = 0; i < len; i++) {
      if (list[i].y >= cy) {
        downList.push(list[i]);
      } else {
        upList.push(list[i]);
      }
    }

    changeX(upList, false, cx, cy, r, dir);
    changeX(downList, true, cx, cy, r, dir);
  }

  function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
    var leftList = [];
    var rightList = [];
    var leftmostX = Number.MAX_VALUE;
    var rightmostX = -Number.MAX_VALUE;

    for (var i = 0; i < labelLayoutList.length; i++) {
      if (isPositionCenter(labelLayoutList[i])) {
        continue;
      }

      if (labelLayoutList[i].x < cx) {
        leftmostX = Math.min(leftmostX, labelLayoutList[i].x);
        leftList.push(labelLayoutList[i]);
      } else {
        rightmostX = Math.max(rightmostX, labelLayoutList[i].x);
        rightList.push(labelLayoutList[i]);
      }
    }

    adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
    adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);

    for (var i = 0; i < labelLayoutList.length; i++) {
      var layout = labelLayoutList[i];

      if (isPositionCenter(layout)) {
        continue;
      }

      var linePoints = layout.linePoints;

      if (linePoints) {
        var isAlignToEdge = layout.labelAlignTo === 'edge';
        var realTextWidth = layout.textRect.width;
        var targetTextWidth;

        if (isAlignToEdge) {
          if (layout.x < cx) {
            targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.labelMargin;
          } else {
            targetTextWidth = viewLeft + viewWidth - layout.labelMargin - linePoints[2][0] - layout.labelDistance;
          }
        } else {
          if (layout.x < cx) {
            targetTextWidth = layout.x - viewLeft - layout.bleedMargin;
          } else {
            targetTextWidth = viewLeft + viewWidth - layout.x - layout.bleedMargin;
          }
        }

        if (targetTextWidth < layout.textRect.width) {
          layout.text = text.truncateText(layout.text, targetTextWidth, layout.font);

          if (layout.labelAlignTo === 'edge') {
            realTextWidth = text.getWidth(layout.text, layout.font);
          }
        }

        var dist = linePoints[1][0] - linePoints[2][0];

        if (isAlignToEdge) {
          if (layout.x < cx) {
            linePoints[2][0] = viewLeft + layout.labelMargin + realTextWidth + layout.labelDistance;
          } else {
            linePoints[2][0] = viewLeft + viewWidth - layout.labelMargin - realTextWidth - layout.labelDistance;
          }
        } else {
          if (layout.x < cx) {
            linePoints[2][0] = layout.x + layout.labelDistance;
          } else {
            linePoints[2][0] = layout.x - layout.labelDistance;
          }

          linePoints[1][0] = linePoints[2][0] + dist;
        }

        linePoints[1][1] = linePoints[2][1] = layout.y;
      }
    }
  }

  function isPositionCenter(layout) {
    // Not change x for center label
    return layout.position === 'center';
  }

  function _default$24(seriesModel, r, viewWidth, viewHeight, viewLeft, viewTop) {
    var data = seriesModel.getData();
    var labelLayoutList = [];
    var cx;
    var cy;
    var hasLabelRotate = false;
    var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN;
    data.each(function (idx) {
      var layout = data.getItemLayout(idx);
      var itemModel = data.getItemModel(idx);
      var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis

      var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');
      var labelDistance = labelModel.get('distanceToLabelLine');
      var labelAlignTo = labelModel.get('alignTo');
      var labelMargin = parsePercent$6(labelModel.get('margin'), viewWidth);
      var bleedMargin = labelModel.get('bleedMargin');
      var font = labelModel.getFont();
      var labelLineModel = itemModel.getModel('labelLine');
      var labelLineLen = labelLineModel.get('length');
      labelLineLen = parsePercent$6(labelLineLen, viewWidth);
      var labelLineLen2 = labelLineModel.get('length2');
      labelLineLen2 = parsePercent$6(labelLineLen2, viewWidth);

      if (layout.angle < minShowLabelRadian) {
        return;
      }

      var midAngle = (layout.startAngle + layout.endAngle) / 2;
      var dx = Math.cos(midAngle);
      var dy = Math.sin(midAngle);
      var textX;
      var textY;
      var linePoints;
      var textAlign;
      cx = layout.cx;
      cy = layout.cy;
      var text$1 = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);
      var textRect = text.getBoundingRect(text$1, font, textAlign, 'top');
      var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';

      if (labelPosition === 'center') {
        textX = layout.cx;
        textY = layout.cy;
        textAlign = 'center';
      } else {
        var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;
        var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;
        textX = x1 + dx * 3;
        textY = y1 + dy * 3;

        if (!isLabelInside) {
          // For roseType
          var x2 = x1 + dx * (labelLineLen + r - layout.r);
          var y2 = y1 + dy * (labelLineLen + r - layout.r);
          var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;
          var y3 = y2;

          if (labelAlignTo === 'edge') {
            // Adjust textX because text align of edge is opposite
            textX = dx < 0 ? viewLeft + labelMargin : viewLeft + viewWidth - labelMargin;
          } else {
            textX = x3 + (dx < 0 ? -labelDistance : labelDistance);
          }

          textY = y3;
          linePoints = [[x1, y1], [x2, y2], [x3, y3]];
        }

        textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? dx > 0 ? 'right' : 'left' : dx > 0 ? 'left' : 'right';
      }

      var labelRotate;
      var rotate = labelModel.get('rotate');

      if (typeof rotate === 'number') {
        labelRotate = rotate * (Math.PI / 180);
      } else {
        labelRotate = rotate ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;
      }

      hasLabelRotate = !!labelRotate;
      layout.label = {
        x: textX,
        y: textY,
        position: labelPosition,
        height: textRect.height,
        len: labelLineLen,
        len2: labelLineLen2,
        linePoints: linePoints,
        textAlign: textAlign,
        verticalAlign: 'middle',
        rotation: labelRotate,
        inside: isLabelInside,
        labelDistance: labelDistance,
        labelAlignTo: labelAlignTo,
        labelMargin: labelMargin,
        bleedMargin: bleedMargin,
        textRect: textRect,
        text: text$1,
        font: font
      }; // Not layout the inside label

      if (!isLabelInside) {
        labelLayoutList.push(layout.label);
      }
    });

    if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {
      avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
    }
  }

  var labelLayout = _default$24;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var parsePercent$7 = number.parsePercent;
  var linearMap$2 = number.linearMap;







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var PI2$4 = Math.PI * 2;
  var RADIAN$1 = Math.PI / 180;

  function getViewRect(seriesModel, api) {
    return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }

  function _default$25(seriesType, ecModel, api, payload) {
    ecModel.eachSeriesByType(seriesType, function (seriesModel) {
      var data = seriesModel.getData();
      var valueDim = data.mapDimension('value');
      var viewRect = getViewRect(seriesModel, api);
      var center = seriesModel.get('center');
      var radius = seriesModel.get('radius');

      if (!util.isArray(radius)) {
        radius = [0, radius];
      }

      if (!util.isArray(center)) {
        center = [center, center];
      }

      var width = parsePercent$7(viewRect.width, api.getWidth());
      var height = parsePercent$7(viewRect.height, api.getHeight());
      var size = Math.min(width, height);
      var cx = parsePercent$7(center[0], width) + viewRect.x;
      var cy = parsePercent$7(center[1], height) + viewRect.y;
      var r0 = parsePercent$7(radius[0], size / 2);
      var r = parsePercent$7(radius[1], size / 2);
      var startAngle = -seriesModel.get('startAngle') * RADIAN$1;
      var minAngle = seriesModel.get('minAngle') * RADIAN$1;
      var validDataCount = 0;
      data.each(valueDim, function (value) {
        !isNaN(value) && validDataCount++;
      });
      var sum = data.getSum(valueDim); // Sum may be 0

      var unitRadian = Math.PI / (sum || validDataCount) * 2;
      var clockwise = seriesModel.get('clockwise');
      var roseType = seriesModel.get('roseType');
      var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]

      var extent = data.getDataExtent(valueDim);
      extent[0] = 0; // In the case some sector angle is smaller than minAngle

      var restAngle = PI2$4;
      var valueSumLargerThanMinAngle = 0;
      var currentAngle = startAngle;
      var dir = clockwise ? 1 : -1;
      data.each(valueDim, function (value, idx) {
        var angle;

        if (isNaN(value)) {
          data.setItemLayout(idx, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise: clockwise,
            cx: cx,
            cy: cy,
            r0: r0,
            r: roseType ? NaN : r,
            viewRect: viewRect
          });
          return;
        } // FIXME å¼å®¹ 2.0 ä½æ¯ roseType æ¯ area çæ¶åææ¯è¿æ ·ï¼


        if (roseType !== 'area') {
          angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
        } else {
          angle = PI2$4 / validDataCount;
        }

        if (angle < minAngle) {
          angle = minAngle;
          restAngle -= minAngle;
        } else {
          valueSumLargerThanMinAngle += value;
        }

        var endAngle = currentAngle + dir * angle;
        data.setItemLayout(idx, {
          angle: angle,
          startAngle: currentAngle,
          endAngle: endAngle,
          clockwise: clockwise,
          cx: cx,
          cy: cy,
          r0: r0,
          r: roseType ? linearMap$2(value, extent, [r0, r]) : r,
          viewRect: viewRect
        });
        currentAngle = endAngle;
      }); // Some sector is constrained by minAngle
      // Rest sectors needs recalculate angle

      if (restAngle < PI2$4 && validDataCount) {
        // Average the angle if rest angle is not enough after all angles is
        // Constrained by minAngle
        if (restAngle <= 1e-3) {
          var angle = PI2$4 / validDataCount;
          data.each(valueDim, function (value, idx) {
            if (!isNaN(value)) {
              var layout = data.getItemLayout(idx);
              layout.angle = angle;
              layout.startAngle = startAngle + dir * idx * angle;
              layout.endAngle = startAngle + dir * (idx + 1) * angle;
            }
          });
        } else {
          unitRadian = restAngle / valueSumLargerThanMinAngle;
          currentAngle = startAngle;
          data.each(valueDim, function (value, idx) {
            if (!isNaN(value)) {
              var layout = data.getItemLayout(idx);
              var angle = layout.angle === minAngle ? minAngle : value * unitRadian;
              layout.startAngle = currentAngle;
              layout.endAngle = currentAngle + dir * angle;
              currentAngle += dir * angle;
            }
          });
        }
      }

      labelLayout(seriesModel, r, viewRect.width, viewRect.height, viewRect.x, viewRect.y);
    });
  }

  var pieLayout = _default$25;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

















  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  createDataSelectAction('pie', [{
    type: 'pieToggleSelect',
    event: 'pieselectchanged',
    method: 'toggleSelected'
  }, {
    type: 'pieSelect',
    event: 'pieselected',
    method: 'select'
  }, {
    type: 'pieUnSelect',
    event: 'pieunselected',
    method: 'unSelect'
  }]);
  echarts.registerVisual(dataColor('pie'));
  echarts.registerLayout(util.curry(pieLayout, 'pie'));
  echarts.registerProcessor(dataFilter('pie'));

  function _interopDefault$4 (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }





  var Core$2 = _interopDefault$4(core_1);

  var _extends$3 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var pieRadius = 100;
  var ringRadius = [80, 100];
  var roseRingRadius = [20, 100];
  var pieOffsetY = 200;

  function getPieSeries(args) {
    var innerRows = args.innerRows,
        dataType = args.dataType,
        percentShow = args.percentShow,
        dimension = args.dimension,
        metrics = args.metrics,
        radius = args.radius,
        offsetY = args.offsetY,
        selectedMode = args.selectedMode,
        hoverAnimation = args.hoverAnimation,
        digit = args.digit,
        roseType = args.roseType,
        label = args.label,
        level = args.level,
        limitShowNum = args.limitShowNum,
        isRing = args.isRing,
        labelLine = args.labelLine,
        itemStyle = args.itemStyle;


    var series = [];
    var levelTemp = {};
    var rowsTemp = [];
    if (level) {
      level.forEach(function (levelItems, index) {
        levelItems.forEach(function (item) {
          utils.setArrayValue(levelTemp, item, index);
        });
      });
      innerRows.forEach(function (row) {
        var itemLevel = levelTemp[row[dimension]];
        if (itemLevel && itemLevel.length) {
          itemLevel.forEach(function (levelItem) {
            utils.setArrayValue(rowsTemp, levelItem, row);
          });
        }
      });
    } else {
      rowsTemp.push(innerRows);
    }
    var seriesBase = {
      type: 'pie',
      selectedMode: selectedMode,
      hoverAnimation: hoverAnimation,
      roseType: roseType,
      center: ['50%', offsetY]
    };
    var rowsTempLength = rowsTemp.length;
    rowsTemp.forEach(function (dataRows, index) {
      var seriesItem = _extends$3({ data: [] }, seriesBase);
      var centerWidth = radius / rowsTempLength;
      if (!index) {
        seriesItem.radius = isRing ? radius : centerWidth;
      } else {
        var outerWidth = centerWidth + radius / (2 * rowsTempLength) * (2 * index - 1);
        var innerWidth = outerWidth + radius / (2 * rowsTempLength);
        seriesItem.radius = [outerWidth, innerWidth];
      }
      if (rowsTempLength > 1 && index === 0) {
        seriesItem.label = {
          normal: { position: 'inner' }
        };
      }
      if (label) seriesItem.label = label;
      if (labelLine) seriesItem.labelLine = labelLine;
      if (itemStyle) seriesItem.itemStyle = itemStyle;
      if (percentShow) {
        seriesItem.label = {
          normal: {
            show: true,
            position: rowsTempLength > 1 && index === 0 ? 'inner' : 'outside',
            formatter: function formatter(item) {
              var tpl = [];
              tpl.push(item.name + ':');
              tpl.push(utils.getFormated(item.value, dataType, digit));
              tpl.push('(' + item.percent + '%)');
              return tpl.join(' ');
            }
          }
        };
      }
      seriesItem.data = dataRows.map(function (row) {
        return {
          name: row[dimension],
          value: row[metrics]
        };
      });
      series.push(seriesItem);
    });
    if (limitShowNum && limitShowNum < series[0].data.length) {
      var firstData = series[0].data;
      var remainArr = firstData.slice(limitShowNum, firstData.length);
      var sum = 0;
      remainArr.forEach(function (item) {
        sum += item.value;
      });
      series[0].data = firstData.slice(0, limitShowNum);
      series[0].data.push({ name: 'å¶ä»', value: sum });
    }
    return series;
  }

  function getPieLegend(args) {
    var innerRows = args.innerRows,
        dimension = args.dimension,
        legendLimit = args.legendLimit,
        legendName = args.legendName,
        level = args.level,
        limitShowNum = args.limitShowNum;

    var legend = [];
    var levelTemp = [];
    if (level) {
      level.forEach(function (levelItem) {
        levelItem.forEach(function (item) {
          levelTemp.push(item);
        });
      });
      legend = levelTemp;
    } else if (limitShowNum && limitShowNum < innerRows.length) {
      for (var i = 0; i < limitShowNum; i++) {
        legend.push(innerRows[i][dimension]);
      }
      legend.push('å¶ä»');
    } else {
      legend = innerRows.map(function (row) {
        return row[dimension];
      });
    }
    if (legend.length) {
      return {
        data: legend,
        show: legend.length < legendLimit,
        formatter: function formatter(name) {
          return legendName[name] != null ? legendName[name] : name;
        }
      };
    } else {
      return false;
    }
  }

  function getPieTooltip(args) {
    var dataType = args.dataType,
        innerRows = args.innerRows,
        limitShowNum = args.limitShowNum,
        digit = args.digit,
        metrics = args.metrics,
        dimension = args.dimension;

    var sum = 0;
    var remainArr = innerRows.map(function (row) {
      sum += row[metrics];
      return {
        name: row[dimension],
        value: row[metrics]
      };
    }).slice(limitShowNum, innerRows.length);
    return {
      formatter: function formatter(item) {
        var tpl = [];
        tpl.push(constants.itemPoint(item.color));
        if (limitShowNum && item.name === 'å¶ä»') {
          tpl.push('å¶ä»:');
          remainArr.forEach(function (_ref) {
            var name = _ref.name,
                value = _ref.value;

            var percent = utils.getFormated(value / sum, 'percent');
            tpl.push('<br>' + name + ':');
            tpl.push(utils.getFormated(value, dataType, digit));
            tpl.push('(' + percent + ')');
          });
        } else {
          tpl.push(item.name + ':');
          tpl.push(utils.getFormated(item.value, dataType, digit));
          tpl.push('(' + item.percent + '%)');
        }
        return tpl.join(' ');
      }
    };
  }

  var pie$1 = function pie$$1(columns, rows, settings, extra, isRing) {
    var innerRows = utilsLite.cloneDeep(rows);
    var _settings$dataType = settings.dataType,
        dataType = _settings$dataType === undefined ? 'normal' : _settings$dataType,
        percentShow = settings.percentShow,
        _settings$dimension = settings.dimension,
        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,
        _settings$metrics = settings.metrics,
        metrics = _settings$metrics === undefined ? columns[1] : _settings$metrics,
        _settings$roseType = settings.roseType,
        roseType = _settings$roseType === undefined ? false : _settings$roseType,
        _settings$radius = settings.radius,
        radius = _settings$radius === undefined ? isRing ? roseType ? roseRingRadius : ringRadius : pieRadius : _settings$radius,
        _settings$offsetY = settings.offsetY,
        offsetY = _settings$offsetY === undefined ? pieOffsetY : _settings$offsetY,
        _settings$legendLimit = settings.legendLimit,
        legendLimit = _settings$legendLimit === undefined ? 30 : _settings$legendLimit,
        _settings$selectedMod = settings.selectedMode,
        selectedMode = _settings$selectedMod === undefined ? false : _settings$selectedMod,
        _settings$hoverAnimat = settings.hoverAnimation,
        hoverAnimation = _settings$hoverAnimat === undefined ? true : _settings$hoverAnimat,
        _settings$digit = settings.digit,
        digit = _settings$digit === undefined ? 2 : _settings$digit,
        _settings$legendName = settings.legendName,
        legendName = _settings$legendName === undefined ? {} : _settings$legendName,
        _settings$label = settings.label,
        label = _settings$label === undefined ? false : _settings$label,
        _settings$level = settings.level,
        level = _settings$level === undefined ? false : _settings$level,
        _settings$limitShowNu = settings.limitShowNum,
        limitShowNum = _settings$limitShowNu === undefined ? 0 : _settings$limitShowNu,
        labelLine = settings.labelLine,
        itemStyle = settings.itemStyle;
    var tooltipVisible = extra.tooltipVisible,
        legendVisible = extra.legendVisible;

    if (limitShowNum) innerRows.sort(function (a, b) {
      return b[metrics] - a[metrics];
    });
    var seriesParams = {
      innerRows: innerRows,
      dataType: dataType,
      percentShow: percentShow,
      dimension: dimension,
      metrics: metrics,
      radius: radius,
      offsetY: offsetY,
      selectedMode: selectedMode,
      hoverAnimation: hoverAnimation,
      digit: digit,
      roseType: roseType,
      label: label,
      level: level,
      legendName: legendName,
      limitShowNum: limitShowNum,
      isRing: isRing,
      labelLine: labelLine,
      itemStyle: itemStyle
    };
    var series = getPieSeries(seriesParams);
    var legendParams = {
      innerRows: innerRows,
      dimension: dimension,
      legendLimit: legendLimit,
      legendName: legendName,
      level: level,
      limitShowNum: limitShowNum
    };
    var legend = legendVisible && getPieLegend(legendParams);
    var tooltip = tooltipVisible && getPieTooltip({
      dataType: dataType,
      innerRows: innerRows,
      limitShowNum: limitShowNum,
      digit: digit,
      metrics: metrics,
      dimension: dimension
    });
    var options = { series: series, legend: legend, tooltip: tooltip };
    return options;
  };

  var index$2 = _extends$3({}, Core$2, {
    name: 'VePie',
    data: function data() {
      this.chartHandler = pie$1;
      return {};
    }
  });

  var pie_common = index$2;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var _default$26 = Series.extend({
    type: 'series.__base_bar__',
    getInitialData: function (option, ecModel) {
      return createListFromArray_1(this.getSource(), this, {
        useEncodeDefaulter: true
      });
    },
    getMarkerPosition: function (value) {
      var coordSys = this.coordinateSystem;

      if (coordSys) {
        // PENDING if clamp ?
        var pt = coordSys.dataToPoint(coordSys.clampData(value));
        var data = this.getData();
        var offset = data.getLayout('offset');
        var size = data.getLayout('size');
        var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
        pt[offsetIndex] += offset + size / 2;
        return pt;
      }

      return [NaN, NaN];
    },
    defaultOption: {
      zlevel: 0,
      // ä¸çº§å±å 
      z: 2,
      // äºçº§å±å 
      coordinateSystem: 'cartesian2d',
      legendHoverLink: true,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // æå°é«åº¦æ¹ä¸º0
      barMinHeight: 0,
      // æå°è§åº¦ä¸º0ï¼ä»å¯¹æåæ ç³»ä¸çæ±ç¶å¾ææ
      barMinAngle: 0,
      // cursor: null,
      large: false,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: 'mod',
      // barMaxWidth: null,
      // In cartesian, the default value is 1. Otherwise null.
      // barMinWidth: null,
      // é»è®¤èªéåº
      // barWidth: null,
      // æ±é´è·ç¦»ï¼é»è®¤ä¸ºæ±å½¢å®½åº¦ç30%ï¼å¯è®¾åºå®å¼
      // barGap: '30%',
      // ç±»ç®é´æ±å½¢è·ç¦»ï¼é»è®¤ä¸ºç±»ç®é´è·ç20%ï¼å¯è®¾åºå®å¼
      // barCategoryGap: '20%',
      // label: {
      //      show: false
      // },
      itemStyle: {},
      emphasis: {}
    }
  });

  var BaseBarSeries = _default$26;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var _default$27 = BaseBarSeries.extend({
    type: 'series.bar',
    dependencies: ['grid', 'polar'],
    brushSelector: 'rect',

    /**
     * @override
     */
    getProgressive: function () {
      // Do not support progressive in normal mode.
      return this.get('large') ? this.get('progressive') : false;
    },

    /**
     * @override
     */
    getProgressiveThreshold: function () {
      // Do not support progressive in normal mode.
      var progressiveThreshold = this.get('progressiveThreshold');
      var largeThreshold = this.get('largeThreshold');

      if (largeThreshold > progressiveThreshold) {
        progressiveThreshold = largeThreshold;
      }

      return progressiveThreshold;
    },
    defaultOption: {
      // If clipped
      // Only available on cartesian2d
      clip: true,
      // If use caps on two sides of bars
      // Only available on tangential polar bar
      roundCap: false,
      showBackground: false,
      backgroundStyle: {
        color: 'rgba(180, 180, 180, 0.2)',
        borderColor: null,
        borderWidth: 0,
        borderType: 'solid',
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      }
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  var getDefaultLabel$2 = labelHelper.getDefaultLabel;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {
    var labelModel = itemModel.getModel('label');
    var hoverLabelModel = itemModel.getModel('emphasis.label');
    graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {
      labelFetcher: seriesModel,
      labelDataIndex: dataIndex,
      defaultText: getDefaultLabel$2(seriesModel.getData(), dataIndex),
      isRectText: true,
      autoColor: color
    });
    fixPosition(normalStyle);
    fixPosition(hoverStyle);
  }

  function fixPosition(style, labelPositionOutside) {
    if (style.textPosition === 'outside') {
      style.textPosition = labelPositionOutside;
    }
  }

  var setLabel_1 = setLabel;

  var helper$4 = {
  	setLabel: setLabel_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2
  ['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);
  var _default$28 = {
    getBarItemStyle: function (excludes) {
      var style = getBarItemStyle(this, excludes);

      if (this.getBorderLineDash) {
        var lineDash = this.getBorderLineDash();
        lineDash && (style.lineDash = lineDash);
      }

      return style;
    }
  };
  var barItemStyle = _default$28;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  var extendShape$1 = graphic.extendShape;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Sausage: similar to sector, but have half circle on both sides
   * @public
   */
  var _default$29 = extendShape$1({
    type: 'sausage',
    shape: {
      cx: 0,
      cy: 0,
      r0: 0,
      r: 0,
      startAngle: 0,
      endAngle: Math.PI * 2,
      clockwise: true
    },
    buildPath: function (ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var r0 = Math.max(shape.r0 || 0, 0);
      var r = Math.max(shape.r, 0);
      var dr = (r - r0) * 0.5;
      var rCenter = r0 + dr;
      var startAngle = shape.startAngle;
      var endAngle = shape.endAngle;
      var clockwise = shape.clockwise;
      var unitStartX = Math.cos(startAngle);
      var unitStartY = Math.sin(startAngle);
      var unitEndX = Math.cos(endAngle);
      var unitEndY = Math.sin(endAngle);
      var lessThanCircle = clockwise ? endAngle - startAngle < Math.PI * 2 : startAngle - endAngle < Math.PI * 2;

      if (lessThanCircle) {
        ctx.moveTo(unitStartX * r0 + x, unitStartY * r0 + y);
        ctx.arc(unitStartX * rCenter + x, unitStartY * rCenter + y, dr, -Math.PI + startAngle, startAngle, !clockwise);
      }

      ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
      ctx.moveTo(unitEndX * r + x, unitEndY * r + y);
      ctx.arc(unitEndX * rCenter + x, unitEndY * rCenter + y, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);

      if (r0 !== 0) {
        ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
        ctx.moveTo(unitStartX * r0 + x, unitEndY * r0 + y);
      }

      ctx.closePath();
    }
  });

  var sausage = _default$29;

  var setLabel$1 = helper$4.setLabel;











  var throttle$2 = throttle_1.throttle;



  var createClipPath$1 = createClipPathFromCoordSys.createClipPath;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'barBorderWidth'];
  var _eventPos = [0, 0]; // FIXME
  // Just for compatible with ec2.

  util.extend(Model_1.prototype, barItemStyle);

  function getClipArea(coord, data) {
    var coordSysClipArea = coord.getArea && coord.getArea();

    if (coord.type === 'cartesian2d') {
      var baseAxis = coord.getBaseAxis(); // When boundaryGap is false or using time axis. bar may exceed the grid.
      // We should not clip this part.
      // See test/bar2.html

      if (baseAxis.type !== 'category' || !baseAxis.onBand) {
        var expandWidth = data.getLayout('bandWidth');

        if (baseAxis.isHorizontal()) {
          coordSysClipArea.x -= expandWidth;
          coordSysClipArea.width += expandWidth * 2;
        } else {
          coordSysClipArea.y -= expandWidth;
          coordSysClipArea.height += expandWidth * 2;
        }
      }
    }

    return coordSysClipArea;
  }

  var _default$2a = echarts.extendChartView({
    type: 'bar',
    render: function (seriesModel, ecModel, api) {
      this._updateDrawMode(seriesModel);

      var coordinateSystemType = seriesModel.get('coordinateSystem');

      if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
        this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api);
      }

      return this.group;
    },
    incrementalPrepareRender: function (seriesModel, ecModel, api) {
      this._clear();

      this._updateDrawMode(seriesModel);
    },
    incrementalRender: function (params, seriesModel, ecModel, api) {
      // Do not support progressive in normal mode.
      this._incrementalRenderLarge(params, seriesModel);
    },
    _updateDrawMode: function (seriesModel) {
      var isLargeDraw = seriesModel.pipelineContext.large;

      if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
        this._isLargeDraw = isLargeDraw;

        this._clear();
      }
    },
    _renderNormal: function (seriesModel, ecModel, api) {
      var group = this.group;
      var data = seriesModel.getData();
      var oldData = this._data;
      var coord = seriesModel.coordinateSystem;
      var baseAxis = coord.getBaseAxis();
      var isHorizontalOrRadial;

      if (coord.type === 'cartesian2d') {
        isHorizontalOrRadial = baseAxis.isHorizontal();
      } else if (coord.type === 'polar') {
        isHorizontalOrRadial = baseAxis.dim === 'angle';
      }

      var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
      var needsClip = seriesModel.get('clip', true);
      var coordSysClipArea = getClipArea(coord, data); // If there is clipPath created in large mode. Remove it.

      group.removeClipPath(); // We don't use clipPath in normal mode because we needs a perfect animation
      // And don't want the label are clipped.

      var roundCap = seriesModel.get('roundCap', true);
      var drawBackground = seriesModel.get('showBackground', true);
      var backgroundModel = seriesModel.getModel('backgroundStyle');
      var barBorderRadius = backgroundModel.get('barBorderRadius') || 0;
      var bgEls = [];
      var oldBgEls = this._backgroundEls || [];

      var createBackground = function (dataIndex) {
        var bgLayout = getLayout[coord.type](data, dataIndex);
        var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
        bgEl.useStyle(backgroundModel.getBarItemStyle()); // Only cartesian2d support borderRadius.

        if (coord.type === 'cartesian2d') {
          bgEl.setShape('r', barBorderRadius);
        }

        bgEls[dataIndex] = bgEl;
        return bgEl;
      };

      data.diff(oldData).add(function (dataIndex) {
        var itemModel = data.getItemModel(dataIndex);
        var layout = getLayout[coord.type](data, dataIndex, itemModel);

        if (drawBackground) {
          createBackground(dataIndex);
        } // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in "axisProxy".


        if (!data.hasValue(dataIndex)) {
          return;
        }

        if (needsClip) {
          // Clip will modify the layout params.
          // And return a boolean to determine if the shape are fully clipped.
          var isClipped = clip[coord.type](coordSysClipArea, layout);

          if (isClipped) {
            group.remove(el);
            return;
          }
        }

        var el = elementCreator[coord.type](dataIndex, layout, isHorizontalOrRadial, animationModel, false, roundCap);
        data.setItemGraphicEl(dataIndex, el);
        group.add(el);
        updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
      }).update(function (newIndex, oldIndex) {
        var itemModel = data.getItemModel(newIndex);
        var layout = getLayout[coord.type](data, newIndex, itemModel);

        if (drawBackground) {
          var bgEl;

          if (oldBgEls.length === 0) {
            bgEl = createBackground(oldIndex);
          } else {
            bgEl = oldBgEls[oldIndex];
            bgEl.useStyle(backgroundModel.getBarItemStyle()); // Only cartesian2d support borderRadius.

            if (coord.type === 'cartesian2d') {
              bgEl.setShape('r', barBorderRadius);
            }

            bgEls[newIndex] = bgEl;
          }

          var bgLayout = getLayout[coord.type](data, newIndex);
          var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
          graphic.updateProps(bgEl, {
            shape: shape
          }, animationModel, newIndex);
        }

        var el = oldData.getItemGraphicEl(oldIndex);

        if (!data.hasValue(newIndex)) {
          group.remove(el);
          return;
        }

        if (needsClip) {
          var isClipped = clip[coord.type](coordSysClipArea, layout);

          if (isClipped) {
            group.remove(el);
            return;
          }
        }

        if (el) {
          graphic.updateProps(el, {
            shape: layout
          }, animationModel, newIndex);
        } else {
          el = elementCreator[coord.type](newIndex, layout, isHorizontalOrRadial, animationModel, true, roundCap);
        }

        data.setItemGraphicEl(newIndex, el); // Add back

        group.add(el);
        updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
      }).remove(function (dataIndex) {
        var el = oldData.getItemGraphicEl(dataIndex);

        if (coord.type === 'cartesian2d') {
          el && removeRect(dataIndex, animationModel, el);
        } else {
          el && removeSector(dataIndex, animationModel, el);
        }
      }).execute();
      var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group_1());
      bgGroup.removeAll();

      for (var i = 0; i < bgEls.length; ++i) {
        bgGroup.add(bgEls[i]);
      }

      group.add(bgGroup);
      this._backgroundEls = bgEls;
      this._data = data;
    },
    _renderLarge: function (seriesModel, ecModel, api) {
      this._clear();

      createLarge(seriesModel, this.group); // Use clipPath in large mode.

      var clipPath = seriesModel.get('clip', true) ? createClipPath$1(seriesModel.coordinateSystem, false, seriesModel) : null;

      if (clipPath) {
        this.group.setClipPath(clipPath);
      } else {
        this.group.removeClipPath();
      }
    },
    _incrementalRenderLarge: function (params, seriesModel) {
      this._removeBackground();

      createLarge(seriesModel, this.group, true);
    },
    dispose: util.noop,
    remove: function (ecModel) {
      this._clear(ecModel);
    },
    _clear: function (ecModel) {
      var group = this.group;
      var data = this._data;

      if (ecModel && ecModel.get('animation') && data && !this._isLargeDraw) {
        this._removeBackground();

        this._backgroundEls = [];
        data.eachItemGraphicEl(function (el) {
          if (el.type === 'sector') {
            removeSector(el.dataIndex, ecModel, el);
          } else {
            removeRect(el.dataIndex, ecModel, el);
          }
        });
      } else {
        group.removeAll();
      }

      this._data = null;
    },
    _removeBackground: function () {
      this.group.remove(this._backgroundGroup);
      this._backgroundGroup = null;
    }
  });

  var mathMax$4 = Math.max;
  var mathMin$4 = Math.min;
  var clip = {
    cartesian2d: function (coordSysBoundingRect, layout) {
      var signWidth = layout.width < 0 ? -1 : 1;
      var signHeight = layout.height < 0 ? -1 : 1; // Needs positive width and height

      if (signWidth < 0) {
        layout.x += layout.width;
        layout.width = -layout.width;
      }

      if (signHeight < 0) {
        layout.y += layout.height;
        layout.height = -layout.height;
      }

      var x = mathMax$4(layout.x, coordSysBoundingRect.x);
      var x2 = mathMin$4(layout.x + layout.width, coordSysBoundingRect.x + coordSysBoundingRect.width);
      var y = mathMax$4(layout.y, coordSysBoundingRect.y);
      var y2 = mathMin$4(layout.y + layout.height, coordSysBoundingRect.y + coordSysBoundingRect.height);
      layout.x = x;
      layout.y = y;
      layout.width = x2 - x;
      layout.height = y2 - y;
      var clipped = layout.width < 0 || layout.height < 0; // Reverse back

      if (signWidth < 0) {
        layout.x += layout.width;
        layout.width = -layout.width;
      }

      if (signHeight < 0) {
        layout.y += layout.height;
        layout.height = -layout.height;
      }

      return clipped;
    },
    polar: function (coordSysClipArea, layout) {
      var signR = layout.r0 <= layout.r ? 1 : -1; // Make sure r is larger than r0

      if (signR < 0) {
        var r = layout.r;
        layout.r = layout.r0;
        layout.r0 = r;
      }

      var r = mathMin$4(layout.r, coordSysClipArea.r);
      var r0 = mathMax$4(layout.r0, coordSysClipArea.r0);
      layout.r = r;
      layout.r0 = r0;
      var clipped = r - r0 < 0; // Reverse back

      if (signR < 0) {
        var r = layout.r;
        layout.r = layout.r0;
        layout.r0 = r;
      }

      return clipped;
    }
  };
  var elementCreator = {
    cartesian2d: function (dataIndex, layout, isHorizontal, animationModel, isUpdate) {
      var rect = new graphic.Rect({
        shape: util.extend({}, layout),
        z2: 1
      });
      rect.name = 'item'; // Animation

      if (animationModel) {
        var rectShape = rect.shape;
        var animateProperty = isHorizontal ? 'height' : 'width';
        var animateTarget = {};
        rectShape[animateProperty] = 0;
        animateTarget[animateProperty] = layout[animateProperty];
        graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {
          shape: animateTarget
        }, animationModel, dataIndex);
      }

      return rect;
    },
    polar: function (dataIndex, layout, isRadial, animationModel, isUpdate, roundCap) {
      // Keep the same logic with bar in catesion: use end value to control
      // direction. Notice that if clockwise is true (by default), the sector
      // will always draw clockwisely, no matter whether endAngle is greater
      // or less than startAngle.
      var clockwise = layout.startAngle < layout.endAngle;
      var ShapeClass = !isRadial && roundCap ? sausage : graphic.Sector;
      var sector = new ShapeClass({
        shape: util.defaults({
          clockwise: clockwise
        }, layout),
        z2: 1
      });
      sector.name = 'item'; // Animation

      if (animationModel) {
        var sectorShape = sector.shape;
        var animateProperty = isRadial ? 'r' : 'endAngle';
        var animateTarget = {};
        sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
        animateTarget[animateProperty] = layout[animateProperty];
        graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {
          shape: animateTarget
        }, animationModel, dataIndex);
      }

      return sector;
    }
  };

  function removeRect(dataIndex, animationModel, el) {
    // Not show text when animating
    el.style.text = null;
    graphic.updateProps(el, {
      shape: {
        width: 0
      }
    }, animationModel, dataIndex, function () {
      el.parent && el.parent.remove(el);
    });
  }

  function removeSector(dataIndex, animationModel, el) {
    // Not show text when animating
    el.style.text = null;
    graphic.updateProps(el, {
      shape: {
        r: el.shape.r0
      }
    }, animationModel, dataIndex, function () {
      el.parent && el.parent.remove(el);
    });
  }

  var getLayout = {
    // itemModel is only used to get borderWidth, which is not needed
    // when calculating bar background layout.
    cartesian2d: function (data, dataIndex, itemModel) {
      var layout = data.getItemLayout(dataIndex);
      var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0; // fix layout with lineWidth

      var signX = layout.width > 0 ? 1 : -1;
      var signY = layout.height > 0 ? 1 : -1;
      return {
        x: layout.x + signX * fixedLineWidth / 2,
        y: layout.y + signY * fixedLineWidth / 2,
        width: layout.width - signX * fixedLineWidth,
        height: layout.height - signY * fixedLineWidth
      };
    },
    polar: function (data, dataIndex, itemModel) {
      var layout = data.getItemLayout(dataIndex);
      return {
        cx: layout.cx,
        cy: layout.cy,
        r0: layout.r0,
        r: layout.r,
        startAngle: layout.startAngle,
        endAngle: layout.endAngle
      };
    }
  };

  function isZeroOnPolar(layout) {
    return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;
  }

  function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
    var color = data.getItemVisual(dataIndex, 'color');
    var opacity = data.getItemVisual(dataIndex, 'opacity');
    var stroke = data.getVisual('borderColor');
    var itemStyleModel = itemModel.getModel('itemStyle');
    var hoverStyle = itemModel.getModel('emphasis.itemStyle').getBarItemStyle();

    if (!isPolar) {
      el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);
    }

    el.useStyle(util.defaults({
      stroke: isZeroOnPolar(layout) ? 'none' : stroke,
      fill: isZeroOnPolar(layout) ? 'none' : color,
      opacity: opacity
    }, itemStyleModel.getBarItemStyle()));
    var cursorStyle = itemModel.getShallow('cursor');
    cursorStyle && el.attr('cursor', cursorStyle);
    var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';

    if (!isPolar) {
      setLabel$1(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);
    }

    if (isZeroOnPolar(layout)) {
      hoverStyle.fill = hoverStyle.stroke = 'none';
    }

    graphic.setHoverStyle(el, hoverStyle);
  } // In case width or height are too small.


  function getLineWidth(itemModel, rawLayout) {
    var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0; // width or height may be NaN for empty data

    var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
    var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
    return Math.min(lineWidth, width, height);
  }

  var LargePath = Path_1.extend({
    type: 'largeBar',
    shape: {
      points: []
    },
    buildPath: function (ctx, shape) {
      // Drawing lines is more efficient than drawing
      // a whole line or drawing rects.
      var points = shape.points;
      var startPoint = this.__startPoint;
      var baseDimIdx = this.__baseDimIdx;

      for (var i = 0; i < points.length; i += 2) {
        startPoint[baseDimIdx] = points[i + baseDimIdx];
        ctx.moveTo(startPoint[0], startPoint[1]);
        ctx.lineTo(points[i], points[i + 1]);
      }
    }
  });

  function createLarge(seriesModel, group, incremental) {
    // TODO support polar
    var data = seriesModel.getData();
    var startPoint = [];
    var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;
    startPoint[1 - baseDimIdx] = data.getLayout('valueAxisStart');
    var largeDataIndices = data.getLayout('largeDataIndices');
    var barWidth = data.getLayout('barWidth');
    var backgroundModel = seriesModel.getModel('backgroundStyle');
    var drawBackground = seriesModel.get('showBackground', true);

    if (drawBackground) {
      var points = data.getLayout('largeBackgroundPoints');
      var backgroundStartPoint = [];
      backgroundStartPoint[1 - baseDimIdx] = data.getLayout('backgroundStart');
      var bgEl = new LargePath({
        shape: {
          points: points
        },
        incremental: !!incremental,
        __startPoint: backgroundStartPoint,
        __baseDimIdx: baseDimIdx,
        __largeDataIndices: largeDataIndices,
        __barWidth: barWidth,
        silent: true,
        z2: 0
      });
      setLargeBackgroundStyle(bgEl, backgroundModel, data);
      group.add(bgEl);
    }

    var el = new LargePath({
      shape: {
        points: data.getLayout('largePoints')
      },
      incremental: !!incremental,
      __startPoint: startPoint,
      __baseDimIdx: baseDimIdx,
      __largeDataIndices: largeDataIndices,
      __barWidth: barWidth
    });
    group.add(el);
    setLargeStyle(el, seriesModel, data); // Enable tooltip and user mouse/touch event handlers.

    el.seriesIndex = seriesModel.seriesIndex;

    if (!seriesModel.get('silent')) {
      el.on('mousedown', largePathUpdateDataIndex);
      el.on('mousemove', largePathUpdateDataIndex);
    }
  } // Use throttle to avoid frequently traverse to find dataIndex.


  var largePathUpdateDataIndex = throttle$2(function (event) {
    var largePath = this;
    var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
    largePath.dataIndex = dataIndex >= 0 ? dataIndex : null;
  }, 30, false);

  function largePathFindDataIndex(largePath, x, y) {
    var baseDimIdx = largePath.__baseDimIdx;
    var valueDimIdx = 1 - baseDimIdx;
    var points = largePath.shape.points;
    var largeDataIndices = largePath.__largeDataIndices;
    var barWidthHalf = Math.abs(largePath.__barWidth / 2);
    var startValueVal = largePath.__startPoint[valueDimIdx];
    _eventPos[0] = x;
    _eventPos[1] = y;
    var pointerBaseVal = _eventPos[baseDimIdx];
    var pointerValueVal = _eventPos[1 - baseDimIdx];
    var baseLowerBound = pointerBaseVal - barWidthHalf;
    var baseUpperBound = pointerBaseVal + barWidthHalf;

    for (var i = 0, len = points.length / 2; i < len; i++) {
      var ii = i * 2;
      var barBaseVal = points[ii + baseDimIdx];
      var barValueVal = points[ii + valueDimIdx];

      if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {
        return largeDataIndices[i];
      }
    }

    return -1;
  }

  function setLargeStyle(el, seriesModel, data) {
    var borderColor = data.getVisual('borderColor') || data.getVisual('color');
    var itemStyle = seriesModel.getModel('itemStyle').getItemStyle(['color', 'borderColor']);
    el.useStyle(itemStyle);
    el.style.fill = null;
    el.style.stroke = borderColor;
    el.style.lineWidth = data.getLayout('barWidth');
  }

  function setLargeBackgroundStyle(el, backgroundModel, data) {
    var borderColor = backgroundModel.get('borderColor') || backgroundModel.get('color');
    var itemStyle = backgroundModel.getItemStyle(['color', 'borderColor']);
    el.useStyle(itemStyle);
    el.style.fill = null;
    el.style.stroke = borderColor;
    el.style.lineWidth = data.getLayout('barWidth');
  }

  function createBackgroundShape(isHorizontalOrRadial, layout, coord) {
    var coordLayout;
    var isPolar = coord.type === 'polar';

    if (isPolar) {
      coordLayout = coord.getArea();
    } else {
      coordLayout = coord.grid.getRect();
    }

    if (isPolar) {
      return {
        cx: coordLayout.cx,
        cy: coordLayout.cy,
        r0: isHorizontalOrRadial ? coordLayout.r0 : layout.r0,
        r: isHorizontalOrRadial ? coordLayout.r : layout.r,
        startAngle: isHorizontalOrRadial ? layout.startAngle : 0,
        endAngle: isHorizontalOrRadial ? layout.endAngle : Math.PI * 2
      };
    } else {
      return {
        x: isHorizontalOrRadial ? layout.x : coordLayout.x,
        y: isHorizontalOrRadial ? coordLayout.y : layout.y,
        width: isHorizontalOrRadial ? layout.width : coordLayout.width,
        height: isHorizontalOrRadial ? coordLayout.height : layout.height
      };
    }
  }

  function createBackgroundEl(coord, isHorizontalOrRadial, layout) {
    var ElementClz = coord.type === 'polar' ? graphic.Sector : graphic.Rect;
    return new ElementClz({
      shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),
      silent: true,
      z2: 0
    });
  }

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  var layout$4 = barGrid.layout;
  var largeLayout$1 = barGrid.largeLayout;









  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // In case developer forget to include grid component
  echarts.registerLayout(echarts.PRIORITY.VISUAL.LAYOUT, util.curry(layout$4, 'bar')); // Use higher prority to avoid to be blocked by other overall layout, which do not
  // only exist in this module, but probably also exist in other modules, like `barPolar`.

  echarts.registerLayout(echarts.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, largeLayout$1);
  echarts.registerVisual({
    seriesType: 'bar',
    reset: function (seriesModel) {
      // Visual coding for legend
      seriesModel.getData().setVisual('legendSymbol', 'roundRect');
    }
  });

  function _interopDefault$5 (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }





  var Core$3 = _interopDefault$5(core_1);

  var defineProperty$7 = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends$4 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  // default opacity of bar while dim-axis type is 'value'
  var VALUE_AXIS_OPACITY = 0.5;

  function getBarDimAxis(args) {
    var innerRows = args.innerRows,
        dimAxisName = args.dimAxisName,
        dimension = args.dimension,
        axisVisible = args.axisVisible,
        dimAxisType = args.dimAxisType,
        dims = args.dims;

    return dimension.map(function (item) {
      return {
        type: 'category',
        name: dimAxisName,
        nameLocation: 'middle',
        nameGap: 22,
        data: dimAxisType === 'value' ? getValueAxisData(dims) : innerRows.map(function (row) {
          return row[item];
        }),
        axisLabel: {
          formatter: function formatter(v) {
            return String(v);
          }
        },
        show: axisVisible
      };
    });
  }

  function getValueAxisData(dims) {
    var max = Math.max.apply(null, dims);
    var min = Math.min.apply(null, dims);
    var result = [];
    for (var i = min; i <= max; i++) {
      result.push(i);
    }
    return result;
  }

  function getBarMeaAxis(args) {
    var meaAxisName = args.meaAxisName,
        meaAxisType = args.meaAxisType,
        axisVisible = args.axisVisible,
        digit = args.digit,
        scale = args.scale,
        min = args.min,
        max = args.max;

    var meaAxisBase = {
      type: 'value',
      axisTick: {
        show: false
      },
      show: axisVisible
    };
    var meaAxis = [];

    var _loop = function _loop(i) {
      if (meaAxisType[i]) {
        meaAxis[i] = _extends$4({}, meaAxisBase, {
          axisLabel: {
            formatter: function formatter(val) {
              return utils.getFormated(val, meaAxisType[i], digit);
            }
          }
        });
      } else {
        meaAxis[i] = _extends$4({}, meaAxisBase);
      }
      meaAxis[i].name = meaAxisName[i] || '';
      meaAxis[i].scale = scale[i] || false;
      meaAxis[i].min = min[i] || null;
      meaAxis[i].max = max[i] || null;
    };

    for (var i = 0; i < 2; i++) {
      _loop(i);
    }

    return meaAxis;
  }

  function getBarTooltip(args) {
    var axisSite = args.axisSite,
        isHistogram = args.isHistogram,
        meaAxisType = args.meaAxisType,
        digit = args.digit,
        labelMap = args.labelMap;

    var secondAxis = isHistogram ? axisSite.right || [] : axisSite.top || [];
    if (labelMap) {
      secondAxis = secondAxis.map(function (item) {
        return labelMap[item] === undefined ? item : labelMap[item];
      });
    }
    return {
      trigger: 'axis',
      formatter: function formatter(items) {
        var tpl = [];
        tpl.push(items[0].name + '<br>');
        items.forEach(function (item) {
          var seriesName = item.seriesName;
          var type = ~secondAxis.indexOf(seriesName) ? meaAxisType[1] : meaAxisType[0];
          tpl.push(constants.itemPoint(item.color));
          tpl.push(seriesName + ': ');
          tpl.push(utils.getFormated(item.value, type, digit));
          tpl.push('<br>');
        });

        return tpl.join('');
      }
    };
  }

  function getValueData(seriesTemp, dims) {
    var max = Math.max.apply(null, dims);
    var min = Math.min.apply(null, dims);
    var result = [];
    for (var i = min; i <= max; i++) {
      var index = dims.indexOf(i);
      if (~index) {
        result.push(seriesTemp[index]);
      } else {
        result.push(null);
      }
    }
    return result;
  }

  function getBarSeries(args) {
    var innerRows = args.innerRows,
        metrics = args.metrics,
        stack = args.stack,
        axisSite = args.axisSite,
        isHistogram = args.isHistogram,
        labelMap = args.labelMap,
        itemStyle = args.itemStyle,
        label = args.label,
        _args$showLine = args.showLine,
        showLine = _args$showLine === undefined ? [] : _args$showLine,
        dimAxisType = args.dimAxisType,
        barGap = args.barGap,
        opacity = args.opacity,
        dims = args.dims;

    var series = [];
    var seriesTemp = {};
    var secondAxis = isHistogram ? axisSite.right || [] : axisSite.top || [];
    var secondDimAxisIndex = isHistogram ? 'yAxisIndex' : 'xAxisIndex';
    var stackMap = stack && utils.getStackMap(stack);
    metrics.forEach(function (item) {
      seriesTemp[item] = [];
    });
    innerRows.forEach(function (row) {
      metrics.forEach(function (item) {
        seriesTemp[item].push(row[item]);
      });
    });
    series = Object.keys(seriesTemp).map(function (item, index) {
      var data = dimAxisType === 'value' ? getValueData(seriesTemp[item], dims) : seriesTemp[item];
      var seriesItem = defineProperty$7({
        name: labelMap[item] != null ? labelMap[item] : item,
        type: ~showLine.indexOf(item) ? 'line' : 'bar',
        data: data
      }, secondDimAxisIndex, ~secondAxis.indexOf(item) ? '1' : '0');

      if (stack && stackMap[item]) seriesItem.stack = stackMap[item];

      if (label) seriesItem.label = label;
      if (itemStyle) seriesItem.itemStyle = itemStyle;

      var itemOpacity = opacity || utilsLite.get(seriesItem, 'itemStyle.normal.opacity');
      if (dimAxisType === 'value') {
        seriesItem.barGap = barGap;
        seriesItem.barCategoryGap = '1%';
        if (itemOpacity == null) itemOpacity = VALUE_AXIS_OPACITY;
      }

      if (itemOpacity != null) {
        utilsLite.set(seriesItem, 'itemStyle.normal.opacity', itemOpacity);
      }

      return seriesItem;
    });

    return series.length ? series : false;
  }

  function getLegend$1(args) {
    var metrics = args.metrics,
        labelMap = args.labelMap,
        legendName = args.legendName;

    if (!legendName && !labelMap) return { data: metrics };
    var data = labelMap ? metrics.map(function (item) {
      return labelMap[item] == null ? item : labelMap[item];
    }) : metrics;
    return {
      data: data,
      formatter: function formatter(name) {
        return legendName[name] != null ? legendName[name] : name;
      }
    };
  }

  function getDims(rows, dimension) {
    return rows.map(function (row) {
      return row[dimension[0]];
    });
  }

  var histogram = function histogram(columns, rows, settings, status) {
    var innerRows = utilsLite.cloneDeep(rows);
    var _settings$axisSite2 = settings.axisSite,
        axisSite = _settings$axisSite2 === undefined ? {} : _settings$axisSite2,
        _settings$dimension2 = settings.dimension,
        dimension = _settings$dimension2 === undefined ? [columns[0]] : _settings$dimension2,
        _settings$stack2 = settings.stack,
        stack = _settings$stack2 === undefined ? {} : _settings$stack2,
        _settings$axisVisible2 = settings.axisVisible,
        axisVisible = _settings$axisVisible2 === undefined ? true : _settings$axisVisible2,
        _settings$digit2 = settings.digit,
        digit = _settings$digit2 === undefined ? 2 : _settings$digit2,
        _settings$dataOrder2 = settings.dataOrder,
        dataOrder = _settings$dataOrder2 === undefined ? false : _settings$dataOrder2,
        _settings$scale2 = settings.scale,
        scale = _settings$scale2 === undefined ? [false, false] : _settings$scale2,
        _settings$min2 = settings.min,
        min = _settings$min2 === undefined ? [null, null] : _settings$min2,
        _settings$max2 = settings.max,
        max = _settings$max2 === undefined ? [null, null] : _settings$max2,
        _settings$labelMap2 = settings.labelMap,
        labelMap = _settings$labelMap2 === undefined ? {} : _settings$labelMap2,
        _settings$legendName2 = settings.legendName,
        legendName = _settings$legendName2 === undefined ? {} : _settings$legendName2,
        label = settings.label,
        itemStyle = settings.itemStyle,
        showLine = settings.showLine,
        _settings$barGap2 = settings.barGap,
        barGap = _settings$barGap2 === undefined ? '-100%' : _settings$barGap2,
        opacity = settings.opacity;


    if (dataOrder) {
      var _label2 = dataOrder.label,
          order = dataOrder.order;

      if (!_label2 || !order) {
        console.warn('Need to provide name and order parameters');
      } else {
        innerRows.sort(function (a, b) {
          if (order === 'desc') {
            return a[_label2] - b[_label2];
          } else {
            return b[_label2] - a[_label2];
          }
        });
      }
    }

    var tooltipVisible = status.tooltipVisible,
        legendVisible = status.legendVisible;

    var metrics = columns.slice();
    if (axisSite.left && axisSite.right) {
      metrics = axisSite.left.concat(axisSite.right);
    } else if (axisSite.left && !axisSite.right) {
      metrics = axisSite.left;
    } else if (settings.metrics) {
      metrics = settings.metrics;
    } else {
      metrics.splice(columns.indexOf(dimension[0]), 1);
    }
    var meaAxisType = settings.yAxisType || ['normal', 'normal'];
    var dimAxisType = settings.xAxisType || 'category';
    var meaAxisName = settings.yAxisName || [];
    var dimAxisName = settings.xAxisName || '';
    var isHistogram = true;
    var dims = getDims(innerRows, dimension);

    var legend = legendVisible && getLegend$1({ metrics: metrics, labelMap: labelMap, legendName: legendName });
    var xAxis = getBarDimAxis({
      innerRows: innerRows,
      dimAxisName: dimAxisName,
      dimension: dimension,
      axisVisible: axisVisible,
      dimAxisType: dimAxisType,
      dims: dims
    });
    var yAxis = getBarMeaAxis({
      meaAxisName: meaAxisName,
      meaAxisType: meaAxisType,
      axisVisible: axisVisible,
      digit: digit,
      scale: scale,
      min: min,
      max: max
    });
    var series = getBarSeries({
      innerRows: innerRows,
      metrics: metrics,
      stack: stack,
      axisSite: axisSite,
      isHistogram: isHistogram,
      labelMap: labelMap,
      itemStyle: itemStyle,
      label: label,
      showLine: showLine,
      dimAxisType: dimAxisType,
      dimension: dimension,
      barGap: barGap,
      opacity: opacity,
      dims: dims
    });
    var tooltipParams = { axisSite: axisSite, isHistogram: isHistogram, meaAxisType: meaAxisType, digit: digit, labelMap: labelMap };
    var tooltip = tooltipVisible && getBarTooltip(tooltipParams);
    var options = { legend: legend, yAxis: yAxis, series: series, xAxis: xAxis, tooltip: tooltip };
    return options;
  };

  var index$3 = _extends$4({}, Core$3, {
    name: 'VeHistogram',
    data: function data() {
      this.chartHandler = histogram;
      return {};
    }
  });

  var histogram_common = index$3;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */









  var defaultEmphasis$1 = model.defaultEmphasis;



  var makeSeriesEncodeForNameBased$2 = sourceHelper.makeSeriesEncodeForNameBased;



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var FunnelSeries = echarts.extendSeriesModel({
    type: 'series.funnel',
    init: function (option) {
      FunnelSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item
      // Use a function instead of direct access because data reference may changed

      this.legendVisualProvider = new LegendVisualProvider_1(util.bind(this.getData, this), util.bind(this.getRawData, this)); // Extend labelLine emphasis

      this._defaultLabelLine(option);
    },
    getInitialData: function (option, ecModel) {
      return createListSimply(this, {
        coordDimensions: ['value'],
        encodeDefaulter: util.curry(makeSeriesEncodeForNameBased$2, this)
      });
    },
    _defaultLabelLine: function (option) {
      // Extend labelLine emphasis
      defaultEmphasis$1(option, 'labelLine', ['show']);
      var labelLineNormalOpt = option.labelLine;
      var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`

      labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
      labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
    },
    // Overwrite
    getDataParams: function (dataIndex) {
      var data = this.getData();
      var params = FunnelSeries.superCall(this, 'getDataParams', dataIndex);
      var valueDim = data.mapDimension('value');
      var sum = data.getSum(valueDim); // Percent is 0 if sum is 0

      params.percent = !sum ? 0 : +(data.get(valueDim, dataIndex) / sum * 100).toFixed(2);
      params.$vars.push('percent');
      return params;
    },
    defaultOption: {
      zlevel: 0,
      // ä¸çº§å±å 
      z: 2,
      // äºçº§å±å 
      legendHoverLink: true,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // é»è®¤åæ°æ®æå°æå¤§å¼
      // min: 0,
      // max: 100,
      minSize: '0%',
      maxSize: '100%',
      sort: 'descending',
      // 'ascending', 'descending'
      orient: 'vertical',
      gap: 0,
      funnelAlign: 'center',
      label: {
        show: true,
        position: 'outer' // formatter: æ ç­¾ææ¬æ ¼å¼å¨ï¼åTooltip.formatterï¼ä¸æ¯æå¼æ­¥åè°

      },
      labelLine: {
        show: true,
        length: 20,
        lineStyle: {
          // color: åå¼,
          width: 1,
          type: 'solid'
        }
      },
      itemStyle: {
        // color: åå¼,
        borderColor: '#fff',
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Piece of pie including Sector, Label, LabelLine
   * @constructor
   * @extends {module:zrender/graphic/Group}
   */
  function FunnelPiece(data, idx) {
    graphic.Group.call(this);
    var polygon = new graphic.Polygon();
    var labelLine = new graphic.Polyline();
    var text = new graphic.Text();
    this.add(polygon);
    this.add(labelLine);
    this.add(text);

    this.highDownOnUpdate = function (fromState, toState) {
      if (toState === 'emphasis') {
        labelLine.ignore = labelLine.hoverIgnore;
        text.ignore = text.hoverIgnore;
      } else {
        labelLine.ignore = labelLine.normalIgnore;
        text.ignore = text.normalIgnore;
      }
    };

    this.updateData(data, idx, true);
  }

  var funnelPieceProto = FunnelPiece.prototype;
  var opacityAccessPath = ['itemStyle', 'opacity'];

  funnelPieceProto.updateData = function (data, idx, firstCreate) {
    var polygon = this.childAt(0);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout = data.getItemLayout(idx);
    var opacity = data.getItemModel(idx).get(opacityAccessPath);
    opacity = opacity == null ? 1 : opacity; // Reset style

    polygon.useStyle({});

    if (firstCreate) {
      polygon.setShape({
        points: layout.points
      });
      polygon.setStyle({
        opacity: 0
      });
      graphic.initProps(polygon, {
        style: {
          opacity: opacity
        }
      }, seriesModel, idx);
    } else {
      graphic.updateProps(polygon, {
        style: {
          opacity: opacity
        },
        shape: {
          points: layout.points
        }
      }, seriesModel, idx);
    } // Update common style


    var itemStyleModel = itemModel.getModel('itemStyle');
    var visualColor = data.getItemVisual(idx, 'color');
    polygon.setStyle(util.defaults({
      lineJoin: 'round',
      fill: visualColor
    }, itemStyleModel.getItemStyle(['opacity'])));
    polygon.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();

    this._updateLabel(data, idx);

    graphic.setHoverStyle(this);
  };

  funnelPieceProto._updateLabel = function (data, idx) {
    var labelLine = this.childAt(1);
    var labelText = this.childAt(2);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout = data.getItemLayout(idx);
    var labelLayout = layout.label;
    var visualColor = data.getItemVisual(idx, 'color');
    graphic.updateProps(labelLine, {
      shape: {
        points: labelLayout.linePoints || labelLayout.linePoints
      }
    }, seriesModel, idx);
    graphic.updateProps(labelText, {
      style: {
        x: labelLayout.x,
        y: labelLayout.y
      }
    }, seriesModel, idx);
    labelText.attr({
      rotation: labelLayout.rotation,
      origin: [labelLayout.x, labelLayout.y],
      z2: 10
    });
    var labelModel = itemModel.getModel('label');
    var labelHoverModel = itemModel.getModel('emphasis.label');
    var labelLineModel = itemModel.getModel('labelLine');
    var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');
    var visualColor = data.getItemVisual(idx, 'color');
    graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      defaultText: data.getName(idx),
      autoColor: visualColor,
      useInsideStyle: !!labelLayout.inside
    }, {
      textAlign: labelLayout.textAlign,
      textVerticalAlign: labelLayout.verticalAlign
    });
    labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
    labelText.hoverIgnore = !labelHoverModel.get('show');
    labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
    labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color

    labelLine.setStyle({
      stroke: visualColor
    });
    labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());
    labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();
  };

  util.inherits(FunnelPiece, graphic.Group);
  var FunnelView = Chart_1.extend({
    type: 'funnel',
    render: function (seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      data.diff(oldData).add(function (idx) {
        var funnelPiece = new FunnelPiece(data, idx);
        data.setItemGraphicEl(idx, funnelPiece);
        group.add(funnelPiece);
      }).update(function (newIdx, oldIdx) {
        var piePiece = oldData.getItemGraphicEl(oldIdx);
        piePiece.updateData(data, newIdx);
        group.add(piePiece);
        data.setItemGraphicEl(newIdx, piePiece);
      }).remove(function (idx) {
        var piePiece = oldData.getItemGraphicEl(idx);
        group.remove(piePiece);
      }).execute();
      this._data = data;
    },
    remove: function () {
      this.group.removeAll();
      this._data = null;
    },
    dispose: function () {}
  });

  var parsePercent$8 = number.parsePercent;
  var linearMap$3 = number.linearMap;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function getViewRect$1(seriesModel, api) {
    return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }

  function getSortedIndices(data, sort) {
    var valueDim = data.mapDimension('value');
    var valueArr = data.mapArray(valueDim, function (val) {
      return val;
    });
    var indices = [];
    var isAscending = sort === 'ascending';

    for (var i = 0, len = data.count(); i < len; i++) {
      indices[i] = i;
    } // Add custom sortable function & none sortable opetion by "options.sort"


    if (typeof sort === 'function') {
      indices.sort(sort);
    } else if (sort !== 'none') {
      indices.sort(function (a, b) {
        return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
      });
    }

    return indices;
  }

  function labelLayout$1(data) {
    data.each(function (idx) {
      var itemModel = data.getItemModel(idx);
      var labelModel = itemModel.getModel('label');
      var labelPosition = labelModel.get('position');
      var orient = itemModel.get('orient');
      var labelLineModel = itemModel.getModel('labelLine');
      var layout = data.getItemLayout(idx);
      var points = layout.points;
      var isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center' || labelPosition === 'insideLeft' || labelPosition === 'insideRight';
      var textAlign;
      var textX;
      var textY;
      var linePoints;

      if (isLabelInside) {
        if (labelPosition === 'insideLeft') {
          textX = (points[0][0] + points[3][0]) / 2 + 5;
          textY = (points[0][1] + points[3][1]) / 2;
          textAlign = 'left';
        } else if (labelPosition === 'insideRight') {
          textX = (points[1][0] + points[2][0]) / 2 - 5;
          textY = (points[1][1] + points[2][1]) / 2;
          textAlign = 'right';
        } else {
          textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;
          textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;
          textAlign = 'center';
        }

        linePoints = [[textX, textY], [textX, textY]];
      } else {
        var x1;
        var y1;
        var x2;
        var y2;
        var labelLineLen = labelLineModel.get('length');

        if (labelPosition === 'left') {
          // Left side
          x1 = (points[3][0] + points[0][0]) / 2;
          y1 = (points[3][1] + points[0][1]) / 2;
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = 'right';
        } else if (labelPosition === 'right') {
          // Right side
          x1 = (points[1][0] + points[2][0]) / 2;
          y1 = (points[1][1] + points[2][1]) / 2;
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = 'left';
        } else if (labelPosition === 'top') {
          // Top side
          x1 = (points[3][0] + points[0][0]) / 2;
          y1 = (points[3][1] + points[0][1]) / 2;
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = 'center';
        } else if (labelPosition === 'bottom') {
          // Bottom side
          x1 = (points[1][0] + points[2][0]) / 2;
          y1 = (points[1][1] + points[2][1]) / 2;
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = 'center';
        } else if (labelPosition === 'rightTop') {
          // RightTop side
          x1 = orient === 'horizontal' ? points[3][0] : points[1][0];
          y1 = orient === 'horizontal' ? points[3][1] : points[1][1];

          if (orient === 'horizontal') {
            y2 = y1 - labelLineLen;
            textY = y2 - 5;
            textAlign = 'center';
          } else {
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = 'top';
          }
        } else if (labelPosition === 'rightBottom') {
          // RightBottom side
          x1 = points[2][0];
          y1 = points[2][1];

          if (orient === 'horizontal') {
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = 'center';
          } else {
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = 'bottom';
          }
        } else if (labelPosition === 'leftTop') {
          // LeftTop side
          x1 = points[0][0];
          y1 = orient === 'horizontal' ? points[0][1] : points[1][1];

          if (orient === 'horizontal') {
            y2 = y1 - labelLineLen;
            textY = y2 - 5;
            textAlign = 'center';
          } else {
            x2 = x1 - labelLineLen;
            textX = x2 - 5;
            textAlign = 'right';
          }
        } else if (labelPosition === 'leftBottom') {
          // LeftBottom side
          x1 = orient === 'horizontal' ? points[1][0] : points[3][0];
          y1 = orient === 'horizontal' ? points[1][1] : points[2][1];

          if (orient === 'horizontal') {
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = 'center';
          } else {
            x2 = x1 - labelLineLen;
            textX = x2 - 5;
            textAlign = 'right';
          }
        } else {
          // Right side or Bottom side
          x1 = (points[1][0] + points[2][0]) / 2;
          y1 = (points[1][1] + points[2][1]) / 2;

          if (orient === 'horizontal') {
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = 'center';
          } else {
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = 'left';
          }
        }

        if (orient === 'horizontal') {
          x2 = x1;
          textX = x2;
        } else {
          y2 = y1;
          textY = y2;
        }

        linePoints = [[x1, y1], [x2, y2]];
      }

      layout.label = {
        linePoints: linePoints,
        x: textX,
        y: textY,
        verticalAlign: 'middle',
        textAlign: textAlign,
        inside: isLabelInside
      };
    });
  }

  function _default$2b(ecModel, api, payload) {
    ecModel.eachSeriesByType('funnel', function (seriesModel) {
      var data = seriesModel.getData();
      var valueDim = data.mapDimension('value');
      var sort = seriesModel.get('sort');
      var viewRect = getViewRect$1(seriesModel, api);
      var indices = getSortedIndices(data, sort);
      var orient = seriesModel.get('orient');
      var viewWidth = viewRect.width;
      var viewHeight = viewRect.height;
      var x = viewRect.x;
      var y = viewRect.y;
      var sizeExtent = orient === 'horizontal' ? [parsePercent$8(seriesModel.get('minSize'), viewHeight), parsePercent$8(seriesModel.get('maxSize'), viewHeight)] : [parsePercent$8(seriesModel.get('minSize'), viewWidth), parsePercent$8(seriesModel.get('maxSize'), viewWidth)];
      var dataExtent = data.getDataExtent(valueDim);
      var min = seriesModel.get('min');
      var max = seriesModel.get('max');

      if (min == null) {
        min = Math.min(dataExtent[0], 0);
      }

      if (max == null) {
        max = dataExtent[1];
      }

      var funnelAlign = seriesModel.get('funnelAlign');
      var gap = seriesModel.get('gap');
      var viewSize = orient === 'horizontal' ? viewWidth : viewHeight;
      var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();

      var getLinePoints = function (idx, offset) {
        // End point index is data.count() and we assign it 0
        if (orient === 'horizontal') {
          var val = data.get(valueDim, idx) || 0;
          var itemHeight = linearMap$3(val, [min, max], sizeExtent, true);
          var y0;

          switch (funnelAlign) {
            case 'top':
              y0 = y;
              break;

            case 'center':
              y0 = y + (viewHeight - itemHeight) / 2;
              break;

            case 'bottom':
              y0 = y + (viewHeight - itemHeight);
              break;
          }

          return [[offset, y0], [offset, y0 + itemHeight]];
        }

        var val = data.get(valueDim, idx) || 0;
        var itemWidth = linearMap$3(val, [min, max], sizeExtent, true);
        var x0;

        switch (funnelAlign) {
          case 'left':
            x0 = x;
            break;

          case 'center':
            x0 = x + (viewWidth - itemWidth) / 2;
            break;

          case 'right':
            x0 = x + viewWidth - itemWidth;
            break;
        }

        return [[x0, offset], [x0 + itemWidth, offset]];
      };

      if (sort === 'ascending') {
        // From bottom to top
        itemSize = -itemSize;
        gap = -gap;

        if (orient === 'horizontal') {
          x += viewWidth;
        } else {
          y += viewHeight;
        }

        indices = indices.reverse();
      }

      for (var i = 0; i < indices.length; i++) {
        var idx = indices[i];
        var nextIdx = indices[i + 1];
        var itemModel = data.getItemModel(idx);

        if (orient === 'horizontal') {
          var width = itemModel.get('itemStyle.width');

          if (width == null) {
            width = itemSize;
          } else {
            width = parsePercent$8(width, viewWidth);

            if (sort === 'ascending') {
              width = -width;
            }
          }

          var start = getLinePoints(idx, x);
          var end = getLinePoints(nextIdx, x + width);
          x += width + gap;
          data.setItemLayout(idx, {
            points: start.concat(end.slice().reverse())
          });
        } else {
          var height = itemModel.get('itemStyle.height');

          if (height == null) {
            height = itemSize;
          } else {
            height = parsePercent$8(height, viewHeight);

            if (sort === 'ascending') {
              height = -height;
            }
          }

          var start = orient === 'horizontal' ? getLinePoints(idx, x) : getLinePoints(idx, y);
          var end = orient === 'horizontal' ? getLinePoints(nextIdx, x + width) : getLinePoints(nextIdx, y + height);
          y += height + gap;
          data.setItemLayout(idx, {
            points: start.concat(end.slice().reverse())
          });
        }
      }

      labelLayout$1(data);
    });
  }

  var funnelLayout = _default$2b;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */













  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  echarts.registerVisual(dataColor('funnel'));
  echarts.registerLayout(funnelLayout);
  echarts.registerProcessor(dataFilter('funnel'));

  function _interopDefault$6 (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }




  var Core$4 = _interopDefault$6(core_1);

  function getFunnelTooltip(dataType, digit) {
    return {
      trigger: 'item',
      formatter: function formatter(item) {
        var tpl = [];
        tpl.push(constants.itemPoint(item.color));
        tpl.push(item.name + ': ' + utils.getFormated(item.data.realValue, dataType, digit));
        return tpl.join('');
      }
    };
  }

  function getFunnelLegend(args) {
    var data = args.data,
        legendName = args.legendName;

    return {
      data: data,
      formatter: function formatter(name) {
        return legendName[name] != null ? legendName[name] : name;
      }
    };
  }

  function getFunnelSeries(args) {
    var dimension = args.dimension,
        metrics = args.metrics,
        rows = args.rows,
        sequence = args.sequence,
        ascending = args.ascending,
        label = args.label,
        labelLine = args.labelLine,
        itemStyle = args.itemStyle,
        filterZero = args.filterZero,
        useDefaultOrder = args.useDefaultOrder;

    var series = { type: 'funnel' };
    var innerRows = rows.sort(function (a, b) {
      return sequence.indexOf(a[dimension]) - sequence.indexOf(b[dimension]);
    });

    if (filterZero) {
      innerRows = innerRows.filter(function (row) {
        return row[metrics];
      });
    }

    var falseFunnel = false;
    innerRows.some(function (row, index) {
      if (index && row[metrics] > innerRows[index - 1][metrics]) {
        falseFunnel = true;
        return true;
      }
    });

    var step = 100 / innerRows.length;

    if (falseFunnel && !useDefaultOrder) {
      series.data = innerRows.slice().reverse().map(function (row, index) {
        return {
          name: row[dimension],
          value: (index + 1) * step,
          realValue: row[metrics]
        };
      });
    } else {
      series.data = innerRows.map(function (row) {
        return {
          name: row[dimension],
          value: row[metrics],
          realValue: row[metrics]
        };
      });
    }

    if (ascending) series.sort = 'ascending';
    if (label) series.label = label;
    if (labelLine) series.labelLine = labelLine;
    if (itemStyle) series.itemStyle = itemStyle;
    return series;
  }

  var funnel$1 = function funnel$$1(outerColumns, outerRows, settings, extra) {
    var columns = outerColumns.slice();
    var rows = outerRows.slice();
    var _settings$dataType = settings.dataType,
        dataType = _settings$dataType === undefined ? 'normal' : _settings$dataType,
        _settings$dimension = settings.dimension,
        dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,
        _settings$sequence = settings.sequence,
        sequence = _settings$sequence === undefined ? rows.map(function (row) {
      return row[dimension];
    }) : _settings$sequence,
        _settings$digit = settings.digit,
        digit = _settings$digit === undefined ? 2 : _settings$digit,
        ascending = settings.ascending,
        label = settings.label,
        labelLine = settings.labelLine,
        _settings$legendName = settings.legendName,
        legendName = _settings$legendName === undefined ? {} : _settings$legendName,
        itemStyle = settings.itemStyle,
        filterZero = settings.filterZero,
        useDefaultOrder = settings.useDefaultOrder;
    var tooltipVisible = extra.tooltipVisible,
        legendVisible = extra.legendVisible;

    var metrics = void 0;
    if (settings.metrics) {
      metrics = settings.metrics;
    } else {
      var metricsTemp = columns.slice();
      metricsTemp.splice(columns.indexOf(dimension), 1);
      metrics = metricsTemp[0];
    }

    var tooltip = tooltipVisible && getFunnelTooltip(dataType, digit);
    var legend = legendVisible && getFunnelLegend({ data: sequence, legendName: legendName });
    var series = getFunnelSeries({
      dimension: dimension,
      metrics: metrics,
      rows: rows,
      sequence: sequence,
      ascending: ascending,
      label: label,
      labelLine: labelLine,
      itemStyle: itemStyle,
      filterZero: filterZero,
      useDefaultOrder: useDefaultOrder
    });
    var options = { tooltip: tooltip, legend: legend, series: series };
    return options;
  };

  var _extends$5 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var index$4 = _extends$5({}, Core$4, {
    name: 'VeFunnel',
    data: function data() {
      this.chartHandler = funnel$1;
      return {};
    }
  });

  var funnel_common = index$4;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var addCommas$2 = format$1.addCommas;
  var encodeHTML$3 = format$1.encodeHTML;

  function fillLabel(opt) {
    model.defaultEmphasis(opt, 'label', ['show']);
  }

  var MarkerModel = echarts.extendComponentModel({
    type: 'marker',
    dependencies: ['series', 'grid', 'polar', 'geo'],

    /**
     * @overrite
     */
    init: function (option, parentModel, ecModel) {
      this.mergeDefaultAndTheme(option, ecModel);

      this._mergeOption(option, ecModel, false, true);
    },

    /**
     * @return {boolean}
     */
    isAnimationEnabled: function () {
      if (env_1.node) {
        return false;
      }

      var hostSeries = this.__hostSeries;
      return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();
    },

    /**
     * @overrite
     */
    mergeOption: function (newOpt, ecModel) {
      this._mergeOption(newOpt, ecModel, false, false);
    },
    _mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {
      var MarkerModel = this.constructor;
      var modelPropName = this.mainType + 'Model';

      if (!createdBySelf) {
        ecModel.eachSeries(function (seriesModel) {
          var markerOpt = seriesModel.get(this.mainType, true);
          var markerModel = seriesModel[modelPropName];

          if (!markerOpt || !markerOpt.data) {
            seriesModel[modelPropName] = null;
            return;
          }

          if (!markerModel) {
            if (isInit) {
              // Default label emphasis `position` and `show`
              fillLabel(markerOpt);
            }

            util.each(markerOpt.data, function (item) {
              // FIXME Overwrite fillLabel method ?
              if (item instanceof Array) {
                fillLabel(item[0]);
                fillLabel(item[1]);
              } else {
                fillLabel(item);
              }
            });
            markerModel = new MarkerModel(markerOpt, this, ecModel);
            util.extend(markerModel, {
              mainType: this.mainType,
              // Use the same series index and name
              seriesIndex: seriesModel.seriesIndex,
              name: seriesModel.name,
              createdBySelf: true
            });
            markerModel.__hostSeries = seriesModel;
          } else {
            markerModel._mergeOption(markerOpt, ecModel, true);
          }

          seriesModel[modelPropName] = markerModel;
        }, this);
      }
    },
    formatTooltip: function (dataIndex, multipleSeries, dataType, renderMode) {
      var data = this.getData();
      var value = this.getRawValue(dataIndex);
      var formattedValue = util.isArray(value) ? util.map(value, addCommas$2).join(', ') : addCommas$2(value);
      var name = data.getName(dataIndex);
      var html = encodeHTML$3(this.name);
      var newLine = renderMode === 'html' ? '<br/>' : '\n';

      if (value != null || name) {
        html += newLine;
      }

      if (name) {
        html += encodeHTML$3(name);

        if (value != null) {
          html += ' : ';
        }
      }

      if (value != null) {
        html += encodeHTML$3(formattedValue);
      }

      return html;
    },
    getData: function () {
      return this._data;
    },
    setData: function (data) {
      this._data = data;
    }
  });
  util.mixin(MarkerModel, dataFormat);
  var _default$2c = MarkerModel;
  var MarkerModel_1 = _default$2c;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var _default$2d = MarkerModel_1.extend({
    type: 'markLine',
    defaultOption: {
      zlevel: 0,
      z: 5,
      symbol: ['circle', 'arrow'],
      symbolSize: [8, 16],
      //symbolRotate: 0,
      precision: 2,
      tooltip: {
        trigger: 'item'
      },
      label: {
        show: true,
        position: 'end',
        distance: 5
      },
      lineStyle: {
        type: 'dashed'
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: 'linear'
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  var isDimensionStacked$5 = dataStackHelper.isDimensionStacked;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var indexOf$5 = util.indexOf;

  function hasXOrY(item) {
    return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
  }

  function hasXAndY(item) {
    return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
  } // Make it simple, do not visit all stacked value to count precision.
  // function getPrecision(data, valueAxisDim, dataIndex) {
  //     var precision = -1;
  //     var stackedDim = data.mapDimension(valueAxisDim);
  //     do {
  //         precision = Math.max(
  //             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),
  //             precision
  //         );
  //         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
  //         if (stackedOnSeries) {
  //             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);
  //             data = stackedOnSeries.getData();
  //             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);
  //             stackedDim = data.getCalculationInfo('stackedDimension');
  //         }
  //         else {
  //             data = null;
  //         }
  //     } while (data);
  //     return precision;
  // }


  function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
    var coordArr = [];
    var stacked = isDimensionStacked$5(data, targetDataDim
    /*, otherDataDim*/
    );
    var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;
    var value = numCalculate(data, calcDataDim, mlType);
    var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
    coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
    coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
    var coordArrValue = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.

    var precision = number.getPrecision(data.get(targetDataDim, dataIndex));
    precision = Math.min(precision, 20);

    if (precision >= 0) {
      coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
    }

    return [coordArr, coordArrValue];
  }

  var curry$4 = util.curry; // TODO Specified percent

  var markerTypeCalculator = {
    /**
     * @method
     * @param {module:echarts/data/List} data
     * @param {string} baseAxisDim
     * @param {string} valueAxisDim
     */
    min: curry$4(markerTypeCalculatorWithExtent, 'min'),

    /**
     * @method
     * @param {module:echarts/data/List} data
     * @param {string} baseAxisDim
     * @param {string} valueAxisDim
     */
    max: curry$4(markerTypeCalculatorWithExtent, 'max'),

    /**
     * @method
     * @param {module:echarts/data/List} data
     * @param {string} baseAxisDim
     * @param {string} valueAxisDim
     */
    average: curry$4(markerTypeCalculatorWithExtent, 'average')
  };
  /**
   * Transform markPoint data item to format used in List by do the following
   * 1. Calculate statistic like `max`, `min`, `average`
   * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/coord/*} [coordSys]
   * @param  {Object} item
   * @return {Object}
   */

  function dataTransform(seriesModel, item) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly
    // 2. If `coord` is not a data array. Which uses `xAxis`,
    // `yAxis` to specify the coord on each dimension
    // parseFloat first because item.x and item.y can be percent string like '20%'

    if (item && !hasXAndY(item) && !util.isArray(item.coord) && coordSys) {
      var dims = coordSys.dimensions;
      var axisInfo = getAxisInfo$1(item, data, coordSys, seriesModel); // Clone the option
      // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value

      item = util.clone(item);

      if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
        var otherCoordIndex = indexOf$5(dims, axisInfo.baseAxis.dim);
        var targetCoordIndex = indexOf$5(dims, axisInfo.valueAxis.dim);
        var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
        item.coord = coordInfo[0]; // Force to use the value of calculated value.
        // let item use the value without stack.

        item.value = coordInfo[1];
      } else {
        // FIXME Only has one of xAxis and yAxis.
        var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average

        for (var i = 0; i < 2; i++) {
          if (markerTypeCalculator[coord[i]]) {
            coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
          }
        }

        item.coord = coord;
      }
    }

    return item;
  }

  function getAxisInfo$1(item, data, coordSys, seriesModel) {
    var ret = {};

    if (item.valueIndex != null || item.valueDim != null) {
      ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
      ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
      ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
      ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
    } else {
      ret.baseAxis = seriesModel.getBaseAxis();
      ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
      ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
      ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
    }

    return ret;
  }

  function dataDimToCoordDim(seriesModel, dataDim) {
    var data = seriesModel.getData();
    var dimensions = data.dimensions;
    dataDim = data.getDimension(dataDim);

    for (var i = 0; i < dimensions.length; i++) {
      var dimItem = data.getDimensionInfo(dimensions[i]);

      if (dimItem.name === dataDim) {
        return dimItem.coordDim;
      }
    }
  }
  /**
   * Filter data which is out of coordinateSystem range
   * [dataFilter description]
   * @param  {module:echarts/coord/*} [coordSys]
   * @param  {Object} item
   * @return {boolean}
   */


  function dataFilter$1(coordSys, item) {
    // Alwalys return true if there is no coordSys
    return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
  }

  function dimValueGetter(item, dimName, dataIndex, dimIndex) {
    // x, y, radius, angle
    if (dimIndex < 2) {
      return item.coord && item.coord[dimIndex];
    }

    return item.value;
  }

  function numCalculate(data, valueDataDim, type) {
    if (type === 'average') {
      var sum = 0;
      var count = 0;
      data.each(valueDataDim, function (val, idx) {
        if (!isNaN(val)) {
          sum += val;
          count++;
        }
      });
      return sum / count;
    } else if (type === 'median') {
      return data.getMedian(valueDataDim);
    } else {
      // max & min
      return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];
    }
  }

  var dataTransform_1 = dataTransform;
  var getAxisInfo_1$1 = getAxisInfo$1;
  var dataFilter_1 = dataFilter$1;
  var dimValueGetter_1 = dimValueGetter;
  var numCalculate_1 = numCalculate;

  var markerHelper = {
  	dataTransform: dataTransform_1,
  	getAxisInfo: getAxisInfo_1$1,
  	dataFilter: dataFilter_1,
  	dimValueGetter: dimValueGetter_1,
  	numCalculate: numCalculate_1
  };

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * Line path for bezier and straight line draw
   */
  var straightLineProto = graphic.Line.prototype;
  var bezierCurveProto = graphic.BezierCurve.prototype;

  function isLine(shape) {
    return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
  }

  var _default$2e = graphic.extendShape({
    type: 'ec-line',
    style: {
      stroke: '#000',
      fill: null
    },
    shape: {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      percent: 1,
      cpx1: null,
      cpy1: null
    },
    buildPath: function (ctx, shape) {
      this[isLine(shape) ? '_buildPathLine' : '_buildPathCurve'](ctx, shape);
    },
    _buildPathLine: straightLineProto.buildPath,
    _buildPathCurve: bezierCurveProto.buildPath,
    pointAt: function (t) {
      return this[isLine(this.shape) ? '_pointAtLine' : '_pointAtCurve'](t);
    },
    _pointAtLine: straightLineProto.pointAt,
    _pointAtCurve: bezierCurveProto.pointAt,
    tangentAt: function (t) {
      var shape = this.shape;
      var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : this._tangentAtCurve(t);
      return vector.normalize(p, p);
    },
    _tangentAtCurve: bezierCurveProto.tangentAt
  });

  var LinePath = _default$2e;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */













  var round$4 = number.round;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @module echarts/chart/helper/Line
   */
  var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];

  function makeSymbolTypeKey(symbolCategory) {
    return '_' + symbolCategory + 'Type';
  }
  /**
   * @inner
   */


  function createSymbol$5(name, lineData, idx) {
    var symbolType = lineData.getItemVisual(idx, name);

    if (!symbolType || symbolType === 'none') {
      return;
    }

    var color = lineData.getItemVisual(idx, 'color');
    var symbolSize = lineData.getItemVisual(idx, name + 'Size');
    var symbolRotate = lineData.getItemVisual(idx, name + 'Rotate');

    if (!util.isArray(symbolSize)) {
      symbolSize = [symbolSize, symbolSize];
    }

    var symbolPath = symbol.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color); // rotate by default if symbolRotate is not specified or NaN

    symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
    symbolPath.name = name;
    return symbolPath;
  }

  function createLine(points) {
    var line = new LinePath({
      name: 'line',
      subPixelOptimize: true
    });
    setLinePoints(line.shape, points);
    return line;
  }

  function setLinePoints(targetShape, points) {
    targetShape.x1 = points[0][0];
    targetShape.y1 = points[0][1];
    targetShape.x2 = points[1][0];
    targetShape.y2 = points[1][1];
    targetShape.percent = 1;
    var cp1 = points[2];

    if (cp1) {
      targetShape.cpx1 = cp1[0];
      targetShape.cpy1 = cp1[1];
    } else {
      targetShape.cpx1 = NaN;
      targetShape.cpy1 = NaN;
    }
  }

  function updateSymbolAndLabelBeforeLineUpdate() {
    var lineGroup = this;
    var symbolFrom = lineGroup.childOfName('fromSymbol');
    var symbolTo = lineGroup.childOfName('toSymbol');
    var label = lineGroup.childOfName('label'); // Quick reject

    if (!symbolFrom && !symbolTo && label.ignore) {
      return;
    }

    var invScale = 1;
    var parentNode = this.parent;

    while (parentNode) {
      if (parentNode.scale) {
        invScale /= parentNode.scale[0];
      }

      parentNode = parentNode.parent;
    }

    var line = lineGroup.childOfName('line'); // If line not changed
    // FIXME Parent scale changed

    if (!this.__dirty && !line.__dirty) {
      return;
    }

    var percent = line.shape.percent;
    var fromPos = line.pointAt(0);
    var toPos = line.pointAt(percent);
    var d = vector.sub([], toPos, fromPos);
    vector.normalize(d, d);

    if (symbolFrom) {
      symbolFrom.attr('position', fromPos); // Fix #12388
      // when symbol is set to be 'arrow' in markLine,
      // symbolRotate value will be ignored, and compulsively use tangent angle.
      // rotate by default if symbol rotation is not specified

      var specifiedRotation = symbolFrom.__specifiedRotation;

      if (specifiedRotation == null) {
        var tangent = line.tangentAt(0);
        symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
      } else {
        symbolFrom.attr('rotation', specifiedRotation);
      }

      symbolFrom.attr('scale', [invScale * percent, invScale * percent]);
    }

    if (symbolTo) {
      symbolTo.attr('position', toPos); // Fix #12388
      // when symbol is set to be 'arrow' in markLine,
      // symbolRotate value will be ignored, and compulsively use tangent angle.
      // rotate by default if symbol rotation is not specified

      var specifiedRotation = symbolTo.__specifiedRotation;

      if (specifiedRotation == null) {
        var tangent = line.tangentAt(1);
        symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
      } else {
        symbolTo.attr('rotation', specifiedRotation);
      }

      symbolTo.attr('scale', [invScale * percent, invScale * percent]);
    }

    if (!label.ignore) {
      label.attr('position', toPos);
      var textPosition;
      var textAlign;
      var textVerticalAlign;
      var textOrigin;
      var distance = label.__labelDistance;
      var distanceX = distance[0] * invScale;
      var distanceY = distance[1] * invScale;
      var halfPercent = percent / 2;
      var tangent = line.tangentAt(halfPercent);
      var n = [tangent[1], -tangent[0]];
      var cp = line.pointAt(halfPercent);

      if (n[1] > 0) {
        n[0] = -n[0];
        n[1] = -n[1];
      }

      var dir = tangent[0] < 0 ? -1 : 1;

      if (label.__position !== 'start' && label.__position !== 'end') {
        var rotation = -Math.atan2(tangent[1], tangent[0]);

        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }

        label.attr('rotation', rotation);
      }

      var dy;

      switch (label.__position) {
        case 'insideStartTop':
        case 'insideMiddleTop':
        case 'insideEndTop':
        case 'middle':
          dy = -distanceY;
          textVerticalAlign = 'bottom';
          break;

        case 'insideStartBottom':
        case 'insideMiddleBottom':
        case 'insideEndBottom':
          dy = distanceY;
          textVerticalAlign = 'top';
          break;

        default:
          dy = 0;
          textVerticalAlign = 'middle';
      }

      switch (label.__position) {
        case 'end':
          textPosition = [d[0] * distanceX + toPos[0], d[1] * distanceY + toPos[1]];
          textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';
          textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';
          break;

        case 'start':
          textPosition = [-d[0] * distanceX + fromPos[0], -d[1] * distanceY + fromPos[1]];
          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';
          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';
          break;

        case 'insideStartTop':
        case 'insideStart':
        case 'insideStartBottom':
          textPosition = [distanceX * dir + fromPos[0], fromPos[1] + dy];
          textAlign = tangent[0] < 0 ? 'right' : 'left';
          textOrigin = [-distanceX * dir, -dy];
          break;

        case 'insideMiddleTop':
        case 'insideMiddle':
        case 'insideMiddleBottom':
        case 'middle':
          textPosition = [cp[0], cp[1] + dy];
          textAlign = 'center';
          textOrigin = [0, -dy];
          break;

        case 'insideEndTop':
        case 'insideEnd':
        case 'insideEndBottom':
          textPosition = [-distanceX * dir + toPos[0], toPos[1] + dy];
          textAlign = tangent[0] >= 0 ? 'right' : 'left';
          textOrigin = [distanceX * dir, -dy];
          break;
      }

      label.attr({
        style: {
          // Use the user specified text align and baseline first
          textVerticalAlign: label.__verticalAlign || textVerticalAlign,
          textAlign: label.__textAlign || textAlign
        },
        position: textPosition,
        scale: [invScale, invScale],
        origin: textOrigin
      });
    }
  }
  /**
   * @constructor
   * @extends {module:zrender/graphic/Group}
   * @alias {module:echarts/chart/helper/Line}
   */


  function Line$1(lineData, idx, seriesScope) {
    graphic.Group.call(this);

    this._createLine(lineData, idx, seriesScope);
  }

  var lineProto = Line$1.prototype; // Update symbol position and rotation

  lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;

  lineProto._createLine = function (lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var linePoints = lineData.getItemLayout(idx);
    var line = createLine(linePoints);
    line.shape.percent = 0;
    graphic.initProps(line, {
      shape: {
        percent: 1
      }
    }, seriesModel, idx);
    this.add(line);
    var label = new graphic.Text({
      name: 'label',
      // FIXME
      // Temporary solution for `focusNodeAdjacency`.
      // line label do not use the opacity of lineStyle.
      lineLabelOriginalOpacity: 1
    });
    this.add(label);
    util.each(SYMBOL_CATEGORIES, function (symbolCategory) {
      var symbol = createSymbol$5(symbolCategory, lineData, idx); // symbols must added after line to make sure
      // it will be updated after line#update.
      // Or symbol position and rotation update in line#beforeUpdate will be one frame slow

      this.add(symbol);
      this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
    }, this);

    this._updateCommonStl(lineData, idx, seriesScope);
  };

  lineProto.updateData = function (lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childOfName('line');
    var linePoints = lineData.getItemLayout(idx);
    var target = {
      shape: {}
    };
    setLinePoints(target.shape, linePoints);
    graphic.updateProps(line, target, seriesModel, idx);
    util.each(SYMBOL_CATEGORIES, function (symbolCategory) {
      var symbolType = lineData.getItemVisual(idx, symbolCategory);
      var key = makeSymbolTypeKey(symbolCategory); // Symbol changed

      if (this[key] !== symbolType) {
        this.remove(this.childOfName(symbolCategory));
        var symbol = createSymbol$5(symbolCategory, lineData, idx);
        this.add(symbol);
      }

      this[key] = symbolType;
    }, this);

    this._updateCommonStl(lineData, idx, seriesScope);
  };

  lineProto._updateCommonStl = function (lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childOfName('line');
    var lineStyle = seriesScope && seriesScope.lineStyle;
    var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
    var labelModel = seriesScope && seriesScope.labelModel;
    var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset

    if (!seriesScope || lineData.hasItemOption) {
      var itemModel = lineData.getItemModel(idx);
      lineStyle = itemModel.getModel('lineStyle').getLineStyle();
      hoverLineStyle = itemModel.getModel('emphasis.lineStyle').getLineStyle();
      labelModel = itemModel.getModel('label');
      hoverLabelModel = itemModel.getModel('emphasis.label');
    }

    var visualColor = lineData.getItemVisual(idx, 'color');
    var visualOpacity = util.retrieve3(lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1);
    line.useStyle(util.defaults({
      strokeNoScale: true,
      fill: 'none',
      stroke: visualColor,
      opacity: visualOpacity
    }, lineStyle));
    line.hoverStyle = hoverLineStyle; // Update symbol

    util.each(SYMBOL_CATEGORIES, function (symbolCategory) {
      var symbol = this.childOfName(symbolCategory);

      if (symbol) {
        symbol.setColor(visualColor);
        symbol.setStyle({
          opacity: visualOpacity
        });
      }
    }, this);
    var showLabel = labelModel.getShallow('show');
    var hoverShowLabel = hoverLabelModel.getShallow('show');
    var label = this.childOfName('label');
    var defaultLabelColor;
    var baseText; // FIXME: the logic below probably should be merged to `graphic.setLabelStyle`.

    if (showLabel || hoverShowLabel) {
      defaultLabelColor = visualColor || '#000';
      baseText = seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType);

      if (baseText == null) {
        var rawVal = seriesModel.getRawValue(idx);
        baseText = rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round$4(rawVal) : rawVal;
      }
    }

    var normalText = showLabel ? baseText : null;
    var emphasisText = hoverShowLabel ? util.retrieve2(seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), baseText) : null;
    var labelStyle = label.style; // Always set `textStyle` even if `normalStyle.text` is null, because default
    // values have to be set on `normalStyle`.

    if (normalText != null || emphasisText != null) {
      graphic.setTextStyle(label.style, labelModel, {
        text: normalText
      }, {
        autoColor: defaultLabelColor
      });
      label.__textAlign = labelStyle.textAlign;
      label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end'

      label.__position = labelModel.get('position') || 'middle';
      var distance = labelModel.get('distance');

      if (!util.isArray(distance)) {
        distance = [distance, distance];
      }

      label.__labelDistance = distance;
    }

    if (emphasisText != null) {
      // Only these properties supported in this emphasis style here.
      label.hoverStyle = {
        text: emphasisText,
        textFill: hoverLabelModel.getTextColor(true),
        // For merging hover style to normal style, do not use
        // `hoverLabelModel.getFont()` here.
        fontStyle: hoverLabelModel.getShallow('fontStyle'),
        fontWeight: hoverLabelModel.getShallow('fontWeight'),
        fontSize: hoverLabelModel.getShallow('fontSize'),
        fontFamily: hoverLabelModel.getShallow('fontFamily')
      };
    } else {
      label.hoverStyle = {
        text: null
      };
    }

    label.ignore = !showLabel && !hoverShowLabel;
    graphic.setHoverStyle(this);
  };

  lineProto.highlight = function () {
    this.trigger('emphasis');
  };

  lineProto.downplay = function () {
    this.trigger('normal');
  };

  lineProto.updateLayout = function (lineData, idx) {
    this.setLinePoints(lineData.getItemLayout(idx));
  };

  lineProto.setLinePoints = function (points) {
    var linePath = this.childOfName('line');
    setLinePoints(linePath.shape, points);
    linePath.dirty();
  };

  util.inherits(Line$1, graphic.Group);
  var _default$2f = Line$1;
  var Line_1$1 = _default$2f;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */

  /**
   * @module echarts/chart/helper/LineDraw
   */
  // import IncrementalDisplayable from 'zrender/src/graphic/IncrementalDisplayable';

  /**
   * @alias module:echarts/component/marker/LineDraw
   * @constructor
   */
  function LineDraw(ctor) {
    this._ctor = ctor || Line_1$1;
    this.group = new graphic.Group();
  }

  var lineDrawProto = LineDraw.prototype;

  lineDrawProto.isPersistent = function () {
    return true;
  };
  /**
   * @param {module:echarts/data/List} lineData
   */


  lineDrawProto.updateData = function (lineData) {
    var lineDraw = this;
    var group = lineDraw.group;
    var oldLineData = lineDraw._lineData;
    lineDraw._lineData = lineData; // There is no oldLineData only when first rendering or switching from
    // stream mode to normal mode, where previous elements should be removed.

    if (!oldLineData) {
      group.removeAll();
    }

    var seriesScope = makeSeriesScope$1(lineData);
    lineData.diff(oldLineData).add(function (idx) {
      doAdd(lineDraw, lineData, idx, seriesScope);
    }).update(function (newIdx, oldIdx) {
      doUpdate(lineDraw, oldLineData, lineData, oldIdx, newIdx, seriesScope);
    }).remove(function (idx) {
      group.remove(oldLineData.getItemGraphicEl(idx));
    }).execute();
  };

  function doAdd(lineDraw, lineData, idx, seriesScope) {
    var itemLayout = lineData.getItemLayout(idx);

    if (!lineNeedsDraw(itemLayout)) {
      return;
    }

    var el = new lineDraw._ctor(lineData, idx, seriesScope);
    lineData.setItemGraphicEl(idx, el);
    lineDraw.group.add(el);
  }

  function doUpdate(lineDraw, oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
    var itemEl = oldLineData.getItemGraphicEl(oldIdx);

    if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
      lineDraw.group.remove(itemEl);
      return;
    }

    if (!itemEl) {
      itemEl = new lineDraw._ctor(newLineData, newIdx, seriesScope);
    } else {
      itemEl.updateData(newLineData, newIdx, seriesScope);
    }

    newLineData.setItemGraphicEl(newIdx, itemEl);
    lineDraw.group.add(itemEl);
  }

  lineDrawProto.updateLayout = function () {
    var lineData = this._lineData; // Do not support update layout in incremental mode.

    if (!lineData) {
      return;
    }

    lineData.eachItemGraphicEl(function (el, idx) {
      el.updateLayout(lineData, idx);
    }, this);
  };

  lineDrawProto.incrementalPrepareUpdate = function (lineData) {
    this._seriesScope = makeSeriesScope$1(lineData);
    this._lineData = null;
    this.group.removeAll();
  };

  function isEffectObject(el) {
    return el.animators && el.animators.length > 0;
  }

  lineDrawProto.incrementalUpdate = function (taskParams, lineData) {
    function updateIncrementalAndHover(el) {
      if (!el.isGroup && !isEffectObject(el)) {
        el.incremental = el.useHoverLayer = true;
      }
    }

    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var itemLayout = lineData.getItemLayout(idx);

      if (lineNeedsDraw(itemLayout)) {
        var el = new this._ctor(lineData, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        this.group.add(el);
        lineData.setItemGraphicEl(idx, el);
      }
    }
  };

  function makeSeriesScope$1(lineData) {
    var hostModel = lineData.hostModel;
    return {
      lineStyle: hostModel.getModel('lineStyle').getLineStyle(),
      hoverLineStyle: hostModel.getModel('emphasis.lineStyle').getLineStyle(),
      labelModel: hostModel.getModel('label'),
      hoverLabelModel: hostModel.getModel('emphasis.label')
    };
  }

  lineDrawProto.remove = function () {
    this._clearIncremental();

    this._incremental = null;
    this.group.removeAll();
  };

  lineDrawProto._clearIncremental = function () {
    var incremental = this._incremental;

    if (incremental) {
      incremental.clearDisplaybles();
    }
  };

  function isPointNaN(pt) {
    return isNaN(pt[0]) || isNaN(pt[1]);
  }

  function lineNeedsDraw(pts) {
    return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
  }

  var _default$2g = LineDraw;
  var LineDraw_1 = _default$2g;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */





  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var _default$2h = echarts.extendComponentView({
    type: 'marker',
    init: function () {
      /**
       * Markline grouped by series
       * @private
       * @type {module:zrender/core/util.HashMap}
       */
      this.markerGroupMap = util.createHashMap();
    },
    render: function (markerModel, ecModel, api) {
      var markerGroupMap = this.markerGroupMap;
      markerGroupMap.each(function (item) {
        item.__keep = false;
      });
      var markerModelKey = this.type + 'Model';
      ecModel.eachSeries(function (seriesModel) {
        var markerModel = seriesModel[markerModelKey];
        markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);
      }, this);
      markerGroupMap.each(function (item) {
        !item.__keep && this.group.remove(item.group);
      }, this);
    },
    renderSeries: function () {}
  });

  var MarkerView = _default$2h;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */















  var getStackedDimension$3 = dataStackHelper.getStackedDimension;

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var markLineTransform = function (seriesModel, coordSys, mlModel, item) {
    var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average', 'median'

    var mlType = item.type;

    if (!util.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' // In case
    // data: [{
    //   yAxis: 10
    // }]
    || item.xAxis != null || item.yAxis != null)) {
      var valueAxis;
      var value;

      if (item.yAxis != null || item.xAxis != null) {
        valueAxis = coordSys.getAxis(item.yAxis != null ? 'y' : 'x');
        value = util.retrieve(item.yAxis, item.xAxis);
      } else {
        var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
        valueAxis = axisInfo.valueAxis;
        var valueDataDim = getStackedDimension$3(data, axisInfo.valueDataDim);
        value = markerHelper.numCalculate(data, valueDataDim, mlType);
      }

      var valueIndex = valueAxis.dim === 'x' ? 0 : 1;
      var baseIndex = 1 - valueIndex;
      var mlFrom = util.clone(item);
      var mlTo = {};
      mlFrom.type = null;
      mlFrom.coord = [];
      mlTo.coord = [];
      mlFrom.coord[baseIndex] = -Infinity;
      mlTo.coord[baseIndex] = Infinity;
      var precision = mlModel.get('precision');

      if (precision >= 0 && typeof value === 'number') {
        value = +value.toFixed(Math.min(precision, 20));
      }

      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
      item = [mlFrom, mlTo, {
        // Extra option for tooltip and label
        type: mlType,
        valueIndex: item.valueIndex,
        // Force to use the value of calculated value.
        value: value
      }];
    }

    item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), util.extend({}, item[2])]; // Avoid line data type is extended by from(to) data type

    item[2].type = item[2].type || ''; // Merge from option and to option into line option

    util.merge(item[2], item[0]);
    util.merge(item[2], item[1]);
    return item;
  };

  function isInifinity(val) {
    return !isNaN(val) && !isFinite(val);
  } // If a markLine has one dim


  function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
    var otherDimIndex = 1 - dimIndex;
    var dimName = coordSys.dimensions[dimIndex];
    return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
  }

  function markLineFilter(coordSys, item) {
    if (coordSys.type === 'cartesian2d') {
      var fromCoord = item[0].coord;
      var toCoord = item[1].coord; // In case
      // {
      //  markLine: {
      //    data: [{ yAxis: 2 }]
      //  }
      // }

      if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
        return true;
      }
    }

    return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
  }

  function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var itemModel = data.getItemModel(idx);
    var point;
    var xPx = number.parsePercent(itemModel.get('x'), api.getWidth());
    var yPx = number.parsePercent(itemModel.get('y'), api.getHeight());

    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else {
      // Chart like bar may have there own marker positioning logic
      if (seriesModel.getMarkerPosition) {
        // Use the getMarkerPoisition
        point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
      } else {
        var dims = coordSys.dimensions;
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        point = coordSys.dataToPoint([x, y]);
      } // Expand line to the edge of grid if value on one axis is Inifnity
      // In case
      //  markLine: {
      //    data: [{
      //      yAxis: 2
      //      // or
      //      type: 'average'
      //    }]
      //  }


      if (coordSys.type === 'cartesian2d') {
        var xAxis = coordSys.getAxis('x');
        var yAxis = coordSys.getAxis('y');
        var dims = coordSys.dimensions;

        if (isInifinity(data.get(dims[0], idx))) {
          point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
        } else if (isInifinity(data.get(dims[1], idx))) {
          point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
        }
      } // Use x, y if has any


      if (!isNaN(xPx)) {
        point[0] = xPx;
      }

      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
    }

    data.setItemLayout(idx, point);
  }

  var _default$2i = MarkerView.extend({
    type: 'markLine',
    // updateLayout: function (markLineModel, ecModel, api) {
    //     ecModel.eachSeries(function (seriesModel) {
    //         var mlModel = seriesModel.markLineModel;
    //         if (mlModel) {
    //             var mlData = mlModel.getData();
    //             var fromData = mlModel.__from;
    //             var toData = mlModel.__to;
    //             // Update visual and layout of from symbol and to symbol
    //             fromData.each(function (idx) {
    //                 updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
    //                 updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
    //             });
    //             // Update layout of line
    //             mlData.each(function (idx) {
    //                 mlData.setItemLayout(idx, [
    //                     fromData.getItemLayout(idx),
    //                     toData.getItemLayout(idx)
    //                 ]);
    //             });
    //             this.markerGroupMap.get(seriesModel.id).updateLayout();
    //         }
    //     }, this);
    // },
    updateTransform: function (markLineModel, ecModel, api) {
      ecModel.eachSeries(function (seriesModel) {
        var mlModel = seriesModel.markLineModel;

        if (mlModel) {
          var mlData = mlModel.getData();
          var fromData = mlModel.__from;
          var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol

          fromData.each(function (idx) {
            updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
            updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
          }); // Update layout of line

          mlData.each(function (idx) {
            mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
          });
          this.markerGroupMap.get(seriesModel.id).updateLayout();
        }
      }, this);
    },
    renderSeries: function (seriesModel, mlModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesId = seriesModel.id;
      var seriesData = seriesModel.getData();
      var lineDrawMap = this.markerGroupMap;
      var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw_1());
      this.group.add(lineDraw.group);
      var mlData = createList$1(coordSys, seriesModel, mlModel);
      var fromData = mlData.from;
      var toData = mlData.to;
      var lineData = mlData.line;
      mlModel.__from = fromData;
      mlModel.__to = toData; // Line data for tooltip and formatter

      mlModel.setData(lineData);
      var symbolType = mlModel.get('symbol');
      var symbolSize = mlModel.get('symbolSize');

      if (!util.isArray(symbolType)) {
        symbolType = [symbolType, symbolType];
      }

      if (typeof symbolSize === 'number') {
        symbolSize = [symbolSize, symbolSize];
      } // Update visual and layout of from symbol and to symbol


      mlData.from.each(function (idx) {
        updateDataVisualAndLayout(fromData, idx, true);
        updateDataVisualAndLayout(toData, idx, false);
      }); // Update visual and layout of line

      lineData.each(function (idx) {
        var lineColor = lineData.getItemModel(idx).get('lineStyle.color');
        lineData.setItemVisual(idx, {
          color: lineColor || fromData.getItemVisual(idx, 'color')
        });
        lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
        lineData.setItemVisual(idx, {
          'fromSymbolRotate': fromData.getItemVisual(idx, 'symbolRotate'),
          'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),
          'fromSymbol': fromData.getItemVisual(idx, 'symbol'),
          'toSymbolRotate': toData.getItemVisual(idx, 'symbolRotate'),
          'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),
          'toSymbol': toData.getItemVisual(idx, 'symbol')
        });
      });
      lineDraw.updateData(lineData); // Set host model for tooltip
      // FIXME

      mlData.line.eachItemGraphicEl(function (el, idx) {
        el.traverse(function (child) {
          child.dataModel = mlModel;
        });
      });

      function updateDataVisualAndLayout(data, idx, isFrom) {
        var itemModel = data.getItemModel(idx);
        updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
        data.setItemVisual(idx, {
          symbolRotate: itemModel.get('symbolRotate'),
          symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],
          symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],
          color: itemModel.get('itemStyle.color') || seriesData.getVisual('color')
        });
      }

      lineDraw.__keep = true;
      lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');
    }
  });
  /**
   * @inner
   * @param {module:echarts/coord/*} coordSys
   * @param {module:echarts/model/Series} seriesModel
   * @param {module:echarts/model/Model} mpModel
   */


  function createList$1(coordSys, seriesModel, mlModel) {
    var coordDimsInfos;

    if (coordSys) {
      coordDimsInfos = util.map(coordSys && coordSys.dimensions, function (coordDim) {
        var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

        return util.defaults({
          name: coordDim
        }, info);
      });
    } else {
      coordDimsInfos = [{
        name: 'value',
        type: 'float'
      }];
    }

    var fromData = new List_1(coordDimsInfos, mlModel);
    var toData = new List_1(coordDimsInfos, mlModel); // No dimensions

    var lineData = new List_1([], mlModel);
    var optData = util.map(mlModel.get('data'), util.curry(markLineTransform, seriesModel, coordSys, mlModel));

    if (coordSys) {
      optData = util.filter(optData, util.curry(markLineFilter, coordSys));
    }

    var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {
      return item.value;
    };
    fromData.initData(util.map(optData, function (item) {
      return item[0];
    }), null, dimValueGetter);
    toData.initData(util.map(optData, function (item) {
      return item[1];
    }), null, dimValueGetter);
    lineData.initData(util.map(optData, function (item) {
      return item[2];
    }));
    lineData.hasItemOption = true;
    return {
      from: fromData,
      to: toData,
      line: lineData
    };
  }

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  echarts.registerPreprocessor(function (opt) {
    // Make sure markLine component is enabled
    opt.markLine = opt.markLine || {};
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var _default$2j = MarkerModel_1.extend({
    type: 'markPoint',
    defaultOption: {
      zlevel: 0,
      z: 5,
      symbol: 'pin',
      symbolSize: 50,
      //symbolRotate: 0,
      //symbolOffset: [0, 0]
      tooltip: {
        trigger: 'item'
      },
      label: {
        show: true,
        position: 'inside'
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */













  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  function updateMarkerLayout(mpData, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    mpData.each(function (idx) {
      var itemModel = mpData.getItemModel(idx);
      var point;
      var xPx = number.parsePercent(itemModel.get('x'), api.getWidth());
      var yPx = number.parsePercent(itemModel.get('y'), api.getHeight());

      if (!isNaN(xPx) && !isNaN(yPx)) {
        point = [xPx, yPx];
      } // Chart like bar may have there own marker positioning logic
      else if (seriesModel.getMarkerPosition) {
          // Use the getMarkerPoisition
          point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
        } else if (coordSys) {
          var x = mpData.get(coordSys.dimensions[0], idx);
          var y = mpData.get(coordSys.dimensions[1], idx);
          point = coordSys.dataToPoint([x, y]);
        } // Use x, y if has any


      if (!isNaN(xPx)) {
        point[0] = xPx;
      }

      if (!isNaN(yPx)) {
        point[1] = yPx;
      }

      mpData.setItemLayout(idx, point);
    });
  }

  var _default$2k = MarkerView.extend({
    type: 'markPoint',
    // updateLayout: function (markPointModel, ecModel, api) {
    //     ecModel.eachSeries(function (seriesModel) {
    //         var mpModel = seriesModel.markPointModel;
    //         if (mpModel) {
    //             updateMarkerLayout(mpModel.getData(), seriesModel, api);
    //             this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
    //         }
    //     }, this);
    // },
    updateTransform: function (markPointModel, ecModel, api) {
      ecModel.eachSeries(function (seriesModel) {
        var mpModel = seriesModel.markPointModel;

        if (mpModel) {
          updateMarkerLayout(mpModel.getData(), seriesModel, api);
          this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
        }
      }, this);
    },
    renderSeries: function (seriesModel, mpModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesId = seriesModel.id;
      var seriesData = seriesModel.getData();
      var symbolDrawMap = this.markerGroupMap;
      var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw_1());
      var mpData = createList$2(coordSys, seriesModel, mpModel); // FIXME

      mpModel.setData(mpData);
      updateMarkerLayout(mpModel.getData(), seriesModel, api);
      mpData.each(function (idx) {
        var itemModel = mpData.getItemModel(idx);
        var symbol = itemModel.getShallow('symbol');
        var symbolSize = itemModel.getShallow('symbolSize');
        var symbolRotate = itemModel.getShallow('symbolRotate');
        var isFnSymbol = util.isFunction(symbol);
        var isFnSymbolSize = util.isFunction(symbolSize);
        var isFnSymbolRotate = util.isFunction(symbolRotate);

        if (isFnSymbol || isFnSymbolSize || isFnSymbolRotate) {
          var rawIdx = mpModel.getRawValue(idx);
          var dataParams = mpModel.getDataParams(idx);

          if (isFnSymbol) {
            symbol = symbol(rawIdx, dataParams);
          }

          if (isFnSymbolSize) {
            // FIXME è¿éä¸å¼å®¹ ECharts 2.xï¼2.x è²ä¼¼åæ°æ¯æ´ä¸ªæ°æ®ï¼
            symbolSize = symbolSize(rawIdx, dataParams);
          }

          if (isFnSymbolRotate) {
            symbolRotate = symbolRotate(rawIdx, dataParams);
          }
        }

        mpData.setItemVisual(idx, {
          symbol: symbol,
          symbolSize: symbolSize,
          symbolRotate: symbolRotate,
          color: itemModel.get('itemStyle.color') || seriesData.getVisual('color')
        });
      }); // TODO Text are wrong

      symbolDraw.updateData(mpData);
      this.group.add(symbolDraw.group); // Set host model for tooltip
      // FIXME

      mpData.eachItemGraphicEl(function (el) {
        el.traverse(function (child) {
          child.dataModel = mpModel;
        });
      });
      symbolDraw.__keep = true;
      symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');
    }
  });
  /**
   * @inner
   * @param {module:echarts/coord/*} [coordSys]
   * @param {module:echarts/model/Series} seriesModel
   * @param {module:echarts/model/Model} mpModel
   */


  function createList$2(coordSys, seriesModel, mpModel) {
    var coordDimsInfos;

    if (coordSys) {
      coordDimsInfos = util.map(coordSys && coordSys.dimensions, function (coordDim) {
        var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

        return util.defaults({
          name: coordDim
        }, info);
      });
    } else {
      coordDimsInfos = [{
        name: 'value',
        type: 'float'
      }];
    }

    var mpData = new List_1(coordDimsInfos, mpModel);
    var dataOpt = util.map(mpModel.get('data'), util.curry(markerHelper.dataTransform, seriesModel));

    if (coordSys) {
      dataOpt = util.filter(dataOpt, util.curry(markerHelper.dataFilter, coordSys));
    }

    mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {
      return item.value;
    });
    return mpData;
  }

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // HINT Markpoint can't be used too much
  echarts.registerPreprocessor(function (opt) {
    // Make sure markPoint component is enabled
    opt.markPoint = opt.markPoint || {};
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */



  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  var _default$2l = MarkerModel_1.extend({
    type: 'markArea',
    defaultOption: {
      zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: 'item'
      },
      // markArea should fixed on the coordinate system
      animation: false,
      label: {
        show: true,
        position: 'top'
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: true,
          position: 'top'
        }
      }
    }
  });

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */















  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  // TODO Better on polar
  var markAreaTransform = function (seriesModel, coordSys, maModel, item) {
    var lt = markerHelper.dataTransform(seriesModel, item[0]);
    var rb = markerHelper.dataTransform(seriesModel, item[1]);
    var retrieve = util.retrieve; // FIXME make sure lt is less than rb

    var ltCoord = lt.coord;
    var rbCoord = rb.coord;
    ltCoord[0] = retrieve(ltCoord[0], -Infinity);
    ltCoord[1] = retrieve(ltCoord[1], -Infinity);
    rbCoord[0] = retrieve(rbCoord[0], Infinity);
    rbCoord[1] = retrieve(rbCoord[1], Infinity); // Merge option into one

    var result = util.mergeAll([{}, lt, rb]);
    result.coord = [lt.coord, rb.coord];
    result.x0 = lt.x;
    result.y0 = lt.y;
    result.x1 = rb.x;
    result.y1 = rb.y;
    return result;
  };

  function isInifinity$1(val) {
    return !isNaN(val) && !isFinite(val);
  } // If a markArea has one dim


  function ifMarkLineHasOnlyDim$1(dimIndex, fromCoord, toCoord, coordSys) {
    var otherDimIndex = 1 - dimIndex;
    return isInifinity$1(fromCoord[otherDimIndex]) && isInifinity$1(toCoord[otherDimIndex]);
  }

  function markAreaFilter(coordSys, item) {
    var fromCoord = item.coord[0];
    var toCoord = item.coord[1];

    if (coordSys.type === 'cartesian2d') {
      // In case
      // {
      //  markArea: {
      //    data: [{ yAxis: 2 }]
      //  }
      // }
      if (fromCoord && toCoord && (ifMarkLineHasOnlyDim$1(1, fromCoord, toCoord) || ifMarkLineHasOnlyDim$1(0, fromCoord, toCoord))) {
        return true;
      }
    }

    return markerHelper.dataFilter(coordSys, {
      coord: fromCoord,
      x: item.x0,
      y: item.y0
    }) || markerHelper.dataFilter(coordSys, {
      coord: toCoord,
      x: item.x1,
      y: item.y1
    });
  } // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']


  function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var itemModel = data.getItemModel(idx);
    var point;
    var xPx = number.parsePercent(itemModel.get(dims[0]), api.getWidth());
    var yPx = number.parsePercent(itemModel.get(dims[1]), api.getHeight());

    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else {
      // Chart like bar may have there own marker positioning logic
      if (seriesModel.getMarkerPosition) {
        // Use the getMarkerPoisition
        point = seriesModel.getMarkerPosition(data.getValues(dims, idx));
      } else {
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        var pt = [x, y];
        coordSys.clampData && coordSys.clampData(pt, pt);
        point = coordSys.dataToPoint(pt, true);
      }

      if (coordSys.type === 'cartesian2d') {
        var xAxis = coordSys.getAxis('x');
        var yAxis = coordSys.getAxis('y');
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);

        if (isInifinity$1(x)) {
          point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);
        } else if (isInifinity$1(y)) {
          point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);
        }
      } // Use x, y if has any


      if (!isNaN(xPx)) {
        point[0] = xPx;
      }

      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
    }

    return point;
  }

  var dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];
  MarkerView.extend({
    type: 'markArea',
    // updateLayout: function (markAreaModel, ecModel, api) {
    //     ecModel.eachSeries(function (seriesModel) {
    //         var maModel = seriesModel.markAreaModel;
    //         if (maModel) {
    //             var areaData = maModel.getData();
    //             areaData.each(function (idx) {
    //                 var points = zrUtil.map(dimPermutations, function (dim) {
    //                     return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
    //                 });
    //                 // Layout
    //                 areaData.setItemLayout(idx, points);
    //                 var el = areaData.getItemGraphicEl(idx);
    //                 el.setShape('points', points);
    //             });
    //         }
    //     }, this);
    // },
    updateTransform: function (markAreaModel, ecModel, api) {
      ecModel.eachSeries(function (seriesModel) {
        var maModel = seriesModel.markAreaModel;

        if (maModel) {
          var areaData = maModel.getData();
          areaData.each(function (idx) {
            var points = util.map(dimPermutations, function (dim) {
              return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
            }); // Layout

            areaData.setItemLayout(idx, points);
            var el = areaData.getItemGraphicEl(idx);
            el.setShape('points', points);
          });
        }
      }, this);
    },
    renderSeries: function (seriesModel, maModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesId = seriesModel.id;
      var seriesData = seriesModel.getData();
      var areaGroupMap = this.markerGroupMap;
      var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
        group: new graphic.Group()
      });
      this.group.add(polygonGroup.group);
      polygonGroup.__keep = true;
      var areaData = createList$3(coordSys, seriesModel, maModel); // Line data for tooltip and formatter

      maModel.setData(areaData); // Update visual and layout of line

      areaData.each(function (idx) {
        // Layout
        var points = util.map(dimPermutations, function (dim) {
          return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
        }); // If none of the area is inside coordSys, allClipped is set to be true
        // in layout so that label will not be displayed. See #12591

        var allClipped = true;
        util.each(dimPermutations, function (dim) {
          if (!allClipped) {
            return;
          }

          var xValue = areaData.get(dim[0], idx);
          var yValue = areaData.get(dim[1], idx); // If is infinity, the axis should be considered not clipped

          if ((isInifinity$1(xValue) || coordSys.getAxis('x').containData(xValue)) && (isInifinity$1(yValue) || coordSys.getAxis('y').containData(yValue))) {
            allClipped = false;
          }
        });
        areaData.setItemLayout(idx, {
          points: points,
          allClipped: allClipped
        }); // Visual

        areaData.setItemVisual(idx, {
          color: seriesData.getVisual('color')
        });
      });
      areaData.diff(polygonGroup.__data).add(function (idx) {
        var layout = areaData.getItemLayout(idx);

        if (!layout.allClipped) {
          var polygon = new graphic.Polygon({
            shape: {
              points: layout.points
            }
          });
          areaData.setItemGraphicEl(idx, polygon);
          polygonGroup.group.add(polygon);
        }
      }).update(function (newIdx, oldIdx) {
        var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);

        var layout = areaData.getItemLayout(newIdx);

        if (!layout.allClipped) {
          if (polygon) {
            graphic.updateProps(polygon, {
              shape: {
                points: layout.points
              }
            }, maModel, newIdx);
          } else {
            polygon = new graphic.Polygon({
              shape: {
                points: layout.points
              }
            });
          }

          areaData.setItemGraphicEl(newIdx, polygon);
          polygonGroup.group.add(polygon);
        } else if (polygon) {
          polygonGroup.group.remove(polygon);
        }
      }).remove(function (idx) {
        var polygon = polygonGroup.__data.getItemGraphicEl(idx);

        polygonGroup.group.remove(polygon);
      }).execute();
      areaData.eachItemGraphicEl(function (polygon, idx) {
        var itemModel = areaData.getItemModel(idx);
        var labelModel = itemModel.getModel('label');
        var labelHoverModel = itemModel.getModel('emphasis.label');
        var color$1 = areaData.getItemVisual(idx, 'color');
        polygon.useStyle(util.defaults(itemModel.getModel('itemStyle').getItemStyle(), {
          fill: color.modifyAlpha(color$1, 0.4),
          stroke: color$1
        }));
        polygon.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();
        graphic.setLabelStyle(polygon.style, polygon.hoverStyle, labelModel, labelHoverModel, {
          labelFetcher: maModel,
          labelDataIndex: idx,
          defaultText: areaData.getName(idx) || '',
          isRectText: true,
          autoColor: color$1
        });
        graphic.setHoverStyle(polygon, {});
        polygon.dataModel = maModel;
      });
      polygonGroup.__data = areaData;
      polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');
    }
  });
  /**
   * @inner
   * @param {module:echarts/coord/*} coordSys
   * @param {module:echarts/model/Series} seriesModel
   * @param {module:echarts/model/Model} mpModel
   */

  function createList$3(coordSys, seriesModel, maModel) {
    var coordDimsInfos;
    var areaData;
    var dims = ['x0', 'y0', 'x1', 'y1'];

    if (coordSys) {
      coordDimsInfos = util.map(coordSys && coordSys.dimensions, function (coordDim) {
        var data = seriesModel.getData();
        var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys

        return util.defaults({
          name: coordDim
        }, info);
      });
      areaData = new List_1(util.map(dims, function (dim, idx) {
        return {
          name: dim,
          type: coordDimsInfos[idx % 2].type
        };
      }), maModel);
    } else {
      coordDimsInfos = [{
        name: 'value',
        type: 'float'
      }];
      areaData = new List_1(coordDimsInfos, maModel);
    }

    var optData = util.map(maModel.get('data'), util.curry(markAreaTransform, seriesModel, coordSys, maModel));

    if (coordSys) {
      optData = util.filter(optData, util.curry(markAreaFilter, coordSys));
    }

    var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {
      return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
    } : function (item) {
      return item.value;
    };
    areaData.initData(optData, null, dimValueGetter);
    areaData.hasItemOption = true;
    return areaData;
  }

  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */







  /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
  echarts.registerPreprocessor(function (opt) {
    // Make sure markArea component is enabled
    opt.markArea = opt.markArea || {};
  });

  var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('slice');
  var USES_TO_LENGTH$6 = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

  var SPECIES$5 = wellKnownSymbol('species');
  var nativeSlice$1 = [].slice;
  var max$4 = Math.max;

  // `Array.prototype.slice` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.slice
  // fallback for not array-like ES3 strings and DOM objects
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$6 }, {
    slice: function slice(start, end) {
      var O = toIndexedObject(this);
      var length = toLength(O.length);
      var k = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === undefined ? length : end, length);
      // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
      var Constructor, result, n;
      if (isArray(O)) {
        Constructor = O.constructor;
        // cross-realm fallback
        if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
          Constructor = undefined;
        } else if (isObject(Constructor)) {
          Constructor = Constructor[SPECIES$5];
          if (Constructor === null) Constructor = undefined;
        }
        if (Constructor === Array || Constructor === undefined) {
          return nativeSlice$1.call(O, k, fin);
        }
      }
      result = new (Constructor === undefined ? Array : Constructor)(max$4(fin - k, 0));
      for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
      result.length = n;
      return result;
    }
  });

  var propertyIsEnumerable = objectPropertyIsEnumerable.f;

  // `Object.{ entries, values }` methods implementation
  var createMethod$3 = function (TO_ENTRIES) {
    return function (it) {
      var O = toIndexedObject(it);
      var keys = objectKeys(O);
      var length = keys.length;
      var i = 0;
      var result = [];
      var key;
      while (length > i) {
        key = keys[i++];
        if (!descriptors || propertyIsEnumerable.call(O, key)) {
          result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
        }
      }
      return result;
    };
  };

  var objectToArray = {
    // `Object.entries` method
    // https://tc39.github.io/ecma262/#sec-object.entries
    entries: createMethod$3(true),
    // `Object.values` method
    // https://tc39.github.io/ecma262/#sec-object.values
    values: createMethod$3(false)
  };

  var $values = objectToArray.values;

  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  _export({ target: 'Object', stat: true }, {
    values: function values(O) {
      return $values(O);
    }
  });

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  var arrayWithHoles = _arrayWithHoles;

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  var iterableToArrayLimit = _iterableToArrayLimit;

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var nonIterableRest = _nonIterableRest;

  function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
  }

  var slicedToArray = _slicedToArray;

  var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var classCallCheck = _classCallCheck;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var createClass = _createClass;

  /**
   *
   declare module ExcelRows {
    export interface cell {
        text: string;
    }
    export interface Cells {
      0: cell;
      1: cell;
      2: cell;
    }
    export interface ExcelRows {
      cells: Cells;
    }
  }
   */

  /**
    *
    BinaryMatrix = [
      [any, any, any, ...],
      [any, any, any, ...],
      [any, any, any, ...],
    ]

    ExcelDataType = [
      {
        cells: {
          0: { text: any },
          1: { text: any },
          2: { text: any }
        }
      },
      {
        cells: {
          0: { text: any },
          1: { text: any },
          2: { text: any }
        }
      },
    ]
    */
  var Parser = /*#__PURE__*/function () {
    function Parser() {
      classCallCheck(this, Parser);
    }

    createClass(Parser, null, [{
      key: "dataset2excel",

      /**
       *
       * @param {*} dataset ExcelDataType
       */
      value: function dataset2excel(dataset) {
        return dataset.map(function (item) {
          return {
            cells: {
              0: {
                text: item.x
              },
              1: {
                text: item.y
              },
              2: {
                text: item.s
              }
            }
          };
        });
      }
      /**
       *
        [
          [1,2,3,4],
          [5,6,7,8],
          [9,10,11,12]
        ]
       * @param {Object} BinaryMatrix
       * @returns {Object} ExcelDataType
       */

    }, {
      key: "binaryMatrix2excel",
      value: function binaryMatrix2excel() {
        var binaryMatrix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var excelData = binaryMatrix.map(function (row, rowIndex) {
          // cells: {
          //   0: { text: item.x },
          //   1: { text: item.y },
          //   2: { text: item.s }
          // }
          var cells = {};
          row.forEach(function (cellValue, cellIndex) {
            cells[cellIndex] = {
              text: cellValue
            };
          });
          return {
            cells: cells
          };
        });
        return excelData;
      }
    }, {
      key: "excel2chartDataSet",
      value: function excel2chartDataSet(excelData) {
        var rowsArray = Object.values(excelData.rows).filter(function (item) {
          return _typeof_1(item) === 'object';
        });
        var dataset = rowsArray.map(function (row) {
          var _Object$values$map = Object.values(row.cells).map(function (item) {
            return item.text;
          }),
              _Object$values$map2 = slicedToArray(_Object$values$map, 3),
              x = _Object$values$map2[0],
              y = _Object$values$map2[1],
              s = _Object$values$map2[2];

          return {
            x: x,
            y: y,
            s: s
          };
        });
        return dataset;
      }
    }, {
      key: "excel2BinaryMatrix",
      value: function excel2BinaryMatrix(excelData) {
        var rowsArray = Object.values(excelData.rows).filter(function (item) {
          return _typeof_1(item) === 'object';
        });
        var dataset = rowsArray.map(function (row) {
          // [1,2,3,4]
          var cells = Object.values(row.cells).map(function (item) {
            return item.text;
          });
          return cells;
        });
        console.log('dataset', dataset);
        return dataset;
      }
      /**
      *
      * @param {Array} csvArray
      *    [
             ['æ¥æ', 'éå®é'],
             ["1æ1æ¥",123],
             ["1æ2æ¥",1223],
             ["1æ3æ¥",2123],
             ["1æ4æ¥",4123],
             ["1æ5æ¥",3123],
             ["1æ6æ¥",7123]
           ]
      * @returns {Object}
         {
           columns: ['æ¥æ', 'éå®é'],
           rows:[
             { 'æ¥æ': '1æ1æ¥', 'éå®é': 123 },
             { 'æ¥æ': '1æ2æ¥', 'éå®é': 1223 },
             { 'æ¥æ': '1æ3æ¥', 'éå®é': 2123 },
             { 'æ¥æ': '1æ4æ¥', 'éå®é': 4123 },
             { 'æ¥æ': '1æ5æ¥', 'éå®é': 3123 },
             { 'æ¥æ': '1æ6æ¥', 'éå®é': 7123 }
           ]
         }
      */

    }, {
      key: "csv2VChartJson",
      value: function csv2VChartJson(csvArray) {
        var columns = csvArray[0];
        var rows = csvArray.slice(1);
        var json = {
          columns: columns,
          rows: rows.map(function (row, index) {
            var obj = {};
            columns.forEach(function (col, colIndex) {
              obj[col.trim()] = row[colIndex];
            });
            return obj;
          })
        };
        return json;
      }
    }]);

    return Parser;
  }();

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-02 16:12:09
   * @LastEditTime : 2020-11-17 16:44:01
   * @Description :
   */

  var LbpLineChart = {
    name: 'lbp-line-chart',
    // mixins: [ChartMixin],
    props: {
      width: {
        default: 120
      },
      height: {
        default: 120
      },
      dataset: PropTypes.excel({
        defaultValue: function defaultValue() {
          return [['æ¥æ', 'éå®é'], ['1æ1æ¥', 123], ['1æ2æ¥', 1223], ['1æ3æ¥', 2123], ['1æ4æ¥', 4123], ['1æ5æ¥', 3123], ['1æ6æ¥', 7123]];
        }
      }),
      type: PropTypes.string({
        label: 'ç±»å',
        defaultValue: 'line',
        visible: false
      }),
      colors: PropTypes.colors({
        label: 'é¢è²é¢æ¿',
        defaultValue: function defaultValue() {
          return [// https://github.com/ElemeFE/v-charts/blob/01ebb541a5d905047dd52957ae0898d529342235/src/constants.js#L20
          '#19d4ae', '#5ab1ef', '#fa6e86', '#ffb980', '#0067a6', '#c4b4e4', '#d87a80', '#9cbbff', '#d9d0c7', '#87a997', '#d49ea2', '#5b4947', '#7ba3a8'];
        }
      })
    },
    data: function data() {
      return {
        option: {}
      };
    },
    render: function render() {
      var h = arguments[0];
      var chartData = Parser.csv2VChartJson(this.dataset);

      switch (this.type) {
        case 'line':
          return h(line_common, {
            "attrs": {
              "data": chartData,
              "colors": this.colors
            }
          });

        case 'histogram':
          return h(histogram_common, {
            "attrs": {
              "data": chartData,
              "colors": this.colors
            }
          });

        case 'pie':
          return h(pie_common, {
            "attrs": {
              "data": chartData,
              "colors": this.colors
            }
          });

        case 'funnel':
          return h(funnel_common, {
            "attrs": {
              "data": chartData,
              "colors": this.colors
            }
          });

        case 'radar':
          return h(radar_common, {
            "attrs": {
              "data": chartData,
              "colors": this.colors
            }
          });

        default:
          return null;
      }
    },
    mounted: function mounted() {// this.renderChart()
    }
  };

  // `Array.prototype.{ reduce, reduceRight }` methods implementation
  var createMethod$4 = function (IS_RIGHT) {
    return function (that, callbackfn, argumentsLength, memo) {
      aFunction$1(callbackfn);
      var O = toObject(that);
      var self = indexedObject(O);
      var length = toLength(O.length);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self) {
          memo = self[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw TypeError('Reduce of empty array with no initial value');
        }
      }
      for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }
      return memo;
    };
  };

  var arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
    left: createMethod$4(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
    right: createMethod$4(true)
  };

  var $reduce = arrayReduce.left;



  var STRICT_METHOD$3 = arrayMethodIsStrict('reduce');
  var USES_TO_LENGTH$7 = arrayMethodUsesToLength('reduce', { 1: 0 });

  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  _export({ target: 'Array', proto: true, forced: !STRICT_METHOD$3 || !USES_TO_LENGTH$7 }, {
    reduce: function reduce(callbackfn /* , initialValue */) {
      return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  function sum() {
    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var key = arguments.length > 1 ? arguments[1] : undefined;
    return arr.map(function (item) {
      return item[key];
    }).reduce(function (a, b) {
      return a + b;
    }, 0);
  }

  var LbpTable = {
    name: 'lbp-table',
    data: function data() {
      return {
        mainTableWrapperEle: null,
        mainTableEle: null,
        fixedTableWrapperEle: null,
        fixedTableEle: null
      };
    },
    props: {
      width: {
        default: 120
      },
      height: {
        default: 120
      },
      theme: PropTypes.string({
        defaultValue: '',
        label: 'ä¸»é¢',
        visible: false
      }),
      columnWidth: PropTypes.number({
        label: 'æ¯åå®½åº¦(px)',
        defaultValue: 100
      }),
      freezeCount: PropTypes.number({
        label: 'å»ç»åæ°(px)',
        defaultValue: 0
      }),
      dataset: PropTypes.excel({
        defaultValue: function defaultValue() {
          return [['åA', 'åB', 'åC'], ['ââââ', 'ââââ', 'ââââ'], ['ââââ', 'ââââ', 'ââââ'], ['ââââ', 'ââââ', 'ââââ']];
        }
      })
    },
    watch: {
      freezeCount: function freezeCount() {
        var _this = this;

        setTimeout(function () {
          _this.setFixedTableStyle();
        }, 100);
      }
    },
    render: function render() {
      var _this2 = this;

      var h = arguments[0];

      var renderCell = function renderCell(cell) {
        return h("td", [h("div", {
          "class": "cell"
        }, [cell])]);
      };

      var renderTable = function renderTable() {
        var tableData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var tableClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var tableStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var headers = tableData.length ? tableData[0] : [];
        var columnsCount = headers.length;
        return h("table", {
          "class": tableClass,
          "style": tableStyle
        }, [h("colgroup", [toConsumableArray(Array(columnsCount)).map(function (item, i) {
          return h("col", {
            "style": {
              width: _this2.columnWidth + 'px'
            }
          });
        })]), h("tbody", [tableData.map(function (row) {
          return h("tr", [row.map(renderCell)]);
        })])]);
      };

      return h("div", {
        "class": ['lbp-table', this.theme],
        "ref": "lbpTable"
      }, [h("div", {
        "class": "main-table-wrapper"
      }, [renderTable(this.dataset)]), h("div", {
        "class": "fixed-table-wrapper",
        "directives": [{
          name: "show",
          value: "freezeCount"
        }]
      }, [renderTable(this.dataset, 'left-table')])]);
    },
    methods: {
      getFixedColsWidth: function getFixedColsWidth() {
        var tableHeaders = [].slice.apply(this.mainTableEle.querySelectorAll('tr:first-child > td'));
        var freezeColsWidth = sum(tableHeaders.slice(0, +this.freezeCount), 'offsetWidth');
        return freezeColsWidth;
      },
      setFixedTableStyle: function setFixedTableStyle() {
        this.fixedTableWrapperEle.style.width = "".concat(this.getFixedColsWidth(), "px");
        this.fixedTableWrapperEle.style.height = "calc(100% - ".concat(this.mainTableWrapperEle.offsetHeight - this.mainTableWrapperEle.scrollHeight, "px)");
      },
      setTableWidth: function setTableWidth() {
        var parentWidth = this.$el.parentNode.style.width;
        this.fixedTableEle.style.width = this.mainTableEle.style.width = parentWidth;
      },
      initElements: function initElements() {
        var root = this.$el;
        this.mainTableWrapperEle = root.querySelector('.main-table-wrapper');
        this.mainTableEle = root.querySelector('.main-table-wrapper > table');
        this.fixedTableWrapperEle = root.querySelector('.fixed-table-wrapper');
        this.fixedTableEle = root.querySelector('.left-table');
      },
      __resizeHandler: function __resizeHandler() {
        this.setTableWidth();

        if (this.freezeCount) {
          this.setFixedTableStyle();
        }
      }
    },
    mounted: function mounted() {
      this.initElements();
      this.setTableWidth();
      this.setFixedTableStyle();
      resizeDetector.addListener(this.$refs.lbpTable, this.__resizeHandler);
    },
    destroy: function destroy() {
      resizeDetector.removeListener(this.$el, this.__resizeHandler);
    }
  };

  /**
   *
   declare module ExcelRows {
    export interface cell {
        text: string;
    }
    export interface Cells {
      0: cell;
      1: cell;
      2: cell;
    }
    export interface ExcelRows {
      cells: Cells;
    }
  }
   */

  /**
    *
    BinaryMatrix = [
      [any, any, any, ...],
      [any, any, any, ...],
      [any, any, any, ...],
    ]

    ExcelDataType = [
      {
        cells: {
          0: { text: any },
          1: { text: any },
          2: { text: any }
        }
      },
      {
        cells: {
          0: { text: any },
          1: { text: any },
          2: { text: any }
        }
      },
    ]
    */
  var Parser$1 = /*#__PURE__*/function () {
    function Parser() {
      classCallCheck(this, Parser);
    }

    createClass(Parser, null, [{
      key: "dataset2excel",

      /**
       *
       * @param {*} dataset ExcelDataType
       */
      value: function dataset2excel(dataset) {
        return dataset.map(function (item) {
          return {
            cells: {
              0: {
                text: item.x
              },
              1: {
                text: item.y
              },
              2: {
                text: item.s
              }
            }
          };
        });
      }
      /**
       *
        [
          [1,2,3,4],
          [5,6,7,8],
          [9,10,11,12]
        ]
       * @param {Object} BinaryMatrix
       * @returns {Object} ExcelDataType
       */

    }, {
      key: "binaryMatrix2excel",
      value: function binaryMatrix2excel() {
        var binaryMatrix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var excelData = binaryMatrix.map(function (row, rowIndex) {
          // cells: {
          //   0: { text: item.x },
          //   1: { text: item.y },
          //   2: { text: item.s }
          // }
          var cells = {};
          row.forEach(function (cellValue, cellIndex) {
            cells[cellIndex] = {
              text: cellValue
            };
          });
          return {
            cells: cells
          };
        });
        return excelData;
      }
    }, {
      key: "excel2chartDataSet",
      value: function excel2chartDataSet(excelData) {
        var rowsArray = Object.values(excelData.rows).filter(function (item) {
          return _typeof_1(item) === 'object';
        });
        var dataset = rowsArray.map(function (row) {
          var _Object$values$map = Object.values(row.cells).map(function (item) {
            return item.text;
          }),
              _Object$values$map2 = slicedToArray(_Object$values$map, 3),
              x = _Object$values$map2[0],
              y = _Object$values$map2[1],
              s = _Object$values$map2[2];

          return {
            x: x,
            y: y,
            s: s
          };
        });
        return dataset;
      }
    }, {
      key: "excel2BinaryMatrix",
      value: function excel2BinaryMatrix(excelData) {
        var rowsArray = Object.values(excelData.rows).filter(function (item) {
          return _typeof_1(item) === 'object';
        });
        var dataset = rowsArray.map(function (row) {
          // [1,2,3,4]
          var cells = Object.values(row.cells).map(function (item) {
            return item.text;
          });
          return cells;
        });
        console.log('dataset', dataset);
        return dataset;
      }
      /**
      *
      * @param {Array} csvArray
      *    [
             ['æ¥æ', 'éå®é'],
             ["1æ1æ¥",123],
             ["1æ2æ¥",1223],
             ["1æ3æ¥",2123],
             ["1æ4æ¥",4123],
             ["1æ5æ¥",3123],
             ["1æ6æ¥",7123]
           ]
      * @returns {Object}
         {
           columns: ['æ¥æ', 'éå®é'],
           rows:[
             { 'æ¥æ': '1æ1æ¥', 'éå®é': 123 },
             { 'æ¥æ': '1æ2æ¥', 'éå®é': 1223 },
             { 'æ¥æ': '1æ3æ¥', 'éå®é': 2123 },
             { 'æ¥æ': '1æ4æ¥', 'éå®é': 4123 },
             { 'æ¥æ': '1æ5æ¥', 'éå®é': 3123 },
             { 'æ¥æ': '1æ6æ¥', 'éå®é': 7123 }
           ]
         }
      */

    }, {
      key: "csv2VChartJson",
      value: function csv2VChartJson(csvArray) {
        var columns = csvArray[0];
        var rows = csvArray.slice(1);
        var json = {
          columns: columns,
          rows: rows.map(function (row, index) {
            var obj = {};
            columns.forEach(function (col, colIndex) {
              obj[col.trim()] = row[colIndex];
            });
            return obj;
          })
        };
        return json;
      }
    }]);

    return Parser;
  }();

  var LbpNewsList = {
    name: 'lbp-news-list',
    props: {
      width: {
        default: 120
      },
      height: {
        default: 120
      },
      dataset: PropTypes.excel({
        defaultValue: function defaultValue() {
          return [['æ°é»æ é¢', 'æè¦', 'é¾æ¥', 'æ¥æ', 'æ¥æº'], ['1 . é²ç­H5 å¯è§åæ­å»ºå¹³å°ï¼', 'é²ç­H5-æ¯ä¸æ¬¾åºäºå¸¸è§ä¸å¡ç»ä»¶ï¼éè¿ææ½çå½¢å¼ï¼çæé¡µé¢çå¯è§åæ­å»ºç³»ç»ï¼æä»¬çåå¿ä¹æ¯å¸æè½éè¿å·¥ç¨åçææ®µï¼æé«ç®åH5é¡µé¢çå¶ä½æç', 'https://luban-h5.com/', '2020-01-01', 'é²ç­H5'], ['2 . é²ç­H5-å¼æºçå¯è§åæ­å»ºå¹³å°ï¼', 'en: web design tool || mobile page builder/editor || mini webflow for mobile page. zh: ç±»ä¼¼æä¼ç§çH5å¶ä½ãå»ºç«å·¥å·ãå¯è§åæ­å»ºç³»ç».', 'https://github.com/ly525/luban-h5', '2020-01-01', 'é²ç­H5(github)']];
        }
      })
    },
    data: function data() {
      return {
        option: {}
      };
    },
    render: function render() {
      var h = arguments[0];

      /**
       * rows[0] {
          'æ°é»æ é¢': '',
          'æè¦': '',
          'é¾æ¥': '',
          'æ¥æ': '',
          'æ¥æº': '',
        }
       */
      var _Parser$csv2VChartJso = Parser$1.csv2VChartJson(this.dataset),
          rows = _Parser$csv2VChartJso.rows;

      return h("div", {
        "class": "newslist",
        "style": "border-color: transparent;"
      }, [rows.map(function (item, i) {
        return h("div", {
          "class": "news-item"
        }, [h("a", {
          "attrs": {
            "href": item['é¾æ¥'],
            "target": "_blank"
          },
          "class": "link"
        }, [h("div", {
          "class": "title"
        }, [item['æ°é»æ é¢']])]), h("div", {
          "class": "content"
        }, [item['æè¦']]), h("div", {
          "class": "source"
        }, [item['æ¥æº']]), h("div", {
          "class": "time"
        }, [item['æ¥æ']])]);
      })]);
    },
    mounted: function mounted() {// this.renderChart()
    }
  };

  var _plugins = [{
    i18nTitle: {
      'en-US': 'RadarChart',
      'zh-CN': 'é·è¾¾å¾'
    },
    title: 'é·è¾¾å¾',
    icon: 'line-chart',
    visible: true,
    name: LbpLineChart.name,
    component: LbpLineChart,
    shortcutProps: {
      type: 'radar'
    }
  }, {
    i18nTitle: {
      'en-US': 'LineChart',
      'zh-CN': 'æçº¿å¾'
    },
    title: 'æçº¿å¾',
    icon: 'line-chart',
    visible: true,
    name: LbpLineChart.name,
    component: LbpLineChart,
    shortcutProps: {
      type: 'line'
    }
  }, {
    i18nTitle: {
      'en-US': 'LineChart',
      'zh-CN': 'æ±ç¶å¾'
    },
    title: 'æ±ç¶å¾',
    icon: 'bar-chart',
    visible: true,
    name: LbpLineChart.name,
    component: LbpLineChart,
    shortcutProps: {
      type: 'histogram'
    }
  }, {
    i18nTitle: {
      'en-US': 'LineChart',
      'zh-CN': 'é¥¼ç¶å¾'
    },
    title: 'é¥¼ç¶å¾',
    icon: 'pie-chart',
    visible: true,
    name: LbpLineChart.name,
    component: LbpLineChart,
    shortcutProps: {
      type: 'pie'
    }
  }, {
    i18nTitle: {
      'en-US': 'LineChart',
      'zh-CN': 'æ¼æå¾'
    },
    title: 'æ¼æå¾',
    icon: 'filter',
    visible: true,
    name: LbpLineChart.name,
    component: LbpLineChart,
    shortcutProps: {
      type: 'funnel'
    }
  }, {
    title: 'å¬å',
    i18nTitle: {
      'en-US': 'Notice-Bar',
      'zh-CN': 'å¬å'
    },
    icon: 'volume-up',
    visible: true,
    name: LbpNoticeBar.name,
    component: LbpNoticeBar
  }, {
    title: 'è¯å',
    i18nTitle: {
      'en-US': 'Rate',
      'zh-CN': 'è¯å'
    },
    icon: 'star-o',
    visible: true,
    name: LbpRate.name,
    component: LbpRate
  }, {
    title: 'å¾ç',
    i18nTitle: {
      'en-US': 'Picture',
      'zh-CN': 'å¾ç'
    },
    icon: 'photo',
    visible: true,
    name: LbpPicture.name,
    component: LbpPicture
  }, {
    i18nTitle: {
      'en-US': 'Text',
      'zh-CN': 'æå­'
    },
    title: 'æå­',
    icon: 'text-width',
    visible: true,
    name: LbpText.name,
    component: LbpText
  }, {
    i18nTitle: {
      'en-US': 'Button',
      'zh-CN': 'æ®éæé®'
    },
    title: 'æ®éæé®',
    icon: 'hand-pointer-o',
    visible: true,
    name: LbpButton.name,
    component: LbpButton
  }, {
    i18nTitle: {
      'en-US': 'Carousel',
      'zh-CN': 'è½®æ­å¾'
    },
    title: 'è½®æ­å¾',
    icon: 'photo',
    visible: true,
    name: LbpSlide.name,
    component: LbpSlide
  }, {
    i18nTitle: {
      'en-US': 'Map',
      'zh-CN': 'å°å¾'
    },
    title: 'å°å¾',
    icon: 'map-o',
    visible: true,
    name: __vue_component__.name,
    component: __vue_component__
  }, {
    i18nTitle: {
      'en-US': 'Video',
      'zh-CN': 'è§é¢'
    },
    title: 'è§é¢',
    icon: 'file-video-o',
    visible: true,
    name: LbpVideo.name,
    component: LbpVideo
  }, {
    i18nTitle: {
      'en-US': 'Form Input',
      'zh-CN': 'è¡¨åè¾å¥'
    },
    title: 'è¡¨åè¾å¥',
    icon: 'pencil-square-o',
    visible: true,
    name: LbpFormInput.name,
    component: LbpFormInput
  }, {
    i18nTitle: {
      'en-US': 'Form Submit',
      'zh-CN': 'è¡¨åæäº¤'
    },
    title: 'è¡¨åæäº¤',
    icon: 'hand-pointer-o',
    visible: true,
    name: LbpFormButton.name,
    component: LbpFormButton
  }, {
    i18nTitle: {
      'en-US': 'Form Checkbox',
      'zh-CN': 'è¡¨åå¤é'
    },
    title: 'è¡¨åå¤é',
    icon: 'check-square-o',
    visible: true,
    name: LbpFormCheckboxGroup.name,
    component: LbpFormCheckboxGroup
  }, {
    i18nTitle: {
      'en-US': 'Form Radio',
      'zh-CN': 'è¡¨ååé'
    },
    title: 'è¡¨ååé',
    icon: 'dot-circle-o',
    visible: true,
    name: LbpFormRadioGroup.name,
    component: LbpFormRadioGroup
  }, {
    i18nTitle: {
      'en-US': 'Background',
      'zh-CN': 'èæ¯'
    },
    title: 'èæ¯',
    icon: 'dot-circle-o',
    visible: false,
    name: LbpBackground.name,
    component: LbpBackground
  }, {
    i18nTitle: {
      'en-US': 'BgMusic',
      'zh-CN': 'èæ¯é³ä¹'
    },
    title: 'èæ¯é³ä¹',
    icon: 'music',
    visible: true,
    name: LbpBgMusic.name,
    component: LbpBgMusic
  }, {
    i18nTitle: {
      'en-US': 'Table(Default)',
      'zh-CN': 'é»è®¤è¡¨æ ¼'
    },
    icon: 'table',
    visible: true,
    name: LbpTable.name,
    component: LbpTable
  }, {
    i18nTitle: {
      'en-US': 'Table(Stripe)',
      'zh-CN': '(æé©¬çº¿)è¡¨æ ¼'
    },
    icon: 'table',
    visible: true,
    name: LbpTable.name,
    component: LbpTable,
    shortcutProps: {
      theme: 'lbp-table-theme-stripe'
    }
  }, {
    i18nTitle: {
      'en-US': 'Table(LightBlue)',
      'zh-CN': '(æ·¡èè²)è¡¨æ ¼'
    },
    icon: 'table',
    visible: true,
    name: LbpTable.name,
    component: LbpTable,
    shortcutProps: {
      theme: 'lbp-table-theme-light-blue'
    }
  }, {
    i18nTitle: {
      'en-US': 'NewsList',
      'zh-CN': 'æ°é»åè¡¨'
    },
    title: 'æ°é»åè¡¨',
    icon: 'list',
    visible: true,
    name: LbpNewsList.name,
    component: LbpNewsList
  }];

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-16 15:12:42
   * @LastEditTime : 2020-11-16 15:12:49
   * @Description :
   */
  var LbpPlugin = function LbpPlugin() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        name = _ref.name,
        _ref$i18nTitle = _ref.i18nTitle,
        i18nTitle = _ref$i18nTitle === void 0 ? {} : _ref$i18nTitle,
        title = _ref.title,
        icon = _ref.icon,
        visible = _ref.visible,
        component = _ref.component;

    classCallCheck(this, LbpPlugin);

    this.name = name;
    this.i18nTitle = i18nTitle;
    this.title = title;
    this.icon = icon;
    this.visible = visible;
    this.component = component;
  };

  var LbpPluginController = /*#__PURE__*/function () {
    function LbpPluginController() {
      var _this = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [],
          _ref$plugins = _ref.plugins,
          plugins = _ref$plugins === void 0 ? [] : _ref$plugins;

      classCallCheck(this, LbpPluginController);

      this._plugins = [];
      this._pluginsMap = {};
      plugins.forEach(function (v) {
        return _this.registerPlugin(v);
      });
    }

    createClass(LbpPluginController, [{
      key: "registerPlugin",
      value: function registerPlugin() {
        var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (!option.name) return;
        var plugin = new LbpPlugin(option);

        this._plugins.push(plugin);

        this._pluginsMap[plugin.name] = plugin;
      }
    }, {
      key: "getPlugins",
      value: function getPlugins() {
        return this._plugins;
      }
    }, {
      key: "getPluginsMap",
      value: function getPluginsMap() {
        return this._pluginsMap;
      }
    }, {
      key: "getPlugin",
      value: function getPlugin(name) {
        return this.getPluginsMap()[name];
      }
    }]);

    return LbpPluginController;
  }();

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-11 19:49:25
   * @LastEditTime : 2020-11-16 15:18:02
   * @Description :
   */
  var lbpPluginController = new LbpPluginController({
    plugins: _plugins
  });

  var enUSLang = {
    app: {
      title: 'Luban H5'
    },
    header: {
      chineseDocument: 'ä¸­æææ¡£',
      englishDocument: 'Document(En)',
      chat: 'Discussion Group',
      //
      logout: 'Logout'
    },
    sidebar: {
      myWorks: 'My Works',
      dataCenter: 'Data Center',
      basicData: 'Basic Data',
      templateCenter: 'Templates',
      freeTemplates: 'Templates List',
      accountCenter: 'Account'
    },
    workCard: {
      description: 'Desc',
      createTime: 'Time',
      useNow: 'Use it Now',
      preview: 'Preview',
      edit: 'Edit',
      createNewWork: 'Create New',
      view: 'View Work'
    },
    basicData: {
      viewData: 'View Data'
    },
    editor: {
      sidebar: {
        components: 'Components',
        pages: 'Pages',
        templates: 'Templates',
        tree: 'Tree'
      },
      pageManager: {
        title: 'Page {index}',
        action: {
          add: 'Add Page',
          copy: 'Copy Page',
          delete: 'Delete Page'
        }
      },
      header: {
        preview: 'Preview',
        save: 'Save',
        publish: 'Publish',
        setAsTemplate: 'Set As Template'
      },
      centerPanel: {
        mode: {
          edit: 'Edit',
          preview: 'Preview'
        },
        contextMenu: {
          copy: 'Copy',
          delete: 'Delete',
          moveToTop: 'Move To Top',
          moveToBottom: 'Move To Bottom',
          moveUp: 'Move Up',
          moveDown: 'Move Down',
          showOnlyButton: 'showOnlyButton',
          showExcludePicture: 'showExcludePicture'
        }
      },
      fixedTool: {
        undo: 'Undo{hotkey}',
        redo: 'Redo{hotkey}',
        preview: 'Preview',
        copyCurrentPage: 'CopyCurrentPage',
        copyCurrentElement: 'copyCurrentElement',
        importPSD: 'Import PSD',
        zoomIn: 'Zoom In{hotkey}',
        zoomOut: 'Zoom Out{hotkey}',
        issues: 'Issues'
      },
      editPanel: {
        tab: {
          prop: 'Prop',
          animation: 'Animation',
          action: 'Action',
          script: 'Script',
          page: 'Page'
        },
        animation: {
          add: 'Add',
          run: 'Run',
          type: 'Type',
          duration: 'Duration',
          delay: 'Delay',
          iteration: 'Iteration',
          inifinite: 'Inifinite',
          list: 'Select Animation',
          title: 'Animation {index}'
        },
        common: {
          empty: 'Select an element first please!'
        }
      },
      tip: {
        componentUsage: 'Tip: just {0} on component',
        click: 'click/drag'
      }
    }
  };

  /*
   * @Author: ly525
   * @Date: 2019-11-24 18:51:58
   * @LastEditors: ly525
   * @LastEditTime: 2020-10-13 01:29:21
   * @FilePath: /h5/src/locales/lang/zh-CN.js
   * @Github: https://github.com/ly525/luban-h5
   * @Description: Do not edit
   * @Copyright 2018 - 2020 luban-h5. All Rights Reserved
   */
  var zhCNLang = {
    app: {
      title: 'é²ç­ H5'
    },
    header: {
      chineseDocument: 'ä¸­æææ¡£',
      englishDocument: 'è±æææ¡£',
      chat: 'äº¤æµç¾¤',
      //  Discussion Group
      logout: 'éåºç»å½'
    },
    sidebar: {
      myWorks: 'æçä½å',
      dataCenter: 'æ°æ®ä¸­å¿',
      basicData: 'åºç¡æ°æ®',
      templateCenter: 'æ¨¡æ¿ä¸­å¿',
      freeTemplates: 'æ¨¡æ¿åè¡¨',
      accountCenter: 'è´¦å·ä¸­å¿'
    },
    workCard: {
      description: 'æè¿°',
      createTime: 'æ¶é´',
      useNow: 'ç«å³æ¥ç',
      preview: 'é¢è§',
      createNewWork: 'åå»ºæ°ä½å',
      edit: 'ç¼è¾',
      view: 'æ¥çä½å'
    },
    basicData: {
      viewData: 'æ¥çæ°æ®'
    },
    editor: {
      sidebar: {
        components: 'ç»ä»¶åè¡¨',
        pages: 'é¡µé¢ç®¡ç',
        templates: 'æ¨¡æ¿',
        tree: 'ç»ä»¶æ '
      },
      pageManager: {
        title: 'ç¬¬{index}é¡µé¢',
        action: {
          add: 'æ°å¢é¡µé¢',
          copy: 'å¤å¶é¡µé¢',
          delete: 'å é¤é¡µé¢'
        }
      },
      header: {
        preview: 'é¢è§',
        save: 'ä¿å­',
        publish: 'åå¸',
        setAsTemplate: 'è®¾ç½®ä¸ºæ¨¡æ¿'
      },
      centerPanel: {
        mode: {
          edit: 'Edit',
          preview: 'Preview'
        },
        contextMenu: {
          copy: 'å¤å¶',
          delete: 'å é¤',
          moveToTop: 'ç½®é¡¶',
          moveToBottom: 'ç½®åº',
          moveUp: 'ä¸ç§»',
          moveDown: 'ä¸ç§»',
          showOnlyButton: 'åªææé®ææ¾ç¤ºè¯¥éé¡¹',
          showExcludePicture: 'é¤äºå¾çé½æ¾ç¤ºè¯¥éé¡¹'
        }
      },
      fixedTool: {
        undo: 'æ¤é{hotkey}',
        redo: 'éå{hotkey}',
        preview: 'é¢è§',
        copyCurrentPage: 'å¤å¶å½åé¡µé¢',
        copyCurrentElement: 'å¤å¶å½ååç´ ',
        importPSD: 'å¯¼å¥PSD',
        zoomIn: 'ç¼©å°{hotkey}',
        zoomOut: 'æ¾å¤§{hotkey}',
        issues: 'å¸¸è§é®é¢'
      },
      editPanel: {
        tab: {
          prop: 'å±æ§',
          animation: 'å¨ç»',
          action: 'å¨ä½',
          script: 'èæ¬',
          page: 'é¡µé¢'
        },
        animation: {
          add: 'æ·»å å¨ç»',
          run: 'è¿è¡å¨ç»',
          type: 'å¨ç»ç±»å',
          duration: 'å¨ç»æ¶é¿',
          delay: 'å¨ç»å»¶æ¶',
          iteration: 'è¿è¡æ¬¡æ°',
          inifinite: 'å¾ªç¯æ­æ¾',
          list: 'éæ©å¨ç»',
          title: 'Animation {index}'
        },
        common: {
          empty: 'Select an element first please!'
        }
      },
      tip: {
        componentUsage: 'ä½¿ç¨æç¤º: {0} ç»ä»¶å³å¯',
        click: 'ç¹å»æææ½'
      }
    }
  };

  function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  Vue__default['default'].use(VueI18n__default['default']);
  var messages = {
    'en-US': _objectSpread$1({}, enUSLang),
    'zh-CN': _objectSpread$1({}, zhCNLang)
  };
  var defaultLang = 'zh-CN';
  var i18n = new VueI18n__default['default']({
    locale: defaultLang,
    fallbackLocale: defaultLang,
    messages: messages
  });

  function _extends$6(){return _extends$6=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends$6.apply(this,arguments)}var normalMerge=["attrs","props","domProps"],toArrayMerge=["class","style","directives"],functionalMerge=["on","nativeOn"],mergeJsxProps=function(a){return a.reduce(function(c,a){for(var b in a)if(!c[b])c[b]=a[b];else if(-1!==normalMerge.indexOf(b))c[b]=_extends$6({},c[b],a[b]);else if(-1!==toArrayMerge.indexOf(b)){var d=c[b]instanceof Array?c[b]:[c[b]],e=a[b]instanceof Array?a[b]:[a[b]];c[b]=d.concat(e);}else if(-1!==functionalMerge.indexOf(b)){for(var f in a[b])if(c[b][f]){var g=c[b][f]instanceof Array?c[b][f]:[c[b][f]],h=a[b][f]instanceof Array?a[b][f]:[a[b][f]];c[b][f]=g.concat(h);}else c[b][f]=a[b][f];}else if("hook"==b)for(var i in a[b])c[b][i]=c[b][i]?mergeFn(c[b][i],a[b][i]):a[b][i];else c[b]=a[b];return c},{})},mergeFn=function(a,b){return function(){a&&a.apply(this,arguments),b&&b.apply(this,arguments);}};var helper$5=mergeJsxProps;

  var $entries = objectToArray.entries;

  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  _export({ target: 'Object', stat: true }, {
    entries: function entries(O) {
      return $entries(O);
    }
  });

  // `RegExp.prototype.flags` getter implementation
  // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
  var regexpFlags = function () {
    var that = anObject(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.dotAll) result += 's';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
  };

  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
  // so we use an intermediate function.
  function RE(s, f) {
    return RegExp(s, f);
  }

  var UNSUPPORTED_Y = fails(function () {
    // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
    var re = RE('a', 'y');
    re.lastIndex = 2;
    return re.exec('abcd') != null;
  });

  var BROKEN_CARET = fails(function () {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
    var re = RE('^r', 'gy');
    re.lastIndex = 2;
    return re.exec('str') != null;
  });

  var regexpStickyHelpers = {
  	UNSUPPORTED_Y: UNSUPPORTED_Y,
  	BROKEN_CARET: BROKEN_CARET
  };

  var nativeExec = RegExp.prototype.exec;
  // This always refers to the native implementation, because the
  // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
  // which loads this file before patching the method.
  var nativeReplace = String.prototype.replace;

  var patchedExec = nativeExec;

  var UPDATES_LAST_INDEX_WRONG = (function () {
    var re1 = /a/;
    var re2 = /b*/g;
    nativeExec.call(re1, 'a');
    nativeExec.call(re2, 'a');
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  })();

  var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

  // nonparticipating capturing group, copied from es5-shim's String#split patch.
  var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

  if (PATCH) {
    patchedExec = function exec(str) {
      var re = this;
      var lastIndex, reCopy, match, i;
      var sticky = UNSUPPORTED_Y$1 && re.sticky;
      var flags = regexpFlags.call(re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;

      if (sticky) {
        flags = flags.replace('y', '');
        if (flags.indexOf('g') === -1) {
          flags += 'g';
        }

        strCopy = String(str).slice(re.lastIndex);
        // Support anchored sticky behavior.
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
          source = '(?: ' + source + ')';
          strCopy = ' ' + strCopy;
          charsAdded++;
        }
        // ^(? + rx + ) is needed, in combination with some str slicing, to
        // simulate the 'y' flag.
        reCopy = new RegExp('^(?:' + source + ')', flags);
      }

      if (NPCG_INCLUDED) {
        reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

      match = nativeExec.call(sticky ? reCopy : re, strCopy);

      if (sticky) {
        if (match) {
          match.input = match.input.slice(charsAdded);
          match[0] = match[0].slice(charsAdded);
          match.index = re.lastIndex;
          re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match) {
        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match && match.length > 1) {
        // Fix browsers whose `exec` methods don't consistently return `undefined`
        // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
        nativeReplace.call(match[0], reCopy, function () {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined) match[i] = undefined;
          }
        });
      }

      return match;
    };
  }

  var regexpExec = patchedExec;

  _export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
    exec: regexpExec
  });

  // TODO: Remove from `core-js@4` since it's moved to entry points







  var SPECIES$6 = wellKnownSymbol('species');

  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
    // #replace needs built-in support for named groups.
    // #match works fine because it just return the exec results, even if it has
    // a "grops" property.
    var re = /./;
    re.exec = function () {
      var result = [];
      result.groups = { a: '7' };
      return result;
    };
    return ''.replace(re, '$<a>') !== '7';
  });

  // IE <= 11 replaces $0 with the whole match, as if it was $&
  // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
  var REPLACE_KEEPS_$0 = (function () {
    return 'a'.replace(/./, '$0') === '$0';
  })();

  var REPLACE = wellKnownSymbol('replace');
  // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
    if (/./[REPLACE]) {
      return /./[REPLACE]('a', '$0') === '';
    }
    return false;
  })();

  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  // Weex JS has frozen built-in prototypes, so use try / catch wrapper
  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function () { return originalExec.apply(this, arguments); };
    var result = 'ab'.split(re);
    return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
  });

  var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
    var SYMBOL = wellKnownSymbol(KEY);

    var DELEGATES_TO_SYMBOL = !fails(function () {
      // String methods call symbol-named RegEp methods
      var O = {};
      O[SYMBOL] = function () { return 7; };
      return ''[KEY](O) != 7;
    });

    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
      // Symbol-named RegExp methods call .exec
      var execCalled = false;
      var re = /a/;

      if (KEY === 'split') {
        // We can't use real regex here since it causes deoptimization
        // and serious performance degradation in V8
        // https://github.com/zloirock/core-js/issues/306
        re = {};
        // RegExp[@@split] doesn't call the regex's exec method, but first creates
        // a new one. We need to return the patched regex when creating the new one.
        re.constructor = {};
        re.constructor[SPECIES$6] = function () { return re; };
        re.flags = '';
        re[SYMBOL] = /./[SYMBOL];
      }

      re.exec = function () { execCalled = true; return null; };

      re[SYMBOL]('');
      return !execCalled;
    });

    if (
      !DELEGATES_TO_SYMBOL ||
      !DELEGATES_TO_EXEC ||
      (KEY === 'replace' && !(
        REPLACE_SUPPORTS_NAMED_GROUPS &&
        REPLACE_KEEPS_$0 &&
        !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
      )) ||
      (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
    ) {
      var nativeRegExpMethod = /./[SYMBOL];
      var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }, {
        REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
      });
      var stringMethod = methods[0];
      var regexMethod = methods[1];

      redefine(String.prototype, KEY, stringMethod);
      redefine(RegExp.prototype, SYMBOL, length == 2
        // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
        // 21.2.5.11 RegExp.prototype[@@split](string, limit)
        ? function (string, arg) { return regexMethod.call(string, this, arg); }
        // 21.2.5.6 RegExp.prototype[@@match](string)
        // 21.2.5.9 RegExp.prototype[@@search](string)
        : function (string) { return regexMethod.call(string, this); }
      );
    }

    if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
  };

  // `String.prototype.{ codePointAt, at }` methods implementation
  var createMethod$5 = function (CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = String(requireObjectCoercible($this));
      var position = toInteger(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = S.charCodeAt(position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size
        || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
          ? CONVERT_TO_STRING ? S.charAt(position) : first
          : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$5(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$5(true)
  };

  var charAt = stringMultibyte.charAt;

  // `AdvanceStringIndex` abstract operation
  // https://tc39.github.io/ecma262/#sec-advancestringindex
  var advanceStringIndex = function (S, index, unicode) {
    return index + (unicode ? charAt(S, index).length : 1);
  };

  // `RegExpExec` abstract operation
  // https://tc39.github.io/ecma262/#sec-regexpexec
  var regexpExecAbstract = function (R, S) {
    var exec = R.exec;
    if (typeof exec === 'function') {
      var result = exec.call(R, S);
      if (typeof result !== 'object') {
        throw TypeError('RegExp exec method returned something other than an Object or null');
      }
      return result;
    }

    if (classofRaw(R) !== 'RegExp') {
      throw TypeError('RegExp#exec called on incompatible receiver');
    }

    return regexpExec.call(R, S);
  };

  var max$5 = Math.max;
  var min$5 = Math.min;
  var floor$1 = Math.floor;
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

  var maybeToString = function (it) {
    return it === undefined ? it : String(it);
  };

  // @@replace logic
  fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
    var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

    return [
      // `String.prototype.replace` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
        return replacer !== undefined
          ? replacer.call(searchValue, O, replaceValue)
          : nativeReplace.call(String(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
      function (regexp, replaceValue) {
        if (
          (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
          (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
        ) {
          var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
          if (res.done) return res.value;
        }

        var rx = anObject(regexp);
        var S = String(this);

        var functionalReplace = typeof replaceValue === 'function';
        if (!functionalReplace) replaceValue = String(replaceValue);

        var global = rx.global;
        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regexpExecAbstract(rx, S);
          if (result === null) break;

          results.push(result);
          if (!global) break;

          var matchStr = String(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }

        var accumulatedResult = '';
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];

          var matched = String(result[0]);
          var position = max$5(min$5(toInteger(result.index), S.length), 0);
          var captures = [];
          // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
          for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = [matched].concat(captures, position, S);
            if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
            var replacement = String(replaceValue.apply(undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + S.slice(nextSourcePosition);
      }
    ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
    function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== undefined) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return nativeReplace.call(replacement, symbols, function (match, ch) {
        var capture;
        switch (ch.charAt(0)) {
          case '$': return '$';
          case '&': return matched;
          case '`': return str.slice(0, position);
          case "'": return str.slice(tailPos);
          case '<':
            capture = namedCaptures[ch.slice(1, -1)];
            break;
          default: // \d\d?
            var n = +ch;
            if (n === 0) return match;
            if (n > m) {
              var f = floor$1(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === undefined ? '' : capture;
      });
    }
  });

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-17 16:59:14
   * @LastEditTime : 2020-11-17 16:59:14
   * @Description :
   */
  var hyphenateStyleName = function hyphenateStyleName(name) {
    var uppercasePattern = /([A-Z])/g;
    var msPattern = /^ms-/;
    return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
  };

  /**
   * å¢å èå´scopeNodeå±æ§ ä»¥éå¶è§¦åç¹å»å¤é¨ç åºåèå´
   *
   */
  var HANDLERS_PROPERTY = '__v-click-outside';
  var HAS_WINDOWS = typeof window !== 'undefined';
  var HAS_NAVIGATOR = typeof navigator !== 'undefined';
  var IS_TOUCH = HAS_WINDOWS && ('ontouchstart' in window || HAS_NAVIGATOR && navigator.msMaxTouchPoints > 0);
  var EVENTS = IS_TOUCH ? ['touchstart'] : ['click'];

  function processDirectiveArguments(bindingValue) {
    var isFunction = typeof bindingValue === 'function';

    if (!isFunction && _typeof_1(bindingValue) !== 'object') {
      throw new Error('v-click-outside: Binding value must be a function or an object');
    }

    return {
      handler: isFunction ? bindingValue : bindingValue.handler,
      middleware: bindingValue.middleware || function (item) {
        return item;
      },
      events: bindingValue.events || EVENTS,
      isActive: !(bindingValue.isActive === false),
      detectIframe: !(bindingValue.detectIframe === false),
      capture: !!bindingValue.capture,
      scopeNode: bindingValue.scopeNode || document.documentElement
    };
  }

  function execHandler(_ref) {
    var event = _ref.event,
        handler = _ref.handler,
        middleware = _ref.middleware;

    if (middleware(event)) {
      handler && handler(event);
    }
  }

  function onFauxIframeClick(_ref2) {
    var el = _ref2.el,
        event = _ref2.event,
        handler = _ref2.handler,
        middleware = _ref2.middleware;
    // Note: on firefox clicking on iframe triggers blur, but only on
    //       next event loop it becomes document.activeElement
    // https://stackoverflow.com/q/2381336#comment61192398_23231136
    setTimeout(function () {
      var _document = document,
          activeElement = _document.activeElement;

      if (activeElement && activeElement.tagName === 'IFRAME' && !el.contains(activeElement)) {
        execHandler({
          event: event,
          handler: handler,
          middleware: middleware
        });
      }
    }, 0);
  }

  function onEvent(_ref3) {
    var el = _ref3.el,
        event = _ref3.event,
        handler = _ref3.handler,
        middleware = _ref3.middleware,
        scopeNode = _ref3.scopeNode;
    // Note: composedPath is not supported on IE and Edge, more information here:
    //       https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath
    //       In the meanwhile, we are using el.contains for those browsers, not
    //       the ideal solution, but using IE or EDGE is not ideal either.
    var path = event.path || event.composedPath && event.composedPath();
    var isClickOutside = path ? path.indexOf(el) < 0 && path.indexOf(scopeNode) > -1 : !el.contains(event.target) && scopeNode.contains(event.target);

    if (!isClickOutside) {
      return;
    }

    execHandler({
      event: event,
      handler: handler,
      middleware: middleware
    });
  }

  function bind$4(el, _ref4) {
    var value = _ref4.value;

    var _processDirectiveArgu = processDirectiveArguments(value),
        events = _processDirectiveArgu.events,
        _handler = _processDirectiveArgu.handler,
        middleware = _processDirectiveArgu.middleware,
        isActive = _processDirectiveArgu.isActive,
        detectIframe = _processDirectiveArgu.detectIframe,
        capture = _processDirectiveArgu.capture,
        scopeNode = _processDirectiveArgu.scopeNode;

    if (!isActive || !_handler) {
      return;
    }

    el[HANDLERS_PROPERTY] = events.map(function (eventName) {
      return {
        event: eventName,
        srcTarget: document.documentElement,
        handler: function handler(event) {
          return onEvent({
            el: el,
            event: event,
            handler: _handler,
            middleware: middleware,
            scopeNode: scopeNode
          });
        },
        capture: capture
      };
    });

    if (detectIframe) {
      var detectIframeEvent = {
        event: 'blur',
        srcTarget: window,
        handler: function handler(event) {
          return onFauxIframeClick({
            el: el,
            event: event,
            handler: _handler,
            middleware: middleware
          });
        },
        capture: capture
      };
      el[HANDLERS_PROPERTY] = [].concat(toConsumableArray(el[HANDLERS_PROPERTY]), [detectIframeEvent]);
    }

    el[HANDLERS_PROPERTY].forEach(function (_ref5) {
      var event = _ref5.event,
          srcTarget = _ref5.srcTarget,
          handler = _ref5.handler;
      return setTimeout(function () {
        // Note: More info about this implementation can be found here:
        //       https://github.com/ndelvalle/v-click-outside/issues/137
        if (!el[HANDLERS_PROPERTY]) {
          return;
        }

        srcTarget.addEventListener(event, handler, capture);
      }, 0);
    });
  }

  function unbind(el) {
    var handlers = el[HANDLERS_PROPERTY] || [];
    handlers.forEach(function (_ref6) {
      var event = _ref6.event,
          srcTarget = _ref6.srcTarget,
          handler = _ref6.handler,
          capture = _ref6.capture;
      return srcTarget.removeEventListener(event, handler, capture);
    });
    delete el[HANDLERS_PROPERTY];
  }

  function update(el, _ref7) {
    var value = _ref7.value,
        oldValue = _ref7.oldValue;

    if (JSON.stringify(value) === JSON.stringify(oldValue)) {
      return;
    }

    unbind(el);
    bind$4(el, {
      value: value
    });
  }

  var directive = {
    bind: bind$4,
    update: update,
    unbind: unbind
  };
  var vClickOutside = HAS_WINDOWS ? directive : {};

  function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * #!zh: ä¸ä¸å·¦å³ å¯¹åºç ä¸åè¥¿å
   * #!en: top(north)ãbottom(south)ãleft(west)ãright(east)
   */
  // const directionKey = {
  //   t: 'n',
  //   b: 's',
  //   l: 'w',
  //   r: 'e'
  // }

  var ShapeLayerDefaultProps = {
    top: 0,
    left: 0,
    width: 100,
    height: 40
  };
  var points$2 = ['lt', 'rt', 'lb', 'rb', 'lm', 'rm', 'tm', 'bm'];
  var ShapeLayer = {
    directives: {
      clickOutside: vClickOutside
    },
    props: {
      elStyle: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      disable: {
        type: Boolean,
        default: ShapeLayerDefaultProps.disable
      }
    },
    inject: ['canvas'],
    data: function data() {
      return {
        rect: this.getReact(this.elStyle),
        shapeStyle: this.getStyle(this.elStyle),
        startY: 0,
        startX: 0,
        point: '',
        active: false,
        vcoConfig: {}
      };
    },
    computed: {
      ltPointStyle: function ltPointStyle() {
        return {
          left: "".concat(0, "px"),
          top: "".concat(0, "px")
        };
      },
      rtPointStyle: function rtPointStyle() {
        var width = this.rect.width;
        return {
          left: "".concat(width, "px"),
          top: "".concat(0, "px")
        };
      },
      lbPointStyle: function lbPointStyle() {
        var height = this.rect.height;
        return {
          left: "".concat(0, "px"),
          top: "".concat(height, "px")
        };
      },
      rbPointStyle: function rbPointStyle() {
        var _this$rect = this.rect,
            width = _this$rect.width,
            height = _this$rect.height;
        return {
          left: "".concat(width, "px"),
          top: "".concat(height, "px")
        };
      },
      lmPointStyle: function lmPointStyle() {
        var height = this.rect.height;
        return {
          left: "".concat(0, "px"),
          top: "".concat(height / 2, "px")
        };
      },
      rmPointStyle: function rmPointStyle() {
        var _this$rect2 = this.rect,
            width = _this$rect2.width,
            height = _this$rect2.height;
        return {
          left: "".concat(width, "px"),
          top: "".concat(height / 2, "px")
        };
      },
      tmPointStyle: function tmPointStyle() {
        var width = this.rect.width;
        return {
          left: "".concat(width / 2, "px"),
          top: "".concat(0, "px")
        };
      },
      bmPointStyle: function bmPointStyle() {
        var _this$rect3 = this.rect,
            width = _this$rect3.width,
            height = _this$rect3.height;
        return {
          left: "".concat(width / 2, "px"),
          top: "".concat(height, "px")
        };
      },
      bound: function bound() {
        return {
          left: 0,
          top: 0,
          right: this.canvas.width,
          bottom: this.canvas.height
        };
      }
    },
    mounted: function mounted() {
      this.vcoConfig = {
        events: ['mousedown'],
        handler: this.onClickOutside,
        scopeNode: document.querySelector('.lb-canvas-wrapper')
      };
    },
    watch: {
      elStyle: function elStyle() {
        var elStyle = this.elStyle;
        this.rect = this.getReact(elStyle);
        this.shapeStyle = this.getStyle(elStyle);
      },
      rect: {
        handler: function handler() {
          var newStyle = _objectSpread$2(_objectSpread$2({}, this.elStyle), this.rect);

          this.shapeStyle = _objectSpread$2(_objectSpread$2({}, this.shapeStyle), this.getStyle(this.rect));
          this.$emit('change', newStyle);
        },
        deep: true
      }
    },
    methods: {
      getReact: function getReact(elStyle) {
        return {
          left: elStyle.left,
          top: elStyle.top,
          width: elStyle.width,
          height: elStyle.height
        };
      },
      getStyle: function getStyle(style) {
        var newStyle = {};
        Object.entries(style).forEach(function (_ref) {
          var _ref2 = slicedToArray(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          var v = typeof value === 'number' ? "".concat(value, "px") : value;
          var n = hyphenateStyleName(key);
          newStyle[n] = v;
        });
        return newStyle;
      },
      setActive: function setActive(active) {
        if (this.active === active) return;
        active ? this.$emit('active', active) : this.$emit('deactive', active);
        this.active = active;
      },
      onClickOutside: function onClickOutside() {
        this.setActive(false);
      },
      addWidth: function addWidth(distance) {
        var _this$rect4 = this.rect,
            currentLeft = _this$rect4.left,
            currentWidth = _this$rect4.width;
        var boundRight = this.bound.right;
        var nextWidth = currentWidth + distance;
        if (nextWidth < 0) nextWidth = 0;
        if (currentLeft + nextWidth > boundRight) return;
        return this.rect.width = nextWidth;
      },
      addHeight: function addHeight(distance) {
        var _this$rect5 = this.rect,
            currentTop = _this$rect5.top,
            currentHeight = _this$rect5.height;
        var boundBottom = this.bound.bottom;
        var nextHeight = currentHeight + distance;
        if (nextHeight < 0) nextHeight = 0;
        if (currentTop + nextHeight > boundBottom) return;
        return this.rect.height = nextHeight;
      },
      addLeft: function addLeft(distance) {
        var _this$rect6 = this.rect,
            currentLeft = _this$rect6.left,
            currentWidth = _this$rect6.width;
        var _this$bound = this.bound,
            boundLeft = _this$bound.left,
            boundRight = _this$bound.right;
        var nextLeft = currentLeft + distance;
        if (nextLeft < boundLeft) nextLeft = boundLeft;
        if (nextLeft + currentWidth > boundRight) return;
        return this.rect.left = nextLeft;
      },
      addTop: function addTop(distance) {
        var _this$rect7 = this.rect,
            currentTop = _this$rect7.top,
            currentHeight = _this$rect7.height;
        var _this$bound2 = this.bound,
            boundTop = _this$bound2.top,
            boundBottom = _this$bound2.bottom;
        var nextTop = currentTop + distance;
        if (nextTop < boundTop) nextTop = boundTop;
        if (nextTop + currentHeight > boundBottom) return;
        return this.rect.top = nextTop;
      },
      handleShapeDown: function handleShapeDown(e) {
        this.setActive(true);
        this.startY = e.clientY;
        this.startX = e.clientX;
        document.addEventListener('mousemove', this.handleShapeMove);
        document.addEventListener('mouseup', this.handleShapeUp);
      },
      handleShapeMove: function handleShapeMove(e) {
        e.preventDefault();
        var distanceX = e.clientX - this.startX;
        var distanceY = e.clientY - this.startY;
        this.startX = e.clientX;
        this.startY = e.clientY;
        this.addLeft(distanceX);
        this.addTop(distanceY);
      },
      handleShapeUp: function handleShapeUp() {
        document.removeEventListener('mousemove', this.handleShapeMove);
        document.removeEventListener('mouseup', this.handleShapeUp);
      },
      handlePointDown: function handlePointDown(point, e) {
        this.startY = e.clientY;
        this.startX = e.clientX;
        this.point = point;
        document.addEventListener('mousemove', this.handlePointMove);
        document.addEventListener('mouseup', this.handlePointUp);
      },
      handlePointMove: function handlePointMove(e) {
        var _this = this;

        var effect = [/l/, /t/, /r/, /b/].map(function (v) {
          return v.test(_this.point);
        });

        var _effect = slicedToArray(effect, 4),
            effectLeft = _effect[0],
            effectTop = _effect[1],
            effectWidth = _effect[2],
            effectHeight = _effect[3];

        var distanceX = e.clientX - this.startX;
        var distanceY = e.clientY - this.startY;
        this.startX = e.clientX;
        this.startY = e.clientY;

        if (effectLeft) {
          var _this$rect8 = this.rect,
              currentLeft = _this$rect8.left,
              currentWidth = _this$rect8.width;
          var effectLeftDistance = Math.min(currentWidth, distanceX);
          var effectWidthDistance = Math.min(currentLeft, -distanceX);
          this.addLeft(effectLeftDistance);
          this.addWidth(effectWidthDistance);
        }

        if (effectTop) {
          var _this$rect9 = this.rect,
              currentTop = _this$rect9.top,
              currentHeight = _this$rect9.height;
          var effectTopDistance = Math.min(currentHeight, distanceY);
          var effectHeightDistance = Math.min(currentTop, -distanceY);
          this.addTop(effectTopDistance);
          this.addHeight(effectHeightDistance);
        }

        effectWidth && this.addWidth(distanceX);
        effectHeight && this.addHeight(distanceY);
      },
      handlePointUp: function handlePointUp() {
        document.removeEventListener('mousemove', this.handlePointMove);
        document.removeEventListener('mouseup', this.handlePointUp);
      }
    },
    render: function render() {
      var _this2 = this;

      var h = arguments[0];
      return h("div", {
        "attrs": {
          "tabindex": "0"
        },
        "directives": [{
          name: "click-outside",
          value: this.vcoConfig
        }],
        "style": this.getStyle(this.shapeStyle),
        "class": ['shape-layer', {
          active: this.active
        }],
        "on": {
          "mousedown": this.handleShapeDown
        },
        "ref": "shape"
      }, [h("div", {
        "class": "shape-content"
      }, [this.$slots.default]), h("div", {
        "class": "control"
      }, [points$2.map(function (v) {
        return h("div", {
          "directives": [{
            name: "show",
            value: _this2.active
          }],
          "style": _this2["".concat(v, "PointStyle")],
          "class": "shape-scale__point",
          "attrs": {
            "data-point": v
          },
          "on": {
            "mousedown": _this2.handlePointDown.bind(_this2, v)
          }
        });
      })])]);
    }
  };

  function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var id$1 = 0;

  var LbpElement = /*#__PURE__*/function () {
    function LbpElement() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      classCallCheck(this, LbpElement);

      var _options$name = options.name,
          name = _options$name === void 0 ? '' : _options$name,
          _options$props = options.props,
          props = _options$props === void 0 ? {} : _options$props,
          _options$style = options.style,
          style = _options$style === void 0 ? {} : _options$style,
          _options$attrs = options.attrs,
          attrs = _options$attrs === void 0 ? {} : _options$attrs,
          _options$animations = options.animations,
          animations = _options$animations === void 0 ? [] : _options$animations;

      if (name) {
        this.name = name;
        this.id = id$1++;
        this.vm = null;

        var _pluginsControl$getPl = lbpPluginController.getPlugin(name),
            component = _pluginsControl$getPl.component; // ä¼ å¥å·ä½çelement render ç åæ°


        this.props = _objectSpread$3(_objectSpread$3({}, LbpElement.getPluginProps(component)), props); // ä¼ å¥å·ä½çelement render ç å±æ§

        this.attrs = _objectSpread$3({}, attrs); // ä¼ å¥å·ä½çelement render ç æ ·å¼

        this.class = _objectSpread$3({}, options.class); // ä¼ å¥ shapeLayer ä»¥æ¹åä½ç½®ä»¥åå¤§å°

        this.style = _objectSpread$3(_objectSpread$3({}, ShapeLayerDefaultProps), style); // ä¼ å¥ animateLayer ä»¥å®ç°å¨ç»ææ

        this.animations = toConsumableArray(animations);
      } else {
        console.error('lbpElement need a name of plugin');
      }
    }

    createClass(LbpElement, [{
      key: "clone",
      value: function clone() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$zIndex = _ref.zIndex,
            zIndex = _ref$zIndex === void 0 ? this.zIndex + 1 : _ref$zIndex;

        return new LbpElement({
          zIndex: zIndex,
          name: this.name,
          pluginProps: this.pluginProps,
          commonStyle: _objectSpread$3(_objectSpread$3({}, this.commonStyle), {}, {
            top: this.commonStyle.top + 20,
            left: this.commonStyle.left + 20
          })
        });
      }
    }, {
      key: "update",
      value: function update(_ref2) {
        var props = _ref2.props,
            style = _ref2.style,
            animations = _ref2.animations;
        props && Object.assign(this.props, props);
        style && Object.assign(this.style, style);

        if (animations) {
          Object.assign(this.animations, animations);
          this.animations.length = animations.length;
        }
      }
    }, {
      key: "setVm",
      value: function setVm(vm) {
        this.vm = vm;
      }
    }], [{
      key: "getPluginProps",
      value: function getPluginProps(component) {
        var props = {};
        var propsDefine = component.props;
        Object.entries(propsDefine).forEach(function (_ref3) {
          var _ref4 = slicedToArray(_ref3, 2),
              key = _ref4[0],
              prop = _ref4[1];

          props[key] = LbpElement.getPropDefaultValue(null, prop);
        });
        return props;
      }
    }, {
      key: "getPropDefaultValue",
      value: function getPropDefaultValue(vm, prop) {
        if (!Object.prototype.hasOwnProperty.call(prop, 'default')) {
          return undefined;
        }

        var def = prop.default;
        return lodash.isFunction(def) ? def.call(vm) : def;
      }
    }]);

    return LbpElement;
  }();

  var Render = {
    props: {
      elName: {
        type: String,
        require: true
      },
      elProps: {
        type: Object,
        require: true
      }
    },
    render: function render() {
      var h = arguments[0];
      var component = lbpPluginController.getPlugin(this.elName).component;
      return h(component, helper$5([{}, {
        "props": this.elProps
      }]));
    }
  };

  var EventBus = new Vue__default['default'](); // event bus

  var AnimateLayer = {
    props: {
      animations: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    methods: {
      runAnimations: function runAnimations() {
        if (!this.animations) return;
        var animationQueue = this.animations || [];
        var len = animationQueue.length;
        if (len === 0) return;
        var parentNode = this.$el;
        var animIdx = 0;
        runAnimation();

        function runAnimation() {
          if (animIdx < len) {
            var animation = animationQueue[animIdx];
            Object.assign(parentNode.style, {
              animationName: animation.type,
              animationDuration: "".concat(animation.duration, "s"),
              animationIterationCount: animation.infinite ? 'infinite' : animation.interationCount,
              animationDelay: "".concat(animation.delay, "s"),
              animationFillMode: 'both'
            });
            animIdx++;
          } else {
            Object.assign(parentNode.style, {
              animationName: null,
              animationDuration: null,
              animationIterationCount: null,
              animationDelay: null,
              animationFillMode: null
            });
          }
        }

        parentNode.addEventListener('animationend', runAnimation, false);
      }
    },
    created: function created() {
      var _this = this;

      EventBus.$on('RUN_ANIMATIONS', function () {
        _this.runAnimations();
      });
    },
    render: function render() {
      var h = arguments[0];
      return h("div", {
        "class": "animate-layer"
      }, [this.$slots.default]);
    }
  };

  var ElementRender = {
    props: {
      element: {
        type: LbpElement,
        default: function _default() {
          return new LbpElement({});
        }
      }
    },
    created: function created() {
      this.element.setVm(this);
    },
    render: function render() {
      var h = arguments[0];
      var element = this.element;
      return h(ShapeLayer, helper$5([{
        "attrs": {
          "elStyle": element.style
        }
      }, {
        "on": this.$listeners
      }]), [h(AnimateLayer, {
        "attrs": {
          "animations": element.animations
        }
      }, [h(Render, {
        "attrs": {
          "elProps": element.props,
          "elName": element.name
        }
      })])]);
    }
  };

  var LbpCanvas = {
    props: {
      width: {
        type: Number,
        default: 0
      },
      height: {
        type: Number,
        default: 0
      },
      elements: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    provide: function provide() {
      return {
        canvas: this.canvas
      };
    },
    data: function data() {
      return {
        canvas: {
          width: this.width,
          height: this.height
        }
      };
    },
    watch: {
      width: function width(_width) {
        this.updateCanvas({
          width: _width
        });
      },
      height: function height(_height) {
        this.updateCanvas({
          height: _height
        });
      }
    },
    computed: {
      canvasStyle: function canvasStyle() {
        return {
          width: "".concat(this.width, "px"),
          height: "".concat(this.height, "px")
        };
      }
    },
    methods: {
      updateCanvas: function updateCanvas(data) {
        Object.assign(this.canvas, data);
      }
    },
    render: function render() {
      var _this = this;

      var h = arguments[0];
      return h("div", {
        "class": "lb-canvas",
        "style": this.canvasStyle
      }, [h("div", {
        "class": "lb-canvas-wrapper"
      }, [h("div", {
        "class": "elements"
      }, [this.elements.map(function (element) {
        return h(ElementRender, {
          "key": element.id,
          "attrs": {
            "element": element
          },
          "on": {
            "active": function active() {
              return _this.$listeners.active(element);
            },
            "deactive": function deactive() {
              return _this.$listeners.deactive(element);
            },
            "change": _this.$listeners.elementRectChange
          }
        });
      })])])]);
    }
  };

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-02 16:12:09
   * @LastEditTime : 2020-11-17 14:58:22
   * @Description :
   */
  // import undoRedoHistory from '@/store/plugins/undo-redo/History'
  var fixedTools = [{
    i18nTooltip: 'editor.fixedTool.undo',
    icon: 'mail-reply',
    // action: () => undoRedoHistory.undo(),
    hotkey: 'ctrl&z,â&z',
    hotkeyTooltip: '(ctrl+z)'
  }, {
    i18nTooltip: 'editor.fixedTool.redo',
    icon: 'mail-forward',
    // action: () => undoRedoHistory.redo(),
    hotkey: 'ctrl&y,â&u',
    hotkeyTooltip: '(ctrl+y)'
  }, {
    i18nTooltip: 'editor.fixedTool.preview',
    icon: 'eye',
    action: function action() {
      this.previewDialogVisible = true;
    }
  }, {
    i18nTooltip: 'editor.fixedTool.copyCurrentPage',
    icon: 'copy',
    action: function action() {
      this.pageManager({
        type: 'copy'
      });
    },
    hotkey: 'ctrl&c,â&c'
  }, {
    i18nTooltip: 'editor.fixedTool.copyCurrentElement',
    icon: 'copy',
    action: function action() {
      this.elementManager({
        type: 'copy'
      });
    }
  }, {
    i18nTooltip: 'editor.fixedTool.importPSD',
    text: 'Ps',
    icon: '',
    // ä¼åçº§: icon > text > i18nTooltip
    action: '',
    disabled: true
  }, {
    i18nTooltip: 'editor.fixedTool.zoomOut',
    icon: 'plus',
    action: function action() {
      this.updateScaleRate(0.25);
    },
    hotkey: 'ctrl&=,â&=',
    hotkeyTooltip: '(ctrl +)'
  }, {
    i18nTooltip: 'editor.fixedTool.zoomIn',
    icon: 'minus',
    action: function action() {
      this.updateScaleRate(-0.25);
    },
    hotkey: 'ctrl&-,â&-',
    hotkeyTooltip: '(ctrl -)'
  }, {
    i18nTooltip: 'editor.fixedTool.issues',
    icon: 'question',
    action: function action() {
      window.open('https://github.com/ly525/luban-h5/issues/110');
    }
  }];

  var _components;
  var FixedTools = {
    components: (_components = {}, defineProperty$3(_components, antDesignVue.Layout.Sider.name, antDesignVue.Layout.Sider), defineProperty$3(_components, antDesignVue.Button.Group.name, antDesignVue.Button.Group), defineProperty$3(_components, antDesignVue.Tooltip.name, antDesignVue.Tooltip), defineProperty$3(_components, antDesignVue.Button.name, antDesignVue.Button), _components),
    data: function data() {
      return {
        scaleRate: 1
      };
    },
    render: function render() {
      var _this = this;

      var h = arguments[0];
      return h("a-layout-sider", {
        "attrs": {
          "width": "40",
          "theme": "light"
        },
        "style": {
          background: '#fff',
          border: '1px solid #eee'
        }
      }, [h("a-button-group", {
        "style": {
          display: 'flex',
          flexDirection: 'column'
        }
      }, [fixedTools.map(function (tool) {
        return h("a-tooltip", {
          "attrs": {
            "effect": "dark",
            "placement": "left",
            "title": _this.$t(tool.i18nTooltip, {
              hotkey: tool.hotkeyTooltip
            })
          }
        }, [h("a-button", {
          "attrs": {
            "block": true,
            "type": "link",
            "size": "small",
            "disabled": !!tool.disabled
          },
          "class": "transparent-bg",
          "style": {
            height: '40px',
            color: '#000'
          },
          "on": {
            "click": function click() {
              return tool.action && tool.action.call(_this);
            }
          }
        }, [tool.icon ? h("i", {
          "class": ['shortcut-icon', 'fa', "fa-".concat(tool.icon)],
          "attrs": {
            "aria-hidden": "true"
          }
        }) : tool.text || _this.$t(tool.i18nTooltip)]), tool.icon === 'minus' && h("div", {
          "style": {
            fontSize: '12px',
            textAlign: 'center'
          }
        }, [_this.scaleRate * 100, "%"])]);
      })])]);
    },
    mounted: function mounted() {
      var _this2 = this;

      fixedTools.map(function (tool) {
        tool.hotkey && hotkeys__default['default'](tool.hotkey, {
          splitKey: '&'
        }, function (event, handler) {
          event.preventDefault();
          event.stopPropagation();
          tool.action && tool.action.call(_this2);
        });
      });
    }
  };

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-02 16:12:09
   * @LastEditTime : 2020-11-17 11:44:55
   * @Description :
   */
  var colorsPanel = {
    name: 'colors-panel',
    props: {
      value: {
        type: [Array, String]
      }
    },
    render: function render() {
      var _this = this;

      var h = arguments[0];
      return h("div", [Array.isArray(this.value) ? this.value.map(function (v, index) {
        return h("input", {
          "attrs": {
            "size": "small",
            "type": "color",
            "autocomplete": true
          },
          "domProps": {
            "value": v
          },
          "on": {
            "change": function change(e) {
              var colors = _this.value.slice(0);

              colors[index] = e.target.value;

              _this.$emit('change', colors);
            }
          }
        });
      }) : h("input", {
        "attrs": {
          "size": "small",
          "type": "color",
          "autocomplete": true
        },
        "domProps": {
          "value": this.value
        },
        "on": {
          "change": function change(e) {
            _this.$emit('change', e.target.value);
          }
        }
      })]);
    }
  };

  var _components$1;
  var lbsTextAlign = {
    name: 'lbs-text-align',
    components: (_components$1 = {}, defineProperty$3(_components$1, antDesignVue.Radio.Group.name, antDesignVue.Radio.Group), defineProperty$3(_components$1, antDesignVue.Radio.Button.name, antDesignVue.Radio.Button), defineProperty$3(_components$1, antDesignVue.Tooltip.name, antDesignVue.Tooltip), _components$1),
    render: function render(h) {
      var _this = this;

      return h("div", {
        "class": "wrap"
      }, [h("a-radio-group", {
        "attrs": {
          "size": "small",
          "value": this.value
        },
        "on": {
          "change": function change(value) {
            _this.$emit('change', value);

            _this.$emit('input', value);
          }
        }
      }, [this.textAlignTabs.map(function (item) {
        return h("a-tooltip", {
          "attrs": {
            "effect": "dark",
            "placement": "top",
            "title": item.label
          },
          "key": item.value
        }, [h("a-radio-button", {
          "attrs": {
            "value": item.value
          }
        }, [h("i", {
          "class": ['fa', 'fa-align-' + item.value],
          "attrs": {
            "aria-hidden": "true"
          }
        })])]);
      })])]);
    },
    props: {
      value: {
        type: [String, Number]
      }
    },
    data: function data() {
      return {
        textAlignTabs: [{
          label: 'å·¦å¯¹é½',
          value: 'left'
        }, {
          label: 'å±ä¸­å¯¹é½',
          value: 'center'
        }, {
          label: 'å³å¯¹é½',
          value: 'right'
        }]
      };
    }
  };

  /**
   *
   declare module ExcelRows {
    export interface cell {
        text: string;
    }
    export interface Cells {
      0: cell;
      1: cell;
      2: cell;
    }
    export interface ExcelRows {
      cells: Cells;
    }
  }
   */

  /**
    *
    BinaryMatrix = [
      [any, any, any, ...],
      [any, any, any, ...],
      [any, any, any, ...],
    ]

    ExcelDataType = [
      {
        cells: {
          0: { text: any },
          1: { text: any },
          2: { text: any }
        }
      },
      {
        cells: {
          0: { text: any },
          1: { text: any },
          2: { text: any }
        }
      },
    ]
    */
  var Parser$2 = /*#__PURE__*/function () {
    function Parser() {
      classCallCheck(this, Parser);
    }

    createClass(Parser, null, [{
      key: "dataset2excel",

      /**
       *
       * @param {*} dataset ExcelDataType
       */
      value: function dataset2excel(dataset) {
        return dataset.map(function (item) {
          return {
            cells: {
              0: {
                text: item.x
              },
              1: {
                text: item.y
              },
              2: {
                text: item.s
              }
            }
          };
        });
      }
      /**
       *
        [
          [1,2,3,4],
          [5,6,7,8],
          [9,10,11,12]
        ]
       * @param {Object} BinaryMatrix
       * @returns {Object} ExcelDataType
       */

    }, {
      key: "binaryMatrix2excel",
      value: function binaryMatrix2excel() {
        var binaryMatrix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var excelData = binaryMatrix.map(function (row, rowIndex) {
          // cells: {
          //   0: { text: item.x },
          //   1: { text: item.y },
          //   2: { text: item.s }
          // }
          var cells = {};
          row.forEach(function (cellValue, cellIndex) {
            cells[cellIndex] = {
              text: cellValue
            };
          });
          return {
            cells: cells
          };
        });
        return excelData;
      }
    }, {
      key: "excel2chartDataSet",
      value: function excel2chartDataSet(excelData) {
        var rowsArray = Object.values(excelData.rows).filter(function (item) {
          return _typeof_1(item) === 'object';
        });
        var dataset = rowsArray.map(function (row) {
          var _Object$values$map = Object.values(row.cells).map(function (item) {
            return item.text;
          }),
              _Object$values$map2 = slicedToArray(_Object$values$map, 3),
              x = _Object$values$map2[0],
              y = _Object$values$map2[1],
              s = _Object$values$map2[2];

          return {
            x: x,
            y: y,
            s: s
          };
        });
        return dataset;
      }
    }, {
      key: "excel2BinaryMatrix",
      value: function excel2BinaryMatrix(excelData) {
        var rowsArray = Object.values(excelData.rows).filter(function (item) {
          return _typeof_1(item) === 'object';
        });
        var dataset = rowsArray.map(function (row) {
          // [1,2,3,4]
          var cells = Object.values(row.cells).map(function (item) {
            return item.text;
          });
          return cells;
        });
        console.log('dataset', dataset);
        return dataset;
      }
      /**
      *
      * @param {Array} csvArray
      *    [
             ['æ¥æ', 'éå®é'],
             ["1æ1æ¥",123],
             ["1æ2æ¥",1223],
             ["1æ3æ¥",2123],
             ["1æ4æ¥",4123],
             ["1æ5æ¥",3123],
             ["1æ6æ¥",7123]
           ]
      * @returns {Object}
         {
           columns: ['æ¥æ', 'éå®é'],
           rows:[
             { 'æ¥æ': '1æ1æ¥', 'éå®é': 123 },
             { 'æ¥æ': '1æ2æ¥', 'éå®é': 1223 },
             { 'æ¥æ': '1æ3æ¥', 'éå®é': 2123 },
             { 'æ¥æ': '1æ4æ¥', 'éå®é': 4123 },
             { 'æ¥æ': '1æ5æ¥', 'éå®é': 3123 },
             { 'æ¥æ': '1æ6æ¥', 'éå®é': 7123 }
           ]
         }
      */

    }, {
      key: "csv2VChartJson",
      value: function csv2VChartJson(csvArray) {
        var columns = csvArray[0];
        var rows = csvArray.slice(1);
        var json = {
          columns: columns,
          rows: rows.map(function (row, index) {
            var obj = {};
            columns.forEach(function (col, colIndex) {
              obj[col.trim()] = row[colIndex];
            });
            return obj;
          })
        };
        return json;
      }
    }]);

    return Parser;
  }();

  var validFileMimeTypes = ['text/csv', 'text/x-csv', 'application/vnd.ms-excel', 'text/plain'];
  var CsvImport = {
    name: 'lbs-csv-import',
    methods: {
      checkMimeType: function checkMimeType(type) {
        return validFileMimeTypes.indexOf(type) > -1;
      },
      validFileMimeType: function validFileMimeType(e) {
        e.preventDefault();
        var file = this.$refs.csv.files[0];
        var isValidFileMimeType = this.checkMimeType(file.type);
        if (isValidFileMimeType) this.loadFile();
      },
      loadFile: function loadFile() {
        var _this = this;

        /**
         * output {String}
            "columnA,columnB,columnC
            "Susan",41,a
            "Mike",5,b
            "Jake",33,c
            "Jill",30,d
            "
          * csv {Object}
          {
            "data": [
              ["columnA", "columnB", "columnC"],
              ["Susan", "41", "a"],
              ["Mike", "5", "b"],
              ["Jake", "33", "c"],
              ["Jill", "30", "d"],
            ],
            "errors": [],
            "meta": {
              "delimiter": ",",
              "linebreak": "\n",
              "aborted": false,
              "truncated": false,
              "cursor": 72
            }
          }
         */
        this.readFile(function (output) {
          // const sample = Papa.parse(output, { preview: 2, skipEmptyLines: true })
          var csv = Papa__default['default'].parse(output, {
            skipEmptyLines: true
          });

          _this.$emit('parse', csv);

          _this.$refs.input.value = '';
        });
      },
      readFile: function readFile(callback) {
        var file = this.$refs.csv.files[0];

        if (file) {
          var reader = new FileReader();
          reader.readAsText(file, 'UTF-8');

          reader.onload = function (evt) {
            callback(evt.target.result);
          };

          reader.onerror = function () {};
        }
      }
    },
    render: function render() {
      var h = arguments[0];
      var randomId = +new Date();
      return h("div", {
        "style": "height: 24px;"
      }, [h("label", {
        "attrs": {
          "for": randomId
        },
        "class": "ant-btn ant-btn-primary ant-btn-sm"
      }, ["\u9009\u62E9\u5BFC\u5165 csv \u6587\u4EF6"]), h("input", {
        "ref": "csv",
        "attrs": {
          "id": randomId,
          "type": "file",
          "name": "csv"
        },
        "on": {
          "change": this.validFileMimeType
        },
        "style": "visibility:hidden;"
      }, ["xxxx"])]);
    }
  };

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-02 16:12:09
   * @LastEditTime : 2020-11-17 16:45:47
   * @Description :
   */
  var lbsExcelEditor = {
    name: 'lbs-excel-editor',
    props: {
      value: {
        type: Array
      },
      formatter: {
        type: Function
      }
    },
    computed: {
      innerItems: {
        get: function get() {
          return Parser$2.binaryMatrix2excel(this.value);
        },
        set: function set(val) {
          this.$emit('input', val);
        }
      }
    },
    watch: {
      value: function value() {
        this.refreshSheet({
          rows: this.innerItems
        });
      }
    },
    methods: {
      parseCSV: function parseCSV(csv) {
        var sheetData = Parser$2.binaryMatrix2excel(csv.data);
        this.$emit('change', csv.data);
        this.refreshSheet({
          rows: sheetData
        });
      },

      /**
       *
       * @param {Object} data { rows }
       */
      refreshSheet: function refreshSheet(data) {
        this.sheet.loadData(data);
        this.sheet.reRender();
      },
      initSheet: function initSheet() {
        var _this = this;

        var ele = this.$refs.excel;
        return this.sheet || new Spreadsheet__default['default'](ele, {
          showToolbar: false,
          showGrid: true,
          showContextmenu: true // view: {
          //   height: () => 400,
          //   width: () => ele.getBoundingClientRect().width
          // }

        }).change(function (excelData) {
          // console.log('----------')
          // console.log(excelData)
          // console.log(this.formatter(excelData))
          // console.log('----------')
          _this.$emit('change', _this.formatter(excelData)
          /** BinaryMatrix */
          ); // save data to db

        });
      }
    },
    // æ³¨æ(çæºç )ï¼ å¦æä¸è°ç¨ data æ props çæä¸ªå¼ï¼å render ä¸ä¼æ§è¡ãwatcher çæ´æ°æ¶æºæ¯ä»ä¹ï¼ï¼
    render: function render() {
      var h = arguments[0];
      return h("div", {
        "style": "max-height: 320px;overflow:scroll;"
      }, [h("div", {
        "style": "line-height:2;"
      }, [h("span", ["\u65B9\u68481: ", h(CsvImport, {
        "on": {
          "parse": this.parseCSV
        }
      })]), h("span", ["\u65B9\u68482: \u76F4\u63A5\u7F16\u8F91 Excel"]), h("div", {
        "ref": "excel",
        "style": "margin-right: 12px;width: 100%;overflow: scroll"
      })])]);
    },
    mounted: function mounted() {
      this.sheet = this.initSheet();
      this.refreshSheet({
        rows: this.innerItems
      });
    }
  };

  var _components$2;
  var lbpSlideCustomEditor = {
    components: (_components$2 = {}, defineProperty$3(_components$2, antDesignVue.Pagination.name, antDesignVue.Pagination), defineProperty$3(_components$2, antDesignVue.Button.name, antDesignVue.Pagination), _components$2),
    props: {
      elementProps: {
        type: Object,
        default: function _default() {
          return {
            items: [],
            activeIndex: 0
          };
        }
      }
    },
    computed: {
      innerItems: function innerItems() {
        return this.elementProps.items;
      }
    },
    data: function data() {
      return {
        current: 1
      };
    },
    methods: {
      itemRender: function itemRender(current, type, originalElement) {
        var _this = this;

        var h = this.$createElement;

        if (type === 'prev') {
          return h("a-button", {
            "style": {
              marginRight: '8px'
            },
            "attrs": {
              "size": "small",
              "icon": "minus",
              "disabled": this.innerItems.length === 1
            },
            "on": {
              "click": function click() {
                return _this.minus(current);
              }
            }
          });
        } else if (type === 'next') {
          return h("a-button", {
            "style": {
              marginLeft: '8px'
            },
            "attrs": {
              "size": "small",
              "icon": "plus"
            },
            "on": {
              "click": this.add
            }
          });
        }

        return originalElement;
      },
      add: function add() {
        this.elementProps.items.push({
          image: '',
          value: "\u9009\u9879".concat(this.innerItems.length + 1, "-value"),
          label: "\u9009\u9879".concat(this.innerItems.length + 1, "-label")
        });
      },
      minus: function minus(index) {
        if (this.innerItems.length === 1) return;
        this.elementProps.items.splice(index, 1); // this.elementProps.activeIndex = index > 0 ? index - 1 : 0

        this.elementProps.activeIndex = Math.max(index - 1, 0);
      }
    },
    render: function render() {
      var _this2 = this;

      var h = arguments[0];
      var currentItem = this.innerItems[this.current - 1] || {};
      return h("div", [h("a-pagination", {
        "attrs": {
          "current": this.current,
          "size": "small",
          "total": this.innerItems.length,
          "defaultPageSize": 1,
          "itemRender": this.itemRender
        },
        "on": {
          "change": function change(page) {
            _this2.current = page;
            _this2.elementProps.activeIndex = page - 1;
          }
        }
      }), h("lbs-image-gallery", {
        "style": {
          margin: '16px 0'
        },
        "attrs": {
          "value": currentItem.image
        },
        "on": {
          "change": function change(url) {
            currentItem.image = url;
          }
        }
      })]);
    }
  };

  var _components$3;

  function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var RenderPropsEditor = {
    components: (_components$3 = {}, defineProperty$3(_components$3, antDesignVue.Form.name, antDesignVue.Form), defineProperty$3(_components$3, antDesignVue.Form.Item.name, antDesignVue.Form.Item), defineProperty$3(_components$3, antDesignVue.Tabs.name, antDesignVue.Tabs), defineProperty$3(_components$3, antDesignVue.Button.name, antDesignVue.Button), defineProperty$3(_components$3, antDesignVue.Radio.name, antDesignVue.Radio), defineProperty$3(_components$3, antDesignVue.Radio.Group.name, antDesignVue.Radio.Group), defineProperty$3(_components$3, antDesignVue.Radio.Button.name, antDesignVue.Radio.Button), defineProperty$3(_components$3, antDesignVue.Input.name, antDesignVue.Input), defineProperty$3(_components$3, antDesignVue.Input.TextArea.name, antDesignVue.Input.TextArea), defineProperty$3(_components$3, antDesignVue.Switch.name, antDesignVue.Switch), defineProperty$3(_components$3, antDesignVue.InputNumber.name, antDesignVue.InputNumber), defineProperty$3(_components$3, antDesignVue.Select.name, antDesignVue.Select), defineProperty$3(_components$3, "colorsPanel", colorsPanel), defineProperty$3(_components$3, "lbsTextAlign", lbsTextAlign), defineProperty$3(_components$3, "lbsExcelEditor", lbsExcelEditor), defineProperty$3(_components$3, "lbpSlideCustomEditor", lbpSlideCustomEditor), _components$3),
    data: function data() {
      return {
        loadCustomEditorFlag: false
      };
    },
    props: {
      layout: {
        type: String,
        default: 'horizontal'
      },
      config: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      value: {
        type: Object,
        default: function _default() {
          return {};
        }
      }
    },
    watch: {
      config: function config() {
        var _this = this;

        // config éè¦éæ°render
        setTimeout(function () {
          _this.form.setFieldsValue(_this.value);
        });
      }
    },
    created: function created() {
      var _this2 = this;

      this.form = this.$form.createForm(this, {
        onFieldsChange: function onFieldsChange() {
          _this2.$emit('change', _this2.form.getFieldsValue());
        }
      });
    },
    computed: {
      formItemLayout: function formItemLayout() {
        return this.layout === 'horizontal' ? {
          labelCol: {
            span: 6
          },
          wrapperCol: {
            span: 16,
            offset: 2
          }
        } : {};
      }
    },
    methods: {
      renderPropFormItem: function renderPropFormItem(propName, propConfig) {
        var h = this.$createElement;
        var editor = propConfig.editor;
        if (!editor) return;
        var formItemData = {
          props: _objectSpread$4(_objectSpread$4(_objectSpread$4({}, this.formItemLayout), editor.layout), {}, {
            label: editor.label
          })
        };
        return h("a-form-item", helper$5([{}, formItemData]), [h(editor.type, helper$5([{
          "directives": [{
            name: "decorator",
            value: [propName]
          }]
        }, {
          "props": editor.props
        }]))]);
      }
    },
    render: function render() {
      var _this3 = this;

      var h = arguments[0];
      var configEntries = Object.entries(this.config);
      return h("a-form", {
        "attrs": {
          "form": this.form,
          "size": "mini",
          "layout": this.layout,
          "initialValue": this.value
        },
        "class": "props-config-form"
      }, [configEntries.map(function (_ref) {
        var _ref2 = slicedToArray(_ref, 2),
            propName = _ref2[0],
            propConfig = _ref2[1];

        return _this3.renderPropFormItem(propName, propConfig);
      })]);
    }
  };

  var _components$4;
  var RenderScriptEditor = {
    components: (_components$4 = {}, defineProperty$3(_components$4, antDesignVue.Input.TextArea.name, antDesignVue.Input.TextArea), defineProperty$3(_components$4, antDesignVue.Button.name, antDesignVue.Button), _components$4),
    data: function data() {
      return {
        editorContent: "return {\n      editorMethods: {              // \u6B64\u9879\u914D\u7F6E\u81EA\u5B9A\u4E49\u65B9\u6CD5\u7684\u5728\u7EC4\u4EF6\u914D\u7F6E\u9762\u677F\u5982\u4F55\u5C55\u793A\n        projectJump1: {             // \u65B9\u6CD5\u540D\uFF0C\u5BF9\u5E94\u4E8E methods \u5185\u7684\u67D0\u65B9\u6CD5\n          label: '\u5916\u90E8\u8DF3\u8F6C1',        // \u81EA\u5B9A\u4E49\u65B9\u6CD5\u663E\u793A\u540D\n          params: [                 // \u53C2\u6570\u5217\u8868\uFF0C\u5BF9\u8C61\u6570\u7EC4\n            {\n              label: '\u8DF3\u8F6C\u5730\u5740',     // \u53C2\u65701\u7684\u540D\u79F0\n              desc: '\u9879\u76EE\u76F8\u5BF9\u5730\u5740',   // \u53C2\u65701\u7684\u63CF\u8FF0\n              type: 'string',       // \u53C2\u65701\u7684\u7C7B\u578B\uFF0C\u652F\u6301string|number|boolean|array|object\n              default: ''           // \u53C2\u65701\u9ED8\u8BA4\u503C\n            },\n            {\n              label: '\u53C2\u6570',\n              desc: 'query\u5F62\u5F0F\u53C2\u6570',\n              type: 'object',\n              default: {}\n            }\n          ]\n        }\n      },\n      methods:{\n        projectJump1:function(url, query){\n          console.log(url, query)\n          let win = window.open(url, '_blank')\n          win.focus()\n        }\n      }\n    }"
      };
    },
    render: function render(h) {
      return h("span", [this.$t('editor.editPanel.common.empty')]);
    }
  };

  // @@match logic
  fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
    return [
      // `String.prototype.match` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O = requireObjectCoercible(this);
        var matcher = regexp == undefined ? undefined : regexp[MATCH];
        return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
      },
      // `RegExp.prototype[@@match]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
      function (regexp) {
        var res = maybeCallNative(nativeMatch, regexp, this);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);

        if (!rx.global) return regexpExecAbstract(rx, S);

        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;
        while ((result = regexpExecAbstract(rx, S)) !== null) {
          var matchStr = String(result[0]);
          A[n] = matchStr;
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          n++;
        }
        return n === 0 ? null : A;
      }
    ];
  });

  // #!zh: å¯éçå¨ç»åè¡¨çç¬¬ä¸ä¸ªå±çº§
  var firstLevelAnimationOptions = [{
    label: 'è¿å¥',
    value: /è¿/
  }, {
    label: 'éåº',
    value: /é/
  }, {
    label: 'å¼ºè°',
    value: /å¼ºè°|ç¹æ®/
  }];
  var animationOptions = [{
    label: '',
    value: 'ç©º',
    children: [{
      label: 'æ ',
      value: ''
    }]
  }, {
    label: 'å¼ºè°',
    value: 'Attention Seekers',
    children: [{
      label: 'æè½¬',
      value: 'justRotate'
    }, {
      label: 'å¼¹è·³',
      value: 'bounce'
    }, {
      label: 'éªç',
      value: 'flash'
    }, {
      label: 'è·³å¨',
      value: 'pulse'
    }, {
      label: 'æå¨',
      value: 'shake'
    }, {
      label: 'ææ',
      value: 'swing'
    }, {
      label: 'æ©¡ç®å',
      value: 'rubberBand'
    }, {
      label: 'æå»',
      value: 'jello'
    }, {
      label: '',
      value: 'tada'
    }, {
      label: '',
      value: 'wobble'
    }]
  }, {
    label: 'å¼¹è·³è¿å¥',
    value: 'Bouncing Entrances',
    children: [{
      label: 'å¼¹è·³è¿å¥',
      value: 'bounceIn'
    }, {
      label: 'åä¸å¼¹è·³è¿å¥',
      value: 'bounceInDown'
    }, {
      label: 'åå³å¼¹è·³è¿å¥',
      value: 'bounceInLeft'
    }, {
      label: 'åå·¦å¼¹è·³è¿å¥',
      value: 'bounceInRight'
    }, {
      label: 'åä¸å¼¹è·³è¿å¥',
      value: 'bounceInUp'
    }]
  }, {
    label: 'å¼¹è·³éåº',
    value: 'Bouncing Exits',
    children: [{
      label: 'å¼¹è·³éåº',
      value: 'bounceOut'
    }, {
      label: 'åä¸å¼¹è·³éåº',
      value: 'bounceOutDown'
    }, {
      label: 'åå·¦å¼¹è·³éåº',
      value: 'bounceOutLeft'
    }, {
      label: 'åå³å¼¹è·³éåº',
      value: 'bounceOutRight'
    }, {
      label: 'åä¸å¼¹è·³éåº',
      value: 'bounceOutUp'
    }]
  }, {
    label: 'æ¸æ¾è¿å¥',
    value: 'Fading Entrances',
    children: [{
      label: 'æ¸æ¾è¿å¥',
      value: 'fadeIn'
    }, {
      label: 'åä¸æ¸æ¾è¿å¥',
      value: 'fadeInDown'
    }, {
      label: 'ç±å±å¹å¤åä¸æ¸æ¾è¿å¥',
      value: 'fadeInDownBig'
    }, {
      label: 'åå³æ¾è¿å¥',
      value: 'fadeInLeft'
    }, {
      label: 'ç±å±å¹å¤åå³æ¸æ¾è¿å¥',
      value: 'fadeInLeftBig'
    }, {
      label: 'åå·¦æ¸æ¾è¿å¥',
      value: 'fadeInRight'
    }, {
      label: 'ç±å±å¹å¤åå·¦æ¸æ¾è¿å¥',
      value: 'fadeInRightBig'
    }, {
      label: 'åä¸æ¸æ¾è¿å¥',
      value: 'fadeInUp'
    }, {
      label: 'ç±å±å¹å¤åä¸æ¸æ¾è¿å¥',
      value: 'fadeInUpBig'
    }]
  }, {
    label: 'æ¸ééåº',
    value: 'Fading Exits',
    children: [{
      label: 'æ¸ééåº',
      value: 'fadeOut'
    }, {
      label: 'åä¸æ¸ééåº',
      value: 'fadeOutDown'
    }, {
      label: 'åä¸æ¸ééåºå±å¹å¤',
      value: 'fadeOutDownBig'
    }, {
      label: 'åå·¦æ¸ééåº',
      value: 'fadeOutLeft'
    }, {
      label: 'åå·¦æ¸ééåºå±å¹å¤',
      value: 'fadeOutLeftBig'
    }, {
      label: 'åå³æ¸ééåº',
      value: 'fadeOutRight'
    }, {
      label: 'åå³æ¸ééåºå±å¹å¤',
      value: 'fadeOutRightBig'
    }, {
      label: 'åä¸æ¸ééåº',
      value: 'fadeOutUp'
    }, {
      label: 'åä¸æ¸ééåºå±å¹å¤',
      value: 'fadeOutUpBig'
    }]
  }, {
    label: 'ç¿»å¨',
    value: 'Flippers',
    children: [{
      label: 'ç¿»å¨',
      value: 'flip'
    }, {
      label: 'çºµåç¿»å¨',
      value: 'flipInX'
    }, {
      label: 'æ¨ªåç¿»å¨',
      value: 'flipInY'
    }, {
      label: 'ç«ä½çºµåç¿»å¨',
      value: 'flipOutX'
    }, {
      label: 'ç«ä½æ¨ªåç¿»å¨',
      value: 'flipOutY'
    }]
  }, {
    label: 'å éè¿åº',
    value: 'Lightspeed',
    children: [{
      label: 'å éè¿å¥',
      value: 'lightSpeedIn'
    }, {
      label: 'å ééåº',
      value: 'lightSpeedOut'
    }]
  }, {
    label: 'æè½¬æ¸æ¾',
    value: 'Rotating Entrances',
    children: [{
      label: 'æè½¬æ¸æ¾',
      value: 'rotateIn'
    }, {
      label: 'å·¦ä¸è§æè½¬æ¸æ¾',
      value: 'rotateInDownLeft'
    }, {
      label: 'æè½¬æ¸æ¾',
      value: 'å³ä¸è§rotateInDownRight'
    }, {
      label: 'å·¦ä¸è§æè½¬æ¸æ¾',
      value: 'rotateInUpLeft'
    }, {
      label: 'å³ä¸è§æè½¬æ¸æ¾',
      value: 'rotateInUpRight'
    }]
  }, {
    label: 'æè½¬æ¸é',
    value: 'Rotating Exits',
    children: [{
      label: 'æè½¬æ¸é',
      value: 'rotateOut'
    }, {
      label: 'å·¦ä¸è§æè½¬æ¸é',
      value: 'rotateOutDownLeft'
    }, {
      label: 'å·¦ä¸è§æè½¬æ¸é',
      value: 'rotateOutDownRight'
    }, {
      label: 'å·¦ä¸è§æè½¬æ¸é',
      value: 'rotateOutUpLeft'
    }, {
      label: 'å³ä¸è§æè½¬æ¸é',
      value: 'rotateOutUpRight'
    }]
  }, {
    label: 'å¹³ç§»è¿å¥',
    value: 'Sliding Entrances',
    children: [{
      label: 'åä¸å¹³ç§»è¿å¥',
      value: 'slideInUp'
    }, {
      label: 'åä¸å¹³ç§»è¿å¥',
      value: 'slideInDown'
    }, {
      label: 'åå³å¹³ç§»è¿å¥',
      value: 'slideInLeft'
    }, {
      label: 'åå·¦å¹³ç§»è¿å¥',
      value: 'slideInRight'
    }]
  }, {
    label: 'å¹³ç§»éåº',
    value: 'Sliding Exits',
    children: [{
      label: 'åä¸å¹³ç§»éåº',
      value: 'slideOutUp'
    }, {
      label: 'åä¸å¹³ç§»éåº',
      value: 'slideOutDown'
    }, {
      label: 'åå·¦å¹³ç§»éåº',
      value: 'slideOutLeft'
    }, {
      label: 'åå³å¹³ç§»éåº',
      value: 'slideOutRight'
    }]
  }, {
    label: 'æ¾å¤§è¿å¥',
    value: 'Zoom Entrances',
    children: [{
      label: 'æ¾å¤§è¿å¥',
      value: 'zoomIn'
    }, {
      label: 'åä¸æ¾å¤§è¿å¥',
      value: 'zoomInDown'
    }, {
      label: 'åå³æ¾å¤§è¿å¥',
      value: 'zoomInLeft'
    }, {
      label: 'åå·¦æ¾å¤§è¿å¥',
      value: 'zoomInRight'
    }, {
      label: 'åä¸æ¾å¤§è¿å¥',
      value: 'zoomInUp'
    }]
  }, {
    label: 'ç¼©å°éåº',
    value: 'Zoom Exits',
    children: [{
      label: 'ç¼©å°éåº',
      value: 'zoomOut'
    }, {
      label: 'åä¸ç¼©å°éåº',
      value: 'zoomOutDown'
    }, {
      label: 'åå·¦ç¼©å°éåº',
      value: 'zoomOutLeft'
    }, {
      label: 'åå³ç¼©å°éåº',
      value: 'zoomOutRight'
    }, {
      label: 'åä¸ç¼©å°éåº',
      value: 'zoomOutUp'
    }]
  }, {
    label: 'ç¹æ®ææ',
    value: 'Specials',
    children: [{
      label: 'æ¬æ',
      value: 'hinge'
    }, {
      label: 'æ»å¨è¿å¥',
      value: 'rollIn'
    }, {
      label: 'æ»å¨éåº',
      value: 'rollOut'
    }]
  }];
  /**
   * @return {Object} { animationValue: animatonLabel }
   */

  var animationValue2Name = animationOptions.reduce(function (obj, curr) {
    var items = curr.children;
    items.forEach(function (item) {
      obj[item.value] = item.label;
    });
    return obj;
  }, {});

  var _components$5;
  var RenderAnimationEditor = {
    components: (_components$5 = {}, defineProperty$3(_components$5, antDesignVue.InputNumber.name, antDesignVue.InputNumber), defineProperty$3(_components$5, antDesignVue.Tabs.name, antDesignVue.Tabs), defineProperty$3(_components$5, antDesignVue.List.name, antDesignVue.List), defineProperty$3(_components$5, antDesignVue.List.Item.name, antDesignVue.List.Item), defineProperty$3(_components$5, antDesignVue.Form.name, antDesignVue.Form), defineProperty$3(_components$5, antDesignVue.Button.name, antDesignVue.Button), defineProperty$3(_components$5, antDesignVue.Popover.name, antDesignVue.Popover), defineProperty$3(_components$5, antDesignVue.Slider.name, antDesignVue.Slider), defineProperty$3(_components$5, antDesignVue.Switch.name, antDesignVue.Switch), defineProperty$3(_components$5, antDesignVue.Collapse.name, antDesignVue.Collapse), defineProperty$3(_components$5, antDesignVue.Collapse.Panel.name, antDesignVue.Collapse.Panel), defineProperty$3(_components$5, antDesignVue.Icon.name, antDesignVue.Icon), defineProperty$3(_components$5, antDesignVue.Drawer.name, antDesignVue.Drawer), defineProperty$3(_components$5, antDesignVue.Tabs.TabPane.name, antDesignVue.Tabs.TabPane), defineProperty$3(_components$5, antDesignVue.Button.Group.name, antDesignVue.Button.Group), defineProperty$3(_components$5, antDesignVue.Form.Item.name, antDesignVue.Form.Item), defineProperty$3(_components$5, antDesignVue.Tag.name, antDesignVue.Tag), _components$5),
    props: {
      value: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    computed: {
      animationQueue: function animationQueue() {
        return this.value || [];
      }
    },
    data: function data() {
      return {
        activeCollapsePanel: 0,
        activePreviewAnimation: '',
        drawerVisible: false
      };
    },
    methods: {
      addAnimation: function addAnimation() {
        this.animationQueue.push({
          type: '',
          duration: 1,
          delay: 0,
          interationCount: 1,
          infinite: false
        });
        this.activeCollapsePanel = this.animationQueue.length - 1;
        this.$emit('change', this.animationQueue);
      },
      deleteAnimate: function deleteAnimate(index) {
        this.animationQueue.splice(index, 1);
        this.$emit('change', this.animationQueue);
      },
      updateAnimation: function updateAnimation(type) {
        var activeAnimationQueue = this.animationQueue[this.activeCollapsePanel];

        if (activeAnimationQueue) {
          activeAnimationQueue.type = type;
        }

        this.drawerVisible = false;
        this.$emit('change', this.animationQueue);
      },
      runAnimate: function runAnimate() {
        EventBus.$emit('RUN_ANIMATIONS');
      },
      renderSecondAnimationTabs: function renderSecondAnimationTabs(animations) {
        var _this = this;

        var h = this.$createElement;
        return h("a-tabs", {
          "attrs": {
            "defaultActiveKey": animations[0].value,
            "tabBarStyle": {
              marginLeft: '-16px'
            },
            "size": "small",
            "tabBarGutter": 0,
            "tabPosition": "left"
          },
          "on": {
            "change": function change(tab) {}
          },
          "style": "width:100%;"
        }, [animations.map(function (group) {
          return h("a-tab-pane", {
            "attrs": {
              "tab": group.label || group.value
            },
            "key": group.value
          }, [h("a-list", {
            "attrs": {
              "grid": {
                gutter: 12,
                column: 2
              },
              "dataSource": group.children,
              "renderItem": function renderItem(item, index) {
                return h("a-list-item", {
                  "class": "shortcut-button-wrapper"
                }, [h("div", {
                  "on": {
                    "click": function click() {
                      return _this.updateAnimation(item.value);
                    },
                    "mouseenter": function mouseenter(e) {
                      _this.activePreviewAnimation = item.value;
                    },
                    "mouseleave": function mouseleave() {}
                  },
                  "class": ['shortcut-button', _this.activePreviewAnimation === item.value && "".concat(item.value, " animated")]
                }, [item.label])]);
              }
            }
          })]);
        })]);
      },
      renderAvaiableAnimations: function renderAvaiableAnimations() {
        var _this2 = this;

        var h = this.$createElement;
        return h("a-tabs", {
          "class": "avaiable-animations-tabs",
          "attrs": {
            "defaultActiveKey": firstLevelAnimationOptions[0].label,
            "size": "small",
            "tabBarGutter": 0
          },
          "on": {
            "change": function change(tab) {}
          },
          "style": "width:100%;"
        }, [firstLevelAnimationOptions.map(function (firstGroup) {
          return h("a-tab-pane", {
            "attrs": {
              "tab": firstGroup.label
            },
            "key": firstGroup.label
          }, [_this2.renderSecondAnimationTabs(animationOptions.filter(function (group) {
            return !!group.label.match(firstGroup.value);
          }))]);
        })]);
      },
      renderAnimationOptions: function renderAnimationOptions(animationOption) {
        var _this3 = this;

        var h = this.$createElement;
        return h("a-form", {
          "attrs": {
            "layout": "horizontal"
          }
        }, [h("a-form-item", {
          "attrs": {
            "label": this.$t('editor.editPanel.animation.type'),
            "labelCol": {
              span: 5
            },
            "wrapperCol": {
              span: 16,
              offset: 2
            }
          }
        }, [h("a-button", {
          "attrs": {
            "type": "link",
            "size": "small",
            "icon": "ordered-list"
          },
          "on": {
            "click": function click() {
              _this3.drawerVisible = true;
            }
          }
        }, [this.$t('editor.editPanel.animation.list')])]), h("a-form-item", {
          "attrs": {
            "label": this.$t('editor.editPanel.animation.duration'),
            "labelCol": {
              span: 5
            },
            "wrapperCol": {
              span: 16,
              offset: 2
            }
          },
          "style": "margin-bottom:0;"
        }, [h("a-form-item", {
          "style": {
            display: 'inline-block',
            width: 'calc(50% - 12px)'
          }
        }, [h("a-slider", {
          "attrs": {
            "defaultValue": 2,
            "min": 0,
            "max": 20,
            "value": animationOption.duration
          },
          "on": {
            "change": function change(value) {
              animationOption.duration = value;
            }
          }
        })]), h("a-form-item", {
          "style": {
            display: 'inline-block',
            width: 'calc(50% - 12px)',
            marginLeft: '4px'
          }
        }, [h("a-input-number", {
          "attrs": {
            "min": 0,
            "max": 20,
            "size": "small",
            "formatter": function formatter(value) {
              return "".concat(value, "\u79D2(s)");
            },
            "value": animationOption.duration
          },
          "on": {
            "change": function change(value) {
              animationOption.duration = value;
            }
          }
        })])]), h("a-form-item", {
          "attrs": {
            "label": this.$t('editor.editPanel.animation.delay'),
            "labelCol": {
              span: 5
            },
            "wrapperCol": {
              span: 16,
              offset: 2
            }
          },
          "style": "margin-bottom:0;"
        }, [h("a-form-item", {
          "style": {
            display: 'inline-block',
            width: 'calc(50% - 12px)'
          }
        }, [h("a-slider", {
          "attrs": {
            "defaultValue": 2,
            "min": 0,
            "max": 20,
            "value": animationOption.delay
          },
          "on": {
            "change": function change(value) {
              animationOption.delay = value;
            }
          }
        })]), h("a-form-item", {
          "style": {
            display: 'inline-block',
            width: 'calc(50% - 12px)',
            marginLeft: '4px'
          }
        }, [h("a-input-number", {
          "attrs": {
            "min": 0,
            "max": 20,
            "size": "small",
            "formatter": function formatter(value) {
              return "".concat(value, "\u79D2(s)");
            },
            "value": animationOption.delay
          },
          "on": {
            "change": function change(value) {
              animationOption.delay = value;
            }
          }
        })])]), h("a-form-item", {
          "attrs": {
            "label": this.$t('editor.editPanel.animation.iteration'),
            "labelCol": {
              span: 5
            },
            "wrapperCol": {
              span: 16,
              offset: 2
            }
          },
          "style": "margin-bottom:0;"
        }, [h("a-form-item", {
          "style": {
            display: 'inline-block',
            width: 'calc(50% - 12px)'
          }
        }, [h("a-slider", {
          "attrs": {
            "defaultValue": 2,
            "min": 0,
            "max": 20,
            "value": animationOption.interationCount
          },
          "on": {
            "change": function change(value) {
              animationOption.interationCount = value;
            }
          }
        })]), h("a-form-item", {
          "style": {
            display: 'inline-block',
            width: 'calc(50% - 12px)',
            marginLeft: '4px'
          }
        }, [h("a-input-number", {
          "attrs": {
            "min": 0,
            "max": 20,
            "size": "small",
            "formatter": function formatter(value) {
              return "".concat(value, "\u6B21(times)");
            },
            "value": animationOption.interationCount
          },
          "on": {
            "change": function change(value) {
              animationOption.interationCount = value;
            }
          }
        })])]), h("a-form-item", {
          "attrs": {
            "label": this.$t('editor.editPanel.animation.inifinite'),
            "labelCol": {
              span: 5
            },
            "wrapperCol": {
              span: 16,
              offset: 2
            }
          },
          "style": "margin-bottom:0;"
        }, [h("a-switch", {
          "attrs": {
            "value": animationOption.infinite
          },
          "on": {
            "change": function change(value) {
              animationOption.infinite = value;
            }
          }
        })])]);
      }
    },
    render: function render(h) {
      var _this4 = this;

      return h("div", {
        "class": "main-animate widget",
        "attrs": {
          "id": "animation-right-panel"
        }
      }, [h("a-button-group", [h("a-button", {
        "attrs": {
          "type": "primary"
        },
        "on": {
          "click": this.addAnimation
        }
      }, [h("a-icon", {
        "attrs": {
          "type": "plus"
        }
      }), this.$t('editor.editPanel.animation.add')]), h("a-button", {
        "attrs": {
          "type": "primary"
        },
        "on": {
          "click": this.runAnimate
        }
      }, [this.$t('editor.editPanel.animation.run'), h("a-icon", {
        "attrs": {
          "type": "right-circle"
        }
      })])]), h("a-collapse", {
        "attrs": {
          "accordion": true,
          "activeKey": '' + this.activeCollapsePanel
        },
        "class": "collapse-wrapper",
        "on": {
          "change": function change(key) {
            // å½å¨é¨æ¶èµ·æ¥æ¶åï¼key ä¸º undefined
            _this4.activeCollapsePanel = typeof key !== 'undefined' ? +key : -1;
          }
        }
      }, [this.animationQueue.map(function (addedAnimation, index) {
        return h("a-collapse-panel", {
          "key": "".concat(index)
        }, [h("template", {
          "slot": "header"
        }, [h("span", [_this4.$t('editor.editPanel.animation.title', {
          index: index + 1
        })]), h("a-tag", {
          "attrs": {
            "color": "orange"
          }
        }, [animationValue2Name[addedAnimation.type] || addedAnimation.type]), h("a-icon", {
          "attrs": {
            "type": "delete",
            "title": "å é¤å¨ç»"
          },
          "on": {
            "click": function click() {
              return _this4.deleteAnimate(index);
            }
          }
        })]), _this4.renderAnimationOptions(addedAnimation)]);
      })]), h("a-drawer", {
        "attrs": {
          "title": "è¯·éæ©å¨ç»",
          "placement": "left",
          "closable": true,
          "width": "100%",
          "visible": this.drawerVisible,
          "wrapStyle": {
            position: 'absolute'
          },
          "getContainer": false
        },
        "on": {
          "close": function close() {
            _this4.drawerVisible = false;
          }
        }
      }, [h("div", [this.renderAvaiableAnimations()])])]);
    }
  };

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-02 16:12:09
   * @LastEditTime : 2020-11-12 16:35:48
   * @Description :
   */
  var RenderActionEditor = {
    data: function data() {
      return {};
    },
    render: function render() {
      var h = arguments[0];
      var ele = this.editingElement;
      if (!ele) return h("span", [this.$t('editor.editPanel.common.empty')]);
      return h("div", ["TODO"]);
    }
  };

  var freezing = !fails(function () {
    return Object.isExtensible(Object.preventExtensions({}));
  });

  var internalMetadata = createCommonjsModule(function (module) {
  var defineProperty = objectDefineProperty.f;



  var METADATA = uid('meta');
  var id = 0;

  var isExtensible = Object.isExtensible || function () {
    return true;
  };

  var setMetadata = function (it) {
    defineProperty(it, METADATA, { value: {
      objectID: 'O' + ++id, // object ID
      weakData: {}          // weak collections IDs
    } });
  };

  var fastKey = function (it, create) {
    // return a primitive with prefix
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!has(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F';
      // not necessary to add metadata
      if (!create) return 'E';
      // add missing metadata
      setMetadata(it);
    // return object ID
    } return it[METADATA].objectID;
  };

  var getWeakData = function (it, create) {
    if (!has(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true;
      // not necessary to add metadata
      if (!create) return false;
      // add missing metadata
      setMetadata(it);
    // return the store of weak collections IDs
    } return it[METADATA].weakData;
  };

  // add metadata on freeze-family methods calling
  var onFreeze = function (it) {
    if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
    return it;
  };

  var meta = module.exports = {
    REQUIRED: false,
    fastKey: fastKey,
    getWeakData: getWeakData,
    onFreeze: onFreeze
  };

  hiddenKeys[METADATA] = true;
  });

  var onFreeze = internalMetadata.onFreeze;

  var nativeFreeze = Object.freeze;
  var FAILS_ON_PRIMITIVES$2 = fails(function () { nativeFreeze(1); });

  // `Object.freeze` method
  // https://tc39.github.io/ecma262/#sec-object.freeze
  _export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$2, sham: !freezing }, {
    freeze: function freeze(it) {
      return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
    }
  });

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-02 16:12:09
   * @LastEditTime : 2020-11-06 14:56:14
   * @Description :
   */

  /**
    * é¡µé¢æ¨¡å¼ï¼æä¸¾å¼
    * h5_swipper ç¿»é¡µH5
    * h5_long_page é¿é¡µé¢H5
   */
  var PAGE_MODE = {
    SWIPPER_PAGE: 'h5_swipper',
    LONG_PAGE: 'h5_long_page',
    WIDTH: 375,
    HEIGHT: 667
  };
  var PAGE_MODE_LABEL = {
    SWIPPER_PAGE: 'ç¿»é¡µH5',
    LONG_PAGE: 'é¿é¡µé¢'
  };

  var _components$6;
  var RenderBackgroundEditor = {
    components: (_components$6 = {}, defineProperty$3(_components$6, antDesignVue.Form.name, antDesignVue.Form), defineProperty$3(_components$6, antDesignVue.Form.Item.name, antDesignVue.Form.Item), defineProperty$3(_components$6, antDesignVue.Radio.Group.name, antDesignVue.Radio.Group), defineProperty$3(_components$6, antDesignVue.Radio.Button.name, antDesignVue.Radio.Button), _components$6),
    data: function data() {
      return {
        formLayout: 'vertical',
        PAGE_MODE: Object.freeze(PAGE_MODE),
        PAGE_MODE_LABEL: Object.freeze(PAGE_MODE_LABEL)
      };
    },
    computed: {
      pageMode: {
        get: function get() {
          return this.work.page_mode || PAGE_MODE.SWIPPER_PAGE;
        },
        set: function set(pageMode) {
          this.updateWork({
            page_mode: pageMode
          });
        }
      }
    },
    render: function render() {
      var _this = this;

      var h = arguments[0];
      return h("div", [h("a-form", {
        "attrs": {
          "layout": this.formLayout
        }
      }, [h("a-form-item", {
        "attrs": {
          "label": "H5ç±»å"
        }
      }, [h("a-radio-group", {
        "attrs": {
          "size": "small"
        },
        "model": {
          value: _this.pageMode,
          callback: function callback($$v) {
            _this.pageMode = $$v;
          }
        }
      }, [PAGE_MODE.map(function (v, k) {
        return h("a-radio-button", {
          "key": k,
          "attrs": {
            "value": v
          }
        }, [PAGE_MODE_LABEL[k]]);
      })])])])]);
    }
  };

  var _components$7;
  var EditorRightPanel = {
    name: 'ElementPropsEditor',
    components: (_components$7 = {}, defineProperty$3(_components$7, antDesignVue.Layout.Sider.name, antDesignVue.Layout.Sider), defineProperty$3(_components$7, antDesignVue.Tabs.name, antDesignVue.Tabs), defineProperty$3(_components$7, antDesignVue.Tabs.TabPane.name, antDesignVue.Tabs.TabPane), _components$7),
    props: {
      width: {
        type: Number,
        default: 375
      },
      element: {
        type: Object,
        default: function _default() {
          return {};
        }
      }
    },
    computed: {
      editPropsConfig: function editPropsConfig() {
        var element = this.element;

        if (element && element.name) {
          var _pluginsControl$getPl = lbpPluginController.getPlugin(element.name),
              component = _pluginsControl$getPl.component;

          return this.getPropsWithEditor(component.props);
        } else {
          return {};
        }
      },
      editPropsValue: function editPropsValue() {
        var element = this.element,
            editPropsConfig = this.editPropsConfig;
        var editPropsConfigKeys = Object.keys(editPropsConfig);
        var props = element ? element.props : {};
        var propsValue = {};
        editPropsConfigKeys.forEach(function (key) {
          propsValue[key] = props[key];
        });
        return propsValue;
      },
      editAnimationValue: function editAnimationValue() {
        var element = this.element;
        var animations = element ? element.animations : [];
        return animations;
      }
    },
    data: function data() {
      return {
        activeTabKey: 'å±æ§'
      };
    },
    methods: {
      setActiveTab: function setActiveTab(activeTabKey) {
        this.activeTabKey = activeTabKey;
      },
      getPropsWithEditor: function getPropsWithEditor(props) {
        var propsWithEditor = {};
        Object.entries(props).forEach(function (_ref) {
          var _ref2 = slicedToArray(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          if (value.editor) {
            propsWithEditor[key] = value;
          }
        });
        return propsWithEditor;
      }
    },
    render: function render() {
      var h = arguments[0];
      return h("a-layout-sider", {
        "attrs": {
          "width": this.width,
          "theme": "light"
        },
        "style": {
          padding: '0 12px'
        }
      }, [h("a-tabs", {
        "style": "height: 100%;",
        "attrs": {
          "tabBarGutter": 10,
          "defaultActiveKey": this.activeTabKey,
          "activeKey": this.activeTabKey
        },
        "on": {
          "change": this.setActiveTab
        }
      }, [h("a-tab-pane", {
        "key": "å±æ§"
      }, [h("span", {
        "slot": "tab"
      }, [this.$t('editor.editPanel.tab.prop')]), h(RenderPropsEditor, {
        "attrs": {
          "config": this.editPropsConfig,
          "value": this.editPropsValue
        },
        "on": {
          "change": this.$listeners.propsChange
        }
      })]), h("a-tab-pane", {
        "attrs": {
          "label": "å¨ç»",
          "tab": this.$t('editor.editPanel.tab.animation')
        },
        "key": "å¨ç»"
      }, [h(RenderAnimationEditor, {
        "attrs": {
          "value": this.editAnimationValue
        },
        "on": {
          "change": this.$listeners.animationsChange
        }
      })]), h("a-tab-pane", {
        "attrs": {
          "label": "å¨ä½",
          "tab": this.$t('editor.editPanel.tab.action')
        },
        "key": "å¨ä½"
      }, [this.activeTabKey === 'å¨ä½' && h(RenderActionEditor)]), h("a-tab-pane", {
        "attrs": {
          "label": "èæ¬",
          "tab": this.$t('editor.editPanel.tab.script')
        },
        "key": "èæ¬"
      }, [h(RenderScriptEditor)]), h("a-tab-pane", {
        "attrs": {
          "label": "é¡µé¢",
          "tab": this.$t('editor.editPanel.tab.page')
        },
        "key": "é¡µé¢"
      }, [this.activeTabKey === 'é¡µé¢' && h(RenderBackgroundEditor)])])]);
    }
  };

  var ShortcutButton = {
    functional: true,
    props: {
      faIcon: {
        required: true,
        type: String
      },
      title: {
        required: true,
        type: String
      },
      clickFn: {
        required: false,
        type: Function,
        default: function _default() {}
      },
      mousedownFn: {
        required: false,
        type: Function,
        default: function _default() {}
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    render: function render(h, _ref) {
      var props = _ref.props,
          listeners = _ref.listeners,
          slots = _ref.slots;
      return h("button", {
        "class": "shortcut-button",
        "on": {
          "click": props.clickFn,
          "mousedown": props.mousedownFn
        },
        "attrs": {
          "disabled": props.disabled
        }
      }, [h("i", {
        "class": ['shortcut-icon', 'fa', "fa-".concat(props.faIcon)],
        "attrs": {
          "aria-hidden": 'true'
        }
      }), h("span", [props.title])]);
    }
  };

  var UsageTip = {
    components: defineProperty$3({}, antDesignVue.Icon.name, antDesignVue.Icon),
    render: function render() {
      var h = arguments[0];
      return h("div", {
        "class": "plugin-usage-tip "
      }, [h("a-icon", {
        "attrs": {
          "type": "info-circle"
        }
      }), h("i18n", {
        "attrs": {
          "path": "editor.tip.componentUsage",
          "tag": "span"
        },
        "class": "ml-1"
      }, [h("strong", [this.$t('editor.tip.click')]), this.$t('editor.tip.click')])]);
    }
  };

  var _components$8;

  function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$1 = {
    components: (_components$8 = {}, defineProperty$3(_components$8, antDesignVue.Modal.name, antDesignVue.Modal), defineProperty$3(_components$8, antDesignVue.Input.TextArea.name, antDesignVue.Input.TextArea), defineProperty$3(_components$8, antDesignVue.Button.name, antDesignVue.Button), _components$8),
    data: function data() {
      return {
        visible: false,
        confirmLoading: false,
        text: JSON.stringify([{
          package: '@luban-h5/lbp-slide',
          version: '0.0.7',
          name: 'lbp-slide',
          icon: 'photo',
          i18nTitle: {
            'en-US': 'Carousel',
            'zh-CN': 'è½®æ­å¾'
          },
          title: 'è½®æ­å¾',
          visible: true
        }], null, 2)
      };
    },
    methods: {
      showModal: function showModal() {
        this.visible = true;
      },
      handleOk: function handleOk(e) {
        var createjs = window.createjs; // eslint-disable-next-line no-new-func

        var npmPackages = new Function("return ".concat(this.text).replace('\n', ''))();
        npmPackages = npmPackages.map(function (pluginInfo) {
          return _objectSpread$5(_objectSpread$5({}, pluginInfo), {}, {
            // src: `https://cdn.jsdelivr.net/npm/${pluginInfo}/dist/${pluginInfo.name}.umd.js`
            // src: `https://unpkg.com/${pluginInfo}/dist/${pluginName}.umd.js`
            src: "https://cdn.jsdelivr.net/npm/".concat(pluginInfo.package, "@").concat(pluginInfo.version, "/dist/").concat(pluginInfo.name, ".umd.js")
          });
        });
        var queue = new createjs.LoadQueue();
        queue.on('fileload', handleFileLoad, this);
        queue.on('complete', handleComplete, this);
        queue.loadManifest(npmPackages);

        function handleComplete(e) {
          // å¯ä»¥ç´æ¥ä½¿ç¨ this çåå ï¼ queryãon æåä¸ä¸ªåæ°ç¨æ¥åå bind this æä½
          this.visible = false;
          this.confirmLoading = false;
          this.$emit('loadComplete', npmPackages);
        }

        function handleFileLoad(event) {
          var name = event.item.name;
          Vue__default['default'].component(name, window[name]);
        }
      },
      handleCancel: function handleCancel(e) {
        this.visible = false;
      }
    }
  };

  /* script */
  const __vue_script__$1 = script$1;

  /* template */
  var __vue_render__$1 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticStyle: { "text-align": "center" } },
      [
        _c(
          "a-button",
          {
            staticStyle: { "margin-top": "16px" },
            attrs: { type: "primary" },
            on: { click: _vm.showModal }
          },
          [_vm._v("éç½® NPM ç»ä»¶åè¡¨")]
        ),
        _vm._v(" "),
        _c(
          "a-modal",
          {
            attrs: {
              title: "NPM ç»ä»¶åè¡¨éç½®ä¿¡æ¯",
              visible: _vm.visible,
              confirmLoading: _vm.confirmLoading
            },
            on: { ok: _vm.handleOk, cancel: _vm.handleCancel }
          },
          [
            _c(
              "div",
              [
                _c("a-textarea", {
                  attrs: { placeholder: "Basic usage", rows: 20 },
                  model: {
                    value: _vm.text,
                    callback: function($$v) {
                      _vm.text = $$v;
                    },
                    expression: "text"
                  }
                })
              ],
              1
            )
          ]
        )
      ],
      1
    )
  };
  var __vue_staticRenderFns__$1 = [];
  __vue_render__$1._withStripped = true;

    /* style */
    const __vue_inject_styles__$1 = undefined;
    /* scoped */
    const __vue_scope_id__$1 = undefined;
    /* module identifier */
    const __vue_module_identifier__$1 = undefined;
    /* functional template */
    const __vue_is_functional_template__$1 = false;
    /* style inject */
    
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__$1 = /*#__PURE__*/normalizeComponent(
      { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
      __vue_inject_styles__$1,
      __vue_script__$1,
      __vue_scope_id__$1,
      __vue_is_functional_template__$1,
      __vue_module_identifier__$1,
      false,
      undefined,
      undefined,
      undefined
    );

  function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  /*
   * @Author: ly525
   * @Date: 2020-05-17 17:21:04
   * @LastEditors : Please set LastEditors
   * @LastEditTime : 2020-11-11 17:03:29
   * @FilePath: /luban-h5/front-end/h5/src/components/@/mixins/drag.js
   * @Github: https://github.com/ly525/luban-h5
   * @Copyright 2018 - 2020 luban-h5. All Rights Reserved
   * @Description:
   *  ç»ä»¶ææ½è³ç»å¸åè½
   *  å¶ä¸­é¨åä»£ç åèèªï¼https://github.com/hakubox/haku-form-designï¼å·²ç»å¾å¾ä½èåæï¼ç®çæ¯åç»­èèå tab ä¹ç±»çåµå¥å®¹å¨
   */
  var dragDom = null;
  var dragConfig = {
    isPreDrag: false,
    // åå¤ææ½
    isDrag: false,
    // æ­£å¼ææ½
    origin: {
      clientY: 0,
      // é¼ æ æä¸æ¶åæ¶åå¼
      clientX: 0,
      layerX: 0,
      // é¼ æ .x ç¸å¯¹äºåç´ å·¦ä¸è§.left çåç§»
      layerY: 0 // é¼ æ .y ç¸å¯¹äºåç´ å·¦ä¸è§.top  çåç§»

    }
  };

  var Drag = /*#__PURE__*/function () {
    function Drag(options) {
      classCallCheck(this, Drag);

      this.mousedown = options.mousedown;
      this.mousemove = options.mousemove;
      this.mouseup = options.mouseup;
      this._mousedown = this._mousedown.bind(this);
      this._mousemove = this._mousemove.bind(this);
      this._mouseup = this._mouseup.bind(this);
    }

    createClass(Drag, [{
      key: "start",
      value: function start(e) {
        this._mousedown(e);
      }
    }, {
      key: "_mousedown",
      value: function _mousedown(e) {
        this.mousedown(e);
        this.toggleListener('add');
      }
    }, {
      key: "_mousemove",
      value: function _mousemove(e) {
        this.mousemove(e);
      }
    }, {
      key: "_mouseup",
      value: function _mouseup(e) {
        this.mouseup(e);
        this.toggleListener('remove');
      }
    }, {
      key: "toggleListener",
      value: function toggleListener(action) {
        document["".concat(action, "EventListener")]('mousemove', this._mousemove);
        document["".concat(action, "EventListener")]('mouseup', this._mouseup);
      }
    }]);

    return Drag;
  }();

  var dragMixin = {
    data: function data() {
      return {};
    },
    methods: {
      /**
       *
       * @param {*} element shortcutItem
       * @param {*} e
       */
      handleDragStartFromMixin: function handleDragStartFromMixin(element, e) {
        // https://developer.mozilla.org/zh-CN/docs/Web/API/event.button
        // 0 ä¸º å·¦é®ç¹å».
        if (e.button !== 0) return;

        if (dragDom) {
          document.body.removeChild(dragDom);
          dragDom = null;
        }

        this.dragElement = element;
        dragDom = e.target.cloneNode(true);
        document.body.appendChild(dragDom);
        new Drag({
          mousedown: this.mousedown,
          mousemove: this.mousemove,
          mouseup: this.mouseup
        }).start(e);
      },

      /**
       *
       * @param {*} e
       */
      mousedown: function mousedown(e) {
        // é¼ æ .x ç¸å¯¹äºåç´ å·¦ä¸è§ çåç§»
        var layerX = e.layerX,
            layerY = e.layerY;
        dragConfig.origin.layerX = layerX;
        dragConfig.origin.layerY = layerY;
        dragConfig.origin.clientX = e.clientX;
        dragConfig.origin.clientY = e.clientY;
        dragDom.style.position = 'absolute';
        dragDom.style.left = e.clientX - layerX + 'px';
        dragDom.style.top = e.clientY - layerY + 'px';
        dragDom.classList.add('dragging-dom-ele', 'hidden');
        dragConfig.isPreDrag = true;
      },

      /** ç»ä»¶ææ½ä¸­ */
      mousemove: function mousemove(e) {
        dragDom.classList.remove('hidden');
        var _dragConfig$origin = dragConfig.origin,
            layerX = _dragConfig$origin.layerX,
            layerY = _dragConfig$origin.layerY;
        dragDom.style.left = e.clientX - layerX + 'px';
        dragDom.style.top = e.clientY - layerY + 'px';
      },
      mouseup: function mouseup(e) {
        var _dragConfig$origin2 = dragConfig.origin,
            layerX = _dragConfig$origin2.layerX,
            layerY = _dragConfig$origin2.layerY;
        document.body.removeChild(dragDom);
        dragDom = null;
        var canMousedown = this.checkCanMousedown(e, {
          minOffset: 10
        });
        if (!canMousedown) return;
        var canvasWrapper = document.querySelector('.lb-canvas');
        var position = canvasWrapper.getBoundingClientRect();
        this.dragElement && this.clone(_objectSpread$6(_objectSpread$6({}, this.dragElement), {}, {
          dragStyle: {
            left: e.clientX - layerX - position.left,
            top: e.clientY - layerY - position.top
          }
        }));
      },
      checkCanMousedown: function checkCanMousedown(e, _ref) {
        var minOffsetX = _ref.minOffsetX,
            minOffsetY = _ref.minOffsetY,
            minOffset = _ref.minOffset;
        var offsetX = e.clientX - dragConfig.origin.clientX;
        var offsetY = e.clientY - dragConfig.origin.clientY;
        return offsetX >= (minOffsetX || minOffset) || offsetY >= (minOffsetY || minOffset);
      }
    },
    updated: function updated() {
      console.log('updated');
    }
  };

  var _components$9;
  var RenderShortcutsPanel = {
    name: 'shotcuts-panel',
    components: (_components$9 = {}, defineProperty$3(_components$9, antDesignVue.Row.name, antDesignVue.Row), defineProperty$3(_components$9, antDesignVue.Col.name, antDesignVue.Col), _components$9),
    mixins: [dragMixin],
    data: function data() {
      return {
        npmPackages: []
      };
    },
    methods: {
      clone: function clone(shortcutItem) {
        this.$emit('add', shortcutItem);
      }
    },
    render: function render(h) {
      var _this = this;

      return h("a-row", {
        "style": "padding-bottom: 24px"
      }, [h(UsageTip), [].concat(lbpPluginController.getPlugins(), this.npmPackages).filter(function (plugin) {
        return plugin.visible;
      }).map(function (plugin) {
        return h("a-col", {
          "attrs": {
            "span": 12
          },
          "style": {
            marginTop: '10px'
          }
        }, [h(ShortcutButton, {
          "attrs": {
            "clickFn": _this.clone.bind(_this, plugin),
            "mousedownFn": _this.handleDragStartFromMixin.bind(_this, plugin),
            "title": plugin.i18nTitle[_this.$i18n.locale] || plugin.title,
            "faIcon": plugin.icon,
            "disabled": plugin.disabled
          }
        })]);
      }), h(__vue_component__$1, {
        "on": {
          "loadComplete": function loadComplete(npmPackages) {
            _this.npmPackages = npmPackages;
          }
        }
      })]);
    }
  };

  var _components$a;
  var PageTitleEditor = {
    components: (_components$a = {}, defineProperty$3(_components$a, antDesignVue.Popconfirm.name, antDesignVue.Popconfirm), defineProperty$3(_components$a, antDesignVue.Input.name, antDesignVue.Input), defineProperty$3(_components$a, antDesignVue.Icon.name, antDesignVue.Icon), _components$a),
    props: ['page', 'pageIndex'],
    data: function data() {
      return {
        editingTitle: '' // ä¸´æ¶ç¼å­å½åç¼è¾ç titleï¼ç¹å» Yes åçæ­£ç¨å¶æ´æ° page title

      };
    },
    methods: {
      getTitle: function getTitle() {
        return this.page.title || this.$t('editor.pageManager.title', {
          index: this.pageIndex
        });
      }
    },
    render: function render() {
      var _this = this;

      var h = arguments[0];
      return h("a-popconfirm", {
        "attrs": {
          "placement": "bottom",
          "okText": "Yes",
          "cancelText": "No"
        },
        "on": {
          "confirm": function confirm() {
            _this.$emit('editTitle', {
              newTitle: _this.editingTitle,
              pageIndex: _this.pageIndex
            });
          },
          "cancel": function cancel() {}
        }
      }, [h("a-input", {
        "slot": "title",
        "attrs": {
          "value": this.editingTitle,
          "size": "small"
        },
        "on": {
          "change": function change(e) {
            _this.editingTitle = e.target.value;
          }
        }
      }), h("a-icon", {
        "attrs": {
          "type": "edit"
        },
        "on": {
          "click": function click(e) {
            e.stopPropagation(); // å° click icon ä¸ click page item éç¦»å¼ãç¼è¾æ é¢çåæ¶ä¸è¦åæ¢é¡µé¢

            _this.editingTitle = _this.getTitle();
          }
        }
      })]);
    }
  };

  var _components$b;
  var PageTitleMenu = {
    components: (_components$b = {}, defineProperty$3(_components$b, antDesignVue.Dropdown.name, antDesignVue.Dropdown), defineProperty$3(_components$b, antDesignVue.Menu.name, antDesignVue.Menu), defineProperty$3(_components$b, antDesignVue.Menu.Item.name, antDesignVue.Menu.Item), defineProperty$3(_components$b, antDesignVue.Icon.name, antDesignVue.Icon), _components$b),
    render: function render() {
      var _this = this;

      var h = arguments[0];
      var addPageText = this.$t('editor.pageManager.action.add');
      var copyPageText = this.$t('editor.pageManager.action.copy');
      var deletePageText = this.$t('editor.pageManager.action.delete');
      return h("a-dropdown", {
        "attrs": {
          "trigger": ['hover'],
          "placement": "bottomCenter"
        }
      }, [h("a", {
        "class": "ml-2",
        "attrs": {
          "href": "#"
        }
      }, [h("a-icon", {
        "attrs": {
          "type": "down"
        }
      })]), h("a-menu", {
        "slot": "overlay",
        "on": {
          "click": function click(_ref) {
            var key = _ref.key;
            return _this.$emit('selectMenuItem', key);
          }
        }
      }, [h("a-menu-item", {
        "key": "add"
      }, [h("a-icon", {
        "attrs": {
          "type": "plus"
        }
      }), addPageText]), h("a-menu-item", {
        "key": "copy"
      }, [h("a-icon", {
        "attrs": {
          "type": "copy"
        }
      }), copyPageText]), h("a-menu-item", {
        "key": "delete"
      }, [h("a-icon", {
        "attrs": {
          "type": "delete"
        }
      }), deletePageText])])]);
    }
  };

  var PageTitleText = {
    components: defineProperty$3({}, antDesignVue.Badge.name, antDesignVue.Badge),
    props: ['page', 'pageIndex'],
    methods: {
      getTitle: function getTitle() {
        return this.page.title || this.$t('editor.pageManager.title', {
          index: this.pageIndex
        });
      }
    },
    render: function render(h) {
      // #!en: Page<Index>
      // #!zh: ç¬¬<Index>é¡µé¢
      return h("span", [h("a-badge", {
        "attrs": {
          "count": this.pageIndex + 1,
          "numberStyle": {
            backgroundColor: '#fff',
            color: '#999',
            boxShadow: '0 0 0 1px #d9d9d9 inset'
          }
        }
      }), h("span", {
        "class": "ml-3"
      }, [this.getTitle()])]);
    }
  };

  var RenderPageManager = {
    name: 'page-manager',
    props: {
      pages: {
        type: Array,
        default: []
      }
    },
    components: defineProperty$3({}, antDesignVue.Button.name, antDesignVue.Button),
    data: function data() {
      return {
        pageIndex: 0 // æ¾ç¤ºç¼è¾æé®

      };
    },
    methods: {
      onSelectMenuItem: function onSelectMenuItem(menuKey) {
        this.$emit('add');
      },
      onEditTitle: function onEditTitle(_ref) {
        var pageIndex = _ref.pageIndex,
            newTitle = _ref.newTitle;
        this.pageManager({
          type: 'editTitle',
          value: {
            pageIndex: pageIndex,
            newTitle: newTitle
          }
        });
      },
      onSelectPage: function onSelectPage(pageIndex) {
        this.pageIndex = pageIndex;
        this.$emit('pageChange', pageIndex);
      },
      onLeave: function onLeave() {
        this.hoverIndex = -1;
      }
    },
    render: function render(h) {
      var _this = this;

      return h("div", {
        "class": "page-manager-panel"
      }, [this.pages.map(function (page, index) {
        return h("span", {
          "class": ['cursor-pointer', 'page-manager-panel__item', index === _this.pageIndex && 'active'],
          "on": {
            "click": function click() {
              return _this.onSelectPage(index);
            },
            "mouseenter": function mouseenter() {
              _this.hoverIndex = index;
            }
          }
        }, [h(PageTitleText, {
          "attrs": {
            "page": page,
            "pageIndex": index
          }
        }), h("span", [_this.hoverIndex === index && h(PageTitleEditor, {
          "attrs": {
            "page": page,
            "pageIndex": index
          },
          "on": {
            "editTitle": _this.onEditTitle
          }
        }), h(PageTitleMenu, {
          "on": {
            "selectMenuItem": _this.onSelectMenuItem
          }
        })])]);
      }), h("a-button", {
        "attrs": {
          "icon": "plus",
          "type": "dashed"
        },
        "class": "footer-actions",
        "on": {
          "click": function click() {
            return _this.onSelectMenuItem('add');
          }
        }
      }, [this.$t('editor.pageManager.action.add')])]);
    }
  };

  function getTreeNode(ele) {
    return {
      title: ele.name,
      key: ele.id,
      children: (ele.children || []).map(getTreeNode)
    };
  }

  var script$2 = {
    name: 'page-tree',
    components: defineProperty$3({}, antDesignVue.Tree.name, antDesignVue.Tree),
    computed: {
      treeData: function treeData() {
        return this.elements.map(getTreeNode);
      }
    },
    data: function data() {
      return {
        gData: [],
        expandedKeys: []
      };
    }
  };

  /* script */
  const __vue_script__$2 = script$2;

  /* template */
  var __vue_render__$2 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("a-tree", {
      staticClass: "draggable-tree",
      attrs: {
        "default-expanded-keys": _vm.expandedKeys,
        draggable: "",
        "tree-data": _vm.treeData
      }
    })
  };
  var __vue_staticRenderFns__$2 = [];
  __vue_render__$2._withStripped = true;

    /* style */
    const __vue_inject_styles__$2 = undefined;
    /* scoped */
    const __vue_scope_id__$2 = undefined;
    /* module identifier */
    const __vue_module_identifier__$2 = undefined;
    /* functional template */
    const __vue_is_functional_template__$2 = false;
    /* style inject */
    
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__$2 = /*#__PURE__*/normalizeComponent(
      { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
      __vue_inject_styles__$2,
      __vue_script__$2,
      __vue_scope_id__$2,
      __vue_is_functional_template__$2,
      __vue_module_identifier__$2,
      false,
      undefined,
      undefined,
      undefined
    );

  var _components$c;
  var EditorLeftPanel = {
    props: {
      pages: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    components: (_components$c = {}, defineProperty$3(_components$c, antDesignVue.Layout.Sider.name, antDesignVue.Layout.Sider), defineProperty$3(_components$c, antDesignVue.Tabs.name, antDesignVue.Tabs), defineProperty$3(_components$c, antDesignVue.Tabs.TabPane.name, antDesignVue.Tabs.TabPane), _components$c),
    name: 'EditorLeftPanel',
    render: function render(h) {
      return h("a-layout-sider", {
        "attrs": {
          "width": "240",
          "theme": "light"
        },
        "style": {
          padding: '0 12px',
          height: '100%',
          overflow: 'auto'
        }
      }, [h("a-tabs", {
        "attrs": {
          "tabBarGutter": 10
        }
      }, [h("a-tab-pane", {
        "key": "plugin-list",
        "attrs": {
          "tab": this.$t('editor.sidebar.components')
        }
      }, [h(RenderShortcutsPanel, {
        "on": {
          "add": this.$listeners.addElement
        }
      })]), h("a-tab-pane", {
        "key": "page-manager",
        "attrs": {
          "tab": this.$t('editor.sidebar.pages')
        }
      }, [h(RenderPageManager, {
        "attrs": {
          "pages": this.pages
        },
        "on": {
          "add": this.$listeners.addPage,
          "pageChange": this.$listeners.pageChange
        }
      })]), h("a-tab-pane", {
        "key": "page-tree",
        "attrs": {
          "tab": this.$t('editor.sidebar.tree')
        }
      }, [h(__vue_component__$2)])])]);
    }
  };

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-06 10:50:05
   * @LastEditTime : 2020-11-16 18:07:04
   * @Description :
   */
  var AuxiliayLine = {
    props: {
      width: {
        type: Number,
        default: 0
      },
      height: {
        type: Number,
        default: 0
      },
      data: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    data: function data() {
      return {
        vLines: [],
        hLines: []
      };
    },
    watch: {
      data: {
        handler: 'calcVHLine',
        deep: true
      }
    },
    methods: {
      drawVLine: function drawVLine(newLeft) {
        this.vLines = [{
          left: newLeft
        }];
      },
      clearVLine: function clearVLine() {
        this.vLines = [];
      },
      drawHLine: function drawHLine(newTop) {
        this.hLines = [{
          top: newTop
        }];
      },
      clearHLine: function clearHLine() {
        this.hLines = [];
      },
      genBorder: function genBorder(_ref) {
        var left = _ref.left,
            top = _ref.top,
            width = _ref.width,
            height = _ref.height;
        return [[left + width, left + width / 2, left], [top + height, top + height / 2, top]];
      },
      calcVHLine: function calcVHLine() {
        var _this = this;

        var referElementsXCoords = [];
        var referElementsYCoords = [];
        var hasVLine = false;
        var hasHLine = false;
        this.data.forEach(function (e) {
          var _this$genBorder = _this.genBorder(e),
              _this$genBorder2 = slicedToArray(_this$genBorder, 2),
              xCoords = _this$genBorder2[0],
              yCoords = _this$genBorder2[1];

          referElementsXCoords.push.apply(referElementsXCoords, toConsumableArray(xCoords));
          referElementsYCoords.push.apply(referElementsYCoords, toConsumableArray(yCoords));
        });

        var _this$genBorder3 = this.genBorder({
          left: 0,
          top: 0,
          width: this.width,
          height: this.height
        }),
            _this$genBorder4 = slicedToArray(_this$genBorder3, 2),
            exCoords = _this$genBorder4[0],
            eyCoords = _this$genBorder4[1];

        exCoords.forEach(function (eX) {
          referElementsXCoords.forEach(function (referX) {
            var offset = referX - eX;

            if (Math.abs(offset) <= 5) {
              _this.drawVLine(referX);

              hasVLine = true;
            }
          });
        });
        eyCoords.forEach(function (eY) {
          referElementsYCoords.forEach(function (referY) {
            var offset = referY - eY;

            if (Math.abs(offset) <= 5) {
              _this.drawHLine(referY);

              hasHLine = true;
            }
          });
        });

        if (!hasVLine) {
          this.clearVLine();
        }

        if (!hasHLine) {
          this.clearHLine();
        }
      }
    },
    render: function render() {
      var _this2 = this;

      var h = arguments[0];
      return h("div", {
        "class": "luban-auxiliary-line"
      }, [this.vLines.map(function (line) {
        return h("div", {
          "class": "v-line",
          "style": {
            left: "".concat(line.left, "px"),
            height: "".concat(_this2.height, "px")
          }
        });
      }), this.hLines.map(function (line) {
        return h("div", {
          "class": "h-line",
          "style": {
            top: "".concat(line.top, "px"),
            width: "".concat(_this2.width, "px")
          }
        });
      })]);
    }
  };

  var AdjustHeight = {
    props: {
      height: {
        type: Number,
        default: 0
      }
    },
    components: defineProperty$3({}, antDesignVue.InputNumber.name, antDesignVue.InputNumber),
    methods: {
      /**
       * æ´æ°ä½åé«åº¦
       * @param {Number} height
       */
      updateWorkHeight: function updateWorkHeight(height) {
        this.$emit('change', height);
      },

      /**
       * TODO å°è£ adjust editor scale ç»ä»¶
       * scale: height/width
       * @param {MouseEvent} e
       */
      mousedownForAdjustLine: function mousedownForAdjustLine(e) {
        var _this = this;

        var startY = e.clientY;
        var startHeight = this.height;
        var canvasOuterWrapper = document.querySelector('#editor-wrapper .ant-layout');

        var move = function move(moveEvent) {
          // !#zh ç§»å¨çæ¶åï¼ä¸éè¦ååä»£åç´ ä¼ éäºä»¶ï¼åªéè¦åçº¯çç§»å¨å°±OK
          moveEvent.stopPropagation();
          moveEvent.preventDefault();
          var currY = moveEvent.clientY;
          var moveHeight = currY - startY;
          var currentHeight = moveHeight + startHeight;

          _this.updateWorkHeight(currentHeight);

          if (canvasOuterWrapper) {
            canvasOuterWrapper.scrollTop = canvasOuterWrapper.scrollHeight;
          }
        };

        var up = function up() {
          document.removeEventListener('mousemove', move, true);
          document.removeEventListener('mouseup', up, true);
        };

        document.addEventListener('mousemove', move, true);
        document.addEventListener('mouseup', up, true);
      }
    },
    render: function render() {
      var h = arguments[0];
      return h("div", {
        "style": {
          position: 'absolute',
          bottom: '0px',
          width: '100%',
          transform: 'translateY(100%)'
        }
      }, [h("div", {
        "class": "adjust-line-wrapper adjust-line-wrapper-h"
      }, [h("div", {
        "class": "adjust-line adjust-line-h"
      }), h("div", {
        "class": "adjust-button",
        "on": {
          "mousedown": this.mousedownForAdjustLine
        }
      }, [h("div", {
        "class": "indicator"
      })]), h("div", {
        "class": "adjust-tip"
      }, [h("span", ["375 x"]), h("a-input-number", {
        "attrs": {
          "size": "small",
          "value": this.height
        },
        "style": "margin: 0 4px; width:60px;",
        "on": {
          "change": this.updateWorkHeight
        }
      }), h("span", ["px"])])])]);
    }
  };

  var AdjustLineV = {
    methods: {
      onMousedown: function onMousedown(e) {
        var _this = this;

        var startX = e.clientX;

        var move = function move(moveEvent) {
          moveEvent.preventDefault();
          moveEvent.stopPropagation();
          var offset = startX - moveEvent.clientX;

          _this.$emit('lineMove', offset);

          startX -= offset;
        };

        var up = function up(moveEvent) {
          document.removeEventListener('mousemove', move, true);
          document.removeEventListener('mouseup', up, true);
        };

        document.addEventListener('mousemove', move, true);
        document.addEventListener('mouseup', up, true);
      }
    },
    render: function render() {
      var h = arguments[0];
      return h("div", {
        "class": "adjust-line-wrapper adjust-line-wrapper-v",
        "on": {
          "mousedown": this.onMousedown
        }
      }, [h("div", {
        "class": "adjust-line adjust-line-v"
      }), h("div", {
        "class": "adjust-button"
      }, [h("div", {
        "class": "indicator"
      })])]);
    }
  };

  var defineProperty$8 = objectDefineProperty.f;


  var NativeSymbol = global_1.Symbol;

  if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
    // Safari 12 bug
    NativeSymbol().description !== undefined
  )) {
    var EmptyStringDescriptionStore = {};
    // wrap Symbol constructor for correct work with undefined description
    var SymbolWrapper = function Symbol() {
      var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
      var result = this instanceof SymbolWrapper
        ? new NativeSymbol(description)
        // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
        : description === undefined ? NativeSymbol() : NativeSymbol(description);
      if (description === '') EmptyStringDescriptionStore[result] = true;
      return result;
    };
    copyConstructorProperties(SymbolWrapper, NativeSymbol);
    var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
    symbolPrototype.constructor = SymbolWrapper;

    var symbolToString = symbolPrototype.toString;
    var native = String(NativeSymbol('test')) == 'Symbol(test)';
    var regexp = /^Symbol\((.*)\)[^)]+$/;
    defineProperty$8(symbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        var symbol = isObject(this) ? this.valueOf() : this;
        var string = symbolToString.call(symbol);
        if (has(EmptyStringDescriptionStore, symbol)) return '';
        var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
        return desc === '' ? undefined : desc;
      }
    });

    _export({ global: true, forced: true }, {
      Symbol: SymbolWrapper
    });
  }

  var Page = /*#__PURE__*/function () {
    function Page() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$title = _ref.title,
          title = _ref$title === void 0 ? '' : _ref$title,
          _ref$elements = _ref.elements,
          elements = _ref$elements === void 0 ? [] : _ref$elements,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? PAGE_MODE.HEIGHT : _ref$height,
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? PAGE_MODE.WIDTH : _ref$width,
          _ref$pageMode = _ref.pageMode,
          pageMode = _ref$pageMode === void 0 ? PAGE_MODE.SWIPPER_PAGE : _ref$pageMode;

      classCallCheck(this, Page);

      this.id = +new Date();
      this.title = title;
      this.width = width >= 0 ? width : PAGE_MODE.WIDTH;
      this.height = height >= 0 ? height : PAGE_MODE.HEIGHT;
      this.pageMode = pageMode;
      this.elements = this.genElements(elements);
    }

    createClass(Page, [{
      key: "clone",
      value: function clone() {
        var elements = this.elements.map(function (element) {
          return new LbpElement(element);
        });
        return new Page({
          title: this.title,
          elements: elements
        });
      }
    }, {
      key: "genElements",
      value: function genElements() {
        var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return Array.isArray(elements) && elements.length > 0 ? elements.map(function (v) {
          return new LbpElement(v);
        }) : [new LbpElement({
          name: LbpBackground.name
        })];
      }
    }]);

    return Page;
  }();

  var Work = /*#__PURE__*/function () {
    function Work() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          id = _ref.id,
          _ref$title = _ref.title,
          title = _ref$title === void 0 ? 'æ é¢' : _ref$title,
          _ref$description = _ref.description,
          description = _ref$description === void 0 ? 'æè¿°' : _ref$description,
          _ref$pages = _ref.pages,
          pages = _ref$pages === void 0 ? [] : _ref$pages,
          isPublish = _ref.isPublish,
          isTemplate = _ref.isTemplate;

      classCallCheck(this, Work);

      this.id = id;
      this.title = title;
      this.description = description;
      this.pages = this.genPages(pages);
      this.cover_image_url = '';
      this.is_publish = !!isPublish;
      this.is_template = !!isTemplate;
    }

    createClass(Work, [{
      key: "genPages",
      value: function genPages(pages) {
        return Array.isArray(pages) && pages.length > 0 ? pages.map(function (v) {
          return new Page(v);
        }) : [new Page()];
      }
    }]);

    return Work;
  }();

  /*
   * @author : Mater
   * @Email : bxh8640@gmail.com
   * @Date : 2020-11-12 14:49:13
   * @LastEditTime : 2020-11-12 14:49:29
   * @Description :
   */
  var config$1 = {
    rightPanelWidth: 375
  };

  var _components$d;
  var Editor = {
    name: 'lbp-editor',
    i18n: i18n,
    components: (_components$d = {}, defineProperty$3(_components$d, antDesignVue.Layout.name, antDesignVue.Layout), defineProperty$3(_components$d, antDesignVue.Layout.Content.name, antDesignVue.Layout), _components$d),
    props: {
      data: {
        type: Object,
        default: function _default() {
          return {};
        }
      }
    },
    data: function data() {
      return {
        work: {},
        pageIndex: 0,
        activeElement: null,
        auxiliayVisible: false,
        rightPanelWidth: config$1.rightPanelWidth
      };
    },
    computed: {
      currentPage: function currentPage() {
        var _this$work$pages = this.work.pages,
            pages = _this$work$pages === void 0 ? [] : _this$work$pages;
        var currentPage = pages[this.pageIndex] || {};
        return currentPage;
      },
      elementsRect: function elementsRect() {
        var _this$currentPage = this.currentPage,
            currentPage = _this$currentPage === void 0 ? {} : _this$currentPage;
        var _currentPage$elements = currentPage.elements,
            elements = _currentPage$elements === void 0 ? [] : _currentPage$elements;
        return elements.map(function (_ref) {
          var style = _ref.style;
          return style;
        });
      }
    },
    watch: {
      data: {
        handler: function handler() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          this.work = new Work(data);
          console.log(this.work);
        },
        immediate: true
      },
      currentPage: function currentPage() {
        var currentPage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _currentPage$elements2 = currentPage.elements,
            elements = _currentPage$elements2 === void 0 ? [] : _currentPage$elements2;
        this.clear();
        this.addElements.apply(this, toConsumableArray(elements));
      }
    },
    methods: {
      getData: function getData() {
        return this.work;
      },
      addPage: function addPage(title) {
        this.work.pages.push(new Page({
          title: title
        }));
      },
      changePageIndex: function changePageIndex(index) {
        this.pageIndex = index;
      },
      updatePage: function updatePage(data) {
        Object.assign(this.currentPage, data);
      },
      addElements: function addElements() {
        for (var _len = arguments.length, element = new Array(_len), _key = 0; _key < _len; _key++) {
          element[_key] = arguments[_key];
        }

        element.forEach(this.addElement);
      },
      addElement: function addElement(element) {
        if (element instanceof LbpElement) {
          this.currentPage.elements.push(element);
        } else {
          var lbpElement = new LbpElement(element);
          this.currentPage.elements.push(lbpElement);
        }
      },
      updateElement: function updateElement(data) {
        this.activeElement.update(data);
      },
      clear: function clear() {
        this.currentPage.elements = [];
      },
      _hideAuxiliay: function _hideAuxiliay() {
        this.auxiliayVisible = false;
      },
      _showAuxiliay: function _showAuxiliay() {
        this.auxiliayVisible = true;
      },
      _handleElementActive: function _handleElementActive(element) {
        this.activeElement = element;
      },
      _handleElementDeactive: function _handleElementDeactive(deactiveElement) {
        if (deactiveElement === this.activeElement) {
          this.activeElement = null;
        }
      },
      _handleAdjustLieMove: function _handleAdjustLieMove(offset) {
        this.rightPanelWidth += offset;
      },
      _handlePropsChange: function _handlePropsChange(value) {
        this.updateElement({
          props: value
        });
      },
      _handleAnimationsChange: function _handleAnimationsChange(value) {
        this.updateElement({
          animations: value
        });
      },
      _handleElementRectChange: function _handleElementRectChange(value) {
        this.updateElement({
          style: value
        });
      },
      _handleAddElement: function _handleAddElement(data) {
        this.addElement(data);
      },
      _handleAddPage: function _handleAddPage(data) {
        this.addPage(data);
      },
      _handlePageHeightChange: function _handlePageHeightChange(height) {
        this.updatePage({
          height: height
        });
      },
      _handlePageIndexChange: function _handlePageIndexChange(index) {
        this.changePageIndex(index);
      }
    },
    render: function render() {
      var h = arguments[0];
      return h("a-layout", {
        "style": {
          height: '100%'
        }
      }, [h(EditorLeftPanel, {
        "attrs": {
          "pages": this.work.pages
        },
        "on": {
          "pageChange": this._handlePageIndexChange,
          "addElement": this._handleAddElement,
          "addPage": this._handleAddPage
        }
      }), h("a-layout", {
        "attrs": {
          "id": "editor-wrapper"
        }
      }, [h("a-layout-content", {
        "class": "scroll-view remove-scrollbar"
      }, [h("div", {
        "class": "editor-content",
        "on": {
          "mousedown": this._showAuxiliay,
          "mouseup": this._hideAuxiliay
        }
      }, [h(AuxiliayLine, {
        "attrs": {
          "data": this.elementsRect,
          "width": this.currentPage.width,
          "height": this.currentPage.height
        },
        "directives": [{
          name: "show",
          value: this.auxiliayVisible
        }]
      }), h(LbpCanvas, {
        "attrs": {
          "width": this.currentPage.width,
          "height": this.currentPage.height,
          "elements": this.currentPage.elements
        },
        "on": {
          "active": this._handleElementActive,
          "deactive": this._handleElementDeactive,
          "elementRectChange": this._handleElementRectChange
        }
      }), h(AdjustHeight, {
        "attrs": {
          "height": this.currentPage.height
        },
        "on": {
          "change": this._handlePageHeightChange
        }
      })])])]), h(AdjustLineV, {
        "on": {
          "lineMove": this._handleAdjustLieMove
        }
      }), h(FixedTools), h(EditorRightPanel, {
        "attrs": {
          "width": this.rightPanelWidth,
          "element": this.activeElement
        },
        "on": {
          "propsChange": this._handlePropsChange,
          "animationsChange": this._handleAnimationsChange
        }
      })]);
    }
  };

  Editor.install = function (Vue) {
    Vue.component(Editor.name, Editor);
  }; // éè¿scriptæ ç­¾å¼å¥Vueçç¯å¢


  if (typeof window !== 'undefined' && window.Vue) {
    Editor.install(window.Vue);
  }

  return Editor;

})));
//# sourceMappingURL=luban-h5-editor.js.map
